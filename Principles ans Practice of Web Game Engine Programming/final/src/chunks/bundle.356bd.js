System.register([], function(_export, _context) { return { execute: function () {
System.register("chunks:///_virtual/buffproto.js", ['./cjs-loader.mjs', './minimal.js'], function (exports, module) {
  'use strict';

  var loader, __cjsMetaURL$1;

  return {
    setters: [function (module) {
      loader = module.default;
    }, function (module) {
      __cjsMetaURL$1 = module.__cjsMetaURL;
    }],
    execute: function () {
      exports('default', void 0);

      var _cjsExports;

      var __cjsMetaURL = exports('__cjsMetaURL', module.meta.url);

      loader.define(__cjsMetaURL, function (exports$1, require, module, __filename, __dirname) {
        var $protobuf = require("protobufjs/minimal"); // Common aliases


        var $Reader = $protobuf.Reader,
            $Writer = $protobuf.Writer,
            $util = $protobuf.util; // Exported root namespace

        var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

        $root.buffProto = function () {
          /**
           * Namespace buffProto.
           * @exports buffProto
           * @namespace
           */
          var buffProto = {};

          buffProto.BuffParam = function () {
            /**
             * Properties of a BuffParam.
             * @memberof buffProto
             * @interface IBuffParam
             * @property {Long|null} [BuffID] BuffParam BuffID
             * @property {number|null} [Minute] BuffParam Minute
             * @property {number|null} [Param1] BuffParam Param1
             * @property {number|null} [Param2] BuffParam Param2
             * @property {number|null} [Param3] BuffParam Param3
             * @property {number|null} [Param4] BuffParam Param4
             */

            /**
             * Constructs a new BuffParam.
             * @memberof buffProto
             * @classdesc Represents a BuffParam.
             * @implements IBuffParam
             * @constructor
             * @param {buffProto.IBuffParam=} [properties] Properties to set
             */
            function BuffParam(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * BuffParam BuffID.
             * @member {Long} BuffID
             * @memberof buffProto.BuffParam
             * @instance
             */


            BuffParam.prototype.BuffID = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
             * BuffParam Minute.
             * @member {number} Minute
             * @memberof buffProto.BuffParam
             * @instance
             */

            BuffParam.prototype.Minute = 0;
            /**
             * BuffParam Param1.
             * @member {number} Param1
             * @memberof buffProto.BuffParam
             * @instance
             */

            BuffParam.prototype.Param1 = 0;
            /**
             * BuffParam Param2.
             * @member {number} Param2
             * @memberof buffProto.BuffParam
             * @instance
             */

            BuffParam.prototype.Param2 = 0;
            /**
             * BuffParam Param3.
             * @member {number} Param3
             * @memberof buffProto.BuffParam
             * @instance
             */

            BuffParam.prototype.Param3 = 0;
            /**
             * BuffParam Param4.
             * @member {number} Param4
             * @memberof buffProto.BuffParam
             * @instance
             */

            BuffParam.prototype.Param4 = 0;
            /**
             * Creates a new BuffParam instance using the specified properties.
             * @function create
             * @memberof buffProto.BuffParam
             * @static
             * @param {buffProto.IBuffParam=} [properties] Properties to set
             * @returns {buffProto.BuffParam} BuffParam instance
             */

            BuffParam.create = function create(properties) {
              return new BuffParam(properties);
            };
            /**
             * Encodes the specified BuffParam message. Does not implicitly {@link buffProto.BuffParam.verify|verify} messages.
             * @function encode
             * @memberof buffProto.BuffParam
             * @static
             * @param {buffProto.IBuffParam} message BuffParam message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            BuffParam.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.BuffID != null && Object.hasOwnProperty.call(message, "BuffID")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int64(message.BuffID);
              if (message.Minute != null && Object.hasOwnProperty.call(message, "Minute")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int32(message.Minute);
              if (message.Param1 != null && Object.hasOwnProperty.call(message, "Param1")) writer.uint32(
              /* id 3, wireType 1 =*/
              25)["double"](message.Param1);
              if (message.Param2 != null && Object.hasOwnProperty.call(message, "Param2")) writer.uint32(
              /* id 4, wireType 1 =*/
              33)["double"](message.Param2);
              if (message.Param3 != null && Object.hasOwnProperty.call(message, "Param3")) writer.uint32(
              /* id 5, wireType 1 =*/
              41)["double"](message.Param3);
              if (message.Param4 != null && Object.hasOwnProperty.call(message, "Param4")) writer.uint32(
              /* id 6, wireType 1 =*/
              49)["double"](message.Param4);
              return writer;
            };
            /**
             * Encodes the specified BuffParam message, length delimited. Does not implicitly {@link buffProto.BuffParam.verify|verify} messages.
             * @function encodeDelimited
             * @memberof buffProto.BuffParam
             * @static
             * @param {buffProto.IBuffParam} message BuffParam message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            BuffParam.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a BuffParam message from the specified reader or buffer.
             * @function decode
             * @memberof buffProto.BuffParam
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {buffProto.BuffParam} BuffParam
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            BuffParam.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.buffProto.BuffParam();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.BuffID = reader.int64();
                    break;

                  case 2:
                    message.Minute = reader.int32();
                    break;

                  case 3:
                    message.Param1 = reader["double"]();
                    break;

                  case 4:
                    message.Param2 = reader["double"]();
                    break;

                  case 5:
                    message.Param3 = reader["double"]();
                    break;

                  case 6:
                    message.Param4 = reader["double"]();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
             * Decodes a BuffParam message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof buffProto.BuffParam
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {buffProto.BuffParam} BuffParam
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            BuffParam.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a BuffParam message.
             * @function verify
             * @memberof buffProto.BuffParam
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */


            BuffParam.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.BuffID != null && message.hasOwnProperty("BuffID")) if (!$util.isInteger(message.BuffID) && !(message.BuffID && $util.isInteger(message.BuffID.low) && $util.isInteger(message.BuffID.high))) return "BuffID: integer|Long expected";
              if (message.Minute != null && message.hasOwnProperty("Minute")) if (!$util.isInteger(message.Minute)) return "Minute: integer expected";
              if (message.Param1 != null && message.hasOwnProperty("Param1")) if (typeof message.Param1 !== "number") return "Param1: number expected";
              if (message.Param2 != null && message.hasOwnProperty("Param2")) if (typeof message.Param2 !== "number") return "Param2: number expected";
              if (message.Param3 != null && message.hasOwnProperty("Param3")) if (typeof message.Param3 !== "number") return "Param3: number expected";
              if (message.Param4 != null && message.hasOwnProperty("Param4")) if (typeof message.Param4 !== "number") return "Param4: number expected";
              return null;
            };
            /**
             * Creates a BuffParam message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof buffProto.BuffParam
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {buffProto.BuffParam} BuffParam
             */


            BuffParam.fromObject = function fromObject(object) {
              if (object instanceof $root.buffProto.BuffParam) return object;
              var message = new $root.buffProto.BuffParam();
              if (object.BuffID != null) if ($util.Long) (message.BuffID = $util.Long.fromValue(object.BuffID)).unsigned = false;else if (typeof object.BuffID === "string") message.BuffID = parseInt(object.BuffID, 10);else if (typeof object.BuffID === "number") message.BuffID = object.BuffID;else if (typeof object.BuffID === "object") message.BuffID = new $util.LongBits(object.BuffID.low >>> 0, object.BuffID.high >>> 0).toNumber();
              if (object.Minute != null) message.Minute = object.Minute | 0;
              if (object.Param1 != null) message.Param1 = Number(object.Param1);
              if (object.Param2 != null) message.Param2 = Number(object.Param2);
              if (object.Param3 != null) message.Param3 = Number(object.Param3);
              if (object.Param4 != null) message.Param4 = Number(object.Param4);
              return message;
            };
            /**
             * Creates a plain object from a BuffParam message. Also converts values to other types if specified.
             * @function toObject
             * @memberof buffProto.BuffParam
             * @static
             * @param {buffProto.BuffParam} message BuffParam
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */


            BuffParam.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                if ($util.Long) {
                  var _long = new $util.Long(0, 0, false);

                  object.BuffID = options.longs === String ? _long.toString() : options.longs === Number ? _long.toNumber() : _long;
                } else object.BuffID = options.longs === String ? "0" : 0;

                object.Minute = 0;
                object.Param1 = 0;
                object.Param2 = 0;
                object.Param3 = 0;
                object.Param4 = 0;
              }

              if (message.BuffID != null && message.hasOwnProperty("BuffID")) if (typeof message.BuffID === "number") object.BuffID = options.longs === String ? String(message.BuffID) : message.BuffID;else object.BuffID = options.longs === String ? $util.Long.prototype.toString.call(message.BuffID) : options.longs === Number ? new $util.LongBits(message.BuffID.low >>> 0, message.BuffID.high >>> 0).toNumber() : message.BuffID;
              if (message.Minute != null && message.hasOwnProperty("Minute")) object.Minute = message.Minute;
              if (message.Param1 != null && message.hasOwnProperty("Param1")) object.Param1 = options.json && !isFinite(message.Param1) ? String(message.Param1) : message.Param1;
              if (message.Param2 != null && message.hasOwnProperty("Param2")) object.Param2 = options.json && !isFinite(message.Param2) ? String(message.Param2) : message.Param2;
              if (message.Param3 != null && message.hasOwnProperty("Param3")) object.Param3 = options.json && !isFinite(message.Param3) ? String(message.Param3) : message.Param3;
              if (message.Param4 != null && message.hasOwnProperty("Param4")) object.Param4 = options.json && !isFinite(message.Param4) ? String(message.Param4) : message.Param4;
              return object;
            };
            /**
             * Converts this BuffParam to JSON.
             * @function toJSON
             * @memberof buffProto.BuffParam
             * @instance
             * @returns {Object.<string,*>} JSON object
             */


            BuffParam.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BuffParam;
          }();

          buffProto.EBuffOut = function () {
            /**
             * Properties of a EBuffOut.
             * @memberof buffProto
             * @interface IEBuffOut
             * @property {Long|null} [BuffIndex] EBuffOut BuffIndex
             * @property {Long|null} [BuffID] EBuffOut BuffID
             * @property {number|null} [GameID] EBuffOut GameID
             * @property {Long|null} [BeginTime] EBuffOut BeginTime
             * @property {Long|null} [EndTime] EBuffOut EndTime
             * @property {number|null} [BuffType] EBuffOut BuffType
             * @property {number|null} [Param1] EBuffOut Param1
             * @property {number|null} [Param2] EBuffOut Param2
             * @property {number|null} [Param3] EBuffOut Param3
             * @property {number|null} [Param4] EBuffOut Param4
             */

            /**
             * Constructs a new EBuffOut.
             * @memberof buffProto
             * @classdesc Represents a EBuffOut.
             * @implements IEBuffOut
             * @constructor
             * @param {buffProto.IEBuffOut=} [properties] Properties to set
             */
            function EBuffOut(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * EBuffOut BuffIndex.
             * @member {Long} BuffIndex
             * @memberof buffProto.EBuffOut
             * @instance
             */


            EBuffOut.prototype.BuffIndex = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
             * EBuffOut BuffID.
             * @member {Long} BuffID
             * @memberof buffProto.EBuffOut
             * @instance
             */

            EBuffOut.prototype.BuffID = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
             * EBuffOut GameID.
             * @member {number} GameID
             * @memberof buffProto.EBuffOut
             * @instance
             */

            EBuffOut.prototype.GameID = 0;
            /**
             * EBuffOut BeginTime.
             * @member {Long} BeginTime
             * @memberof buffProto.EBuffOut
             * @instance
             */

            EBuffOut.prototype.BeginTime = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
             * EBuffOut EndTime.
             * @member {Long} EndTime
             * @memberof buffProto.EBuffOut
             * @instance
             */

            EBuffOut.prototype.EndTime = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
             * EBuffOut BuffType.
             * @member {number} BuffType
             * @memberof buffProto.EBuffOut
             * @instance
             */

            EBuffOut.prototype.BuffType = 0;
            /**
             * EBuffOut Param1.
             * @member {number} Param1
             * @memberof buffProto.EBuffOut
             * @instance
             */

            EBuffOut.prototype.Param1 = 0;
            /**
             * EBuffOut Param2.
             * @member {number} Param2
             * @memberof buffProto.EBuffOut
             * @instance
             */

            EBuffOut.prototype.Param2 = 0;
            /**
             * EBuffOut Param3.
             * @member {number} Param3
             * @memberof buffProto.EBuffOut
             * @instance
             */

            EBuffOut.prototype.Param3 = 0;
            /**
             * EBuffOut Param4.
             * @member {number} Param4
             * @memberof buffProto.EBuffOut
             * @instance
             */

            EBuffOut.prototype.Param4 = 0;
            /**
             * Creates a new EBuffOut instance using the specified properties.
             * @function create
             * @memberof buffProto.EBuffOut
             * @static
             * @param {buffProto.IEBuffOut=} [properties] Properties to set
             * @returns {buffProto.EBuffOut} EBuffOut instance
             */

            EBuffOut.create = function create(properties) {
              return new EBuffOut(properties);
            };
            /**
             * Encodes the specified EBuffOut message. Does not implicitly {@link buffProto.EBuffOut.verify|verify} messages.
             * @function encode
             * @memberof buffProto.EBuffOut
             * @static
             * @param {buffProto.IEBuffOut} message EBuffOut message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            EBuffOut.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.BuffIndex != null && Object.hasOwnProperty.call(message, "BuffIndex")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int64(message.BuffIndex);
              if (message.BuffID != null && Object.hasOwnProperty.call(message, "BuffID")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int64(message.BuffID);
              if (message.GameID != null && Object.hasOwnProperty.call(message, "GameID")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.GameID);
              if (message.BeginTime != null && Object.hasOwnProperty.call(message, "BeginTime")) writer.uint32(
              /* id 4, wireType 0 =*/
              32).int64(message.BeginTime);
              if (message.EndTime != null && Object.hasOwnProperty.call(message, "EndTime")) writer.uint32(
              /* id 5, wireType 0 =*/
              40).int64(message.EndTime);
              if (message.BuffType != null && Object.hasOwnProperty.call(message, "BuffType")) writer.uint32(
              /* id 6, wireType 0 =*/
              48).int32(message.BuffType);
              if (message.Param1 != null && Object.hasOwnProperty.call(message, "Param1")) writer.uint32(
              /* id 7, wireType 1 =*/
              57)["double"](message.Param1);
              if (message.Param2 != null && Object.hasOwnProperty.call(message, "Param2")) writer.uint32(
              /* id 8, wireType 1 =*/
              65)["double"](message.Param2);
              if (message.Param3 != null && Object.hasOwnProperty.call(message, "Param3")) writer.uint32(
              /* id 9, wireType 1 =*/
              73)["double"](message.Param3);
              if (message.Param4 != null && Object.hasOwnProperty.call(message, "Param4")) writer.uint32(
              /* id 10, wireType 1 =*/
              81)["double"](message.Param4);
              return writer;
            };
            /**
             * Encodes the specified EBuffOut message, length delimited. Does not implicitly {@link buffProto.EBuffOut.verify|verify} messages.
             * @function encodeDelimited
             * @memberof buffProto.EBuffOut
             * @static
             * @param {buffProto.IEBuffOut} message EBuffOut message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            EBuffOut.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a EBuffOut message from the specified reader or buffer.
             * @function decode
             * @memberof buffProto.EBuffOut
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {buffProto.EBuffOut} EBuffOut
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            EBuffOut.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.buffProto.EBuffOut();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.BuffIndex = reader.int64();
                    break;

                  case 2:
                    message.BuffID = reader.int64();
                    break;

                  case 3:
                    message.GameID = reader.int32();
                    break;

                  case 4:
                    message.BeginTime = reader.int64();
                    break;

                  case 5:
                    message.EndTime = reader.int64();
                    break;

                  case 6:
                    message.BuffType = reader.int32();
                    break;

                  case 7:
                    message.Param1 = reader["double"]();
                    break;

                  case 8:
                    message.Param2 = reader["double"]();
                    break;

                  case 9:
                    message.Param3 = reader["double"]();
                    break;

                  case 10:
                    message.Param4 = reader["double"]();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
             * Decodes a EBuffOut message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof buffProto.EBuffOut
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {buffProto.EBuffOut} EBuffOut
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            EBuffOut.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a EBuffOut message.
             * @function verify
             * @memberof buffProto.EBuffOut
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */


            EBuffOut.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.BuffIndex != null && message.hasOwnProperty("BuffIndex")) if (!$util.isInteger(message.BuffIndex) && !(message.BuffIndex && $util.isInteger(message.BuffIndex.low) && $util.isInteger(message.BuffIndex.high))) return "BuffIndex: integer|Long expected";
              if (message.BuffID != null && message.hasOwnProperty("BuffID")) if (!$util.isInteger(message.BuffID) && !(message.BuffID && $util.isInteger(message.BuffID.low) && $util.isInteger(message.BuffID.high))) return "BuffID: integer|Long expected";
              if (message.GameID != null && message.hasOwnProperty("GameID")) if (!$util.isInteger(message.GameID)) return "GameID: integer expected";
              if (message.BeginTime != null && message.hasOwnProperty("BeginTime")) if (!$util.isInteger(message.BeginTime) && !(message.BeginTime && $util.isInteger(message.BeginTime.low) && $util.isInteger(message.BeginTime.high))) return "BeginTime: integer|Long expected";
              if (message.EndTime != null && message.hasOwnProperty("EndTime")) if (!$util.isInteger(message.EndTime) && !(message.EndTime && $util.isInteger(message.EndTime.low) && $util.isInteger(message.EndTime.high))) return "EndTime: integer|Long expected";
              if (message.BuffType != null && message.hasOwnProperty("BuffType")) if (!$util.isInteger(message.BuffType)) return "BuffType: integer expected";
              if (message.Param1 != null && message.hasOwnProperty("Param1")) if (typeof message.Param1 !== "number") return "Param1: number expected";
              if (message.Param2 != null && message.hasOwnProperty("Param2")) if (typeof message.Param2 !== "number") return "Param2: number expected";
              if (message.Param3 != null && message.hasOwnProperty("Param3")) if (typeof message.Param3 !== "number") return "Param3: number expected";
              if (message.Param4 != null && message.hasOwnProperty("Param4")) if (typeof message.Param4 !== "number") return "Param4: number expected";
              return null;
            };
            /**
             * Creates a EBuffOut message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof buffProto.EBuffOut
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {buffProto.EBuffOut} EBuffOut
             */


            EBuffOut.fromObject = function fromObject(object) {
              if (object instanceof $root.buffProto.EBuffOut) return object;
              var message = new $root.buffProto.EBuffOut();
              if (object.BuffIndex != null) if ($util.Long) (message.BuffIndex = $util.Long.fromValue(object.BuffIndex)).unsigned = false;else if (typeof object.BuffIndex === "string") message.BuffIndex = parseInt(object.BuffIndex, 10);else if (typeof object.BuffIndex === "number") message.BuffIndex = object.BuffIndex;else if (typeof object.BuffIndex === "object") message.BuffIndex = new $util.LongBits(object.BuffIndex.low >>> 0, object.BuffIndex.high >>> 0).toNumber();
              if (object.BuffID != null) if ($util.Long) (message.BuffID = $util.Long.fromValue(object.BuffID)).unsigned = false;else if (typeof object.BuffID === "string") message.BuffID = parseInt(object.BuffID, 10);else if (typeof object.BuffID === "number") message.BuffID = object.BuffID;else if (typeof object.BuffID === "object") message.BuffID = new $util.LongBits(object.BuffID.low >>> 0, object.BuffID.high >>> 0).toNumber();
              if (object.GameID != null) message.GameID = object.GameID | 0;
              if (object.BeginTime != null) if ($util.Long) (message.BeginTime = $util.Long.fromValue(object.BeginTime)).unsigned = false;else if (typeof object.BeginTime === "string") message.BeginTime = parseInt(object.BeginTime, 10);else if (typeof object.BeginTime === "number") message.BeginTime = object.BeginTime;else if (typeof object.BeginTime === "object") message.BeginTime = new $util.LongBits(object.BeginTime.low >>> 0, object.BeginTime.high >>> 0).toNumber();
              if (object.EndTime != null) if ($util.Long) (message.EndTime = $util.Long.fromValue(object.EndTime)).unsigned = false;else if (typeof object.EndTime === "string") message.EndTime = parseInt(object.EndTime, 10);else if (typeof object.EndTime === "number") message.EndTime = object.EndTime;else if (typeof object.EndTime === "object") message.EndTime = new $util.LongBits(object.EndTime.low >>> 0, object.EndTime.high >>> 0).toNumber();
              if (object.BuffType != null) message.BuffType = object.BuffType | 0;
              if (object.Param1 != null) message.Param1 = Number(object.Param1);
              if (object.Param2 != null) message.Param2 = Number(object.Param2);
              if (object.Param3 != null) message.Param3 = Number(object.Param3);
              if (object.Param4 != null) message.Param4 = Number(object.Param4);
              return message;
            };
            /**
             * Creates a plain object from a EBuffOut message. Also converts values to other types if specified.
             * @function toObject
             * @memberof buffProto.EBuffOut
             * @static
             * @param {buffProto.EBuffOut} message EBuffOut
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */


            EBuffOut.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                if ($util.Long) {
                  var _long2 = new $util.Long(0, 0, false);

                  object.BuffIndex = options.longs === String ? _long2.toString() : options.longs === Number ? _long2.toNumber() : _long2;
                } else object.BuffIndex = options.longs === String ? "0" : 0;

                if ($util.Long) {
                  var _long2 = new $util.Long(0, 0, false);

                  object.BuffID = options.longs === String ? _long2.toString() : options.longs === Number ? _long2.toNumber() : _long2;
                } else object.BuffID = options.longs === String ? "0" : 0;

                object.GameID = 0;

                if ($util.Long) {
                  var _long2 = new $util.Long(0, 0, false);

                  object.BeginTime = options.longs === String ? _long2.toString() : options.longs === Number ? _long2.toNumber() : _long2;
                } else object.BeginTime = options.longs === String ? "0" : 0;

                if ($util.Long) {
                  var _long2 = new $util.Long(0, 0, false);

                  object.EndTime = options.longs === String ? _long2.toString() : options.longs === Number ? _long2.toNumber() : _long2;
                } else object.EndTime = options.longs === String ? "0" : 0;

                object.BuffType = 0;
                object.Param1 = 0;
                object.Param2 = 0;
                object.Param3 = 0;
                object.Param4 = 0;
              }

              if (message.BuffIndex != null && message.hasOwnProperty("BuffIndex")) if (typeof message.BuffIndex === "number") object.BuffIndex = options.longs === String ? String(message.BuffIndex) : message.BuffIndex;else object.BuffIndex = options.longs === String ? $util.Long.prototype.toString.call(message.BuffIndex) : options.longs === Number ? new $util.LongBits(message.BuffIndex.low >>> 0, message.BuffIndex.high >>> 0).toNumber() : message.BuffIndex;
              if (message.BuffID != null && message.hasOwnProperty("BuffID")) if (typeof message.BuffID === "number") object.BuffID = options.longs === String ? String(message.BuffID) : message.BuffID;else object.BuffID = options.longs === String ? $util.Long.prototype.toString.call(message.BuffID) : options.longs === Number ? new $util.LongBits(message.BuffID.low >>> 0, message.BuffID.high >>> 0).toNumber() : message.BuffID;
              if (message.GameID != null && message.hasOwnProperty("GameID")) object.GameID = message.GameID;
              if (message.BeginTime != null && message.hasOwnProperty("BeginTime")) if (typeof message.BeginTime === "number") object.BeginTime = options.longs === String ? String(message.BeginTime) : message.BeginTime;else object.BeginTime = options.longs === String ? $util.Long.prototype.toString.call(message.BeginTime) : options.longs === Number ? new $util.LongBits(message.BeginTime.low >>> 0, message.BeginTime.high >>> 0).toNumber() : message.BeginTime;
              if (message.EndTime != null && message.hasOwnProperty("EndTime")) if (typeof message.EndTime === "number") object.EndTime = options.longs === String ? String(message.EndTime) : message.EndTime;else object.EndTime = options.longs === String ? $util.Long.prototype.toString.call(message.EndTime) : options.longs === Number ? new $util.LongBits(message.EndTime.low >>> 0, message.EndTime.high >>> 0).toNumber() : message.EndTime;
              if (message.BuffType != null && message.hasOwnProperty("BuffType")) object.BuffType = message.BuffType;
              if (message.Param1 != null && message.hasOwnProperty("Param1")) object.Param1 = options.json && !isFinite(message.Param1) ? String(message.Param1) : message.Param1;
              if (message.Param2 != null && message.hasOwnProperty("Param2")) object.Param2 = options.json && !isFinite(message.Param2) ? String(message.Param2) : message.Param2;
              if (message.Param3 != null && message.hasOwnProperty("Param3")) object.Param3 = options.json && !isFinite(message.Param3) ? String(message.Param3) : message.Param3;
              if (message.Param4 != null && message.hasOwnProperty("Param4")) object.Param4 = options.json && !isFinite(message.Param4) ? String(message.Param4) : message.Param4;
              return object;
            };
            /**
             * Converts this EBuffOut to JSON.
             * @function toJSON
             * @memberof buffProto.EBuffOut
             * @instance
             * @returns {Object.<string,*>} JSON object
             */


            EBuffOut.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return EBuffOut;
          }();

          buffProto.WBuffOut = function () {
            /**
             * Properties of a WBuffOut.
             * @memberof buffProto
             * @interface IWBuffOut
             * @property {Long|null} [BuffIndex] WBuffOut BuffIndex
             * @property {Long|null} [BuffID] WBuffOut BuffID
             * @property {number|null} [GameID] WBuffOut GameID
             * @property {number|null} [Amount] WBuffOut Amount
             * @property {Long|null} [StartTime] WBuffOut StartTime
             * @property {Long|null} [ExpiredTime] WBuffOut ExpiredTime
             * @property {number|null} [Ratio] WBuffOut Ratio
             * @property {number|null} [BuffType] WBuffOut BuffType
             * @property {number|null} [Icon] WBuffOut Icon
             * @property {number|null} [Star] WBuffOut Star
             * @property {Array.<string>|null} [Name] WBuffOut Name
             * @property {Array.<string>|null} [Desc] WBuffOut Desc
             * @property {number|null} [Minute] WBuffOut Minute
             * @property {number|null} [Param1] WBuffOut Param1
             * @property {number|null} [Param2] WBuffOut Param2
             * @property {number|null} [Param3] WBuffOut Param3
             * @property {number|null} [Param4] WBuffOut Param4
             */

            /**
             * Constructs a new WBuffOut.
             * @memberof buffProto
             * @classdesc Represents a WBuffOut.
             * @implements IWBuffOut
             * @constructor
             * @param {buffProto.IWBuffOut=} [properties] Properties to set
             */
            function WBuffOut(properties) {
              this.Name = [];
              this.Desc = [];
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * WBuffOut BuffIndex.
             * @member {Long} BuffIndex
             * @memberof buffProto.WBuffOut
             * @instance
             */


            WBuffOut.prototype.BuffIndex = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
             * WBuffOut BuffID.
             * @member {Long} BuffID
             * @memberof buffProto.WBuffOut
             * @instance
             */

            WBuffOut.prototype.BuffID = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
             * WBuffOut GameID.
             * @member {number} GameID
             * @memberof buffProto.WBuffOut
             * @instance
             */

            WBuffOut.prototype.GameID = 0;
            /**
             * WBuffOut Amount.
             * @member {number} Amount
             * @memberof buffProto.WBuffOut
             * @instance
             */

            WBuffOut.prototype.Amount = 0;
            /**
             * WBuffOut StartTime.
             * @member {Long} StartTime
             * @memberof buffProto.WBuffOut
             * @instance
             */

            WBuffOut.prototype.StartTime = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
             * WBuffOut ExpiredTime.
             * @member {Long} ExpiredTime
             * @memberof buffProto.WBuffOut
             * @instance
             */

            WBuffOut.prototype.ExpiredTime = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
             * WBuffOut Ratio.
             * @member {number} Ratio
             * @memberof buffProto.WBuffOut
             * @instance
             */

            WBuffOut.prototype.Ratio = 0;
            /**
             * WBuffOut BuffType.
             * @member {number} BuffType
             * @memberof buffProto.WBuffOut
             * @instance
             */

            WBuffOut.prototype.BuffType = 0;
            /**
             * WBuffOut Icon.
             * @member {number} Icon
             * @memberof buffProto.WBuffOut
             * @instance
             */

            WBuffOut.prototype.Icon = 0;
            /**
             * WBuffOut Star.
             * @member {number} Star
             * @memberof buffProto.WBuffOut
             * @instance
             */

            WBuffOut.prototype.Star = 0;
            /**
             * WBuffOut Name.
             * @member {Array.<string>} Name
             * @memberof buffProto.WBuffOut
             * @instance
             */

            WBuffOut.prototype.Name = $util.emptyArray;
            /**
             * WBuffOut Desc.
             * @member {Array.<string>} Desc
             * @memberof buffProto.WBuffOut
             * @instance
             */

            WBuffOut.prototype.Desc = $util.emptyArray;
            /**
             * WBuffOut Minute.
             * @member {number} Minute
             * @memberof buffProto.WBuffOut
             * @instance
             */

            WBuffOut.prototype.Minute = 0;
            /**
             * WBuffOut Param1.
             * @member {number} Param1
             * @memberof buffProto.WBuffOut
             * @instance
             */

            WBuffOut.prototype.Param1 = 0;
            /**
             * WBuffOut Param2.
             * @member {number} Param2
             * @memberof buffProto.WBuffOut
             * @instance
             */

            WBuffOut.prototype.Param2 = 0;
            /**
             * WBuffOut Param3.
             * @member {number} Param3
             * @memberof buffProto.WBuffOut
             * @instance
             */

            WBuffOut.prototype.Param3 = 0;
            /**
             * WBuffOut Param4.
             * @member {number} Param4
             * @memberof buffProto.WBuffOut
             * @instance
             */

            WBuffOut.prototype.Param4 = 0;
            /**
             * Creates a new WBuffOut instance using the specified properties.
             * @function create
             * @memberof buffProto.WBuffOut
             * @static
             * @param {buffProto.IWBuffOut=} [properties] Properties to set
             * @returns {buffProto.WBuffOut} WBuffOut instance
             */

            WBuffOut.create = function create(properties) {
              return new WBuffOut(properties);
            };
            /**
             * Encodes the specified WBuffOut message. Does not implicitly {@link buffProto.WBuffOut.verify|verify} messages.
             * @function encode
             * @memberof buffProto.WBuffOut
             * @static
             * @param {buffProto.IWBuffOut} message WBuffOut message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            WBuffOut.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.BuffIndex != null && Object.hasOwnProperty.call(message, "BuffIndex")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int64(message.BuffIndex);
              if (message.BuffID != null && Object.hasOwnProperty.call(message, "BuffID")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int64(message.BuffID);
              if (message.GameID != null && Object.hasOwnProperty.call(message, "GameID")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.GameID);
              if (message.Amount != null && Object.hasOwnProperty.call(message, "Amount")) writer.uint32(
              /* id 4, wireType 0 =*/
              32).int32(message.Amount);
              if (message.StartTime != null && Object.hasOwnProperty.call(message, "StartTime")) writer.uint32(
              /* id 5, wireType 0 =*/
              40).int64(message.StartTime);
              if (message.ExpiredTime != null && Object.hasOwnProperty.call(message, "ExpiredTime")) writer.uint32(
              /* id 6, wireType 0 =*/
              48).int64(message.ExpiredTime);
              if (message.Ratio != null && Object.hasOwnProperty.call(message, "Ratio")) writer.uint32(
              /* id 7, wireType 1 =*/
              57)["double"](message.Ratio);
              if (message.BuffType != null && Object.hasOwnProperty.call(message, "BuffType")) writer.uint32(
              /* id 8, wireType 0 =*/
              64).int32(message.BuffType);
              if (message.Icon != null && Object.hasOwnProperty.call(message, "Icon")) writer.uint32(
              /* id 9, wireType 0 =*/
              72).int32(message.Icon);
              if (message.Star != null && Object.hasOwnProperty.call(message, "Star")) writer.uint32(
              /* id 10, wireType 0 =*/
              80).int32(message.Star);
              if (message.Name != null && message.Name.length) for (var i = 0; i < message.Name.length; ++i) {
                writer.uint32(
                /* id 11, wireType 2 =*/
                90).string(message.Name[i]);
              }
              if (message.Desc != null && message.Desc.length) for (var i = 0; i < message.Desc.length; ++i) {
                writer.uint32(
                /* id 12, wireType 2 =*/
                98).string(message.Desc[i]);
              }
              if (message.Minute != null && Object.hasOwnProperty.call(message, "Minute")) writer.uint32(
              /* id 13, wireType 1 =*/
              105)["double"](message.Minute);
              if (message.Param1 != null && Object.hasOwnProperty.call(message, "Param1")) writer.uint32(
              /* id 14, wireType 1 =*/
              113)["double"](message.Param1);
              if (message.Param2 != null && Object.hasOwnProperty.call(message, "Param2")) writer.uint32(
              /* id 15, wireType 1 =*/
              121)["double"](message.Param2);
              if (message.Param3 != null && Object.hasOwnProperty.call(message, "Param3")) writer.uint32(
              /* id 16, wireType 1 =*/
              129)["double"](message.Param3);
              if (message.Param4 != null && Object.hasOwnProperty.call(message, "Param4")) writer.uint32(
              /* id 17, wireType 1 =*/
              137)["double"](message.Param4);
              return writer;
            };
            /**
             * Encodes the specified WBuffOut message, length delimited. Does not implicitly {@link buffProto.WBuffOut.verify|verify} messages.
             * @function encodeDelimited
             * @memberof buffProto.WBuffOut
             * @static
             * @param {buffProto.IWBuffOut} message WBuffOut message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            WBuffOut.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a WBuffOut message from the specified reader or buffer.
             * @function decode
             * @memberof buffProto.WBuffOut
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {buffProto.WBuffOut} WBuffOut
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            WBuffOut.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.buffProto.WBuffOut();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.BuffIndex = reader.int64();
                    break;

                  case 2:
                    message.BuffID = reader.int64();
                    break;

                  case 3:
                    message.GameID = reader.int32();
                    break;

                  case 4:
                    message.Amount = reader.int32();
                    break;

                  case 5:
                    message.StartTime = reader.int64();
                    break;

                  case 6:
                    message.ExpiredTime = reader.int64();
                    break;

                  case 7:
                    message.Ratio = reader["double"]();
                    break;

                  case 8:
                    message.BuffType = reader.int32();
                    break;

                  case 9:
                    message.Icon = reader.int32();
                    break;

                  case 10:
                    message.Star = reader.int32();
                    break;

                  case 11:
                    if (!(message.Name && message.Name.length)) message.Name = [];
                    message.Name.push(reader.string());
                    break;

                  case 12:
                    if (!(message.Desc && message.Desc.length)) message.Desc = [];
                    message.Desc.push(reader.string());
                    break;

                  case 13:
                    message.Minute = reader["double"]();
                    break;

                  case 14:
                    message.Param1 = reader["double"]();
                    break;

                  case 15:
                    message.Param2 = reader["double"]();
                    break;

                  case 16:
                    message.Param3 = reader["double"]();
                    break;

                  case 17:
                    message.Param4 = reader["double"]();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
             * Decodes a WBuffOut message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof buffProto.WBuffOut
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {buffProto.WBuffOut} WBuffOut
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            WBuffOut.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a WBuffOut message.
             * @function verify
             * @memberof buffProto.WBuffOut
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */


            WBuffOut.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.BuffIndex != null && message.hasOwnProperty("BuffIndex")) if (!$util.isInteger(message.BuffIndex) && !(message.BuffIndex && $util.isInteger(message.BuffIndex.low) && $util.isInteger(message.BuffIndex.high))) return "BuffIndex: integer|Long expected";
              if (message.BuffID != null && message.hasOwnProperty("BuffID")) if (!$util.isInteger(message.BuffID) && !(message.BuffID && $util.isInteger(message.BuffID.low) && $util.isInteger(message.BuffID.high))) return "BuffID: integer|Long expected";
              if (message.GameID != null && message.hasOwnProperty("GameID")) if (!$util.isInteger(message.GameID)) return "GameID: integer expected";
              if (message.Amount != null && message.hasOwnProperty("Amount")) if (!$util.isInteger(message.Amount)) return "Amount: integer expected";
              if (message.StartTime != null && message.hasOwnProperty("StartTime")) if (!$util.isInteger(message.StartTime) && !(message.StartTime && $util.isInteger(message.StartTime.low) && $util.isInteger(message.StartTime.high))) return "StartTime: integer|Long expected";
              if (message.ExpiredTime != null && message.hasOwnProperty("ExpiredTime")) if (!$util.isInteger(message.ExpiredTime) && !(message.ExpiredTime && $util.isInteger(message.ExpiredTime.low) && $util.isInteger(message.ExpiredTime.high))) return "ExpiredTime: integer|Long expected";
              if (message.Ratio != null && message.hasOwnProperty("Ratio")) if (typeof message.Ratio !== "number") return "Ratio: number expected";
              if (message.BuffType != null && message.hasOwnProperty("BuffType")) if (!$util.isInteger(message.BuffType)) return "BuffType: integer expected";
              if (message.Icon != null && message.hasOwnProperty("Icon")) if (!$util.isInteger(message.Icon)) return "Icon: integer expected";
              if (message.Star != null && message.hasOwnProperty("Star")) if (!$util.isInteger(message.Star)) return "Star: integer expected";

              if (message.Name != null && message.hasOwnProperty("Name")) {
                if (!Array.isArray(message.Name)) return "Name: array expected";

                for (var i = 0; i < message.Name.length; ++i) {
                  if (!$util.isString(message.Name[i])) return "Name: string[] expected";
                }
              }

              if (message.Desc != null && message.hasOwnProperty("Desc")) {
                if (!Array.isArray(message.Desc)) return "Desc: array expected";

                for (var i = 0; i < message.Desc.length; ++i) {
                  if (!$util.isString(message.Desc[i])) return "Desc: string[] expected";
                }
              }

              if (message.Minute != null && message.hasOwnProperty("Minute")) if (typeof message.Minute !== "number") return "Minute: number expected";
              if (message.Param1 != null && message.hasOwnProperty("Param1")) if (typeof message.Param1 !== "number") return "Param1: number expected";
              if (message.Param2 != null && message.hasOwnProperty("Param2")) if (typeof message.Param2 !== "number") return "Param2: number expected";
              if (message.Param3 != null && message.hasOwnProperty("Param3")) if (typeof message.Param3 !== "number") return "Param3: number expected";
              if (message.Param4 != null && message.hasOwnProperty("Param4")) if (typeof message.Param4 !== "number") return "Param4: number expected";
              return null;
            };
            /**
             * Creates a WBuffOut message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof buffProto.WBuffOut
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {buffProto.WBuffOut} WBuffOut
             */


            WBuffOut.fromObject = function fromObject(object) {
              if (object instanceof $root.buffProto.WBuffOut) return object;
              var message = new $root.buffProto.WBuffOut();
              if (object.BuffIndex != null) if ($util.Long) (message.BuffIndex = $util.Long.fromValue(object.BuffIndex)).unsigned = false;else if (typeof object.BuffIndex === "string") message.BuffIndex = parseInt(object.BuffIndex, 10);else if (typeof object.BuffIndex === "number") message.BuffIndex = object.BuffIndex;else if (typeof object.BuffIndex === "object") message.BuffIndex = new $util.LongBits(object.BuffIndex.low >>> 0, object.BuffIndex.high >>> 0).toNumber();
              if (object.BuffID != null) if ($util.Long) (message.BuffID = $util.Long.fromValue(object.BuffID)).unsigned = false;else if (typeof object.BuffID === "string") message.BuffID = parseInt(object.BuffID, 10);else if (typeof object.BuffID === "number") message.BuffID = object.BuffID;else if (typeof object.BuffID === "object") message.BuffID = new $util.LongBits(object.BuffID.low >>> 0, object.BuffID.high >>> 0).toNumber();
              if (object.GameID != null) message.GameID = object.GameID | 0;
              if (object.Amount != null) message.Amount = object.Amount | 0;
              if (object.StartTime != null) if ($util.Long) (message.StartTime = $util.Long.fromValue(object.StartTime)).unsigned = false;else if (typeof object.StartTime === "string") message.StartTime = parseInt(object.StartTime, 10);else if (typeof object.StartTime === "number") message.StartTime = object.StartTime;else if (typeof object.StartTime === "object") message.StartTime = new $util.LongBits(object.StartTime.low >>> 0, object.StartTime.high >>> 0).toNumber();
              if (object.ExpiredTime != null) if ($util.Long) (message.ExpiredTime = $util.Long.fromValue(object.ExpiredTime)).unsigned = false;else if (typeof object.ExpiredTime === "string") message.ExpiredTime = parseInt(object.ExpiredTime, 10);else if (typeof object.ExpiredTime === "number") message.ExpiredTime = object.ExpiredTime;else if (typeof object.ExpiredTime === "object") message.ExpiredTime = new $util.LongBits(object.ExpiredTime.low >>> 0, object.ExpiredTime.high >>> 0).toNumber();
              if (object.Ratio != null) message.Ratio = Number(object.Ratio);
              if (object.BuffType != null) message.BuffType = object.BuffType | 0;
              if (object.Icon != null) message.Icon = object.Icon | 0;
              if (object.Star != null) message.Star = object.Star | 0;

              if (object.Name) {
                if (!Array.isArray(object.Name)) throw TypeError(".buffProto.WBuffOut.Name: array expected");
                message.Name = [];

                for (var i = 0; i < object.Name.length; ++i) {
                  message.Name[i] = String(object.Name[i]);
                }
              }

              if (object.Desc) {
                if (!Array.isArray(object.Desc)) throw TypeError(".buffProto.WBuffOut.Desc: array expected");
                message.Desc = [];

                for (var i = 0; i < object.Desc.length; ++i) {
                  message.Desc[i] = String(object.Desc[i]);
                }
              }

              if (object.Minute != null) message.Minute = Number(object.Minute);
              if (object.Param1 != null) message.Param1 = Number(object.Param1);
              if (object.Param2 != null) message.Param2 = Number(object.Param2);
              if (object.Param3 != null) message.Param3 = Number(object.Param3);
              if (object.Param4 != null) message.Param4 = Number(object.Param4);
              return message;
            };
            /**
             * Creates a plain object from a WBuffOut message. Also converts values to other types if specified.
             * @function toObject
             * @memberof buffProto.WBuffOut
             * @static
             * @param {buffProto.WBuffOut} message WBuffOut
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */


            WBuffOut.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.arrays || options.defaults) {
                object.Name = [];
                object.Desc = [];
              }

              if (options.defaults) {
                if ($util.Long) {
                  var _long3 = new $util.Long(0, 0, false);

                  object.BuffIndex = options.longs === String ? _long3.toString() : options.longs === Number ? _long3.toNumber() : _long3;
                } else object.BuffIndex = options.longs === String ? "0" : 0;

                if ($util.Long) {
                  var _long3 = new $util.Long(0, 0, false);

                  object.BuffID = options.longs === String ? _long3.toString() : options.longs === Number ? _long3.toNumber() : _long3;
                } else object.BuffID = options.longs === String ? "0" : 0;

                object.GameID = 0;
                object.Amount = 0;

                if ($util.Long) {
                  var _long3 = new $util.Long(0, 0, false);

                  object.StartTime = options.longs === String ? _long3.toString() : options.longs === Number ? _long3.toNumber() : _long3;
                } else object.StartTime = options.longs === String ? "0" : 0;

                if ($util.Long) {
                  var _long3 = new $util.Long(0, 0, false);

                  object.ExpiredTime = options.longs === String ? _long3.toString() : options.longs === Number ? _long3.toNumber() : _long3;
                } else object.ExpiredTime = options.longs === String ? "0" : 0;

                object.Ratio = 0;
                object.BuffType = 0;
                object.Icon = 0;
                object.Star = 0;
                object.Minute = 0;
                object.Param1 = 0;
                object.Param2 = 0;
                object.Param3 = 0;
                object.Param4 = 0;
              }

              if (message.BuffIndex != null && message.hasOwnProperty("BuffIndex")) if (typeof message.BuffIndex === "number") object.BuffIndex = options.longs === String ? String(message.BuffIndex) : message.BuffIndex;else object.BuffIndex = options.longs === String ? $util.Long.prototype.toString.call(message.BuffIndex) : options.longs === Number ? new $util.LongBits(message.BuffIndex.low >>> 0, message.BuffIndex.high >>> 0).toNumber() : message.BuffIndex;
              if (message.BuffID != null && message.hasOwnProperty("BuffID")) if (typeof message.BuffID === "number") object.BuffID = options.longs === String ? String(message.BuffID) : message.BuffID;else object.BuffID = options.longs === String ? $util.Long.prototype.toString.call(message.BuffID) : options.longs === Number ? new $util.LongBits(message.BuffID.low >>> 0, message.BuffID.high >>> 0).toNumber() : message.BuffID;
              if (message.GameID != null && message.hasOwnProperty("GameID")) object.GameID = message.GameID;
              if (message.Amount != null && message.hasOwnProperty("Amount")) object.Amount = message.Amount;
              if (message.StartTime != null && message.hasOwnProperty("StartTime")) if (typeof message.StartTime === "number") object.StartTime = options.longs === String ? String(message.StartTime) : message.StartTime;else object.StartTime = options.longs === String ? $util.Long.prototype.toString.call(message.StartTime) : options.longs === Number ? new $util.LongBits(message.StartTime.low >>> 0, message.StartTime.high >>> 0).toNumber() : message.StartTime;
              if (message.ExpiredTime != null && message.hasOwnProperty("ExpiredTime")) if (typeof message.ExpiredTime === "number") object.ExpiredTime = options.longs === String ? String(message.ExpiredTime) : message.ExpiredTime;else object.ExpiredTime = options.longs === String ? $util.Long.prototype.toString.call(message.ExpiredTime) : options.longs === Number ? new $util.LongBits(message.ExpiredTime.low >>> 0, message.ExpiredTime.high >>> 0).toNumber() : message.ExpiredTime;
              if (message.Ratio != null && message.hasOwnProperty("Ratio")) object.Ratio = options.json && !isFinite(message.Ratio) ? String(message.Ratio) : message.Ratio;
              if (message.BuffType != null && message.hasOwnProperty("BuffType")) object.BuffType = message.BuffType;
              if (message.Icon != null && message.hasOwnProperty("Icon")) object.Icon = message.Icon;
              if (message.Star != null && message.hasOwnProperty("Star")) object.Star = message.Star;

              if (message.Name && message.Name.length) {
                object.Name = [];

                for (var j = 0; j < message.Name.length; ++j) {
                  object.Name[j] = message.Name[j];
                }
              }

              if (message.Desc && message.Desc.length) {
                object.Desc = [];

                for (var j = 0; j < message.Desc.length; ++j) {
                  object.Desc[j] = message.Desc[j];
                }
              }

              if (message.Minute != null && message.hasOwnProperty("Minute")) object.Minute = options.json && !isFinite(message.Minute) ? String(message.Minute) : message.Minute;
              if (message.Param1 != null && message.hasOwnProperty("Param1")) object.Param1 = options.json && !isFinite(message.Param1) ? String(message.Param1) : message.Param1;
              if (message.Param2 != null && message.hasOwnProperty("Param2")) object.Param2 = options.json && !isFinite(message.Param2) ? String(message.Param2) : message.Param2;
              if (message.Param3 != null && message.hasOwnProperty("Param3")) object.Param3 = options.json && !isFinite(message.Param3) ? String(message.Param3) : message.Param3;
              if (message.Param4 != null && message.hasOwnProperty("Param4")) object.Param4 = options.json && !isFinite(message.Param4) ? String(message.Param4) : message.Param4;
              return object;
            };
            /**
             * Converts this WBuffOut to JSON.
             * @function toJSON
             * @memberof buffProto.WBuffOut
             * @instance
             * @returns {Object.<string,*>} JSON object
             */


            WBuffOut.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WBuffOut;
          }();

          buffProto.GetPlayerBackAck = function () {
            /**
             * Properties of a GetPlayerBackAck.
             * @memberof buffProto
             * @interface IGetPlayerBackAck
             * @property {number|null} [Result] GetPlayerBackAck Result
             * @property {Array.<buffProto.IWBuffOut>|null} [List] GetPlayerBackAck List
             * @property {Array.<buffProto.IWBuffOut>|null} [IList] GetPlayerBackAck IList
             */

            /**
             * Constructs a new GetPlayerBackAck.
             * @memberof buffProto
             * @classdesc Represents a GetPlayerBackAck.
             * @implements IGetPlayerBackAck
             * @constructor
             * @param {buffProto.IGetPlayerBackAck=} [properties] Properties to set
             */
            function GetPlayerBackAck(properties) {
              this.List = [];
              this.IList = [];
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * GetPlayerBackAck Result.
             * @member {number} Result
             * @memberof buffProto.GetPlayerBackAck
             * @instance
             */


            GetPlayerBackAck.prototype.Result = 0;
            /**
             * GetPlayerBackAck List.
             * @member {Array.<buffProto.IWBuffOut>} List
             * @memberof buffProto.GetPlayerBackAck
             * @instance
             */

            GetPlayerBackAck.prototype.List = $util.emptyArray;
            /**
             * GetPlayerBackAck IList.
             * @member {Array.<buffProto.IWBuffOut>} IList
             * @memberof buffProto.GetPlayerBackAck
             * @instance
             */

            GetPlayerBackAck.prototype.IList = $util.emptyArray;
            /**
             * Creates a new GetPlayerBackAck instance using the specified properties.
             * @function create
             * @memberof buffProto.GetPlayerBackAck
             * @static
             * @param {buffProto.IGetPlayerBackAck=} [properties] Properties to set
             * @returns {buffProto.GetPlayerBackAck} GetPlayerBackAck instance
             */

            GetPlayerBackAck.create = function create(properties) {
              return new GetPlayerBackAck(properties);
            };
            /**
             * Encodes the specified GetPlayerBackAck message. Does not implicitly {@link buffProto.GetPlayerBackAck.verify|verify} messages.
             * @function encode
             * @memberof buffProto.GetPlayerBackAck
             * @static
             * @param {buffProto.IGetPlayerBackAck} message GetPlayerBackAck message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            GetPlayerBackAck.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.Result != null && Object.hasOwnProperty.call(message, "Result")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.Result);
              if (message.List != null && message.List.length) for (var i = 0; i < message.List.length; ++i) {
                $root.buffProto.WBuffOut.encode(message.List[i], writer.uint32(
                /* id 2, wireType 2 =*/
                18).fork()).ldelim();
              }
              if (message.IList != null && message.IList.length) for (var i = 0; i < message.IList.length; ++i) {
                $root.buffProto.WBuffOut.encode(message.IList[i], writer.uint32(
                /* id 3, wireType 2 =*/
                26).fork()).ldelim();
              }
              return writer;
            };
            /**
             * Encodes the specified GetPlayerBackAck message, length delimited. Does not implicitly {@link buffProto.GetPlayerBackAck.verify|verify} messages.
             * @function encodeDelimited
             * @memberof buffProto.GetPlayerBackAck
             * @static
             * @param {buffProto.IGetPlayerBackAck} message GetPlayerBackAck message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            GetPlayerBackAck.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a GetPlayerBackAck message from the specified reader or buffer.
             * @function decode
             * @memberof buffProto.GetPlayerBackAck
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {buffProto.GetPlayerBackAck} GetPlayerBackAck
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            GetPlayerBackAck.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.buffProto.GetPlayerBackAck();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.Result = reader.int32();
                    break;

                  case 2:
                    if (!(message.List && message.List.length)) message.List = [];
                    message.List.push($root.buffProto.WBuffOut.decode(reader, reader.uint32()));
                    break;

                  case 3:
                    if (!(message.IList && message.IList.length)) message.IList = [];
                    message.IList.push($root.buffProto.WBuffOut.decode(reader, reader.uint32()));
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
             * Decodes a GetPlayerBackAck message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof buffProto.GetPlayerBackAck
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {buffProto.GetPlayerBackAck} GetPlayerBackAck
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            GetPlayerBackAck.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a GetPlayerBackAck message.
             * @function verify
             * @memberof buffProto.GetPlayerBackAck
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */


            GetPlayerBackAck.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.Result != null && message.hasOwnProperty("Result")) if (!$util.isInteger(message.Result)) return "Result: integer expected";

              if (message.List != null && message.hasOwnProperty("List")) {
                if (!Array.isArray(message.List)) return "List: array expected";

                for (var i = 0; i < message.List.length; ++i) {
                  var error = $root.buffProto.WBuffOut.verify(message.List[i]);
                  if (error) return "List." + error;
                }
              }

              if (message.IList != null && message.hasOwnProperty("IList")) {
                if (!Array.isArray(message.IList)) return "IList: array expected";

                for (var i = 0; i < message.IList.length; ++i) {
                  var error = $root.buffProto.WBuffOut.verify(message.IList[i]);
                  if (error) return "IList." + error;
                }
              }

              return null;
            };
            /**
             * Creates a GetPlayerBackAck message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof buffProto.GetPlayerBackAck
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {buffProto.GetPlayerBackAck} GetPlayerBackAck
             */


            GetPlayerBackAck.fromObject = function fromObject(object) {
              if (object instanceof $root.buffProto.GetPlayerBackAck) return object;
              var message = new $root.buffProto.GetPlayerBackAck();
              if (object.Result != null) message.Result = object.Result | 0;

              if (object.List) {
                if (!Array.isArray(object.List)) throw TypeError(".buffProto.GetPlayerBackAck.List: array expected");
                message.List = [];

                for (var i = 0; i < object.List.length; ++i) {
                  if (typeof object.List[i] !== "object") throw TypeError(".buffProto.GetPlayerBackAck.List: object expected");
                  message.List[i] = $root.buffProto.WBuffOut.fromObject(object.List[i]);
                }
              }

              if (object.IList) {
                if (!Array.isArray(object.IList)) throw TypeError(".buffProto.GetPlayerBackAck.IList: array expected");
                message.IList = [];

                for (var i = 0; i < object.IList.length; ++i) {
                  if (typeof object.IList[i] !== "object") throw TypeError(".buffProto.GetPlayerBackAck.IList: object expected");
                  message.IList[i] = $root.buffProto.WBuffOut.fromObject(object.IList[i]);
                }
              }

              return message;
            };
            /**
             * Creates a plain object from a GetPlayerBackAck message. Also converts values to other types if specified.
             * @function toObject
             * @memberof buffProto.GetPlayerBackAck
             * @static
             * @param {buffProto.GetPlayerBackAck} message GetPlayerBackAck
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */


            GetPlayerBackAck.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.arrays || options.defaults) {
                object.List = [];
                object.IList = [];
              }

              if (options.defaults) object.Result = 0;
              if (message.Result != null && message.hasOwnProperty("Result")) object.Result = message.Result;

              if (message.List && message.List.length) {
                object.List = [];

                for (var j = 0; j < message.List.length; ++j) {
                  object.List[j] = $root.buffProto.WBuffOut.toObject(message.List[j], options);
                }
              }

              if (message.IList && message.IList.length) {
                object.IList = [];

                for (var j = 0; j < message.IList.length; ++j) {
                  object.IList[j] = $root.buffProto.WBuffOut.toObject(message.IList[j], options);
                }
              }

              return object;
            };
            /**
             * Converts this GetPlayerBackAck to JSON.
             * @function toJSON
             * @memberof buffProto.GetPlayerBackAck
             * @instance
             * @returns {Object.<string,*>} JSON object
             */


            GetPlayerBackAck.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GetPlayerBackAck;
          }();

          buffProto.GetPlayerBuffAck = function () {
            /**
             * Properties of a GetPlayerBuffAck.
             * @memberof buffProto
             * @interface IGetPlayerBuffAck
             * @property {number|null} [Result] GetPlayerBuffAck Result
             * @property {Array.<buffProto.IEBuffOut>|null} [List] GetPlayerBuffAck List
             */

            /**
             * Constructs a new GetPlayerBuffAck.
             * @memberof buffProto
             * @classdesc Represents a GetPlayerBuffAck.
             * @implements IGetPlayerBuffAck
             * @constructor
             * @param {buffProto.IGetPlayerBuffAck=} [properties] Properties to set
             */
            function GetPlayerBuffAck(properties) {
              this.List = [];
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * GetPlayerBuffAck Result.
             * @member {number} Result
             * @memberof buffProto.GetPlayerBuffAck
             * @instance
             */


            GetPlayerBuffAck.prototype.Result = 0;
            /**
             * GetPlayerBuffAck List.
             * @member {Array.<buffProto.IEBuffOut>} List
             * @memberof buffProto.GetPlayerBuffAck
             * @instance
             */

            GetPlayerBuffAck.prototype.List = $util.emptyArray;
            /**
             * Creates a new GetPlayerBuffAck instance using the specified properties.
             * @function create
             * @memberof buffProto.GetPlayerBuffAck
             * @static
             * @param {buffProto.IGetPlayerBuffAck=} [properties] Properties to set
             * @returns {buffProto.GetPlayerBuffAck} GetPlayerBuffAck instance
             */

            GetPlayerBuffAck.create = function create(properties) {
              return new GetPlayerBuffAck(properties);
            };
            /**
             * Encodes the specified GetPlayerBuffAck message. Does not implicitly {@link buffProto.GetPlayerBuffAck.verify|verify} messages.
             * @function encode
             * @memberof buffProto.GetPlayerBuffAck
             * @static
             * @param {buffProto.IGetPlayerBuffAck} message GetPlayerBuffAck message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            GetPlayerBuffAck.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.Result != null && Object.hasOwnProperty.call(message, "Result")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.Result);
              if (message.List != null && message.List.length) for (var i = 0; i < message.List.length; ++i) {
                $root.buffProto.EBuffOut.encode(message.List[i], writer.uint32(
                /* id 2, wireType 2 =*/
                18).fork()).ldelim();
              }
              return writer;
            };
            /**
             * Encodes the specified GetPlayerBuffAck message, length delimited. Does not implicitly {@link buffProto.GetPlayerBuffAck.verify|verify} messages.
             * @function encodeDelimited
             * @memberof buffProto.GetPlayerBuffAck
             * @static
             * @param {buffProto.IGetPlayerBuffAck} message GetPlayerBuffAck message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            GetPlayerBuffAck.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a GetPlayerBuffAck message from the specified reader or buffer.
             * @function decode
             * @memberof buffProto.GetPlayerBuffAck
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {buffProto.GetPlayerBuffAck} GetPlayerBuffAck
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            GetPlayerBuffAck.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.buffProto.GetPlayerBuffAck();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.Result = reader.int32();
                    break;

                  case 2:
                    if (!(message.List && message.List.length)) message.List = [];
                    message.List.push($root.buffProto.EBuffOut.decode(reader, reader.uint32()));
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
             * Decodes a GetPlayerBuffAck message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof buffProto.GetPlayerBuffAck
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {buffProto.GetPlayerBuffAck} GetPlayerBuffAck
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            GetPlayerBuffAck.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a GetPlayerBuffAck message.
             * @function verify
             * @memberof buffProto.GetPlayerBuffAck
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */


            GetPlayerBuffAck.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.Result != null && message.hasOwnProperty("Result")) if (!$util.isInteger(message.Result)) return "Result: integer expected";

              if (message.List != null && message.hasOwnProperty("List")) {
                if (!Array.isArray(message.List)) return "List: array expected";

                for (var i = 0; i < message.List.length; ++i) {
                  var error = $root.buffProto.EBuffOut.verify(message.List[i]);
                  if (error) return "List." + error;
                }
              }

              return null;
            };
            /**
             * Creates a GetPlayerBuffAck message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof buffProto.GetPlayerBuffAck
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {buffProto.GetPlayerBuffAck} GetPlayerBuffAck
             */


            GetPlayerBuffAck.fromObject = function fromObject(object) {
              if (object instanceof $root.buffProto.GetPlayerBuffAck) return object;
              var message = new $root.buffProto.GetPlayerBuffAck();
              if (object.Result != null) message.Result = object.Result | 0;

              if (object.List) {
                if (!Array.isArray(object.List)) throw TypeError(".buffProto.GetPlayerBuffAck.List: array expected");
                message.List = [];

                for (var i = 0; i < object.List.length; ++i) {
                  if (typeof object.List[i] !== "object") throw TypeError(".buffProto.GetPlayerBuffAck.List: object expected");
                  message.List[i] = $root.buffProto.EBuffOut.fromObject(object.List[i]);
                }
              }

              return message;
            };
            /**
             * Creates a plain object from a GetPlayerBuffAck message. Also converts values to other types if specified.
             * @function toObject
             * @memberof buffProto.GetPlayerBuffAck
             * @static
             * @param {buffProto.GetPlayerBuffAck} message GetPlayerBuffAck
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */


            GetPlayerBuffAck.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};
              if (options.arrays || options.defaults) object.List = [];
              if (options.defaults) object.Result = 0;
              if (message.Result != null && message.hasOwnProperty("Result")) object.Result = message.Result;

              if (message.List && message.List.length) {
                object.List = [];

                for (var j = 0; j < message.List.length; ++j) {
                  object.List[j] = $root.buffProto.EBuffOut.toObject(message.List[j], options);
                }
              }

              return object;
            };
            /**
             * Converts this GetPlayerBuffAck to JSON.
             * @function toJSON
             * @memberof buffProto.GetPlayerBuffAck
             * @instance
             * @returns {Object.<string,*>} JSON object
             */


            GetPlayerBuffAck.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GetPlayerBuffAck;
          }();

          buffProto.AddPlayerBuffAck = function () {
            /**
             * Properties of an AddPlayerBuffAck.
             * @memberof buffProto
             * @interface IAddPlayerBuffAck
             * @property {number|null} [Result] AddPlayerBuffAck Result
             * @property {number|null} [State] AddPlayerBuffAck State
             * @property {buffProto.IWBuffOut|null} [Info] AddPlayerBuffAck Info
             */

            /**
             * Constructs a new AddPlayerBuffAck.
             * @memberof buffProto
             * @classdesc Represents an AddPlayerBuffAck.
             * @implements IAddPlayerBuffAck
             * @constructor
             * @param {buffProto.IAddPlayerBuffAck=} [properties] Properties to set
             */
            function AddPlayerBuffAck(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * AddPlayerBuffAck Result.
             * @member {number} Result
             * @memberof buffProto.AddPlayerBuffAck
             * @instance
             */


            AddPlayerBuffAck.prototype.Result = 0;
            /**
             * AddPlayerBuffAck State.
             * @member {number} State
             * @memberof buffProto.AddPlayerBuffAck
             * @instance
             */

            AddPlayerBuffAck.prototype.State = 0;
            /**
             * AddPlayerBuffAck Info.
             * @member {buffProto.IWBuffOut|null|undefined} Info
             * @memberof buffProto.AddPlayerBuffAck
             * @instance
             */

            AddPlayerBuffAck.prototype.Info = null;
            /**
             * Creates a new AddPlayerBuffAck instance using the specified properties.
             * @function create
             * @memberof buffProto.AddPlayerBuffAck
             * @static
             * @param {buffProto.IAddPlayerBuffAck=} [properties] Properties to set
             * @returns {buffProto.AddPlayerBuffAck} AddPlayerBuffAck instance
             */

            AddPlayerBuffAck.create = function create(properties) {
              return new AddPlayerBuffAck(properties);
            };
            /**
             * Encodes the specified AddPlayerBuffAck message. Does not implicitly {@link buffProto.AddPlayerBuffAck.verify|verify} messages.
             * @function encode
             * @memberof buffProto.AddPlayerBuffAck
             * @static
             * @param {buffProto.IAddPlayerBuffAck} message AddPlayerBuffAck message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            AddPlayerBuffAck.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.Result != null && Object.hasOwnProperty.call(message, "Result")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.Result);
              if (message.State != null && Object.hasOwnProperty.call(message, "State")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int32(message.State);
              if (message.Info != null && Object.hasOwnProperty.call(message, "Info")) $root.buffProto.WBuffOut.encode(message.Info, writer.uint32(
              /* id 3, wireType 2 =*/
              26).fork()).ldelim();
              return writer;
            };
            /**
             * Encodes the specified AddPlayerBuffAck message, length delimited. Does not implicitly {@link buffProto.AddPlayerBuffAck.verify|verify} messages.
             * @function encodeDelimited
             * @memberof buffProto.AddPlayerBuffAck
             * @static
             * @param {buffProto.IAddPlayerBuffAck} message AddPlayerBuffAck message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            AddPlayerBuffAck.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes an AddPlayerBuffAck message from the specified reader or buffer.
             * @function decode
             * @memberof buffProto.AddPlayerBuffAck
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {buffProto.AddPlayerBuffAck} AddPlayerBuffAck
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            AddPlayerBuffAck.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.buffProto.AddPlayerBuffAck();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.Result = reader.int32();
                    break;

                  case 2:
                    message.State = reader.int32();
                    break;

                  case 3:
                    message.Info = $root.buffProto.WBuffOut.decode(reader, reader.uint32());
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
             * Decodes an AddPlayerBuffAck message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof buffProto.AddPlayerBuffAck
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {buffProto.AddPlayerBuffAck} AddPlayerBuffAck
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            AddPlayerBuffAck.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies an AddPlayerBuffAck message.
             * @function verify
             * @memberof buffProto.AddPlayerBuffAck
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */


            AddPlayerBuffAck.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.Result != null && message.hasOwnProperty("Result")) if (!$util.isInteger(message.Result)) return "Result: integer expected";
              if (message.State != null && message.hasOwnProperty("State")) if (!$util.isInteger(message.State)) return "State: integer expected";

              if (message.Info != null && message.hasOwnProperty("Info")) {
                var error = $root.buffProto.WBuffOut.verify(message.Info);
                if (error) return "Info." + error;
              }

              return null;
            };
            /**
             * Creates an AddPlayerBuffAck message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof buffProto.AddPlayerBuffAck
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {buffProto.AddPlayerBuffAck} AddPlayerBuffAck
             */


            AddPlayerBuffAck.fromObject = function fromObject(object) {
              if (object instanceof $root.buffProto.AddPlayerBuffAck) return object;
              var message = new $root.buffProto.AddPlayerBuffAck();
              if (object.Result != null) message.Result = object.Result | 0;
              if (object.State != null) message.State = object.State | 0;

              if (object.Info != null) {
                if (typeof object.Info !== "object") throw TypeError(".buffProto.AddPlayerBuffAck.Info: object expected");
                message.Info = $root.buffProto.WBuffOut.fromObject(object.Info);
              }

              return message;
            };
            /**
             * Creates a plain object from an AddPlayerBuffAck message. Also converts values to other types if specified.
             * @function toObject
             * @memberof buffProto.AddPlayerBuffAck
             * @static
             * @param {buffProto.AddPlayerBuffAck} message AddPlayerBuffAck
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */


            AddPlayerBuffAck.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.Result = 0;
                object.State = 0;
                object.Info = null;
              }

              if (message.Result != null && message.hasOwnProperty("Result")) object.Result = message.Result;
              if (message.State != null && message.hasOwnProperty("State")) object.State = message.State;
              if (message.Info != null && message.hasOwnProperty("Info")) object.Info = $root.buffProto.WBuffOut.toObject(message.Info, options);
              return object;
            };
            /**
             * Converts this AddPlayerBuffAck to JSON.
             * @function toJSON
             * @memberof buffProto.AddPlayerBuffAck
             * @instance
             * @returns {Object.<string,*>} JSON object
             */


            AddPlayerBuffAck.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AddPlayerBuffAck;
          }();

          buffProto.UsePlayerBuffAck = function () {
            /**
             * Properties of a UsePlayerBuffAck.
             * @memberof buffProto
             * @interface IUsePlayerBuffAck
             * @property {number|null} [Result] UsePlayerBuffAck Result
             * @property {number|null} [State] UsePlayerBuffAck State
             * @property {buffProto.IEBuffOut|null} [Info] UsePlayerBuffAck Info
             */

            /**
             * Constructs a new UsePlayerBuffAck.
             * @memberof buffProto
             * @classdesc Represents a UsePlayerBuffAck.
             * @implements IUsePlayerBuffAck
             * @constructor
             * @param {buffProto.IUsePlayerBuffAck=} [properties] Properties to set
             */
            function UsePlayerBuffAck(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * UsePlayerBuffAck Result.
             * @member {number} Result
             * @memberof buffProto.UsePlayerBuffAck
             * @instance
             */


            UsePlayerBuffAck.prototype.Result = 0;
            /**
             * UsePlayerBuffAck State.
             * @member {number} State
             * @memberof buffProto.UsePlayerBuffAck
             * @instance
             */

            UsePlayerBuffAck.prototype.State = 0;
            /**
             * UsePlayerBuffAck Info.
             * @member {buffProto.IEBuffOut|null|undefined} Info
             * @memberof buffProto.UsePlayerBuffAck
             * @instance
             */

            UsePlayerBuffAck.prototype.Info = null;
            /**
             * Creates a new UsePlayerBuffAck instance using the specified properties.
             * @function create
             * @memberof buffProto.UsePlayerBuffAck
             * @static
             * @param {buffProto.IUsePlayerBuffAck=} [properties] Properties to set
             * @returns {buffProto.UsePlayerBuffAck} UsePlayerBuffAck instance
             */

            UsePlayerBuffAck.create = function create(properties) {
              return new UsePlayerBuffAck(properties);
            };
            /**
             * Encodes the specified UsePlayerBuffAck message. Does not implicitly {@link buffProto.UsePlayerBuffAck.verify|verify} messages.
             * @function encode
             * @memberof buffProto.UsePlayerBuffAck
             * @static
             * @param {buffProto.IUsePlayerBuffAck} message UsePlayerBuffAck message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            UsePlayerBuffAck.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.Result != null && Object.hasOwnProperty.call(message, "Result")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.Result);
              if (message.State != null && Object.hasOwnProperty.call(message, "State")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int32(message.State);
              if (message.Info != null && Object.hasOwnProperty.call(message, "Info")) $root.buffProto.EBuffOut.encode(message.Info, writer.uint32(
              /* id 3, wireType 2 =*/
              26).fork()).ldelim();
              return writer;
            };
            /**
             * Encodes the specified UsePlayerBuffAck message, length delimited. Does not implicitly {@link buffProto.UsePlayerBuffAck.verify|verify} messages.
             * @function encodeDelimited
             * @memberof buffProto.UsePlayerBuffAck
             * @static
             * @param {buffProto.IUsePlayerBuffAck} message UsePlayerBuffAck message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            UsePlayerBuffAck.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a UsePlayerBuffAck message from the specified reader or buffer.
             * @function decode
             * @memberof buffProto.UsePlayerBuffAck
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {buffProto.UsePlayerBuffAck} UsePlayerBuffAck
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            UsePlayerBuffAck.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.buffProto.UsePlayerBuffAck();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.Result = reader.int32();
                    break;

                  case 2:
                    message.State = reader.int32();
                    break;

                  case 3:
                    message.Info = $root.buffProto.EBuffOut.decode(reader, reader.uint32());
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
             * Decodes a UsePlayerBuffAck message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof buffProto.UsePlayerBuffAck
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {buffProto.UsePlayerBuffAck} UsePlayerBuffAck
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            UsePlayerBuffAck.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a UsePlayerBuffAck message.
             * @function verify
             * @memberof buffProto.UsePlayerBuffAck
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */


            UsePlayerBuffAck.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.Result != null && message.hasOwnProperty("Result")) if (!$util.isInteger(message.Result)) return "Result: integer expected";
              if (message.State != null && message.hasOwnProperty("State")) if (!$util.isInteger(message.State)) return "State: integer expected";

              if (message.Info != null && message.hasOwnProperty("Info")) {
                var error = $root.buffProto.EBuffOut.verify(message.Info);
                if (error) return "Info." + error;
              }

              return null;
            };
            /**
             * Creates a UsePlayerBuffAck message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof buffProto.UsePlayerBuffAck
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {buffProto.UsePlayerBuffAck} UsePlayerBuffAck
             */


            UsePlayerBuffAck.fromObject = function fromObject(object) {
              if (object instanceof $root.buffProto.UsePlayerBuffAck) return object;
              var message = new $root.buffProto.UsePlayerBuffAck();
              if (object.Result != null) message.Result = object.Result | 0;
              if (object.State != null) message.State = object.State | 0;

              if (object.Info != null) {
                if (typeof object.Info !== "object") throw TypeError(".buffProto.UsePlayerBuffAck.Info: object expected");
                message.Info = $root.buffProto.EBuffOut.fromObject(object.Info);
              }

              return message;
            };
            /**
             * Creates a plain object from a UsePlayerBuffAck message. Also converts values to other types if specified.
             * @function toObject
             * @memberof buffProto.UsePlayerBuffAck
             * @static
             * @param {buffProto.UsePlayerBuffAck} message UsePlayerBuffAck
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */


            UsePlayerBuffAck.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.Result = 0;
                object.State = 0;
                object.Info = null;
              }

              if (message.Result != null && message.hasOwnProperty("Result")) object.Result = message.Result;
              if (message.State != null && message.hasOwnProperty("State")) object.State = message.State;
              if (message.Info != null && message.hasOwnProperty("Info")) object.Info = $root.buffProto.EBuffOut.toObject(message.Info, options);
              return object;
            };
            /**
             * Converts this UsePlayerBuffAck to JSON.
             * @function toJSON
             * @memberof buffProto.UsePlayerBuffAck
             * @instance
             * @returns {Object.<string,*>} JSON object
             */


            UsePlayerBuffAck.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return UsePlayerBuffAck;
          }();

          buffProto.UpdatelayerBuffAck = function () {
            /**
             * Properties of an UpdatelayerBuffAck.
             * @memberof buffProto
             * @interface IUpdatelayerBuffAck
             * @property {number|null} [Result] UpdatelayerBuffAck Result
             * @property {number|null} [State] UpdatelayerBuffAck State
             */

            /**
             * Constructs a new UpdatelayerBuffAck.
             * @memberof buffProto
             * @classdesc Represents an UpdatelayerBuffAck.
             * @implements IUpdatelayerBuffAck
             * @constructor
             * @param {buffProto.IUpdatelayerBuffAck=} [properties] Properties to set
             */
            function UpdatelayerBuffAck(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * UpdatelayerBuffAck Result.
             * @member {number} Result
             * @memberof buffProto.UpdatelayerBuffAck
             * @instance
             */


            UpdatelayerBuffAck.prototype.Result = 0;
            /**
             * UpdatelayerBuffAck State.
             * @member {number} State
             * @memberof buffProto.UpdatelayerBuffAck
             * @instance
             */

            UpdatelayerBuffAck.prototype.State = 0;
            /**
             * Creates a new UpdatelayerBuffAck instance using the specified properties.
             * @function create
             * @memberof buffProto.UpdatelayerBuffAck
             * @static
             * @param {buffProto.IUpdatelayerBuffAck=} [properties] Properties to set
             * @returns {buffProto.UpdatelayerBuffAck} UpdatelayerBuffAck instance
             */

            UpdatelayerBuffAck.create = function create(properties) {
              return new UpdatelayerBuffAck(properties);
            };
            /**
             * Encodes the specified UpdatelayerBuffAck message. Does not implicitly {@link buffProto.UpdatelayerBuffAck.verify|verify} messages.
             * @function encode
             * @memberof buffProto.UpdatelayerBuffAck
             * @static
             * @param {buffProto.IUpdatelayerBuffAck} message UpdatelayerBuffAck message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            UpdatelayerBuffAck.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.Result != null && Object.hasOwnProperty.call(message, "Result")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.Result);
              if (message.State != null && Object.hasOwnProperty.call(message, "State")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int32(message.State);
              return writer;
            };
            /**
             * Encodes the specified UpdatelayerBuffAck message, length delimited. Does not implicitly {@link buffProto.UpdatelayerBuffAck.verify|verify} messages.
             * @function encodeDelimited
             * @memberof buffProto.UpdatelayerBuffAck
             * @static
             * @param {buffProto.IUpdatelayerBuffAck} message UpdatelayerBuffAck message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            UpdatelayerBuffAck.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes an UpdatelayerBuffAck message from the specified reader or buffer.
             * @function decode
             * @memberof buffProto.UpdatelayerBuffAck
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {buffProto.UpdatelayerBuffAck} UpdatelayerBuffAck
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            UpdatelayerBuffAck.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.buffProto.UpdatelayerBuffAck();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.Result = reader.int32();
                    break;

                  case 2:
                    message.State = reader.int32();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
             * Decodes an UpdatelayerBuffAck message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof buffProto.UpdatelayerBuffAck
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {buffProto.UpdatelayerBuffAck} UpdatelayerBuffAck
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            UpdatelayerBuffAck.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies an UpdatelayerBuffAck message.
             * @function verify
             * @memberof buffProto.UpdatelayerBuffAck
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */


            UpdatelayerBuffAck.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.Result != null && message.hasOwnProperty("Result")) if (!$util.isInteger(message.Result)) return "Result: integer expected";
              if (message.State != null && message.hasOwnProperty("State")) if (!$util.isInteger(message.State)) return "State: integer expected";
              return null;
            };
            /**
             * Creates an UpdatelayerBuffAck message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof buffProto.UpdatelayerBuffAck
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {buffProto.UpdatelayerBuffAck} UpdatelayerBuffAck
             */


            UpdatelayerBuffAck.fromObject = function fromObject(object) {
              if (object instanceof $root.buffProto.UpdatelayerBuffAck) return object;
              var message = new $root.buffProto.UpdatelayerBuffAck();
              if (object.Result != null) message.Result = object.Result | 0;
              if (object.State != null) message.State = object.State | 0;
              return message;
            };
            /**
             * Creates a plain object from an UpdatelayerBuffAck message. Also converts values to other types if specified.
             * @function toObject
             * @memberof buffProto.UpdatelayerBuffAck
             * @static
             * @param {buffProto.UpdatelayerBuffAck} message UpdatelayerBuffAck
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */


            UpdatelayerBuffAck.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.Result = 0;
                object.State = 0;
              }

              if (message.Result != null && message.hasOwnProperty("Result")) object.Result = message.Result;
              if (message.State != null && message.hasOwnProperty("State")) object.State = message.State;
              return object;
            };
            /**
             * Converts this UpdatelayerBuffAck to JSON.
             * @function toJSON
             * @memberof buffProto.UpdatelayerBuffAck
             * @instance
             * @returns {Object.<string,*>} JSON object
             */


            UpdatelayerBuffAck.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return UpdatelayerBuffAck;
          }();

          buffProto.GetSettingParamAck = function () {
            /**
             * Properties of a GetSettingParamAck.
             * @memberof buffProto
             * @interface IGetSettingParamAck
             * @property {number|null} [Result] GetSettingParamAck Result
             * @property {Array.<buffProto.IBuffParam>|null} [Info] GetSettingParamAck Info
             */

            /**
             * Constructs a new GetSettingParamAck.
             * @memberof buffProto
             * @classdesc Represents a GetSettingParamAck.
             * @implements IGetSettingParamAck
             * @constructor
             * @param {buffProto.IGetSettingParamAck=} [properties] Properties to set
             */
            function GetSettingParamAck(properties) {
              this.Info = [];
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * GetSettingParamAck Result.
             * @member {number} Result
             * @memberof buffProto.GetSettingParamAck
             * @instance
             */


            GetSettingParamAck.prototype.Result = 0;
            /**
             * GetSettingParamAck Info.
             * @member {Array.<buffProto.IBuffParam>} Info
             * @memberof buffProto.GetSettingParamAck
             * @instance
             */

            GetSettingParamAck.prototype.Info = $util.emptyArray;
            /**
             * Creates a new GetSettingParamAck instance using the specified properties.
             * @function create
             * @memberof buffProto.GetSettingParamAck
             * @static
             * @param {buffProto.IGetSettingParamAck=} [properties] Properties to set
             * @returns {buffProto.GetSettingParamAck} GetSettingParamAck instance
             */

            GetSettingParamAck.create = function create(properties) {
              return new GetSettingParamAck(properties);
            };
            /**
             * Encodes the specified GetSettingParamAck message. Does not implicitly {@link buffProto.GetSettingParamAck.verify|verify} messages.
             * @function encode
             * @memberof buffProto.GetSettingParamAck
             * @static
             * @param {buffProto.IGetSettingParamAck} message GetSettingParamAck message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            GetSettingParamAck.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.Result != null && Object.hasOwnProperty.call(message, "Result")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.Result);
              if (message.Info != null && message.Info.length) for (var i = 0; i < message.Info.length; ++i) {
                $root.buffProto.BuffParam.encode(message.Info[i], writer.uint32(
                /* id 2, wireType 2 =*/
                18).fork()).ldelim();
              }
              return writer;
            };
            /**
             * Encodes the specified GetSettingParamAck message, length delimited. Does not implicitly {@link buffProto.GetSettingParamAck.verify|verify} messages.
             * @function encodeDelimited
             * @memberof buffProto.GetSettingParamAck
             * @static
             * @param {buffProto.IGetSettingParamAck} message GetSettingParamAck message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            GetSettingParamAck.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a GetSettingParamAck message from the specified reader or buffer.
             * @function decode
             * @memberof buffProto.GetSettingParamAck
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {buffProto.GetSettingParamAck} GetSettingParamAck
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            GetSettingParamAck.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.buffProto.GetSettingParamAck();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.Result = reader.int32();
                    break;

                  case 2:
                    if (!(message.Info && message.Info.length)) message.Info = [];
                    message.Info.push($root.buffProto.BuffParam.decode(reader, reader.uint32()));
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
             * Decodes a GetSettingParamAck message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof buffProto.GetSettingParamAck
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {buffProto.GetSettingParamAck} GetSettingParamAck
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            GetSettingParamAck.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a GetSettingParamAck message.
             * @function verify
             * @memberof buffProto.GetSettingParamAck
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */


            GetSettingParamAck.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.Result != null && message.hasOwnProperty("Result")) if (!$util.isInteger(message.Result)) return "Result: integer expected";

              if (message.Info != null && message.hasOwnProperty("Info")) {
                if (!Array.isArray(message.Info)) return "Info: array expected";

                for (var i = 0; i < message.Info.length; ++i) {
                  var error = $root.buffProto.BuffParam.verify(message.Info[i]);
                  if (error) return "Info." + error;
                }
              }

              return null;
            };
            /**
             * Creates a GetSettingParamAck message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof buffProto.GetSettingParamAck
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {buffProto.GetSettingParamAck} GetSettingParamAck
             */


            GetSettingParamAck.fromObject = function fromObject(object) {
              if (object instanceof $root.buffProto.GetSettingParamAck) return object;
              var message = new $root.buffProto.GetSettingParamAck();
              if (object.Result != null) message.Result = object.Result | 0;

              if (object.Info) {
                if (!Array.isArray(object.Info)) throw TypeError(".buffProto.GetSettingParamAck.Info: array expected");
                message.Info = [];

                for (var i = 0; i < object.Info.length; ++i) {
                  if (typeof object.Info[i] !== "object") throw TypeError(".buffProto.GetSettingParamAck.Info: object expected");
                  message.Info[i] = $root.buffProto.BuffParam.fromObject(object.Info[i]);
                }
              }

              return message;
            };
            /**
             * Creates a plain object from a GetSettingParamAck message. Also converts values to other types if specified.
             * @function toObject
             * @memberof buffProto.GetSettingParamAck
             * @static
             * @param {buffProto.GetSettingParamAck} message GetSettingParamAck
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */


            GetSettingParamAck.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};
              if (options.arrays || options.defaults) object.Info = [];
              if (options.defaults) object.Result = 0;
              if (message.Result != null && message.hasOwnProperty("Result")) object.Result = message.Result;

              if (message.Info && message.Info.length) {
                object.Info = [];

                for (var j = 0; j < message.Info.length; ++j) {
                  object.Info[j] = $root.buffProto.BuffParam.toObject(message.Info[j], options);
                }
              }

              return object;
            };
            /**
             * Converts this GetSettingParamAck to JSON.
             * @function toJSON
             * @memberof buffProto.GetSettingParamAck
             * @instance
             * @returns {Object.<string,*>} JSON object
             */


            GetSettingParamAck.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GetSettingParamAck;
          }();

          return buffProto;
        }();

        module.exports = $root; // #endregion ORIGINAL CODE

        _cjsExports = exports('default', module.exports);
      }, function () {
        return {
          'protobufjs/minimal': __cjsMetaURL$1
        };
      });
    }
  };
});

System.register("chunks:///_virtual/buffproto.mjs_cjs=&original=.js", ['./buffproto.js', './cjs-loader.mjs'], function (exports, module) {
  'use strict';

  var __cjsMetaURL, loader;

  return {
    setters: [function (module) {
      __cjsMetaURL = module.__cjsMetaURL;
      var _setter = {};
      _setter.__cjsMetaURL = module.__cjsMetaURL;
      _setter.default = module.default;
      exports(_setter);
    }, function (module) {
      loader = module.default;
    }],
    execute: function () {
      // I am the facade module who provides access to the CommonJS module './buffproto.js'~
      if (!__cjsMetaURL) {
        loader.throwInvalidWrapper('./buffproto.js', module.meta.url);
      }

      loader.require(__cjsMetaURL);
    }
  };
});

System.register("chunks:///_virtual/cjs-loader.mjs", [], function (exports) {
  'use strict';

  return {
    execute: function () {
      var CjsLoader = /*#__PURE__*/function () {
        function CjsLoader() {
          this._registry = {};
          this._moduleCache = {};
        }
        /**
         * Defines a CommonJS module.
         * @param id Module ID.
         * @param factory The factory.
         * @param resolveMap An object or a function returning object which records the module specifier resolve result.
         * The later is called as "deferred resolve map" and would be invocated right before CommonJS code execution.
         */


        var _proto = CjsLoader.prototype;

        _proto.define = function define(id, factory, resolveMap) {
          this._registry[id] = {
            factory: factory,
            resolveMap: resolveMap
          };
        }
        /**
         * Requires a CommonJS module.
         * @param id Module ID.
         * @returns The module's `module.exports`.
         */
        ;

        _proto.require = function require(id) {
          return this._require(id);
        };

        _proto.throwInvalidWrapper = function throwInvalidWrapper(requestTarget, from) {
          throw new Error("Module '" + requestTarget + "' imported from '" + from + "' is expected be an ESM-wrapped CommonJS module but it doesn't.");
        };

        _proto._require = function _require(id, parent) {
          var cachedModule = this._moduleCache[id];

          if (cachedModule) {
            return cachedModule.exports;
          }

          var module = {
            id: id,
            exports: {}
          };
          this._moduleCache[id] = module;

          this._tryModuleLoad(module, id);

          return module.exports;
        };

        _proto._resolve = function _resolve(specifier, parent) {
          return this._resolveFromInfos(specifier, parent) || this._throwUnresolved(specifier, parent);
        };

        _proto._resolveFromInfos = function _resolveFromInfos(specifier, parent) {
          var _cjsInfos$parent$reso, _cjsInfos$parent;

          if (specifier in cjsInfos) {
            return specifier;
          }

          if (!parent) {
            return;
          }

          return (_cjsInfos$parent$reso = (_cjsInfos$parent = cjsInfos[parent]) == null ? void 0 : _cjsInfos$parent.resolveCache[specifier]) != null ? _cjsInfos$parent$reso : undefined;
        };

        _proto._tryModuleLoad = function _tryModuleLoad(module, id) {
          var threw = true;

          try {
            this._load(module, id);

            threw = false;
          } finally {
            if (threw) {
              delete this._moduleCache[id];
            }
          }
        };

        _proto._load = function _load(module, id) {
          var _this$_loadWrapper = this._loadWrapper(id),
              factory = _this$_loadWrapper.factory,
              resolveMap = _this$_loadWrapper.resolveMap;

          var vendorRequire = this._createRequire(module);

          var require = resolveMap ? this._createRequireWithResolveMap(typeof resolveMap === 'function' ? resolveMap() : resolveMap, vendorRequire) : vendorRequire;

          factory(module.exports, require, module);
        };

        _proto._loadWrapper = function _loadWrapper(id) {
          if (id in this._registry) {
            return this._registry[id];
          } else {
            return this._loadHostProvidedModules(id);
          }
        };

        _proto._loadHostProvidedModules = function _loadHostProvidedModules(id) {
          return {
            factory: function factory(_exports, _require, module) {
              if (typeof require === 'undefined') {
                throw new Error("Current environment does not provide a require() for requiring '" + id + "'.");
              }

              try {
                module.exports = require(id);
              } catch (err) {
                throw new Error("Exception thrown when calling host defined require('" + id + "').", {
                  cause: err
                });
              }
            }
          };
        };

        _proto._createRequire = function _createRequire(module) {
          var _this = this;

          return function (specifier) {
            return _this._require(specifier, module);
          };
        };

        _proto._createRequireWithResolveMap = function _createRequireWithResolveMap(requireMap, originalRequire) {
          return function (specifier) {
            var resolved = requireMap[specifier];

            if (resolved) {
              return originalRequire(resolved);
            } else {
              throw new Error('Unresolved specifier ' + specifier);
            }
          };
        };

        _proto._throwUnresolved = function _throwUnresolved(specifier, parentUrl) {
          throw new Error("Unable to resolve " + specifier + " from " + parent + ".");
        };

        return CjsLoader;
      }();

      var loader = exports('default', new CjsLoader());
    }
  };
});

System.register("chunks:///_virtual/common.js", ['./cjs-loader.mjs'], function (exports, module) {
  'use strict';

  var loader;
  return {
    setters: [function (module) {
      loader = module.default;
    }],
    execute: function () {
      var __cjsMetaURL = exports('__cjsMetaURL', module.meta.url);

      loader.define(__cjsMetaURL, function (exports, require, module, __filename, __dirname) {
        module.exports = common;
        var commonRe = /\/|\./;
        /**
         * Provides common type definitions.
         * Can also be used to provide additional google types or your own custom types.
         * @param {string} name Short name as in `google/protobuf/[name].proto` or full file name
         * @param {Object.<string,*>} json JSON definition within `google.protobuf` if a short name, otherwise the file's root definition
         * @returns {undefined}
         * @property {INamespace} google/protobuf/any.proto Any
         * @property {INamespace} google/protobuf/duration.proto Duration
         * @property {INamespace} google/protobuf/empty.proto Empty
         * @property {INamespace} google/protobuf/field_mask.proto FieldMask
         * @property {INamespace} google/protobuf/struct.proto Struct, Value, NullValue and ListValue
         * @property {INamespace} google/protobuf/timestamp.proto Timestamp
         * @property {INamespace} google/protobuf/wrappers.proto Wrappers
         * @example
         * // manually provides descriptor.proto (assumes google/protobuf/ namespace and .proto extension)
         * protobuf.common("descriptor", descriptorJson);
         *
         * // manually provides a custom definition (uses my.foo namespace)
         * protobuf.common("my/foo/bar.proto", myFooBarJson);
         */

        function common(name, json) {
          if (!commonRe.test(name)) {
            name = "google/protobuf/" + name + ".proto";
            json = {
              nested: {
                google: {
                  nested: {
                    protobuf: {
                      nested: json
                    }
                  }
                }
              }
            };
          }

          common[name] = json;
        } // Not provided because of limited use (feel free to discuss or to provide yourself):
        //
        // google/protobuf/descriptor.proto
        // google/protobuf/source_context.proto
        // google/protobuf/type.proto
        //
        // Stripped and pre-parsed versions of these non-bundled files are instead available as part of
        // the repository or package within the google/protobuf directory.


        common("any", {
          /**
           * Properties of a google.protobuf.Any message.
           * @interface IAny
           * @type {Object}
           * @property {string} [typeUrl]
           * @property {Uint8Array} [bytes]
           * @memberof common
           */
          Any: {
            fields: {
              type_url: {
                type: "string",
                id: 1
              },
              value: {
                type: "bytes",
                id: 2
              }
            }
          }
        });
        var timeType;
        common("duration", {
          /**
           * Properties of a google.protobuf.Duration message.
           * @interface IDuration
           * @type {Object}
           * @property {number|Long} [seconds]
           * @property {number} [nanos]
           * @memberof common
           */
          Duration: timeType = {
            fields: {
              seconds: {
                type: "int64",
                id: 1
              },
              nanos: {
                type: "int32",
                id: 2
              }
            }
          }
        });
        common("timestamp", {
          /**
           * Properties of a google.protobuf.Timestamp message.
           * @interface ITimestamp
           * @type {Object}
           * @property {number|Long} [seconds]
           * @property {number} [nanos]
           * @memberof common
           */
          Timestamp: timeType
        });
        common("empty", {
          /**
           * Properties of a google.protobuf.Empty message.
           * @interface IEmpty
           * @memberof common
           */
          Empty: {
            fields: {}
          }
        });
        common("struct", {
          /**
           * Properties of a google.protobuf.Struct message.
           * @interface IStruct
           * @type {Object}
           * @property {Object.<string,IValue>} [fields]
           * @memberof common
           */
          Struct: {
            fields: {
              fields: {
                keyType: "string",
                type: "Value",
                id: 1
              }
            }
          },

          /**
           * Properties of a google.protobuf.Value message.
           * @interface IValue
           * @type {Object}
           * @property {string} [kind]
           * @property {0} [nullValue]
           * @property {number} [numberValue]
           * @property {string} [stringValue]
           * @property {boolean} [boolValue]
           * @property {IStruct} [structValue]
           * @property {IListValue} [listValue]
           * @memberof common
           */
          Value: {
            oneofs: {
              kind: {
                oneof: ["nullValue", "numberValue", "stringValue", "boolValue", "structValue", "listValue"]
              }
            },
            fields: {
              nullValue: {
                type: "NullValue",
                id: 1
              },
              numberValue: {
                type: "double",
                id: 2
              },
              stringValue: {
                type: "string",
                id: 3
              },
              boolValue: {
                type: "bool",
                id: 4
              },
              structValue: {
                type: "Struct",
                id: 5
              },
              listValue: {
                type: "ListValue",
                id: 6
              }
            }
          },
          NullValue: {
            values: {
              NULL_VALUE: 0
            }
          },

          /**
           * Properties of a google.protobuf.ListValue message.
           * @interface IListValue
           * @type {Object}
           * @property {Array.<IValue>} [values]
           * @memberof common
           */
          ListValue: {
            fields: {
              values: {
                rule: "repeated",
                type: "Value",
                id: 1
              }
            }
          }
        });
        common("wrappers", {
          /**
           * Properties of a google.protobuf.DoubleValue message.
           * @interface IDoubleValue
           * @type {Object}
           * @property {number} [value]
           * @memberof common
           */
          DoubleValue: {
            fields: {
              value: {
                type: "double",
                id: 1
              }
            }
          },

          /**
           * Properties of a google.protobuf.FloatValue message.
           * @interface IFloatValue
           * @type {Object}
           * @property {number} [value]
           * @memberof common
           */
          FloatValue: {
            fields: {
              value: {
                type: "float",
                id: 1
              }
            }
          },

          /**
           * Properties of a google.protobuf.Int64Value message.
           * @interface IInt64Value
           * @type {Object}
           * @property {number|Long} [value]
           * @memberof common
           */
          Int64Value: {
            fields: {
              value: {
                type: "int64",
                id: 1
              }
            }
          },

          /**
           * Properties of a google.protobuf.UInt64Value message.
           * @interface IUInt64Value
           * @type {Object}
           * @property {number|Long} [value]
           * @memberof common
           */
          UInt64Value: {
            fields: {
              value: {
                type: "uint64",
                id: 1
              }
            }
          },

          /**
           * Properties of a google.protobuf.Int32Value message.
           * @interface IInt32Value
           * @type {Object}
           * @property {number} [value]
           * @memberof common
           */
          Int32Value: {
            fields: {
              value: {
                type: "int32",
                id: 1
              }
            }
          },

          /**
           * Properties of a google.protobuf.UInt32Value message.
           * @interface IUInt32Value
           * @type {Object}
           * @property {number} [value]
           * @memberof common
           */
          UInt32Value: {
            fields: {
              value: {
                type: "uint32",
                id: 1
              }
            }
          },

          /**
           * Properties of a google.protobuf.BoolValue message.
           * @interface IBoolValue
           * @type {Object}
           * @property {boolean} [value]
           * @memberof common
           */
          BoolValue: {
            fields: {
              value: {
                type: "bool",
                id: 1
              }
            }
          },

          /**
           * Properties of a google.protobuf.StringValue message.
           * @interface IStringValue
           * @type {Object}
           * @property {string} [value]
           * @memberof common
           */
          StringValue: {
            fields: {
              value: {
                type: "string",
                id: 1
              }
            }
          },

          /**
           * Properties of a google.protobuf.BytesValue message.
           * @interface IBytesValue
           * @type {Object}
           * @property {Uint8Array} [value]
           * @memberof common
           */
          BytesValue: {
            fields: {
              value: {
                type: "bytes",
                id: 1
              }
            }
          }
        });
        common("field_mask", {
          /**
           * Properties of a google.protobuf.FieldMask message.
           * @interface IDoubleValue
           * @type {Object}
           * @property {number} [value]
           * @memberof common
           */
          FieldMask: {
            fields: {
              paths: {
                rule: "repeated",
                type: "string",
                id: 1
              }
            }
          }
        });
        /**
         * Gets the root definition of the specified common proto file.
         *
         * Bundled definitions are:
         * - google/protobuf/any.proto
         * - google/protobuf/duration.proto
         * - google/protobuf/empty.proto
         * - google/protobuf/field_mask.proto
         * - google/protobuf/struct.proto
         * - google/protobuf/timestamp.proto
         * - google/protobuf/wrappers.proto
         *
         * @param {string} file Proto file name
         * @returns {INamespace|null} Root definition or `null` if not defined
         */

        common.get = function get(file) {
          return common[file] || null;
        }; // #endregion ORIGINAL CODE


        module.exports;
      }, {});
    }
  };
});

System.register("chunks:///_virtual/converter.js", ['./cjs-loader.mjs', './enum.js', './util.js'], function (exports, module) {
  'use strict';

  var loader, __cjsMetaURL$1, __cjsMetaURL$2;

  return {
    setters: [function (module) {
      loader = module.default;
    }, function (module) {
      __cjsMetaURL$1 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$2 = module.__cjsMetaURL;
    }],
    execute: function () {
      var __cjsMetaURL = exports('__cjsMetaURL', module.meta.url);

      loader.define(__cjsMetaURL, function (exports, require, module, __filename, __dirname) {
        /**
         * Runtime message from/to plain object converters.
         * @namespace
         */
        var converter = exports;

        var Enum = require("./enum"),
            util = require("./util");
        /**
         * Generates a partial value fromObject conveter.
         * @param {Codegen} gen Codegen instance
         * @param {Field} field Reflected field
         * @param {number} fieldIndex Field index
         * @param {string} prop Property reference
         * @returns {Codegen} Codegen instance
         * @ignore
         */


        function genValuePartial_fromObject(gen, field, fieldIndex, prop) {
          /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
          if (field.resolvedType) {
            if (field.resolvedType instanceof Enum) {
              gen("switch(d%s){", prop);

              for (var values = field.resolvedType.values, keys = Object.keys(values), i = 0; i < keys.length; ++i) {
                if (field.repeated && values[keys[i]] === field.typeDefault) gen("default:");
                gen("case%j:", keys[i])("case %i:", values[keys[i]])("m%s=%j", prop, values[keys[i]])("break");
              }

              gen("}");
            } else gen("if(typeof d%s!==\"object\")", prop)("throw TypeError(%j)", field.fullName + ": object expected")("m%s=types[%i].fromObject(d%s)", prop, fieldIndex, prop);
          } else {
            var isUnsigned = false;

            switch (field.type) {
              case "double":
              case "float":
                gen("m%s=Number(d%s)", prop, prop); // also catches "NaN", "Infinity"

                break;

              case "uint32":
              case "fixed32":
                gen("m%s=d%s>>>0", prop, prop);
                break;

              case "int32":
              case "sint32":
              case "sfixed32":
                gen("m%s=d%s|0", prop, prop);
                break;

              case "uint64":
                isUnsigned = true;
              // eslint-disable-line no-fallthrough

              case "int64":
              case "sint64":
              case "fixed64":
              case "sfixed64":
                gen("if(util.Long)")("(m%s=util.Long.fromValue(d%s)).unsigned=%j", prop, prop, isUnsigned)("else if(typeof d%s===\"string\")", prop)("m%s=parseInt(d%s,10)", prop, prop)("else if(typeof d%s===\"number\")", prop)("m%s=d%s", prop, prop)("else if(typeof d%s===\"object\")", prop)("m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)", prop, prop, prop, isUnsigned ? "true" : "");
                break;

              case "bytes":
                gen("if(typeof d%s===\"string\")", prop)("util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)", prop, prop, prop)("else if(d%s.length)", prop)("m%s=d%s", prop, prop);
                break;

              case "string":
                gen("m%s=String(d%s)", prop, prop);
                break;

              case "bool":
                gen("m%s=Boolean(d%s)", prop, prop);
                break;

              /* default: gen
                  ("m%s=d%s", prop, prop);
                  break; */
            }
          }

          return gen;
          /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
        }
        /**
         * Generates a plain object to runtime message converter specific to the specified message type.
         * @param {Type} mtype Message type
         * @returns {Codegen} Codegen instance
         */


        converter.fromObject = function fromObject(mtype) {
          /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
          var fields = mtype.fieldsArray;
          var gen = util.codegen(["d"], mtype.name + "$fromObject")("if(d instanceof this.ctor)")("return d");
          if (!fields.length) return gen("return new this.ctor");
          gen("var m=new this.ctor");

          for (var i = 0; i < fields.length; ++i) {
            var field = fields[i].resolve(),
                prop = util.safeProp(field.name); // Map fields

            if (field.map) {
              gen("if(d%s){", prop)("if(typeof d%s!==\"object\")", prop)("throw TypeError(%j)", field.fullName + ": object expected")("m%s={}", prop)("for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){", prop);
              genValuePartial_fromObject(gen, field,
              /* not sorted */
              i, prop + "[ks[i]]")("}")("}"); // Repeated fields
            } else if (field.repeated) {
              gen("if(d%s){", prop)("if(!Array.isArray(d%s))", prop)("throw TypeError(%j)", field.fullName + ": array expected")("m%s=[]", prop)("for(var i=0;i<d%s.length;++i){", prop);
              genValuePartial_fromObject(gen, field,
              /* not sorted */
              i, prop + "[i]")("}")("}"); // Non-repeated fields
            } else {
              if (!(field.resolvedType instanceof Enum)) gen // no need to test for null/undefined if an enum (uses switch)
              ("if(d%s!=null){", prop); // !== undefined && !== null

              genValuePartial_fromObject(gen, field,
              /* not sorted */
              i, prop);
              if (!(field.resolvedType instanceof Enum)) gen("}");
            }
          }

          return gen("return m");
          /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
        };
        /**
         * Generates a partial value toObject converter.
         * @param {Codegen} gen Codegen instance
         * @param {Field} field Reflected field
         * @param {number} fieldIndex Field index
         * @param {string} prop Property reference
         * @returns {Codegen} Codegen instance
         * @ignore
         */


        function genValuePartial_toObject(gen, field, fieldIndex, prop) {
          /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
          if (field.resolvedType) {
            if (field.resolvedType instanceof Enum) gen("d%s=o.enums===String?types[%i].values[m%s]:m%s", prop, fieldIndex, prop, prop);else gen("d%s=types[%i].toObject(m%s,o)", prop, fieldIndex, prop);
          } else {
            var isUnsigned = false;

            switch (field.type) {
              case "double":
              case "float":
                gen("d%s=o.json&&!isFinite(m%s)?String(m%s):m%s", prop, prop, prop, prop);
                break;

              case "uint64":
                isUnsigned = true;
              // eslint-disable-line no-fallthrough

              case "int64":
              case "sint64":
              case "fixed64":
              case "sfixed64":
                gen("if(typeof m%s===\"number\")", prop)("d%s=o.longs===String?String(m%s):m%s", prop, prop, prop)("else") // Long-like
                ("d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s", prop, prop, prop, prop, isUnsigned ? "true" : "", prop);
                break;

              case "bytes":
                gen("d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s", prop, prop, prop, prop, prop);
                break;

              default:
                gen("d%s=m%s", prop, prop);
                break;
            }
          }

          return gen;
          /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
        }
        /**
         * Generates a runtime message to plain object converter specific to the specified message type.
         * @param {Type} mtype Message type
         * @returns {Codegen} Codegen instance
         */


        converter.toObject = function toObject(mtype) {
          /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
          var fields = mtype.fieldsArray.slice().sort(util.compareFieldsById);
          if (!fields.length) return util.codegen()("return {}");
          var gen = util.codegen(["m", "o"], mtype.name + "$toObject")("if(!o)")("o={}")("var d={}");
          var repeatedFields = [],
              mapFields = [],
              normalFields = [],
              i = 0;

          for (; i < fields.length; ++i) {
            if (!fields[i].partOf) (fields[i].resolve().repeated ? repeatedFields : fields[i].map ? mapFields : normalFields).push(fields[i]);
          }

          if (repeatedFields.length) {
            gen("if(o.arrays||o.defaults){");

            for (i = 0; i < repeatedFields.length; ++i) {
              gen("d%s=[]", util.safeProp(repeatedFields[i].name));
            }

            gen("}");
          }

          if (mapFields.length) {
            gen("if(o.objects||o.defaults){");

            for (i = 0; i < mapFields.length; ++i) {
              gen("d%s={}", util.safeProp(mapFields[i].name));
            }

            gen("}");
          }

          if (normalFields.length) {
            gen("if(o.defaults){");

            for (i = 0; i < normalFields.length; ++i) {
              var field = normalFields[i],
                  prop = util.safeProp(field.name);
              if (field.resolvedType instanceof Enum) gen("d%s=o.enums===String?%j:%j", prop, field.resolvedType.valuesById[field.typeDefault], field.typeDefault);else if (field["long"]) gen("if(util.Long){")("var n=new util.Long(%i,%i,%j)", field.typeDefault.low, field.typeDefault.high, field.typeDefault.unsigned)("d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n", prop)("}else")("d%s=o.longs===String?%j:%i", prop, field.typeDefault.toString(), field.typeDefault.toNumber());else if (field.bytes) {
                var arrayDefault = "[" + Array.prototype.slice.call(field.typeDefault).join(",") + "]";
                gen("if(o.bytes===String)d%s=%j", prop, String.fromCharCode.apply(String, field.typeDefault))("else{")("d%s=%s", prop, arrayDefault)("if(o.bytes!==Array)d%s=util.newBuffer(d%s)", prop, prop)("}");
              } else gen("d%s=%j", prop, field.typeDefault); // also messages (=null)
            }

            gen("}");
          }

          var hasKs2 = false;

          for (i = 0; i < fields.length; ++i) {
            var field = fields[i],
                index = mtype._fieldsArray.indexOf(field),
                prop = util.safeProp(field.name);

            if (field.map) {
              if (!hasKs2) {
                hasKs2 = true;
                gen("var ks2");
              }

              gen("if(m%s&&(ks2=Object.keys(m%s)).length){", prop, prop)("d%s={}", prop)("for(var j=0;j<ks2.length;++j){");
              genValuePartial_toObject(gen, field,
              /* sorted */
              index, prop + "[ks2[j]]")("}");
            } else if (field.repeated) {
              gen("if(m%s&&m%s.length){", prop, prop)("d%s=[]", prop)("for(var j=0;j<m%s.length;++j){", prop);
              genValuePartial_toObject(gen, field,
              /* sorted */
              index, prop + "[j]")("}");
            } else {
              gen("if(m%s!=null&&m.hasOwnProperty(%j)){", prop, field.name); // !== undefined && !== null

              genValuePartial_toObject(gen, field,
              /* sorted */
              index, prop);
              if (field.partOf) gen("if(o.oneofs)")("d%s=%j", util.safeProp(field.partOf.name), field.name);
            }

            gen("}");
          }

          return gen("return d");
          /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
        }; // #endregion ORIGINAL CODE


        module.exports;
      }, function () {
        return {
          './enum': __cjsMetaURL$1,
          './util': __cjsMetaURL$2
        };
      });
    }
  };
});

System.register("chunks:///_virtual/debrisproto.js", ['./cjs-loader.mjs', './minimal.js'], function (exports, module) {
  'use strict';

  var loader, __cjsMetaURL$1;

  return {
    setters: [function (module) {
      loader = module.default;
    }, function (module) {
      __cjsMetaURL$1 = module.__cjsMetaURL;
    }],
    execute: function () {
      exports('default', void 0);

      var _cjsExports;

      var __cjsMetaURL = exports('__cjsMetaURL', module.meta.url);

      loader.define(__cjsMetaURL, function (exports$1, require, module, __filename, __dirname) {
        var $protobuf = require("protobufjs/minimal"); // Common aliases


        var $Reader = $protobuf.Reader,
            $Writer = $protobuf.Writer,
            $util = $protobuf.util; // Exported root namespace

        var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

        $root.debrisprotocol = function () {
          /**
           * Namespace debrisprotocol.
           * @exports debrisprotocol
           * @namespace
           */
          var debrisprotocol = {};

          debrisprotocol.ChangeFormula = function () {
            /**
             * Properties of a ChangeFormula.
             * @memberof debrisprotocol
             * @interface IChangeFormula
             * @property {number|null} [formula] ChangeFormula formula
             * @property {number|null} [count] ChangeFormula count
             */

            /**
             * Constructs a new ChangeFormula.
             * @memberof debrisprotocol
             * @classdesc Represents a ChangeFormula.
             * @implements IChangeFormula
             * @constructor
             * @param {debrisprotocol.IChangeFormula=} [properties] Properties to set
             */
            function ChangeFormula(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * ChangeFormula formula.
             * @member {number} formula
             * @memberof debrisprotocol.ChangeFormula
             * @instance
             */


            ChangeFormula.prototype.formula = 0;
            /**
             * ChangeFormula count.
             * @member {number} count
             * @memberof debrisprotocol.ChangeFormula
             * @instance
             */

            ChangeFormula.prototype.count = 0;
            /**
             * Creates a new ChangeFormula instance using the specified properties.
             * @function create
             * @memberof debrisprotocol.ChangeFormula
             * @static
             * @param {debrisprotocol.IChangeFormula=} [properties] Properties to set
             * @returns {debrisprotocol.ChangeFormula} ChangeFormula instance
             */

            ChangeFormula.create = function create(properties) {
              return new ChangeFormula(properties);
            };
            /**
             * Encodes the specified ChangeFormula message. Does not implicitly {@link debrisprotocol.ChangeFormula.verify|verify} messages.
             * @function encode
             * @memberof debrisprotocol.ChangeFormula
             * @static
             * @param {debrisprotocol.IChangeFormula} message ChangeFormula message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            ChangeFormula.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.formula != null && Object.hasOwnProperty.call(message, "formula")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).uint32(message.formula);
              if (message.count != null && Object.hasOwnProperty.call(message, "count")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).uint32(message.count);
              return writer;
            };
            /**
             * Encodes the specified ChangeFormula message, length delimited. Does not implicitly {@link debrisprotocol.ChangeFormula.verify|verify} messages.
             * @function encodeDelimited
             * @memberof debrisprotocol.ChangeFormula
             * @static
             * @param {debrisprotocol.IChangeFormula} message ChangeFormula message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            ChangeFormula.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a ChangeFormula message from the specified reader or buffer.
             * @function decode
             * @memberof debrisprotocol.ChangeFormula
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {debrisprotocol.ChangeFormula} ChangeFormula
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            ChangeFormula.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.debrisprotocol.ChangeFormula();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.formula = reader.uint32();
                    break;

                  case 2:
                    message.count = reader.uint32();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
             * Decodes a ChangeFormula message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof debrisprotocol.ChangeFormula
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {debrisprotocol.ChangeFormula} ChangeFormula
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            ChangeFormula.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a ChangeFormula message.
             * @function verify
             * @memberof debrisprotocol.ChangeFormula
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */


            ChangeFormula.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.formula != null && message.hasOwnProperty("formula")) if (!$util.isInteger(message.formula)) return "formula: integer expected";
              if (message.count != null && message.hasOwnProperty("count")) if (!$util.isInteger(message.count)) return "count: integer expected";
              return null;
            };
            /**
             * Creates a ChangeFormula message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof debrisprotocol.ChangeFormula
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {debrisprotocol.ChangeFormula} ChangeFormula
             */


            ChangeFormula.fromObject = function fromObject(object) {
              if (object instanceof $root.debrisprotocol.ChangeFormula) return object;
              var message = new $root.debrisprotocol.ChangeFormula();
              if (object.formula != null) message.formula = object.formula >>> 0;
              if (object.count != null) message.count = object.count >>> 0;
              return message;
            };
            /**
             * Creates a plain object from a ChangeFormula message. Also converts values to other types if specified.
             * @function toObject
             * @memberof debrisprotocol.ChangeFormula
             * @static
             * @param {debrisprotocol.ChangeFormula} message ChangeFormula
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */


            ChangeFormula.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.formula = 0;
                object.count = 0;
              }

              if (message.formula != null && message.hasOwnProperty("formula")) object.formula = message.formula;
              if (message.count != null && message.hasOwnProperty("count")) object.count = message.count;
              return object;
            };
            /**
             * Converts this ChangeFormula to JSON.
             * @function toJSON
             * @memberof debrisprotocol.ChangeFormula
             * @instance
             * @returns {Object.<string,*>} JSON object
             */


            ChangeFormula.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ChangeFormula;
          }();

          debrisprotocol.DebrisList = function () {
            /**
             * Properties of a DebrisList.
             * @memberof debrisprotocol
             * @interface IDebrisList
             * @property {number|null} [no] DebrisList no
             * @property {number|null} [count] DebrisList count
             */

            /**
             * Constructs a new DebrisList.
             * @memberof debrisprotocol
             * @classdesc Represents a DebrisList.
             * @implements IDebrisList
             * @constructor
             * @param {debrisprotocol.IDebrisList=} [properties] Properties to set
             */
            function DebrisList(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * DebrisList no.
             * @member {number} no
             * @memberof debrisprotocol.DebrisList
             * @instance
             */


            DebrisList.prototype.no = 0;
            /**
             * DebrisList count.
             * @member {number} count
             * @memberof debrisprotocol.DebrisList
             * @instance
             */

            DebrisList.prototype.count = 0;
            /**
             * Creates a new DebrisList instance using the specified properties.
             * @function create
             * @memberof debrisprotocol.DebrisList
             * @static
             * @param {debrisprotocol.IDebrisList=} [properties] Properties to set
             * @returns {debrisprotocol.DebrisList} DebrisList instance
             */

            DebrisList.create = function create(properties) {
              return new DebrisList(properties);
            };
            /**
             * Encodes the specified DebrisList message. Does not implicitly {@link debrisprotocol.DebrisList.verify|verify} messages.
             * @function encode
             * @memberof debrisprotocol.DebrisList
             * @static
             * @param {debrisprotocol.IDebrisList} message DebrisList message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            DebrisList.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.no != null && Object.hasOwnProperty.call(message, "no")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).uint32(message.no);
              if (message.count != null && Object.hasOwnProperty.call(message, "count")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).uint32(message.count);
              return writer;
            };
            /**
             * Encodes the specified DebrisList message, length delimited. Does not implicitly {@link debrisprotocol.DebrisList.verify|verify} messages.
             * @function encodeDelimited
             * @memberof debrisprotocol.DebrisList
             * @static
             * @param {debrisprotocol.IDebrisList} message DebrisList message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            DebrisList.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a DebrisList message from the specified reader or buffer.
             * @function decode
             * @memberof debrisprotocol.DebrisList
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {debrisprotocol.DebrisList} DebrisList
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            DebrisList.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.debrisprotocol.DebrisList();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.no = reader.uint32();
                    break;

                  case 2:
                    message.count = reader.uint32();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
             * Decodes a DebrisList message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof debrisprotocol.DebrisList
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {debrisprotocol.DebrisList} DebrisList
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            DebrisList.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a DebrisList message.
             * @function verify
             * @memberof debrisprotocol.DebrisList
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */


            DebrisList.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.no != null && message.hasOwnProperty("no")) if (!$util.isInteger(message.no)) return "no: integer expected";
              if (message.count != null && message.hasOwnProperty("count")) if (!$util.isInteger(message.count)) return "count: integer expected";
              return null;
            };
            /**
             * Creates a DebrisList message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof debrisprotocol.DebrisList
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {debrisprotocol.DebrisList} DebrisList
             */


            DebrisList.fromObject = function fromObject(object) {
              if (object instanceof $root.debrisprotocol.DebrisList) return object;
              var message = new $root.debrisprotocol.DebrisList();
              if (object.no != null) message.no = object.no >>> 0;
              if (object.count != null) message.count = object.count >>> 0;
              return message;
            };
            /**
             * Creates a plain object from a DebrisList message. Also converts values to other types if specified.
             * @function toObject
             * @memberof debrisprotocol.DebrisList
             * @static
             * @param {debrisprotocol.DebrisList} message DebrisList
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */


            DebrisList.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.no = 0;
                object.count = 0;
              }

              if (message.no != null && message.hasOwnProperty("no")) object.no = message.no;
              if (message.count != null && message.hasOwnProperty("count")) object.count = message.count;
              return object;
            };
            /**
             * Converts this DebrisList to JSON.
             * @function toJSON
             * @memberof debrisprotocol.DebrisList
             * @instance
             * @returns {Object.<string,*>} JSON object
             */


            DebrisList.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DebrisList;
          }();

          debrisprotocol.PlayerInfoAck = function () {
            /**
             * Properties of a PlayerInfoAck.
             * @memberof debrisprotocol
             * @interface IPlayerInfoAck
             * @property {number|null} [result] PlayerInfoAck result
             * @property {number|null} [activityno] PlayerInfoAck activityno
             * @property {Array.<debrisprotocol.IChangeFormula>|null} [changelist] PlayerInfoAck changelist
             * @property {Array.<debrisprotocol.IDebrisList>|null} [debrislist] PlayerInfoAck debrislist
             */

            /**
             * Constructs a new PlayerInfoAck.
             * @memberof debrisprotocol
             * @classdesc Represents a PlayerInfoAck.
             * @implements IPlayerInfoAck
             * @constructor
             * @param {debrisprotocol.IPlayerInfoAck=} [properties] Properties to set
             */
            function PlayerInfoAck(properties) {
              this.changelist = [];
              this.debrislist = [];
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * PlayerInfoAck result.
             * @member {number} result
             * @memberof debrisprotocol.PlayerInfoAck
             * @instance
             */


            PlayerInfoAck.prototype.result = 0;
            /**
             * PlayerInfoAck activityno.
             * @member {number} activityno
             * @memberof debrisprotocol.PlayerInfoAck
             * @instance
             */

            PlayerInfoAck.prototype.activityno = 0;
            /**
             * PlayerInfoAck changelist.
             * @member {Array.<debrisprotocol.IChangeFormula>} changelist
             * @memberof debrisprotocol.PlayerInfoAck
             * @instance
             */

            PlayerInfoAck.prototype.changelist = $util.emptyArray;
            /**
             * PlayerInfoAck debrislist.
             * @member {Array.<debrisprotocol.IDebrisList>} debrislist
             * @memberof debrisprotocol.PlayerInfoAck
             * @instance
             */

            PlayerInfoAck.prototype.debrislist = $util.emptyArray;
            /**
             * Creates a new PlayerInfoAck instance using the specified properties.
             * @function create
             * @memberof debrisprotocol.PlayerInfoAck
             * @static
             * @param {debrisprotocol.IPlayerInfoAck=} [properties] Properties to set
             * @returns {debrisprotocol.PlayerInfoAck} PlayerInfoAck instance
             */

            PlayerInfoAck.create = function create(properties) {
              return new PlayerInfoAck(properties);
            };
            /**
             * Encodes the specified PlayerInfoAck message. Does not implicitly {@link debrisprotocol.PlayerInfoAck.verify|verify} messages.
             * @function encode
             * @memberof debrisprotocol.PlayerInfoAck
             * @static
             * @param {debrisprotocol.IPlayerInfoAck} message PlayerInfoAck message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            PlayerInfoAck.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.result != null && Object.hasOwnProperty.call(message, "result")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).uint32(message.result);
              if (message.activityno != null && Object.hasOwnProperty.call(message, "activityno")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).uint32(message.activityno);
              if (message.changelist != null && message.changelist.length) for (var i = 0; i < message.changelist.length; ++i) {
                $root.debrisprotocol.ChangeFormula.encode(message.changelist[i], writer.uint32(
                /* id 3, wireType 2 =*/
                26).fork()).ldelim();
              }
              if (message.debrislist != null && message.debrislist.length) for (var i = 0; i < message.debrislist.length; ++i) {
                $root.debrisprotocol.DebrisList.encode(message.debrislist[i], writer.uint32(
                /* id 4, wireType 2 =*/
                34).fork()).ldelim();
              }
              return writer;
            };
            /**
             * Encodes the specified PlayerInfoAck message, length delimited. Does not implicitly {@link debrisprotocol.PlayerInfoAck.verify|verify} messages.
             * @function encodeDelimited
             * @memberof debrisprotocol.PlayerInfoAck
             * @static
             * @param {debrisprotocol.IPlayerInfoAck} message PlayerInfoAck message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            PlayerInfoAck.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a PlayerInfoAck message from the specified reader or buffer.
             * @function decode
             * @memberof debrisprotocol.PlayerInfoAck
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {debrisprotocol.PlayerInfoAck} PlayerInfoAck
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            PlayerInfoAck.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.debrisprotocol.PlayerInfoAck();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.result = reader.uint32();
                    break;

                  case 2:
                    message.activityno = reader.uint32();
                    break;

                  case 3:
                    if (!(message.changelist && message.changelist.length)) message.changelist = [];
                    message.changelist.push($root.debrisprotocol.ChangeFormula.decode(reader, reader.uint32()));
                    break;

                  case 4:
                    if (!(message.debrislist && message.debrislist.length)) message.debrislist = [];
                    message.debrislist.push($root.debrisprotocol.DebrisList.decode(reader, reader.uint32()));
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
             * Decodes a PlayerInfoAck message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof debrisprotocol.PlayerInfoAck
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {debrisprotocol.PlayerInfoAck} PlayerInfoAck
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            PlayerInfoAck.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a PlayerInfoAck message.
             * @function verify
             * @memberof debrisprotocol.PlayerInfoAck
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */


            PlayerInfoAck.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.result != null && message.hasOwnProperty("result")) if (!$util.isInteger(message.result)) return "result: integer expected";
              if (message.activityno != null && message.hasOwnProperty("activityno")) if (!$util.isInteger(message.activityno)) return "activityno: integer expected";

              if (message.changelist != null && message.hasOwnProperty("changelist")) {
                if (!Array.isArray(message.changelist)) return "changelist: array expected";

                for (var i = 0; i < message.changelist.length; ++i) {
                  var error = $root.debrisprotocol.ChangeFormula.verify(message.changelist[i]);
                  if (error) return "changelist." + error;
                }
              }

              if (message.debrislist != null && message.hasOwnProperty("debrislist")) {
                if (!Array.isArray(message.debrislist)) return "debrislist: array expected";

                for (var i = 0; i < message.debrislist.length; ++i) {
                  var error = $root.debrisprotocol.DebrisList.verify(message.debrislist[i]);
                  if (error) return "debrislist." + error;
                }
              }

              return null;
            };
            /**
             * Creates a PlayerInfoAck message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof debrisprotocol.PlayerInfoAck
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {debrisprotocol.PlayerInfoAck} PlayerInfoAck
             */


            PlayerInfoAck.fromObject = function fromObject(object) {
              if (object instanceof $root.debrisprotocol.PlayerInfoAck) return object;
              var message = new $root.debrisprotocol.PlayerInfoAck();
              if (object.result != null) message.result = object.result >>> 0;
              if (object.activityno != null) message.activityno = object.activityno >>> 0;

              if (object.changelist) {
                if (!Array.isArray(object.changelist)) throw TypeError(".debrisprotocol.PlayerInfoAck.changelist: array expected");
                message.changelist = [];

                for (var i = 0; i < object.changelist.length; ++i) {
                  if (typeof object.changelist[i] !== "object") throw TypeError(".debrisprotocol.PlayerInfoAck.changelist: object expected");
                  message.changelist[i] = $root.debrisprotocol.ChangeFormula.fromObject(object.changelist[i]);
                }
              }

              if (object.debrislist) {
                if (!Array.isArray(object.debrislist)) throw TypeError(".debrisprotocol.PlayerInfoAck.debrislist: array expected");
                message.debrislist = [];

                for (var i = 0; i < object.debrislist.length; ++i) {
                  if (typeof object.debrislist[i] !== "object") throw TypeError(".debrisprotocol.PlayerInfoAck.debrislist: object expected");
                  message.debrislist[i] = $root.debrisprotocol.DebrisList.fromObject(object.debrislist[i]);
                }
              }

              return message;
            };
            /**
             * Creates a plain object from a PlayerInfoAck message. Also converts values to other types if specified.
             * @function toObject
             * @memberof debrisprotocol.PlayerInfoAck
             * @static
             * @param {debrisprotocol.PlayerInfoAck} message PlayerInfoAck
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */


            PlayerInfoAck.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.arrays || options.defaults) {
                object.changelist = [];
                object.debrislist = [];
              }

              if (options.defaults) {
                object.result = 0;
                object.activityno = 0;
              }

              if (message.result != null && message.hasOwnProperty("result")) object.result = message.result;
              if (message.activityno != null && message.hasOwnProperty("activityno")) object.activityno = message.activityno;

              if (message.changelist && message.changelist.length) {
                object.changelist = [];

                for (var j = 0; j < message.changelist.length; ++j) {
                  object.changelist[j] = $root.debrisprotocol.ChangeFormula.toObject(message.changelist[j], options);
                }
              }

              if (message.debrislist && message.debrislist.length) {
                object.debrislist = [];

                for (var j = 0; j < message.debrislist.length; ++j) {
                  object.debrislist[j] = $root.debrisprotocol.DebrisList.toObject(message.debrislist[j], options);
                }
              }

              return object;
            };
            /**
             * Converts this PlayerInfoAck to JSON.
             * @function toJSON
             * @memberof debrisprotocol.PlayerInfoAck
             * @instance
             * @returns {Object.<string,*>} JSON object
             */


            PlayerInfoAck.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PlayerInfoAck;
          }();

          debrisprotocol.PlayerGetAck = function () {
            /**
             * Properties of a PlayerGetAck.
             * @memberof debrisprotocol
             * @interface IPlayerGetAck
             * @property {number|null} [result] PlayerGetAck result
             * @property {boolean|null} [get] PlayerGetAck get
             */

            /**
             * Constructs a new PlayerGetAck.
             * @memberof debrisprotocol
             * @classdesc Represents a PlayerGetAck.
             * @implements IPlayerGetAck
             * @constructor
             * @param {debrisprotocol.IPlayerGetAck=} [properties] Properties to set
             */
            function PlayerGetAck(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * PlayerGetAck result.
             * @member {number} result
             * @memberof debrisprotocol.PlayerGetAck
             * @instance
             */


            PlayerGetAck.prototype.result = 0;
            /**
             * PlayerGetAck get.
             * @member {boolean} get
             * @memberof debrisprotocol.PlayerGetAck
             * @instance
             */

            PlayerGetAck.prototype.get = false;
            /**
             * Creates a new PlayerGetAck instance using the specified properties.
             * @function create
             * @memberof debrisprotocol.PlayerGetAck
             * @static
             * @param {debrisprotocol.IPlayerGetAck=} [properties] Properties to set
             * @returns {debrisprotocol.PlayerGetAck} PlayerGetAck instance
             */

            PlayerGetAck.create = function create(properties) {
              return new PlayerGetAck(properties);
            };
            /**
             * Encodes the specified PlayerGetAck message. Does not implicitly {@link debrisprotocol.PlayerGetAck.verify|verify} messages.
             * @function encode
             * @memberof debrisprotocol.PlayerGetAck
             * @static
             * @param {debrisprotocol.IPlayerGetAck} message PlayerGetAck message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            PlayerGetAck.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.result != null && Object.hasOwnProperty.call(message, "result")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).uint32(message.result);
              if (message.get != null && Object.hasOwnProperty.call(message, "get")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).bool(message.get);
              return writer;
            };
            /**
             * Encodes the specified PlayerGetAck message, length delimited. Does not implicitly {@link debrisprotocol.PlayerGetAck.verify|verify} messages.
             * @function encodeDelimited
             * @memberof debrisprotocol.PlayerGetAck
             * @static
             * @param {debrisprotocol.IPlayerGetAck} message PlayerGetAck message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            PlayerGetAck.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a PlayerGetAck message from the specified reader or buffer.
             * @function decode
             * @memberof debrisprotocol.PlayerGetAck
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {debrisprotocol.PlayerGetAck} PlayerGetAck
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            PlayerGetAck.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.debrisprotocol.PlayerGetAck();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.result = reader.uint32();
                    break;

                  case 2:
                    message.get = reader.bool();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
             * Decodes a PlayerGetAck message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof debrisprotocol.PlayerGetAck
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {debrisprotocol.PlayerGetAck} PlayerGetAck
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            PlayerGetAck.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a PlayerGetAck message.
             * @function verify
             * @memberof debrisprotocol.PlayerGetAck
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */


            PlayerGetAck.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.result != null && message.hasOwnProperty("result")) if (!$util.isInteger(message.result)) return "result: integer expected";
              if (message.get != null && message.hasOwnProperty("get")) if (typeof message.get !== "boolean") return "get: boolean expected";
              return null;
            };
            /**
             * Creates a PlayerGetAck message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof debrisprotocol.PlayerGetAck
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {debrisprotocol.PlayerGetAck} PlayerGetAck
             */


            PlayerGetAck.fromObject = function fromObject(object) {
              if (object instanceof $root.debrisprotocol.PlayerGetAck) return object;
              var message = new $root.debrisprotocol.PlayerGetAck();
              if (object.result != null) message.result = object.result >>> 0;
              if (object.get != null) message.get = Boolean(object.get);
              return message;
            };
            /**
             * Creates a plain object from a PlayerGetAck message. Also converts values to other types if specified.
             * @function toObject
             * @memberof debrisprotocol.PlayerGetAck
             * @static
             * @param {debrisprotocol.PlayerGetAck} message PlayerGetAck
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */


            PlayerGetAck.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.result = 0;
                object.get = false;
              }

              if (message.result != null && message.hasOwnProperty("result")) object.result = message.result;
              if (message.get != null && message.hasOwnProperty("get")) object.get = message.get;
              return object;
            };
            /**
             * Converts this PlayerGetAck to JSON.
             * @function toJSON
             * @memberof debrisprotocol.PlayerGetAck
             * @instance
             * @returns {Object.<string,*>} JSON object
             */


            PlayerGetAck.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PlayerGetAck;
          }();

          debrisprotocol.ExchangeDebrisAck = function () {
            /**
             * Properties of an ExchangeDebrisAck.
             * @memberof debrisprotocol
             * @interface IExchangeDebrisAck
             * @property {number|null} [result] ExchangeDebrisAck result
             * @property {number|null} [awardtype] ExchangeDebrisAck awardtype
             * @property {number|null} [itemno] ExchangeDebrisAck itemno
             * @property {number|null} [amount] ExchangeDebrisAck amount
             * @property {number|null} [iicon] ExchangeDebrisAck iicon
             */

            /**
             * Constructs a new ExchangeDebrisAck.
             * @memberof debrisprotocol
             * @classdesc Represents an ExchangeDebrisAck.
             * @implements IExchangeDebrisAck
             * @constructor
             * @param {debrisprotocol.IExchangeDebrisAck=} [properties] Properties to set
             */
            function ExchangeDebrisAck(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * ExchangeDebrisAck result.
             * @member {number} result
             * @memberof debrisprotocol.ExchangeDebrisAck
             * @instance
             */


            ExchangeDebrisAck.prototype.result = 0;
            /**
             * ExchangeDebrisAck awardtype.
             * @member {number} awardtype
             * @memberof debrisprotocol.ExchangeDebrisAck
             * @instance
             */

            ExchangeDebrisAck.prototype.awardtype = 0;
            /**
             * ExchangeDebrisAck itemno.
             * @member {number} itemno
             * @memberof debrisprotocol.ExchangeDebrisAck
             * @instance
             */

            ExchangeDebrisAck.prototype.itemno = 0;
            /**
             * ExchangeDebrisAck amount.
             * @member {number} amount
             * @memberof debrisprotocol.ExchangeDebrisAck
             * @instance
             */

            ExchangeDebrisAck.prototype.amount = 0;
            /**
             * ExchangeDebrisAck iicon.
             * @member {number} iicon
             * @memberof debrisprotocol.ExchangeDebrisAck
             * @instance
             */

            ExchangeDebrisAck.prototype.iicon = 0;
            /**
             * Creates a new ExchangeDebrisAck instance using the specified properties.
             * @function create
             * @memberof debrisprotocol.ExchangeDebrisAck
             * @static
             * @param {debrisprotocol.IExchangeDebrisAck=} [properties] Properties to set
             * @returns {debrisprotocol.ExchangeDebrisAck} ExchangeDebrisAck instance
             */

            ExchangeDebrisAck.create = function create(properties) {
              return new ExchangeDebrisAck(properties);
            };
            /**
             * Encodes the specified ExchangeDebrisAck message. Does not implicitly {@link debrisprotocol.ExchangeDebrisAck.verify|verify} messages.
             * @function encode
             * @memberof debrisprotocol.ExchangeDebrisAck
             * @static
             * @param {debrisprotocol.IExchangeDebrisAck} message ExchangeDebrisAck message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            ExchangeDebrisAck.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.result != null && Object.hasOwnProperty.call(message, "result")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).uint32(message.result);
              if (message.awardtype != null && Object.hasOwnProperty.call(message, "awardtype")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).uint32(message.awardtype);
              if (message.itemno != null && Object.hasOwnProperty.call(message, "itemno")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).uint32(message.itemno);
              if (message.amount != null && Object.hasOwnProperty.call(message, "amount")) writer.uint32(
              /* id 4, wireType 0 =*/
              32).uint32(message.amount);
              if (message.iicon != null && Object.hasOwnProperty.call(message, "iicon")) writer.uint32(
              /* id 5, wireType 0 =*/
              40).uint32(message.iicon);
              return writer;
            };
            /**
             * Encodes the specified ExchangeDebrisAck message, length delimited. Does not implicitly {@link debrisprotocol.ExchangeDebrisAck.verify|verify} messages.
             * @function encodeDelimited
             * @memberof debrisprotocol.ExchangeDebrisAck
             * @static
             * @param {debrisprotocol.IExchangeDebrisAck} message ExchangeDebrisAck message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            ExchangeDebrisAck.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes an ExchangeDebrisAck message from the specified reader or buffer.
             * @function decode
             * @memberof debrisprotocol.ExchangeDebrisAck
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {debrisprotocol.ExchangeDebrisAck} ExchangeDebrisAck
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            ExchangeDebrisAck.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.debrisprotocol.ExchangeDebrisAck();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.result = reader.uint32();
                    break;

                  case 2:
                    message.awardtype = reader.uint32();
                    break;

                  case 3:
                    message.itemno = reader.uint32();
                    break;

                  case 4:
                    message.amount = reader.uint32();
                    break;

                  case 5:
                    message.iicon = reader.uint32();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
             * Decodes an ExchangeDebrisAck message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof debrisprotocol.ExchangeDebrisAck
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {debrisprotocol.ExchangeDebrisAck} ExchangeDebrisAck
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            ExchangeDebrisAck.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies an ExchangeDebrisAck message.
             * @function verify
             * @memberof debrisprotocol.ExchangeDebrisAck
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */


            ExchangeDebrisAck.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.result != null && message.hasOwnProperty("result")) if (!$util.isInteger(message.result)) return "result: integer expected";
              if (message.awardtype != null && message.hasOwnProperty("awardtype")) if (!$util.isInteger(message.awardtype)) return "awardtype: integer expected";
              if (message.itemno != null && message.hasOwnProperty("itemno")) if (!$util.isInteger(message.itemno)) return "itemno: integer expected";
              if (message.amount != null && message.hasOwnProperty("amount")) if (!$util.isInteger(message.amount)) return "amount: integer expected";
              if (message.iicon != null && message.hasOwnProperty("iicon")) if (!$util.isInteger(message.iicon)) return "iicon: integer expected";
              return null;
            };
            /**
             * Creates an ExchangeDebrisAck message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof debrisprotocol.ExchangeDebrisAck
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {debrisprotocol.ExchangeDebrisAck} ExchangeDebrisAck
             */


            ExchangeDebrisAck.fromObject = function fromObject(object) {
              if (object instanceof $root.debrisprotocol.ExchangeDebrisAck) return object;
              var message = new $root.debrisprotocol.ExchangeDebrisAck();
              if (object.result != null) message.result = object.result >>> 0;
              if (object.awardtype != null) message.awardtype = object.awardtype >>> 0;
              if (object.itemno != null) message.itemno = object.itemno >>> 0;
              if (object.amount != null) message.amount = object.amount >>> 0;
              if (object.iicon != null) message.iicon = object.iicon >>> 0;
              return message;
            };
            /**
             * Creates a plain object from an ExchangeDebrisAck message. Also converts values to other types if specified.
             * @function toObject
             * @memberof debrisprotocol.ExchangeDebrisAck
             * @static
             * @param {debrisprotocol.ExchangeDebrisAck} message ExchangeDebrisAck
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */


            ExchangeDebrisAck.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.result = 0;
                object.awardtype = 0;
                object.itemno = 0;
                object.amount = 0;
                object.iicon = 0;
              }

              if (message.result != null && message.hasOwnProperty("result")) object.result = message.result;
              if (message.awardtype != null && message.hasOwnProperty("awardtype")) object.awardtype = message.awardtype;
              if (message.itemno != null && message.hasOwnProperty("itemno")) object.itemno = message.itemno;
              if (message.amount != null && message.hasOwnProperty("amount")) object.amount = message.amount;
              if (message.iicon != null && message.hasOwnProperty("iicon")) object.iicon = message.iicon;
              return object;
            };
            /**
             * Converts this ExchangeDebrisAck to JSON.
             * @function toJSON
             * @memberof debrisprotocol.ExchangeDebrisAck
             * @instance
             * @returns {Object.<string,*>} JSON object
             */


            ExchangeDebrisAck.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ExchangeDebrisAck;
          }();

          debrisprotocol.Formula = function () {
            /**
             * Properties of a Formula.
             * @memberof debrisprotocol
             * @interface IFormula
             * @property {number|null} [no] Formula no
             * @property {number|null} [level] Formula level
             * @property {number|null} [ftype] Formula ftype
             * @property {number|null} [fitem] Formula fitem
             * @property {number|null} [ficon] Formula ficon
             * @property {number|null} [amount] Formula amount
             * @property {number|null} [max] Formula max
             * @property {number|null} [ItemBet] Formula ItemBet
             * @property {Array.<number>|null} [dn] Formula dn
             * @property {Array.<number>|null} [dc] Formula dc
             */

            /**
             * Constructs a new Formula.
             * @memberof debrisprotocol
             * @classdesc Represents a Formula.
             * @implements IFormula
             * @constructor
             * @param {debrisprotocol.IFormula=} [properties] Properties to set
             */
            function Formula(properties) {
              this.dn = [];
              this.dc = [];
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * Formula no.
             * @member {number} no
             * @memberof debrisprotocol.Formula
             * @instance
             */


            Formula.prototype.no = 0;
            /**
             * Formula level.
             * @member {number} level
             * @memberof debrisprotocol.Formula
             * @instance
             */

            Formula.prototype.level = 0;
            /**
             * Formula ftype.
             * @member {number} ftype
             * @memberof debrisprotocol.Formula
             * @instance
             */

            Formula.prototype.ftype = 0;
            /**
             * Formula fitem.
             * @member {number} fitem
             * @memberof debrisprotocol.Formula
             * @instance
             */

            Formula.prototype.fitem = 0;
            /**
             * Formula ficon.
             * @member {number} ficon
             * @memberof debrisprotocol.Formula
             * @instance
             */

            Formula.prototype.ficon = 0;
            /**
             * Formula amount.
             * @member {number} amount
             * @memberof debrisprotocol.Formula
             * @instance
             */

            Formula.prototype.amount = 0;
            /**
             * Formula max.
             * @member {number} max
             * @memberof debrisprotocol.Formula
             * @instance
             */

            Formula.prototype.max = 0;
            /**
             * Formula ItemBet.
             * @member {number} ItemBet
             * @memberof debrisprotocol.Formula
             * @instance
             */

            Formula.prototype.ItemBet = 0;
            /**
             * Formula dn.
             * @member {Array.<number>} dn
             * @memberof debrisprotocol.Formula
             * @instance
             */

            Formula.prototype.dn = $util.emptyArray;
            /**
             * Formula dc.
             * @member {Array.<number>} dc
             * @memberof debrisprotocol.Formula
             * @instance
             */

            Formula.prototype.dc = $util.emptyArray;
            /**
             * Creates a new Formula instance using the specified properties.
             * @function create
             * @memberof debrisprotocol.Formula
             * @static
             * @param {debrisprotocol.IFormula=} [properties] Properties to set
             * @returns {debrisprotocol.Formula} Formula instance
             */

            Formula.create = function create(properties) {
              return new Formula(properties);
            };
            /**
             * Encodes the specified Formula message. Does not implicitly {@link debrisprotocol.Formula.verify|verify} messages.
             * @function encode
             * @memberof debrisprotocol.Formula
             * @static
             * @param {debrisprotocol.IFormula} message Formula message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            Formula.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.no != null && Object.hasOwnProperty.call(message, "no")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).uint32(message.no);
              if (message.level != null && Object.hasOwnProperty.call(message, "level")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).uint32(message.level);
              if (message.ftype != null && Object.hasOwnProperty.call(message, "ftype")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).uint32(message.ftype);
              if (message.fitem != null && Object.hasOwnProperty.call(message, "fitem")) writer.uint32(
              /* id 4, wireType 0 =*/
              32).uint32(message.fitem);
              if (message.ficon != null && Object.hasOwnProperty.call(message, "ficon")) writer.uint32(
              /* id 5, wireType 0 =*/
              40).uint32(message.ficon);
              if (message.amount != null && Object.hasOwnProperty.call(message, "amount")) writer.uint32(
              /* id 6, wireType 0 =*/
              48).uint32(message.amount);
              if (message.max != null && Object.hasOwnProperty.call(message, "max")) writer.uint32(
              /* id 7, wireType 0 =*/
              56).uint32(message.max);

              if (message.dn != null && message.dn.length) {
                writer.uint32(
                /* id 8, wireType 2 =*/
                66).fork();

                for (var i = 0; i < message.dn.length; ++i) {
                  writer.uint32(message.dn[i]);
                }

                writer.ldelim();
              }

              if (message.dc != null && message.dc.length) {
                writer.uint32(
                /* id 9, wireType 2 =*/
                74).fork();

                for (var i = 0; i < message.dc.length; ++i) {
                  writer.uint32(message.dc[i]);
                }

                writer.ldelim();
              }

              if (message.ItemBet != null && Object.hasOwnProperty.call(message, "ItemBet")) writer.uint32(
              /* id 10, wireType 1 =*/
              81)["double"](message.ItemBet);
              return writer;
            };
            /**
             * Encodes the specified Formula message, length delimited. Does not implicitly {@link debrisprotocol.Formula.verify|verify} messages.
             * @function encodeDelimited
             * @memberof debrisprotocol.Formula
             * @static
             * @param {debrisprotocol.IFormula} message Formula message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            Formula.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a Formula message from the specified reader or buffer.
             * @function decode
             * @memberof debrisprotocol.Formula
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {debrisprotocol.Formula} Formula
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            Formula.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.debrisprotocol.Formula();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.no = reader.uint32();
                    break;

                  case 2:
                    message.level = reader.uint32();
                    break;

                  case 3:
                    message.ftype = reader.uint32();
                    break;

                  case 4:
                    message.fitem = reader.uint32();
                    break;

                  case 5:
                    message.ficon = reader.uint32();
                    break;

                  case 6:
                    message.amount = reader.uint32();
                    break;

                  case 7:
                    message.max = reader.uint32();
                    break;

                  case 10:
                    message.ItemBet = reader["double"]();
                    break;

                  case 8:
                    if (!(message.dn && message.dn.length)) message.dn = [];

                    if ((tag & 7) === 2) {
                      var end2 = reader.uint32() + reader.pos;

                      while (reader.pos < end2) {
                        message.dn.push(reader.uint32());
                      }
                    } else message.dn.push(reader.uint32());

                    break;

                  case 9:
                    if (!(message.dc && message.dc.length)) message.dc = [];

                    if ((tag & 7) === 2) {
                      var end2 = reader.uint32() + reader.pos;

                      while (reader.pos < end2) {
                        message.dc.push(reader.uint32());
                      }
                    } else message.dc.push(reader.uint32());

                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
             * Decodes a Formula message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof debrisprotocol.Formula
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {debrisprotocol.Formula} Formula
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            Formula.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a Formula message.
             * @function verify
             * @memberof debrisprotocol.Formula
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */


            Formula.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.no != null && message.hasOwnProperty("no")) if (!$util.isInteger(message.no)) return "no: integer expected";
              if (message.level != null && message.hasOwnProperty("level")) if (!$util.isInteger(message.level)) return "level: integer expected";
              if (message.ftype != null && message.hasOwnProperty("ftype")) if (!$util.isInteger(message.ftype)) return "ftype: integer expected";
              if (message.fitem != null && message.hasOwnProperty("fitem")) if (!$util.isInteger(message.fitem)) return "fitem: integer expected";
              if (message.ficon != null && message.hasOwnProperty("ficon")) if (!$util.isInteger(message.ficon)) return "ficon: integer expected";
              if (message.amount != null && message.hasOwnProperty("amount")) if (!$util.isInteger(message.amount)) return "amount: integer expected";
              if (message.max != null && message.hasOwnProperty("max")) if (!$util.isInteger(message.max)) return "max: integer expected";
              if (message.ItemBet != null && message.hasOwnProperty("ItemBet")) if (typeof message.ItemBet !== "number") return "ItemBet: number expected";

              if (message.dn != null && message.hasOwnProperty("dn")) {
                if (!Array.isArray(message.dn)) return "dn: array expected";

                for (var i = 0; i < message.dn.length; ++i) {
                  if (!$util.isInteger(message.dn[i])) return "dn: integer[] expected";
                }
              }

              if (message.dc != null && message.hasOwnProperty("dc")) {
                if (!Array.isArray(message.dc)) return "dc: array expected";

                for (var i = 0; i < message.dc.length; ++i) {
                  if (!$util.isInteger(message.dc[i])) return "dc: integer[] expected";
                }
              }

              return null;
            };
            /**
             * Creates a Formula message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof debrisprotocol.Formula
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {debrisprotocol.Formula} Formula
             */


            Formula.fromObject = function fromObject(object) {
              if (object instanceof $root.debrisprotocol.Formula) return object;
              var message = new $root.debrisprotocol.Formula();
              if (object.no != null) message.no = object.no >>> 0;
              if (object.level != null) message.level = object.level >>> 0;
              if (object.ftype != null) message.ftype = object.ftype >>> 0;
              if (object.fitem != null) message.fitem = object.fitem >>> 0;
              if (object.ficon != null) message.ficon = object.ficon >>> 0;
              if (object.amount != null) message.amount = object.amount >>> 0;
              if (object.max != null) message.max = object.max >>> 0;
              if (object.ItemBet != null) message.ItemBet = Number(object.ItemBet);

              if (object.dn) {
                if (!Array.isArray(object.dn)) throw TypeError(".debrisprotocol.Formula.dn: array expected");
                message.dn = [];

                for (var i = 0; i < object.dn.length; ++i) {
                  message.dn[i] = object.dn[i] >>> 0;
                }
              }

              if (object.dc) {
                if (!Array.isArray(object.dc)) throw TypeError(".debrisprotocol.Formula.dc: array expected");
                message.dc = [];

                for (var i = 0; i < object.dc.length; ++i) {
                  message.dc[i] = object.dc[i] >>> 0;
                }
              }

              return message;
            };
            /**
             * Creates a plain object from a Formula message. Also converts values to other types if specified.
             * @function toObject
             * @memberof debrisprotocol.Formula
             * @static
             * @param {debrisprotocol.Formula} message Formula
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */


            Formula.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.arrays || options.defaults) {
                object.dn = [];
                object.dc = [];
              }

              if (options.defaults) {
                object.no = 0;
                object.level = 0;
                object.ftype = 0;
                object.fitem = 0;
                object.ficon = 0;
                object.amount = 0;
                object.max = 0;
                object.ItemBet = 0;
              }

              if (message.no != null && message.hasOwnProperty("no")) object.no = message.no;
              if (message.level != null && message.hasOwnProperty("level")) object.level = message.level;
              if (message.ftype != null && message.hasOwnProperty("ftype")) object.ftype = message.ftype;
              if (message.fitem != null && message.hasOwnProperty("fitem")) object.fitem = message.fitem;
              if (message.ficon != null && message.hasOwnProperty("ficon")) object.ficon = message.ficon;
              if (message.amount != null && message.hasOwnProperty("amount")) object.amount = message.amount;
              if (message.max != null && message.hasOwnProperty("max")) object.max = message.max;

              if (message.dn && message.dn.length) {
                object.dn = [];

                for (var j = 0; j < message.dn.length; ++j) {
                  object.dn[j] = message.dn[j];
                }
              }

              if (message.dc && message.dc.length) {
                object.dc = [];

                for (var j = 0; j < message.dc.length; ++j) {
                  object.dc[j] = message.dc[j];
                }
              }

              if (message.ItemBet != null && message.hasOwnProperty("ItemBet")) object.ItemBet = options.json && !isFinite(message.ItemBet) ? String(message.ItemBet) : message.ItemBet;
              return object;
            };
            /**
             * Converts this Formula to JSON.
             * @function toJSON
             * @memberof debrisprotocol.Formula
             * @instance
             * @returns {Object.<string,*>} JSON object
             */


            Formula.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Formula;
          }();

          debrisprotocol.Debris = function () {
            /**
             * Properties of a Debris.
             * @memberof debrisprotocol
             * @interface IDebris
             * @property {number|null} [no] Debris no
             * @property {number|null} [level] Debris level
             * @property {number|null} [icon] Debris icon
             */

            /**
             * Constructs a new Debris.
             * @memberof debrisprotocol
             * @classdesc Represents a Debris.
             * @implements IDebris
             * @constructor
             * @param {debrisprotocol.IDebris=} [properties] Properties to set
             */
            function Debris(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * Debris no.
             * @member {number} no
             * @memberof debrisprotocol.Debris
             * @instance
             */


            Debris.prototype.no = 0;
            /**
             * Debris level.
             * @member {number} level
             * @memberof debrisprotocol.Debris
             * @instance
             */

            Debris.prototype.level = 0;
            /**
             * Debris icon.
             * @member {number} icon
             * @memberof debrisprotocol.Debris
             * @instance
             */

            Debris.prototype.icon = 0;
            /**
             * Creates a new Debris instance using the specified properties.
             * @function create
             * @memberof debrisprotocol.Debris
             * @static
             * @param {debrisprotocol.IDebris=} [properties] Properties to set
             * @returns {debrisprotocol.Debris} Debris instance
             */

            Debris.create = function create(properties) {
              return new Debris(properties);
            };
            /**
             * Encodes the specified Debris message. Does not implicitly {@link debrisprotocol.Debris.verify|verify} messages.
             * @function encode
             * @memberof debrisprotocol.Debris
             * @static
             * @param {debrisprotocol.IDebris} message Debris message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            Debris.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.no != null && Object.hasOwnProperty.call(message, "no")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).uint32(message.no);
              if (message.level != null && Object.hasOwnProperty.call(message, "level")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).uint32(message.level);
              if (message.icon != null && Object.hasOwnProperty.call(message, "icon")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).uint32(message.icon);
              return writer;
            };
            /**
             * Encodes the specified Debris message, length delimited. Does not implicitly {@link debrisprotocol.Debris.verify|verify} messages.
             * @function encodeDelimited
             * @memberof debrisprotocol.Debris
             * @static
             * @param {debrisprotocol.IDebris} message Debris message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            Debris.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a Debris message from the specified reader or buffer.
             * @function decode
             * @memberof debrisprotocol.Debris
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {debrisprotocol.Debris} Debris
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            Debris.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.debrisprotocol.Debris();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.no = reader.uint32();
                    break;

                  case 2:
                    message.level = reader.uint32();
                    break;

                  case 3:
                    message.icon = reader.uint32();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
             * Decodes a Debris message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof debrisprotocol.Debris
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {debrisprotocol.Debris} Debris
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            Debris.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a Debris message.
             * @function verify
             * @memberof debrisprotocol.Debris
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */


            Debris.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.no != null && message.hasOwnProperty("no")) if (!$util.isInteger(message.no)) return "no: integer expected";
              if (message.level != null && message.hasOwnProperty("level")) if (!$util.isInteger(message.level)) return "level: integer expected";
              if (message.icon != null && message.hasOwnProperty("icon")) if (!$util.isInteger(message.icon)) return "icon: integer expected";
              return null;
            };
            /**
             * Creates a Debris message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof debrisprotocol.Debris
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {debrisprotocol.Debris} Debris
             */


            Debris.fromObject = function fromObject(object) {
              if (object instanceof $root.debrisprotocol.Debris) return object;
              var message = new $root.debrisprotocol.Debris();
              if (object.no != null) message.no = object.no >>> 0;
              if (object.level != null) message.level = object.level >>> 0;
              if (object.icon != null) message.icon = object.icon >>> 0;
              return message;
            };
            /**
             * Creates a plain object from a Debris message. Also converts values to other types if specified.
             * @function toObject
             * @memberof debrisprotocol.Debris
             * @static
             * @param {debrisprotocol.Debris} message Debris
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */


            Debris.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.no = 0;
                object.level = 0;
                object.icon = 0;
              }

              if (message.no != null && message.hasOwnProperty("no")) object.no = message.no;
              if (message.level != null && message.hasOwnProperty("level")) object.level = message.level;
              if (message.icon != null && message.hasOwnProperty("icon")) object.icon = message.icon;
              return object;
            };
            /**
             * Converts this Debris to JSON.
             * @function toJSON
             * @memberof debrisprotocol.Debris
             * @instance
             * @returns {Object.<string,*>} JSON object
             */


            Debris.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Debris;
          }();

          debrisprotocol.ActivityOutput = function () {
            /**
             * Properties of an ActivityOutput.
             * @memberof debrisprotocol
             * @interface IActivityOutput
             * @property {number|null} [no] ActivityOutput no
             * @property {google.protobuf.ITimestamp|null} [start] ActivityOutput start
             * @property {google.protobuf.ITimestamp|null} [fall] ActivityOutput fall
             * @property {google.protobuf.ITimestamp|null} [end] ActivityOutput end
             * @property {Array.<debrisprotocol.IFormula>|null} [formula] ActivityOutput formula
             * @property {Array.<debrisprotocol.IDebris>|null} [Debris] ActivityOutput Debris
             * @property {Array.<number>|null} [minbet] ActivityOutput minbet
             * @property {number|null} [minmul] ActivityOutput minmul
             * @property {string|null} [ItemGameDesc] ActivityOutput ItemGameDesc
             */

            /**
             * Constructs a new ActivityOutput.
             * @memberof debrisprotocol
             * @classdesc Represents an ActivityOutput.
             * @implements IActivityOutput
             * @constructor
             * @param {debrisprotocol.IActivityOutput=} [properties] Properties to set
             */
            function ActivityOutput(properties) {
              this.formula = [];
              this.Debris = [];
              this.minbet = [];
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * ActivityOutput no.
             * @member {number} no
             * @memberof debrisprotocol.ActivityOutput
             * @instance
             */


            ActivityOutput.prototype.no = 0;
            /**
             * ActivityOutput start.
             * @member {google.protobuf.ITimestamp|null|undefined} start
             * @memberof debrisprotocol.ActivityOutput
             * @instance
             */

            ActivityOutput.prototype.start = null;
            /**
             * ActivityOutput fall.
             * @member {google.protobuf.ITimestamp|null|undefined} fall
             * @memberof debrisprotocol.ActivityOutput
             * @instance
             */

            ActivityOutput.prototype.fall = null;
            /**
             * ActivityOutput end.
             * @member {google.protobuf.ITimestamp|null|undefined} end
             * @memberof debrisprotocol.ActivityOutput
             * @instance
             */

            ActivityOutput.prototype.end = null;
            /**
             * ActivityOutput formula.
             * @member {Array.<debrisprotocol.IFormula>} formula
             * @memberof debrisprotocol.ActivityOutput
             * @instance
             */

            ActivityOutput.prototype.formula = $util.emptyArray;
            /**
             * ActivityOutput Debris.
             * @member {Array.<debrisprotocol.IDebris>} Debris
             * @memberof debrisprotocol.ActivityOutput
             * @instance
             */

            ActivityOutput.prototype.Debris = $util.emptyArray;
            /**
             * ActivityOutput minbet.
             * @member {Array.<number>} minbet
             * @memberof debrisprotocol.ActivityOutput
             * @instance
             */

            ActivityOutput.prototype.minbet = $util.emptyArray;
            /**
             * ActivityOutput minmul.
             * @member {number} minmul
             * @memberof debrisprotocol.ActivityOutput
             * @instance
             */

            ActivityOutput.prototype.minmul = 0;
            /**
             * ActivityOutput ItemGameDesc.
             * @member {string} ItemGameDesc
             * @memberof debrisprotocol.ActivityOutput
             * @instance
             */

            ActivityOutput.prototype.ItemGameDesc = "";
            /**
             * Creates a new ActivityOutput instance using the specified properties.
             * @function create
             * @memberof debrisprotocol.ActivityOutput
             * @static
             * @param {debrisprotocol.IActivityOutput=} [properties] Properties to set
             * @returns {debrisprotocol.ActivityOutput} ActivityOutput instance
             */

            ActivityOutput.create = function create(properties) {
              return new ActivityOutput(properties);
            };
            /**
             * Encodes the specified ActivityOutput message. Does not implicitly {@link debrisprotocol.ActivityOutput.verify|verify} messages.
             * @function encode
             * @memberof debrisprotocol.ActivityOutput
             * @static
             * @param {debrisprotocol.IActivityOutput} message ActivityOutput message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            ActivityOutput.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.no != null && Object.hasOwnProperty.call(message, "no")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).uint32(message.no);
              if (message.start != null && Object.hasOwnProperty.call(message, "start")) $root.google.protobuf.Timestamp.encode(message.start, writer.uint32(
              /* id 2, wireType 2 =*/
              18).fork()).ldelim();
              if (message.fall != null && Object.hasOwnProperty.call(message, "fall")) $root.google.protobuf.Timestamp.encode(message.fall, writer.uint32(
              /* id 3, wireType 2 =*/
              26).fork()).ldelim();
              if (message.end != null && Object.hasOwnProperty.call(message, "end")) $root.google.protobuf.Timestamp.encode(message.end, writer.uint32(
              /* id 4, wireType 2 =*/
              34).fork()).ldelim();
              if (message.formula != null && message.formula.length) for (var i = 0; i < message.formula.length; ++i) {
                $root.debrisprotocol.Formula.encode(message.formula[i], writer.uint32(
                /* id 5, wireType 2 =*/
                42).fork()).ldelim();
              }
              if (message.Debris != null && message.Debris.length) for (var i = 0; i < message.Debris.length; ++i) {
                $root.debrisprotocol.Debris.encode(message.Debris[i], writer.uint32(
                /* id 6, wireType 2 =*/
                50).fork()).ldelim();
              }

              if (message.minbet != null && message.minbet.length) {
                writer.uint32(
                /* id 7, wireType 2 =*/
                58).fork();

                for (var i = 0; i < message.minbet.length; ++i) {
                  writer["double"](message.minbet[i]);
                }

                writer.ldelim();
              }

              if (message.minmul != null && Object.hasOwnProperty.call(message, "minmul")) writer.uint32(
              /* id 8, wireType 1 =*/
              65)["double"](message.minmul);
              if (message.ItemGameDesc != null && Object.hasOwnProperty.call(message, "ItemGameDesc")) writer.uint32(
              /* id 9, wireType 2 =*/
              74).string(message.ItemGameDesc);
              return writer;
            };
            /**
             * Encodes the specified ActivityOutput message, length delimited. Does not implicitly {@link debrisprotocol.ActivityOutput.verify|verify} messages.
             * @function encodeDelimited
             * @memberof debrisprotocol.ActivityOutput
             * @static
             * @param {debrisprotocol.IActivityOutput} message ActivityOutput message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            ActivityOutput.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes an ActivityOutput message from the specified reader or buffer.
             * @function decode
             * @memberof debrisprotocol.ActivityOutput
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {debrisprotocol.ActivityOutput} ActivityOutput
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            ActivityOutput.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.debrisprotocol.ActivityOutput();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.no = reader.uint32();
                    break;

                  case 2:
                    message.start = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                    break;

                  case 3:
                    message.fall = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                    break;

                  case 4:
                    message.end = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                    break;

                  case 5:
                    if (!(message.formula && message.formula.length)) message.formula = [];
                    message.formula.push($root.debrisprotocol.Formula.decode(reader, reader.uint32()));
                    break;

                  case 6:
                    if (!(message.Debris && message.Debris.length)) message.Debris = [];
                    message.Debris.push($root.debrisprotocol.Debris.decode(reader, reader.uint32()));
                    break;

                  case 7:
                    if (!(message.minbet && message.minbet.length)) message.minbet = [];

                    if ((tag & 7) === 2) {
                      var end2 = reader.uint32() + reader.pos;

                      while (reader.pos < end2) {
                        message.minbet.push(reader["double"]());
                      }
                    } else message.minbet.push(reader["double"]());

                    break;

                  case 8:
                    message.minmul = reader["double"]();
                    break;

                  case 9:
                    message.ItemGameDesc = reader.string();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
             * Decodes an ActivityOutput message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof debrisprotocol.ActivityOutput
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {debrisprotocol.ActivityOutput} ActivityOutput
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            ActivityOutput.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies an ActivityOutput message.
             * @function verify
             * @memberof debrisprotocol.ActivityOutput
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */


            ActivityOutput.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.no != null && message.hasOwnProperty("no")) if (!$util.isInteger(message.no)) return "no: integer expected";

              if (message.start != null && message.hasOwnProperty("start")) {
                var error = $root.google.protobuf.Timestamp.verify(message.start);
                if (error) return "start." + error;
              }

              if (message.fall != null && message.hasOwnProperty("fall")) {
                var error = $root.google.protobuf.Timestamp.verify(message.fall);
                if (error) return "fall." + error;
              }

              if (message.end != null && message.hasOwnProperty("end")) {
                var error = $root.google.protobuf.Timestamp.verify(message.end);
                if (error) return "end." + error;
              }

              if (message.formula != null && message.hasOwnProperty("formula")) {
                if (!Array.isArray(message.formula)) return "formula: array expected";

                for (var i = 0; i < message.formula.length; ++i) {
                  var error = $root.debrisprotocol.Formula.verify(message.formula[i]);
                  if (error) return "formula." + error;
                }
              }

              if (message.Debris != null && message.hasOwnProperty("Debris")) {
                if (!Array.isArray(message.Debris)) return "Debris: array expected";

                for (var i = 0; i < message.Debris.length; ++i) {
                  var error = $root.debrisprotocol.Debris.verify(message.Debris[i]);
                  if (error) return "Debris." + error;
                }
              }

              if (message.minbet != null && message.hasOwnProperty("minbet")) {
                if (!Array.isArray(message.minbet)) return "minbet: array expected";

                for (var i = 0; i < message.minbet.length; ++i) {
                  if (typeof message.minbet[i] !== "number") return "minbet: number[] expected";
                }
              }

              if (message.minmul != null && message.hasOwnProperty("minmul")) if (typeof message.minmul !== "number") return "minmul: number expected";
              if (message.ItemGameDesc != null && message.hasOwnProperty("ItemGameDesc")) if (!$util.isString(message.ItemGameDesc)) return "ItemGameDesc: string expected";
              return null;
            };
            /**
             * Creates an ActivityOutput message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof debrisprotocol.ActivityOutput
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {debrisprotocol.ActivityOutput} ActivityOutput
             */


            ActivityOutput.fromObject = function fromObject(object) {
              if (object instanceof $root.debrisprotocol.ActivityOutput) return object;
              var message = new $root.debrisprotocol.ActivityOutput();
              if (object.no != null) message.no = object.no >>> 0;

              if (object.start != null) {
                if (typeof object.start !== "object") throw TypeError(".debrisprotocol.ActivityOutput.start: object expected");
                message.start = $root.google.protobuf.Timestamp.fromObject(object.start);
              }

              if (object.fall != null) {
                if (typeof object.fall !== "object") throw TypeError(".debrisprotocol.ActivityOutput.fall: object expected");
                message.fall = $root.google.protobuf.Timestamp.fromObject(object.fall);
              }

              if (object.end != null) {
                if (typeof object.end !== "object") throw TypeError(".debrisprotocol.ActivityOutput.end: object expected");
                message.end = $root.google.protobuf.Timestamp.fromObject(object.end);
              }

              if (object.formula) {
                if (!Array.isArray(object.formula)) throw TypeError(".debrisprotocol.ActivityOutput.formula: array expected");
                message.formula = [];

                for (var i = 0; i < object.formula.length; ++i) {
                  if (typeof object.formula[i] !== "object") throw TypeError(".debrisprotocol.ActivityOutput.formula: object expected");
                  message.formula[i] = $root.debrisprotocol.Formula.fromObject(object.formula[i]);
                }
              }

              if (object.Debris) {
                if (!Array.isArray(object.Debris)) throw TypeError(".debrisprotocol.ActivityOutput.Debris: array expected");
                message.Debris = [];

                for (var i = 0; i < object.Debris.length; ++i) {
                  if (typeof object.Debris[i] !== "object") throw TypeError(".debrisprotocol.ActivityOutput.Debris: object expected");
                  message.Debris[i] = $root.debrisprotocol.Debris.fromObject(object.Debris[i]);
                }
              }

              if (object.minbet) {
                if (!Array.isArray(object.minbet)) throw TypeError(".debrisprotocol.ActivityOutput.minbet: array expected");
                message.minbet = [];

                for (var i = 0; i < object.minbet.length; ++i) {
                  message.minbet[i] = Number(object.minbet[i]);
                }
              }

              if (object.minmul != null) message.minmul = Number(object.minmul);
              if (object.ItemGameDesc != null) message.ItemGameDesc = String(object.ItemGameDesc);
              return message;
            };
            /**
             * Creates a plain object from an ActivityOutput message. Also converts values to other types if specified.
             * @function toObject
             * @memberof debrisprotocol.ActivityOutput
             * @static
             * @param {debrisprotocol.ActivityOutput} message ActivityOutput
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */


            ActivityOutput.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.arrays || options.defaults) {
                object.formula = [];
                object.Debris = [];
                object.minbet = [];
              }

              if (options.defaults) {
                object.no = 0;
                object.start = null;
                object.fall = null;
                object.end = null;
                object.minmul = 0;
                object.ItemGameDesc = "";
              }

              if (message.no != null && message.hasOwnProperty("no")) object.no = message.no;
              if (message.start != null && message.hasOwnProperty("start")) object.start = $root.google.protobuf.Timestamp.toObject(message.start, options);
              if (message.fall != null && message.hasOwnProperty("fall")) object.fall = $root.google.protobuf.Timestamp.toObject(message.fall, options);
              if (message.end != null && message.hasOwnProperty("end")) object.end = $root.google.protobuf.Timestamp.toObject(message.end, options);

              if (message.formula && message.formula.length) {
                object.formula = [];

                for (var j = 0; j < message.formula.length; ++j) {
                  object.formula[j] = $root.debrisprotocol.Formula.toObject(message.formula[j], options);
                }
              }

              if (message.Debris && message.Debris.length) {
                object.Debris = [];

                for (var j = 0; j < message.Debris.length; ++j) {
                  object.Debris[j] = $root.debrisprotocol.Debris.toObject(message.Debris[j], options);
                }
              }

              if (message.minbet && message.minbet.length) {
                object.minbet = [];

                for (var j = 0; j < message.minbet.length; ++j) {
                  object.minbet[j] = options.json && !isFinite(message.minbet[j]) ? String(message.minbet[j]) : message.minbet[j];
                }
              }

              if (message.minmul != null && message.hasOwnProperty("minmul")) object.minmul = options.json && !isFinite(message.minmul) ? String(message.minmul) : message.minmul;
              if (message.ItemGameDesc != null && message.hasOwnProperty("ItemGameDesc")) object.ItemGameDesc = message.ItemGameDesc;
              return object;
            };
            /**
             * Converts this ActivityOutput to JSON.
             * @function toJSON
             * @memberof debrisprotocol.ActivityOutput
             * @instance
             * @returns {Object.<string,*>} JSON object
             */


            ActivityOutput.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ActivityOutput;
          }();

          return debrisprotocol;
        }();

        $root.google = function () {
          /**
           * Namespace google.
           * @exports google
           * @namespace
           */
          var google = {};

          google.protobuf = function () {
            /**
             * Namespace protobuf.
             * @memberof google
             * @namespace
             */
            var protobuf = {};

            protobuf.Timestamp = function () {
              /**
               * Properties of a Timestamp.
               * @memberof google.protobuf
               * @interface ITimestamp
               * @property {number|Long|null} [seconds] Timestamp seconds
               * @property {number|null} [nanos] Timestamp nanos
               */

              /**
               * Constructs a new Timestamp.
               * @memberof google.protobuf
               * @classdesc Represents a Timestamp.
               * @implements ITimestamp
               * @constructor
               * @param {google.protobuf.ITimestamp=} [properties] Properties to set
               */
              function Timestamp(properties) {
                if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                  if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
                }
              }
              /**
               * Timestamp seconds.
               * @member {number|Long} seconds
               * @memberof google.protobuf.Timestamp
               * @instance
               */


              Timestamp.prototype.seconds = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
              /**
               * Timestamp nanos.
               * @member {number} nanos
               * @memberof google.protobuf.Timestamp
               * @instance
               */

              Timestamp.prototype.nanos = 0;
              /**
               * Creates a new Timestamp instance using the specified properties.
               * @function create
               * @memberof google.protobuf.Timestamp
               * @static
               * @param {google.protobuf.ITimestamp=} [properties] Properties to set
               * @returns {google.protobuf.Timestamp} Timestamp instance
               */

              Timestamp.create = function create(properties) {
                return new Timestamp(properties);
              };
              /**
               * Encodes the specified Timestamp message. Does not implicitly {@link google.protobuf.Timestamp.verify|verify} messages.
               * @function encode
               * @memberof google.protobuf.Timestamp
               * @static
               * @param {google.protobuf.ITimestamp} message Timestamp message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              Timestamp.encode = function encode(message, writer) {
                if (!writer) writer = $Writer.create();
                if (message.seconds != null && Object.hasOwnProperty.call(message, "seconds")) writer.uint32(
                /* id 1, wireType 0 =*/
                8).int64(message.seconds);
                if (message.nanos != null && Object.hasOwnProperty.call(message, "nanos")) writer.uint32(
                /* id 2, wireType 0 =*/
                16).int32(message.nanos);
                return writer;
              };
              /**
               * Encodes the specified Timestamp message, length delimited. Does not implicitly {@link google.protobuf.Timestamp.verify|verify} messages.
               * @function encodeDelimited
               * @memberof google.protobuf.Timestamp
               * @static
               * @param {google.protobuf.ITimestamp} message Timestamp message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              Timestamp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              /**
               * Decodes a Timestamp message from the specified reader or buffer.
               * @function decode
               * @memberof google.protobuf.Timestamp
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {google.protobuf.Timestamp} Timestamp
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              Timestamp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length,
                    message = new $root.google.protobuf.Timestamp();

                while (reader.pos < end) {
                  var tag = reader.uint32();

                  switch (tag >>> 3) {
                    case 1:
                      message.seconds = reader.int64();
                      break;

                    case 2:
                      message.nanos = reader.int32();
                      break;

                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }

                return message;
              };
              /**
               * Decodes a Timestamp message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof google.protobuf.Timestamp
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {google.protobuf.Timestamp} Timestamp
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              Timestamp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader)) reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              /**
               * Verifies a Timestamp message.
               * @function verify
               * @memberof google.protobuf.Timestamp
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */


              Timestamp.verify = function verify(message) {
                if (typeof message !== "object" || message === null) return "object expected";
                if (message.seconds != null && message.hasOwnProperty("seconds")) if (!$util.isInteger(message.seconds) && !(message.seconds && $util.isInteger(message.seconds.low) && $util.isInteger(message.seconds.high))) return "seconds: integer|Long expected";
                if (message.nanos != null && message.hasOwnProperty("nanos")) if (!$util.isInteger(message.nanos)) return "nanos: integer expected";
                return null;
              };
              /**
               * Creates a Timestamp message from a plain object. Also converts values to their respective internal types.
               * @function fromObject
               * @memberof google.protobuf.Timestamp
               * @static
               * @param {Object.<string,*>} object Plain object
               * @returns {google.protobuf.Timestamp} Timestamp
               */


              Timestamp.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Timestamp) return object;
                var message = new $root.google.protobuf.Timestamp();
                if (object.seconds != null) if ($util.Long) (message.seconds = $util.Long.fromValue(object.seconds)).unsigned = false;else if (typeof object.seconds === "string") message.seconds = parseInt(object.seconds, 10);else if (typeof object.seconds === "number") message.seconds = object.seconds;else if (typeof object.seconds === "object") message.seconds = new $util.LongBits(object.seconds.low >>> 0, object.seconds.high >>> 0).toNumber();
                if (object.nanos != null) message.nanos = object.nanos | 0;
                return message;
              };
              /**
               * Creates a plain object from a Timestamp message. Also converts values to other types if specified.
               * @function toObject
               * @memberof google.protobuf.Timestamp
               * @static
               * @param {google.protobuf.Timestamp} message Timestamp
               * @param {$protobuf.IConversionOptions} [options] Conversion options
               * @returns {Object.<string,*>} Plain object
               */


              Timestamp.toObject = function toObject(message, options) {
                if (!options) options = {};
                var object = {};

                if (options.defaults) {
                  if ($util.Long) {
                    var _long = new $util.Long(0, 0, false);

                    object.seconds = options.longs === String ? _long.toString() : options.longs === Number ? _long.toNumber() : _long;
                  } else object.seconds = options.longs === String ? "0" : 0;

                  object.nanos = 0;
                }

                if (message.seconds != null && message.hasOwnProperty("seconds")) if (typeof message.seconds === "number") object.seconds = options.longs === String ? String(message.seconds) : message.seconds;else object.seconds = options.longs === String ? $util.Long.prototype.toString.call(message.seconds) : options.longs === Number ? new $util.LongBits(message.seconds.low >>> 0, message.seconds.high >>> 0).toNumber() : message.seconds;
                if (message.nanos != null && message.hasOwnProperty("nanos")) object.nanos = message.nanos;
                return object;
              };
              /**
               * Converts this Timestamp to JSON.
               * @function toJSON
               * @memberof google.protobuf.Timestamp
               * @instance
               * @returns {Object.<string,*>} JSON object
               */


              Timestamp.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              };

              return Timestamp;
            }();

            return protobuf;
          }();

          return google;
        }();

        module.exports = $root; // #endregion ORIGINAL CODE

        _cjsExports = exports('default', module.exports);
      }, function () {
        return {
          'protobufjs/minimal': __cjsMetaURL$1
        };
      });
    }
  };
});

System.register("chunks:///_virtual/debrisproto.mjs_cjs=&original=.js", ['./debrisproto.js', './cjs-loader.mjs'], function (exports, module) {
  'use strict';

  var __cjsMetaURL, loader;

  return {
    setters: [function (module) {
      __cjsMetaURL = module.__cjsMetaURL;
      var _setter = {};
      _setter.__cjsMetaURL = module.__cjsMetaURL;
      _setter.default = module.default;
      exports(_setter);
    }, function (module) {
      loader = module.default;
    }],
    execute: function () {
      // I am the facade module who provides access to the CommonJS module './debrisproto.js'~
      if (!__cjsMetaURL) {
        loader.throwInvalidWrapper('./debrisproto.js', module.meta.url);
      }

      loader.require(__cjsMetaURL);
    }
  };
});

System.register("chunks:///_virtual/decoder.js", ['./cjs-loader.mjs', './enum.js', './types.js', './util.js'], function (exports, module) {
  'use strict';

  var loader, __cjsMetaURL$1, __cjsMetaURL$2, __cjsMetaURL$3;

  return {
    setters: [function (module) {
      loader = module.default;
    }, function (module) {
      __cjsMetaURL$1 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$2 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$3 = module.__cjsMetaURL;
    }],
    execute: function () {
      var __cjsMetaURL = exports('__cjsMetaURL', module.meta.url);

      loader.define(__cjsMetaURL, function (exports, require, module, __filename, __dirname) {
        module.exports = decoder;

        var Enum = require("./enum"),
            types = require("./types"),
            util = require("./util");

        function missing(field) {
          return "missing required '" + field.name + "'";
        }
        /**
         * Generates a decoder specific to the specified message type.
         * @param {Type} mtype Message type
         * @returns {Codegen} Codegen instance
         */


        function decoder(mtype) {
          /* eslint-disable no-unexpected-multiline */
          var gen = util.codegen(["r", "l"], mtype.name + "$decode")("if(!(r instanceof Reader))")("r=Reader.create(r)")("var c=l===undefined?r.len:r.pos+l,m=new this.ctor" + (mtype.fieldsArray.filter(function (field) {
            return field.map;
          }).length ? ",k,value" : ""))("while(r.pos<c){")("var t=r.uint32()");
          if (mtype.group) gen("if((t&7)===4)")("break");
          gen("switch(t>>>3){");
          var i = 0;

          for (; i <
          /* initializes */
          mtype.fieldsArray.length; ++i) {
            var field = mtype._fieldsArray[i].resolve(),
                type = field.resolvedType instanceof Enum ? "int32" : field.type,
                ref = "m" + util.safeProp(field.name);

            gen("case %i:", field.id); // Map fields

            if (field.map) {
              gen("if(%s===util.emptyObject)", ref)("%s={}", ref)("var c2 = r.uint32()+r.pos");
              if (types.defaults[field.keyType] !== undefined) gen("k=%j", types.defaults[field.keyType]);else gen("k=null");
              if (types.defaults[type] !== undefined) gen("value=%j", types.defaults[type]);else gen("value=null");
              gen("while(r.pos<c2){")("var tag2=r.uint32()")("switch(tag2>>>3){")("case 1: k=r.%s(); break", field.keyType)("case 2:");
              if (types.basic[type] === undefined) gen("value=types[%i].decode(r,r.uint32())", i); // can't be groups
              else gen("value=r.%s()", type);
              gen("break")("default:")("r.skipType(tag2&7)")("break")("}")("}");
              if (types["long"][field.keyType] !== undefined) gen("%s[typeof k===\"object\"?util.longToHash(k):k]=value", ref);else gen("%s[k]=value", ref); // Repeated fields
            } else if (field.repeated) {
              gen("if(!(%s&&%s.length))", ref, ref)("%s=[]", ref); // Packable (always check for forward and backward compatiblity)

              if (types.packed[type] !== undefined) gen("if((t&7)===2){")("var c2=r.uint32()+r.pos")("while(r.pos<c2)")("%s.push(r.%s())", ref, type)("}else"); // Non-packed

              if (types.basic[type] === undefined) gen(field.resolvedType.group ? "%s.push(types[%i].decode(r))" : "%s.push(types[%i].decode(r,r.uint32()))", ref, i);else gen("%s.push(r.%s())", ref, type); // Non-repeated
            } else if (types.basic[type] === undefined) gen(field.resolvedType.group ? "%s=types[%i].decode(r)" : "%s=types[%i].decode(r,r.uint32())", ref, i);else gen("%s=r.%s()", ref, type);

            gen("break"); // Unknown fields
          }

          gen("default:")("r.skipType(t&7)")("break")("}")("}"); // Field presence

          for (i = 0; i < mtype._fieldsArray.length; ++i) {
            var rfield = mtype._fieldsArray[i];
            if (rfield.required) gen("if(!m.hasOwnProperty(%j))", rfield.name)("throw util.ProtocolError(%j,{instance:m})", missing(rfield));
          }

          return gen("return m");
          /* eslint-enable no-unexpected-multiline */
        } // #endregion ORIGINAL CODE


        module.exports;
      }, function () {
        return {
          './enum': __cjsMetaURL$1,
          './types': __cjsMetaURL$2,
          './util': __cjsMetaURL$3
        };
      });
    }
  };
});

System.register("chunks:///_virtual/encoder.js", ['./cjs-loader.mjs', './enum.js', './types.js', './util.js'], function (exports, module) {
  'use strict';

  var loader, __cjsMetaURL$1, __cjsMetaURL$2, __cjsMetaURL$3;

  return {
    setters: [function (module) {
      loader = module.default;
    }, function (module) {
      __cjsMetaURL$1 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$2 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$3 = module.__cjsMetaURL;
    }],
    execute: function () {
      var __cjsMetaURL = exports('__cjsMetaURL', module.meta.url);

      loader.define(__cjsMetaURL, function (exports, require, module, __filename, __dirname) {
        module.exports = encoder;

        var Enum = require("./enum"),
            types = require("./types"),
            util = require("./util");
        /**
         * Generates a partial message type encoder.
         * @param {Codegen} gen Codegen instance
         * @param {Field} field Reflected field
         * @param {number} fieldIndex Field index
         * @param {string} ref Variable reference
         * @returns {Codegen} Codegen instance
         * @ignore
         */


        function genTypePartial(gen, field, fieldIndex, ref) {
          return field.resolvedType.group ? gen("types[%i].encode(%s,w.uint32(%i)).uint32(%i)", fieldIndex, ref, (field.id << 3 | 3) >>> 0, (field.id << 3 | 4) >>> 0) : gen("types[%i].encode(%s,w.uint32(%i).fork()).ldelim()", fieldIndex, ref, (field.id << 3 | 2) >>> 0);
        }
        /**
         * Generates an encoder specific to the specified message type.
         * @param {Type} mtype Message type
         * @returns {Codegen} Codegen instance
         */


        function encoder(mtype) {
          /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
          var gen = util.codegen(["m", "w"], mtype.name + "$encode")("if(!w)")("w=Writer.create()");
          var i, ref; // "when a message is serialized its known fields should be written sequentially by field number"

          var fields =
          /* initializes */
          mtype.fieldsArray.slice().sort(util.compareFieldsById);

          for (var i = 0; i < fields.length; ++i) {
            var field = fields[i].resolve(),
                index = mtype._fieldsArray.indexOf(field),
                type = field.resolvedType instanceof Enum ? "int32" : field.type,
                wireType = types.basic[type];

            ref = "m" + util.safeProp(field.name); // Map fields

            if (field.map) {
              gen("if(%s!=null&&Object.hasOwnProperty.call(m,%j)){", ref, field.name) // !== undefined && !== null
              ("for(var ks=Object.keys(%s),i=0;i<ks.length;++i){", ref)("w.uint32(%i).fork().uint32(%i).%s(ks[i])", (field.id << 3 | 2) >>> 0, 8 | types.mapKey[field.keyType], field.keyType);
              if (wireType === undefined) gen("types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()", index, ref); // can't be groups
              else gen(".uint32(%i).%s(%s[ks[i]]).ldelim()", 16 | wireType, type, ref);
              gen("}")("}"); // Repeated fields
            } else if (field.repeated) {
              gen("if(%s!=null&&%s.length){", ref, ref); // !== undefined && !== null
              // Packed repeated

              if (field.packed && types.packed[type] !== undefined) {
                gen("w.uint32(%i).fork()", (field.id << 3 | 2) >>> 0)("for(var i=0;i<%s.length;++i)", ref)("w.%s(%s[i])", type, ref)("w.ldelim()"); // Non-packed
              } else {
                gen("for(var i=0;i<%s.length;++i)", ref);
                if (wireType === undefined) genTypePartial(gen, field, index, ref + "[i]");else gen("w.uint32(%i).%s(%s[i])", (field.id << 3 | wireType) >>> 0, type, ref);
              }

              gen("}"); // Non-repeated
            } else {
              if (field.optional) gen("if(%s!=null&&Object.hasOwnProperty.call(m,%j))", ref, field.name); // !== undefined && !== null

              if (wireType === undefined) genTypePartial(gen, field, index, ref);else gen("w.uint32(%i).%s(%s)", (field.id << 3 | wireType) >>> 0, type, ref);
            }
          }

          return gen("return w");
          /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
        } // #endregion ORIGINAL CODE


        module.exports;
      }, function () {
        return {
          './enum': __cjsMetaURL$1,
          './types': __cjsMetaURL$2,
          './util': __cjsMetaURL$3
        };
      });
    }
  };
});

System.register("chunks:///_virtual/enum.js", ['./cjs-loader.mjs', './object.js', './namespace.js', './util.js'], function (exports, module) {
  'use strict';

  var loader, __cjsMetaURL$1, __cjsMetaURL$2, __cjsMetaURL$3;

  return {
    setters: [function (module) {
      loader = module.default;
    }, function (module) {
      __cjsMetaURL$1 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$2 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$3 = module.__cjsMetaURL;
    }],
    execute: function () {
      var __cjsMetaURL = exports('__cjsMetaURL', module.meta.url);

      loader.define(__cjsMetaURL, function (exports, require, module, __filename, __dirname) {
        module.exports = Enum; // extends ReflectionObject

        var ReflectionObject = require("./object");

        ((Enum.prototype = Object.create(ReflectionObject.prototype)).constructor = Enum).className = "Enum";

        var Namespace = require("./namespace"),
            util = require("./util");
        /**
         * Constructs a new enum instance.
         * @classdesc Reflected enum.
         * @extends ReflectionObject
         * @constructor
         * @param {string} name Unique name within its namespace
         * @param {Object.<string,number>} [values] Enum values as an object, by name
         * @param {Object.<string,*>} [options] Declared options
         * @param {string} [comment] The comment for this enum
         * @param {Object.<string,string>} [comments] The value comments for this enum
         */


        function Enum(name, values, options, comment, comments) {
          ReflectionObject.call(this, name, options);
          if (values && typeof values !== "object") throw TypeError("values must be an object");
          /**
           * Enum values by id.
           * @type {Object.<number,string>}
           */

          this.valuesById = {};
          /**
           * Enum values by name.
           * @type {Object.<string,number>}
           */

          this.values = Object.create(this.valuesById); // toJSON, marker

          /**
           * Enum comment text.
           * @type {string|null}
           */

          this.comment = comment;
          /**
           * Value comment texts, if any.
           * @type {Object.<string,string>}
           */

          this.comments = comments || {};
          /**
           * Reserved ranges, if any.
           * @type {Array.<number[]|string>}
           */

          this.reserved = undefined; // toJSON
          // Note that values inherit valuesById on their prototype which makes them a TypeScript-
          // compatible enum. This is used by pbts to write actual enum definitions that work for
          // static and reflection code alike instead of emitting generic object definitions.

          if (values) for (var keys = Object.keys(values), i = 0; i < keys.length; ++i) {
            if (typeof values[keys[i]] === "number") // use forward entries only
              this.valuesById[this.values[keys[i]] = values[keys[i]]] = keys[i];
          }
        }
        /**
         * Enum descriptor.
         * @interface IEnum
         * @property {Object.<string,number>} values Enum values
         * @property {Object.<string,*>} [options] Enum options
         */

        /**
         * Constructs an enum from an enum descriptor.
         * @param {string} name Enum name
         * @param {IEnum} json Enum descriptor
         * @returns {Enum} Created enum
         * @throws {TypeError} If arguments are invalid
         */


        Enum.fromJSON = function fromJSON(name, json) {
          var enm = new Enum(name, json.values, json.options, json.comment, json.comments);
          enm.reserved = json.reserved;
          return enm;
        };
        /**
         * Converts this enum to an enum descriptor.
         * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
         * @returns {IEnum} Enum descriptor
         */


        Enum.prototype.toJSON = function toJSON(toJSONOptions) {
          var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
          return util.toObject(["options", this.options, "values", this.values, "reserved", this.reserved && this.reserved.length ? this.reserved : undefined, "comment", keepComments ? this.comment : undefined, "comments", keepComments ? this.comments : undefined]);
        };
        /**
         * Adds a value to this enum.
         * @param {string} name Value name
         * @param {number} id Value id
         * @param {string} [comment] Comment, if any
         * @returns {Enum} `this`
         * @throws {TypeError} If arguments are invalid
         * @throws {Error} If there is already a value with this name or id
         */


        Enum.prototype.add = function add(name, id, comment) {
          // utilized by the parser but not by .fromJSON
          if (!util.isString(name)) throw TypeError("name must be a string");
          if (!util.isInteger(id)) throw TypeError("id must be an integer");
          if (this.values[name] !== undefined) throw Error("duplicate name '" + name + "' in " + this);
          if (this.isReservedId(id)) throw Error("id " + id + " is reserved in " + this);
          if (this.isReservedName(name)) throw Error("name '" + name + "' is reserved in " + this);

          if (this.valuesById[id] !== undefined) {
            if (!(this.options && this.options.allow_alias)) throw Error("duplicate id " + id + " in " + this);
            this.values[name] = id;
          } else this.valuesById[this.values[name] = id] = name;

          this.comments[name] = comment || null;
          return this;
        };
        /**
         * Removes a value from this enum
         * @param {string} name Value name
         * @returns {Enum} `this`
         * @throws {TypeError} If arguments are invalid
         * @throws {Error} If `name` is not a name of this enum
         */


        Enum.prototype.remove = function remove(name) {
          if (!util.isString(name)) throw TypeError("name must be a string");
          var val = this.values[name];
          if (val == null) throw Error("name '" + name + "' does not exist in " + this);
          delete this.valuesById[val];
          delete this.values[name];
          delete this.comments[name];
          return this;
        };
        /**
         * Tests if the specified id is reserved.
         * @param {number} id Id to test
         * @returns {boolean} `true` if reserved, otherwise `false`
         */


        Enum.prototype.isReservedId = function isReservedId(id) {
          return Namespace.isReservedId(this.reserved, id);
        };
        /**
         * Tests if the specified name is reserved.
         * @param {string} name Name to test
         * @returns {boolean} `true` if reserved, otherwise `false`
         */


        Enum.prototype.isReservedName = function isReservedName(name) {
          return Namespace.isReservedName(this.reserved, name);
        }; // #endregion ORIGINAL CODE


        module.exports;
      }, function () {
        return {
          './object': __cjsMetaURL$1,
          './namespace': __cjsMetaURL$2,
          './util': __cjsMetaURL$3
        };
      });
    }
  };
});

System.register("chunks:///_virtual/env", [], function (exports) {
  'use strict';

  return {
    execute: function () {
      var EDITOR = exports('EDITOR', false);
      var PREVIEW = exports('PREVIEW', false);
    }
  };
});

System.register("chunks:///_virtual/field.js", ['./cjs-loader.mjs', './object.js', './enum.js', './types.js', './util.js'], function (exports, module) {
  'use strict';

  var loader, __cjsMetaURL$1, __cjsMetaURL$2, __cjsMetaURL$3, __cjsMetaURL$4;

  return {
    setters: [function (module) {
      loader = module.default;
    }, function (module) {
      __cjsMetaURL$1 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$2 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$3 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$4 = module.__cjsMetaURL;
    }],
    execute: function () {
      var __cjsMetaURL = exports('__cjsMetaURL', module.meta.url);

      loader.define(__cjsMetaURL, function (exports, require, module, __filename, __dirname) {
        module.exports = Field; // extends ReflectionObject

        var ReflectionObject = require("./object");

        ((Field.prototype = Object.create(ReflectionObject.prototype)).constructor = Field).className = "Field";

        var Enum = require("./enum"),
            types = require("./types"),
            util = require("./util");

        var Type; // cyclic

        var ruleRe = /^required|optional|repeated$/;
        /**
         * Constructs a new message field instance. Note that {@link MapField|map fields} have their own class.
         * @name Field
         * @classdesc Reflected message field.
         * @extends FieldBase
         * @constructor
         * @param {string} name Unique name within its namespace
         * @param {number} id Unique id within its namespace
         * @param {string} type Value type
         * @param {string|Object.<string,*>} [rule="optional"] Field rule
         * @param {string|Object.<string,*>} [extend] Extended type if different from parent
         * @param {Object.<string,*>} [options] Declared options
         */

        /**
         * Constructs a field from a field descriptor.
         * @param {string} name Field name
         * @param {IField} json Field descriptor
         * @returns {Field} Created field
         * @throws {TypeError} If arguments are invalid
         */

        Field.fromJSON = function fromJSON(name, json) {
          return new Field(name, json.id, json.type, json.rule, json.extend, json.options, json.comment);
        };
        /**
         * Not an actual constructor. Use {@link Field} instead.
         * @classdesc Base class of all reflected message fields. This is not an actual class but here for the sake of having consistent type definitions.
         * @exports FieldBase
         * @extends ReflectionObject
         * @constructor
         * @param {string} name Unique name within its namespace
         * @param {number} id Unique id within its namespace
         * @param {string} type Value type
         * @param {string|Object.<string,*>} [rule="optional"] Field rule
         * @param {string|Object.<string,*>} [extend] Extended type if different from parent
         * @param {Object.<string,*>} [options] Declared options
         * @param {string} [comment] Comment associated with this field
         */


        function Field(name, id, type, rule, extend, options, comment) {
          if (util.isObject(rule)) {
            comment = extend;
            options = rule;
            rule = extend = undefined;
          } else if (util.isObject(extend)) {
            comment = options;
            options = extend;
            extend = undefined;
          }

          ReflectionObject.call(this, name, options);
          if (!util.isInteger(id) || id < 0) throw TypeError("id must be a non-negative integer");
          if (!util.isString(type)) throw TypeError("type must be a string");
          if (rule !== undefined && !ruleRe.test(rule = rule.toString().toLowerCase())) throw TypeError("rule must be a string rule");
          if (extend !== undefined && !util.isString(extend)) throw TypeError("extend must be a string");

          if (rule === "proto3_optional") {
            rule = "optional";
          }
          /**
           * Field rule, if any.
           * @type {string|undefined}
           */


          this.rule = rule && rule !== "optional" ? rule : undefined; // toJSON

          /**
           * Field type.
           * @type {string}
           */

          this.type = type; // toJSON

          /**
           * Unique field id.
           * @type {number}
           */

          this.id = id; // toJSON, marker

          /**
           * Extended type if different from parent.
           * @type {string|undefined}
           */

          this.extend = extend || undefined; // toJSON

          /**
           * Whether this field is required.
           * @type {boolean}
           */

          this.required = rule === "required";
          /**
           * Whether this field is optional.
           * @type {boolean}
           */

          this.optional = !this.required;
          /**
           * Whether this field is repeated.
           * @type {boolean}
           */

          this.repeated = rule === "repeated";
          /**
           * Whether this field is a map or not.
           * @type {boolean}
           */

          this.map = false;
          /**
           * Message this field belongs to.
           * @type {Type|null}
           */

          this.message = null;
          /**
           * OneOf this field belongs to, if any,
           * @type {OneOf|null}
           */

          this.partOf = null;
          /**
           * The field type's default value.
           * @type {*}
           */

          this.typeDefault = null;
          /**
           * The field's default value on prototypes.
           * @type {*}
           */

          this.defaultValue = null;
          /**
           * Whether this field's value should be treated as a long.
           * @type {boolean}
           */

          this["long"] = util.Long ? types["long"][type] !== undefined :
          /* istanbul ignore next */
          false;
          /**
           * Whether this field's value is a buffer.
           * @type {boolean}
           */

          this.bytes = type === "bytes";
          /**
           * Resolved type if not a basic type.
           * @type {Type|Enum|null}
           */

          this.resolvedType = null;
          /**
           * Sister-field within the extended type if a declaring extension field.
           * @type {Field|null}
           */

          this.extensionField = null;
          /**
           * Sister-field within the declaring namespace if an extended field.
           * @type {Field|null}
           */

          this.declaringField = null;
          /**
           * Internally remembers whether this field is packed.
           * @type {boolean|null}
           * @private
           */

          this._packed = null;
          /**
           * Comment for this field.
           * @type {string|null}
           */

          this.comment = comment;
        }
        /**
         * Determines whether this field is packed. Only relevant when repeated and working with proto2.
         * @name Field#packed
         * @type {boolean}
         * @readonly
         */


        Object.defineProperty(Field.prototype, "packed", {
          get: function get() {
            // defaults to packed=true if not explicity set to false
            if (this._packed === null) this._packed = this.getOption("packed") !== false;
            return this._packed;
          }
        });
        /**
         * @override
         */

        Field.prototype.setOption = function setOption(name, value, ifNotSet) {
          if (name === "packed") // clear cached before setting
            this._packed = null;
          return ReflectionObject.prototype.setOption.call(this, name, value, ifNotSet);
        };
        /**
         * Field descriptor.
         * @interface IField
         * @property {string} [rule="optional"] Field rule
         * @property {string} type Field type
         * @property {number} id Field id
         * @property {Object.<string,*>} [options] Field options
         */

        /**
         * Extension field descriptor.
         * @interface IExtensionField
         * @extends IField
         * @property {string} extend Extended type
         */

        /**
         * Converts this field to a field descriptor.
         * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
         * @returns {IField} Field descriptor
         */


        Field.prototype.toJSON = function toJSON(toJSONOptions) {
          var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
          return util.toObject(["rule", this.rule !== "optional" && this.rule || undefined, "type", this.type, "id", this.id, "extend", this.extend, "options", this.options, "comment", keepComments ? this.comment : undefined]);
        };
        /**
         * Resolves this field's type references.
         * @returns {Field} `this`
         * @throws {Error} If any reference cannot be resolved
         */


        Field.prototype.resolve = function resolve() {
          if (this.resolved) return this;

          if ((this.typeDefault = types.defaults[this.type]) === undefined) {
            // if not a basic type, resolve it
            this.resolvedType = (this.declaringField ? this.declaringField.parent : this.parent).lookupTypeOrEnum(this.type);
            if (this.resolvedType instanceof Type) this.typeDefault = null;else // instanceof Enum
              this.typeDefault = this.resolvedType.values[Object.keys(this.resolvedType.values)[0]]; // first defined
          } // use explicitly set default value if present


          if (this.options && this.options["default"] != null) {
            this.typeDefault = this.options["default"];
            if (this.resolvedType instanceof Enum && typeof this.typeDefault === "string") this.typeDefault = this.resolvedType.values[this.typeDefault];
          } // remove unnecessary options


          if (this.options) {
            if (this.options.packed === true || this.options.packed !== undefined && this.resolvedType && !(this.resolvedType instanceof Enum)) delete this.options.packed;
            if (!Object.keys(this.options).length) this.options = undefined;
          } // convert to internal data type if necesssary


          if (this["long"]) {
            this.typeDefault = util.Long.fromNumber(this.typeDefault, this.type.charAt(0) === "u");
            /* istanbul ignore else */

            if (Object.freeze) Object.freeze(this.typeDefault); // long instances are meant to be immutable anyway (i.e. use small int cache that even requires it)
          } else if (this.bytes && typeof this.typeDefault === "string") {
            var buf;
            if (util.base64.test(this.typeDefault)) util.base64.decode(this.typeDefault, buf = util.newBuffer(util.base64.length(this.typeDefault)), 0);else util.utf8.write(this.typeDefault, buf = util.newBuffer(util.utf8.length(this.typeDefault)), 0);
            this.typeDefault = buf;
          } // take special care of maps and repeated fields


          if (this.map) this.defaultValue = util.emptyObject;else if (this.repeated) this.defaultValue = util.emptyArray;else this.defaultValue = this.typeDefault; // ensure proper value on prototype

          if (this.parent instanceof Type) this.parent.ctor.prototype[this.name] = this.defaultValue;
          return ReflectionObject.prototype.resolve.call(this);
        };
        /**
         * Decorator function as returned by {@link Field.d} and {@link MapField.d} (TypeScript).
         * @typedef FieldDecorator
         * @type {function}
         * @param {Object} prototype Target prototype
         * @param {string} fieldName Field name
         * @returns {undefined}
         */

        /**
         * Field decorator (TypeScript).
         * @name Field.d
         * @function
         * @param {number} fieldId Field id
         * @param {"double"|"float"|"int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"string"|"bool"|"bytes"|Object} fieldType Field type
         * @param {"optional"|"required"|"repeated"} [fieldRule="optional"] Field rule
         * @param {T} [defaultValue] Default value
         * @returns {FieldDecorator} Decorator function
         * @template T extends number | number[] | Long | Long[] | string | string[] | boolean | boolean[] | Uint8Array | Uint8Array[] | Buffer | Buffer[]
         */


        Field.d = function decorateField(fieldId, fieldType, fieldRule, defaultValue) {
          // submessage: decorate the submessage and use its name as the type
          if (typeof fieldType === "function") fieldType = util.decorateType(fieldType).name; // enum reference: create a reflected copy of the enum and keep reuseing it
          else if (fieldType && typeof fieldType === "object") fieldType = util.decorateEnum(fieldType).name;
          return function fieldDecorator(prototype, fieldName) {
            util.decorateType(prototype.constructor).add(new Field(fieldName, fieldId, fieldType, fieldRule, {
              "default": defaultValue
            }));
          };
        };
        /**
         * Field decorator (TypeScript).
         * @name Field.d
         * @function
         * @param {number} fieldId Field id
         * @param {Constructor<T>|string} fieldType Field type
         * @param {"optional"|"required"|"repeated"} [fieldRule="optional"] Field rule
         * @returns {FieldDecorator} Decorator function
         * @template T extends Message<T>
         * @variation 2
         */
        // like Field.d but without a default value
        // Sets up cyclic dependencies (called in index-light)


        Field._configure = function configure(Type_) {
          Type = Type_;
        }; // #endregion ORIGINAL CODE


        module.exports;
      }, function () {
        return {
          './object': __cjsMetaURL$1,
          './enum': __cjsMetaURL$2,
          './types': __cjsMetaURL$3,
          './util': __cjsMetaURL$4
        };
      });
    }
  };
});

System.register("chunks:///_virtual/gaiaProto.js", ['./cjs-loader.mjs', './minimal.js'], function (exports, module) {
  'use strict';

  var loader, __cjsMetaURL$1;

  return {
    setters: [function (module) {
      loader = module.default;
    }, function (module) {
      __cjsMetaURL$1 = module.__cjsMetaURL;
    }],
    execute: function () {
      exports('default', void 0);

      var _cjsExports;

      var __cjsMetaURL = exports('__cjsMetaURL', module.meta.url);

      loader.define(__cjsMetaURL, function (exports$1, require, module, __filename, __dirname) {
        // #region ORIGINAL CODE
        var $protobuf = require("protobufjs/minimal"); // Common aliases


        var $Reader = $protobuf.Reader,
            $Writer = $protobuf.Writer,
            $util = $protobuf.util; // Exported root namespace

        var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

        $root.gaiaProto = function () {
          /**
          * Namespace gaiaProto.
          * @exports gaiaProto
          * @namespace
          */
          var gaiaProto = {};

          gaiaProto.GaiaResponse = function () {
            /**
            * Properties of a GaiaResponse.
            * @memberof gaiaProto
            * @interface IGaiaResponse
            * @property {number|null} [type] GaiaResponse type
            * @property {number|null} [ret] GaiaResponse ret
            * @property {string|null} [token] GaiaResponse token
            * @property {string|null} [msg] GaiaResponse msg
            * @property {Uint8Array|null} [data] GaiaResponse data
            */

            /**
            * Constructs a new GaiaResponse.
            * @memberof gaiaProto
            * @classdesc Represents a GaiaResponse.
            * @implements IGaiaResponse
            * @constructor
            * @param {gaiaProto.IGaiaResponse=} [properties] Properties to set
            */
            function GaiaResponse(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * GaiaResponse type.
            * @member {number} type
            * @memberof gaiaProto.GaiaResponse
            * @instance
            */


            GaiaResponse.prototype.type = 0;
            /**
            * GaiaResponse ret.
            * @member {number} ret
            * @memberof gaiaProto.GaiaResponse
            * @instance
            */

            GaiaResponse.prototype.ret = 0;
            /**
            * GaiaResponse token.
            * @member {string} token
            * @memberof gaiaProto.GaiaResponse
            * @instance
            */

            GaiaResponse.prototype.token = "";
            /**
            * GaiaResponse msg.
            * @member {string} msg
            * @memberof gaiaProto.GaiaResponse
            * @instance
            */

            GaiaResponse.prototype.msg = "";
            /**
            * GaiaResponse data.
            * @member {Uint8Array} data
            * @memberof gaiaProto.GaiaResponse
            * @instance
            */

            GaiaResponse.prototype.data = $util.newBuffer([]);
            /**
            * Creates a new GaiaResponse instance using the specified properties.
            * @function create
            * @memberof gaiaProto.GaiaResponse
            * @static
            * @param {gaiaProto.IGaiaResponse=} [properties] Properties to set
            * @returns {gaiaProto.GaiaResponse} GaiaResponse instance
            */

            GaiaResponse.create = function create(properties) {
              return new GaiaResponse(properties);
            };
            /**
            * Encodes the specified GaiaResponse message. Does not implicitly {@link gaiaProto.GaiaResponse.verify|verify} messages.
            * @function encode
            * @memberof gaiaProto.GaiaResponse
            * @static
            * @param {gaiaProto.IGaiaResponse} message GaiaResponse message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            GaiaResponse.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.type != null && Object.hasOwnProperty.call(message, "type")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.type);
              if (message.ret != null && Object.hasOwnProperty.call(message, "ret")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int32(message.ret);
              if (message.token != null && Object.hasOwnProperty.call(message, "token")) writer.uint32(
              /* id 3, wireType 2 =*/
              26).string(message.token);
              if (message.msg != null && Object.hasOwnProperty.call(message, "msg")) writer.uint32(
              /* id 4, wireType 2 =*/
              34).string(message.msg);
              if (message.data != null && Object.hasOwnProperty.call(message, "data")) writer.uint32(
              /* id 5, wireType 2 =*/
              42).bytes(message.data);
              return writer;
            };
            /**
            * Encodes the specified GaiaResponse message, length delimited. Does not implicitly {@link gaiaProto.GaiaResponse.verify|verify} messages.
            * @function encodeDelimited
            * @memberof gaiaProto.GaiaResponse
            * @static
            * @param {gaiaProto.IGaiaResponse} message GaiaResponse message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            GaiaResponse.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a GaiaResponse message from the specified reader or buffer.
            * @function decode
            * @memberof gaiaProto.GaiaResponse
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {gaiaProto.GaiaResponse} GaiaResponse
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            GaiaResponse.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gaiaProto.GaiaResponse();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.type = reader.int32();
                    break;

                  case 2:
                    message.ret = reader.int32();
                    break;

                  case 3:
                    message.token = reader.string();
                    break;

                  case 4:
                    message.msg = reader.string();
                    break;

                  case 5:
                    message.data = reader.bytes();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a GaiaResponse message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof gaiaProto.GaiaResponse
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {gaiaProto.GaiaResponse} GaiaResponse
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            GaiaResponse.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a GaiaResponse message.
            * @function verify
            * @memberof gaiaProto.GaiaResponse
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            GaiaResponse.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.type != null && message.hasOwnProperty("type")) if (!$util.isInteger(message.type)) return "type: integer expected";
              if (message.ret != null && message.hasOwnProperty("ret")) if (!$util.isInteger(message.ret)) return "ret: integer expected";
              if (message.token != null && message.hasOwnProperty("token")) if (!$util.isString(message.token)) return "token: string expected";
              if (message.msg != null && message.hasOwnProperty("msg")) if (!$util.isString(message.msg)) return "msg: string expected";
              if (message.data != null && message.hasOwnProperty("data")) if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data))) return "data: buffer expected";
              return null;
            };
            /**
            * Creates a GaiaResponse message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof gaiaProto.GaiaResponse
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {gaiaProto.GaiaResponse} GaiaResponse
            */


            GaiaResponse.fromObject = function fromObject(object) {
              if (object instanceof $root.gaiaProto.GaiaResponse) return object;
              var message = new $root.gaiaProto.GaiaResponse();
              if (object.type != null) message.type = object.type | 0;
              if (object.ret != null) message.ret = object.ret | 0;
              if (object.token != null) message.token = String(object.token);
              if (object.msg != null) message.msg = String(object.msg);
              if (object.data != null) if (typeof object.data === "string") $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);else if (object.data.length) message.data = object.data;
              return message;
            };
            /**
            * Creates a plain object from a GaiaResponse message. Also converts values to other types if specified.
            * @function toObject
            * @memberof gaiaProto.GaiaResponse
            * @static
            * @param {gaiaProto.GaiaResponse} message GaiaResponse
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            GaiaResponse.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.type = 0;
                object.ret = 0;
                object.token = "";
                object.msg = "";
                if (options.bytes === String) object.data = "";else {
                  object.data = [];
                  if (options.bytes !== Array) object.data = $util.newBuffer(object.data);
                }
              }

              if (message.type != null && message.hasOwnProperty("type")) object.type = message.type;
              if (message.ret != null && message.hasOwnProperty("ret")) object.ret = message.ret;
              if (message.token != null && message.hasOwnProperty("token")) object.token = message.token;
              if (message.msg != null && message.hasOwnProperty("msg")) object.msg = message.msg;
              if (message.data != null && message.hasOwnProperty("data")) object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
              return object;
            };
            /**
            * Converts this GaiaResponse to JSON.
            * @function toJSON
            * @memberof gaiaProto.GaiaResponse
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            GaiaResponse.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GaiaResponse;
          }();

          gaiaProto.Card = function () {
            /**
            * Properties of a Card.
            * @memberof gaiaProto
            * @interface ICard
            * @property {number|null} [GameID] Card GameID
            * @property {number|null} [Level] Card Level
            * @property {number|null} [CardIndex] Card CardIndex
            * @property {number|null} [Star] Card Star
            * @property {number|null} [Count] Card Count
            */

            /**
            * Constructs a new Card.
            * @memberof gaiaProto
            * @classdesc Represents a Card.
            * @implements ICard
            * @constructor
            * @param {gaiaProto.ICard=} [properties] Properties to set
            */
            function Card(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * Card GameID.
            * @member {number} GameID
            * @memberof gaiaProto.Card
            * @instance
            */


            Card.prototype.GameID = 0;
            /**
            * Card Level.
            * @member {number} Level
            * @memberof gaiaProto.Card
            * @instance
            */

            Card.prototype.Level = 0;
            /**
            * Card CardIndex.
            * @member {number} CardIndex
            * @memberof gaiaProto.Card
            * @instance
            */

            Card.prototype.CardIndex = 0;
            /**
            * Card Star.
            * @member {number} Star
            * @memberof gaiaProto.Card
            * @instance
            */

            Card.prototype.Star = 0;
            /**
            * Card Count.
            * @member {number} Count
            * @memberof gaiaProto.Card
            * @instance
            */

            Card.prototype.Count = 0;
            /**
            * Creates a new Card instance using the specified properties.
            * @function create
            * @memberof gaiaProto.Card
            * @static
            * @param {gaiaProto.ICard=} [properties] Properties to set
            * @returns {gaiaProto.Card} Card instance
            */

            Card.create = function create(properties) {
              return new Card(properties);
            };
            /**
            * Encodes the specified Card message. Does not implicitly {@link gaiaProto.Card.verify|verify} messages.
            * @function encode
            * @memberof gaiaProto.Card
            * @static
            * @param {gaiaProto.ICard} message Card message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            Card.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.GameID != null && Object.hasOwnProperty.call(message, "GameID")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.GameID);
              if (message.Level != null && Object.hasOwnProperty.call(message, "Level")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int32(message.Level);
              if (message.CardIndex != null && Object.hasOwnProperty.call(message, "CardIndex")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.CardIndex);
              if (message.Star != null && Object.hasOwnProperty.call(message, "Star")) writer.uint32(
              /* id 4, wireType 0 =*/
              32).int32(message.Star);
              if (message.Count != null && Object.hasOwnProperty.call(message, "Count")) writer.uint32(
              /* id 5, wireType 0 =*/
              40).int32(message.Count);
              return writer;
            };
            /**
            * Encodes the specified Card message, length delimited. Does not implicitly {@link gaiaProto.Card.verify|verify} messages.
            * @function encodeDelimited
            * @memberof gaiaProto.Card
            * @static
            * @param {gaiaProto.ICard} message Card message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            Card.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a Card message from the specified reader or buffer.
            * @function decode
            * @memberof gaiaProto.Card
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {gaiaProto.Card} Card
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            Card.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gaiaProto.Card();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.GameID = reader.int32();
                    break;

                  case 2:
                    message.Level = reader.int32();
                    break;

                  case 3:
                    message.CardIndex = reader.int32();
                    break;

                  case 4:
                    message.Star = reader.int32();
                    break;

                  case 5:
                    message.Count = reader.int32();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a Card message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof gaiaProto.Card
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {gaiaProto.Card} Card
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            Card.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a Card message.
            * @function verify
            * @memberof gaiaProto.Card
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            Card.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.GameID != null && message.hasOwnProperty("GameID")) if (!$util.isInteger(message.GameID)) return "GameID: integer expected";
              if (message.Level != null && message.hasOwnProperty("Level")) if (!$util.isInteger(message.Level)) return "Level: integer expected";
              if (message.CardIndex != null && message.hasOwnProperty("CardIndex")) if (!$util.isInteger(message.CardIndex)) return "CardIndex: integer expected";
              if (message.Star != null && message.hasOwnProperty("Star")) if (!$util.isInteger(message.Star)) return "Star: integer expected";
              if (message.Count != null && message.hasOwnProperty("Count")) if (!$util.isInteger(message.Count)) return "Count: integer expected";
              return null;
            };
            /**
            * Creates a Card message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof gaiaProto.Card
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {gaiaProto.Card} Card
            */


            Card.fromObject = function fromObject(object) {
              if (object instanceof $root.gaiaProto.Card) return object;
              var message = new $root.gaiaProto.Card();
              if (object.GameID != null) message.GameID = object.GameID | 0;
              if (object.Level != null) message.Level = object.Level | 0;
              if (object.CardIndex != null) message.CardIndex = object.CardIndex | 0;
              if (object.Star != null) message.Star = object.Star | 0;
              if (object.Count != null) message.Count = object.Count | 0;
              return message;
            };
            /**
            * Creates a plain object from a Card message. Also converts values to other types if specified.
            * @function toObject
            * @memberof gaiaProto.Card
            * @static
            * @param {gaiaProto.Card} message Card
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            Card.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.GameID = 0;
                object.Level = 0;
                object.CardIndex = 0;
                object.Star = 0;
                object.Count = 0;
              }

              if (message.GameID != null && message.hasOwnProperty("GameID")) object.GameID = message.GameID;
              if (message.Level != null && message.hasOwnProperty("Level")) object.Level = message.Level;
              if (message.CardIndex != null && message.hasOwnProperty("CardIndex")) object.CardIndex = message.CardIndex;
              if (message.Star != null && message.hasOwnProperty("Star")) object.Star = message.Star;
              if (message.Count != null && message.hasOwnProperty("Count")) object.Count = message.Count;
              return object;
            };
            /**
            * Converts this Card to JSON.
            * @function toJSON
            * @memberof gaiaProto.Card
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            Card.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Card;
          }();

          gaiaProto.Mission = function () {
            /**
            * Properties of a Mission.
            * @memberof gaiaProto
            * @interface IMission
            * @property {number|null} [ItemID] Mission ItemID
            * @property {number|null} [ItemCount] Mission ItemCount
            * @property {Long|null} [ExtendID] Mission ExtendID
            */

            /**
            * Constructs a new Mission.
            * @memberof gaiaProto
            * @classdesc Represents a Mission.
            * @implements IMission
            * @constructor
            * @param {gaiaProto.IMission=} [properties] Properties to set
            */
            function Mission(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * Mission ItemID.
            * @member {number} ItemID
            * @memberof gaiaProto.Mission
            * @instance
            */


            Mission.prototype.ItemID = 0;
            /**
            * Mission ItemCount.
            * @member {number} ItemCount
            * @memberof gaiaProto.Mission
            * @instance
            */

            Mission.prototype.ItemCount = 0;
            /**
            * Mission ExtendID.
            * @member {Long} ExtendID
            * @memberof gaiaProto.Mission
            * @instance
            */

            Mission.prototype.ExtendID = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
            * Creates a new Mission instance using the specified properties.
            * @function create
            * @memberof gaiaProto.Mission
            * @static
            * @param {gaiaProto.IMission=} [properties] Properties to set
            * @returns {gaiaProto.Mission} Mission instance
            */

            Mission.create = function create(properties) {
              return new Mission(properties);
            };
            /**
            * Encodes the specified Mission message. Does not implicitly {@link gaiaProto.Mission.verify|verify} messages.
            * @function encode
            * @memberof gaiaProto.Mission
            * @static
            * @param {gaiaProto.IMission} message Mission message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            Mission.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.ItemID != null && Object.hasOwnProperty.call(message, "ItemID")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).uint32(message.ItemID);
              if (message.ItemCount != null && Object.hasOwnProperty.call(message, "ItemCount")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).uint32(message.ItemCount);
              if (message.ExtendID != null && Object.hasOwnProperty.call(message, "ExtendID")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int64(message.ExtendID);
              return writer;
            };
            /**
            * Encodes the specified Mission message, length delimited. Does not implicitly {@link gaiaProto.Mission.verify|verify} messages.
            * @function encodeDelimited
            * @memberof gaiaProto.Mission
            * @static
            * @param {gaiaProto.IMission} message Mission message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            Mission.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a Mission message from the specified reader or buffer.
            * @function decode
            * @memberof gaiaProto.Mission
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {gaiaProto.Mission} Mission
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            Mission.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gaiaProto.Mission();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.ItemID = reader.uint32();
                    break;

                  case 2:
                    message.ItemCount = reader.uint32();
                    break;

                  case 3:
                    message.ExtendID = reader.int64();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a Mission message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof gaiaProto.Mission
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {gaiaProto.Mission} Mission
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            Mission.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a Mission message.
            * @function verify
            * @memberof gaiaProto.Mission
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            Mission.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.ItemID != null && message.hasOwnProperty("ItemID")) if (!$util.isInteger(message.ItemID)) return "ItemID: integer expected";
              if (message.ItemCount != null && message.hasOwnProperty("ItemCount")) if (!$util.isInteger(message.ItemCount)) return "ItemCount: integer expected";
              if (message.ExtendID != null && message.hasOwnProperty("ExtendID")) if (!$util.isInteger(message.ExtendID) && !(message.ExtendID && $util.isInteger(message.ExtendID.low) && $util.isInteger(message.ExtendID.high))) return "ExtendID: integer|Long expected";
              return null;
            };
            /**
            * Creates a Mission message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof gaiaProto.Mission
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {gaiaProto.Mission} Mission
            */


            Mission.fromObject = function fromObject(object) {
              if (object instanceof $root.gaiaProto.Mission) return object;
              var message = new $root.gaiaProto.Mission();
              if (object.ItemID != null) message.ItemID = object.ItemID >>> 0;
              if (object.ItemCount != null) message.ItemCount = object.ItemCount >>> 0;
              if (object.ExtendID != null) if ($util.Long) (message.ExtendID = $util.Long.fromValue(object.ExtendID)).unsigned = false;else if (typeof object.ExtendID === "string") message.ExtendID = parseInt(object.ExtendID, 10);else if (typeof object.ExtendID === "number") message.ExtendID = object.ExtendID;else if (typeof object.ExtendID === "object") message.ExtendID = new $util.LongBits(object.ExtendID.low >>> 0, object.ExtendID.high >>> 0).toNumber();
              return message;
            };
            /**
            * Creates a plain object from a Mission message. Also converts values to other types if specified.
            * @function toObject
            * @memberof gaiaProto.Mission
            * @static
            * @param {gaiaProto.Mission} message Mission
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            Mission.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.ItemID = 0;
                object.ItemCount = 0;

                if ($util.Long) {
                  var _long = new $util.Long(0, 0, false);

                  object.ExtendID = options.longs === String ? _long.toString() : options.longs === Number ? _long.toNumber() : _long;
                } else object.ExtendID = options.longs === String ? "0" : 0;
              }

              if (message.ItemID != null && message.hasOwnProperty("ItemID")) object.ItemID = message.ItemID;
              if (message.ItemCount != null && message.hasOwnProperty("ItemCount")) object.ItemCount = message.ItemCount;
              if (message.ExtendID != null && message.hasOwnProperty("ExtendID")) if (typeof message.ExtendID === "number") object.ExtendID = options.longs === String ? String(message.ExtendID) : message.ExtendID;else object.ExtendID = options.longs === String ? $util.Long.prototype.toString.call(message.ExtendID) : options.longs === Number ? new $util.LongBits(message.ExtendID.low >>> 0, message.ExtendID.high >>> 0).toNumber() : message.ExtendID;
              return object;
            };
            /**
            * Converts this Mission to JSON.
            * @function toJSON
            * @memberof gaiaProto.Mission
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            Mission.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Mission;
          }();

          gaiaProto.ServiceData = function () {
            /**
            * Properties of a ServiceData.
            * @memberof gaiaProto
            * @interface IServiceData
            * @property {number|null} [missionReward] ServiceData missionReward
            * @property {number|null} [jpType] ServiceData jpType
            * @property {number|null} [jpWin] ServiceData jpWin
            * @property {number|null} [fullJpWin] ServiceData fullJpWin
            * @property {number|null} [trialfinish] ServiceData trialfinish
            * @property {number|null} [trialaward] ServiceData trialaward
            * @property {number|null} [freeremain] ServiceData freeremain
            * @property {Array.<gaiaProto.ICard>|null} [cardlist] ServiceData cardlist
            * @property {number|null} [buffmul] ServiceData buffmul
            * @property {number|null} [buffmulwin] ServiceData buffmulwin
            * @property {number|null} [buffexbet] ServiceData buffexbet
            * @property {number|null} [bufffree] ServiceData bufffree
            * @property {Array.<gaiaProto.IMission>|null} [missionlist] ServiceData missionlist
            * @property {string|null} [ErrorMsg] ServiceData ErrorMsg
            */

            /**
            * Constructs a new ServiceData.
            * @memberof gaiaProto
            * @classdesc Represents a ServiceData.
            * @implements IServiceData
            * @constructor
            * @param {gaiaProto.IServiceData=} [properties] Properties to set
            */
            function ServiceData(properties) {
              this.cardlist = [];
              this.missionlist = [];
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * ServiceData missionReward.
            * @member {number} missionReward
            * @memberof gaiaProto.ServiceData
            * @instance
            */


            ServiceData.prototype.missionReward = 0;
            /**
            * ServiceData jpType.
            * @member {number} jpType
            * @memberof gaiaProto.ServiceData
            * @instance
            */

            ServiceData.prototype.jpType = 0;
            /**
            * ServiceData jpWin.
            * @member {number} jpWin
            * @memberof gaiaProto.ServiceData
            * @instance
            */

            ServiceData.prototype.jpWin = 0;
            /**
            * ServiceData fullJpWin.
            * @member {number} fullJpWin
            * @memberof gaiaProto.ServiceData
            * @instance
            */

            ServiceData.prototype.fullJpWin = 0;
            /**
            * ServiceData trialfinish.
            * @member {number} trialfinish
            * @memberof gaiaProto.ServiceData
            * @instance
            */

            ServiceData.prototype.trialfinish = 0;
            /**
            * ServiceData trialaward.
            * @member {number} trialaward
            * @memberof gaiaProto.ServiceData
            * @instance
            */

            ServiceData.prototype.trialaward = 0;
            /**
            * ServiceData freeremain.
            * @member {number} freeremain
            * @memberof gaiaProto.ServiceData
            * @instance
            */

            ServiceData.prototype.freeremain = 0;
            /**
            * ServiceData cardlist.
            * @member {Array.<gaiaProto.ICard>} cardlist
            * @memberof gaiaProto.ServiceData
            * @instance
            */

            ServiceData.prototype.cardlist = $util.emptyArray;
            /**
            * ServiceData buffmul.
            * @member {number} buffmul
            * @memberof gaiaProto.ServiceData
            * @instance
            */

            ServiceData.prototype.buffmul = 0;
            /**
            * ServiceData buffmulwin.
            * @member {number} buffmulwin
            * @memberof gaiaProto.ServiceData
            * @instance
            */

            ServiceData.prototype.buffmulwin = 0;
            /**
            * ServiceData buffexbet.
            * @member {number} buffexbet
            * @memberof gaiaProto.ServiceData
            * @instance
            */

            ServiceData.prototype.buffexbet = 0;
            /**
            * ServiceData bufffree.
            * @member {number} bufffree
            * @memberof gaiaProto.ServiceData
            * @instance
            */

            ServiceData.prototype.bufffree = 0;
            /**
            * ServiceData missionlist.
            * @member {Array.<gaiaProto.IMission>} missionlist
            * @memberof gaiaProto.ServiceData
            * @instance
            */

            ServiceData.prototype.missionlist = $util.emptyArray;
            /**
            * ServiceData ErrorMsg.
            * @member {string} ErrorMsg
            * @memberof gaiaProto.ServiceData
            * @instance
            */

            ServiceData.prototype.ErrorMsg = "";
            /**
            * Creates a new ServiceData instance using the specified properties.
            * @function create
            * @memberof gaiaProto.ServiceData
            * @static
            * @param {gaiaProto.IServiceData=} [properties] Properties to set
            * @returns {gaiaProto.ServiceData} ServiceData instance
            */

            ServiceData.create = function create(properties) {
              return new ServiceData(properties);
            };
            /**
            * Encodes the specified ServiceData message. Does not implicitly {@link gaiaProto.ServiceData.verify|verify} messages.
            * @function encode
            * @memberof gaiaProto.ServiceData
            * @static
            * @param {gaiaProto.IServiceData} message ServiceData message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            ServiceData.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.missionReward != null && Object.hasOwnProperty.call(message, "missionReward")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).uint32(message.missionReward);
              if (message.jpType != null && Object.hasOwnProperty.call(message, "jpType")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int32(message.jpType);
              if (message.jpWin != null && Object.hasOwnProperty.call(message, "jpWin")) writer.uint32(
              /* id 3, wireType 1 =*/
              25)["double"](message.jpWin);
              if (message.fullJpWin != null && Object.hasOwnProperty.call(message, "fullJpWin")) writer.uint32(
              /* id 4, wireType 1 =*/
              33)["double"](message.fullJpWin);
              if (message.trialfinish != null && Object.hasOwnProperty.call(message, "trialfinish")) writer.uint32(
              /* id 5, wireType 0 =*/
              40).int32(message.trialfinish);
              if (message.trialaward != null && Object.hasOwnProperty.call(message, "trialaward")) writer.uint32(
              /* id 6, wireType 0 =*/
              48).int32(message.trialaward);
              if (message.freeremain != null && Object.hasOwnProperty.call(message, "freeremain")) writer.uint32(
              /* id 7, wireType 0 =*/
              56).int32(message.freeremain);
              if (message.cardlist != null && message.cardlist.length) for (var i = 0; i < message.cardlist.length; ++i) {
                $root.gaiaProto.Card.encode(message.cardlist[i], writer.uint32(
                /* id 8, wireType 2 =*/
                66).fork()).ldelim();
              }
              if (message.buffmul != null && Object.hasOwnProperty.call(message, "buffmul")) writer.uint32(
              /* id 9, wireType 1 =*/
              73)["double"](message.buffmul);
              if (message.buffmulwin != null && Object.hasOwnProperty.call(message, "buffmulwin")) writer.uint32(
              /* id 10, wireType 1 =*/
              81)["double"](message.buffmulwin);
              if (message.buffexbet != null && Object.hasOwnProperty.call(message, "buffexbet")) writer.uint32(
              /* id 11, wireType 0 =*/
              88).int32(message.buffexbet);
              if (message.bufffree != null && Object.hasOwnProperty.call(message, "bufffree")) writer.uint32(
              /* id 12, wireType 0 =*/
              96).int32(message.bufffree);
              if (message.missionlist != null && message.missionlist.length) for (var i = 0; i < message.missionlist.length; ++i) {
                $root.gaiaProto.Mission.encode(message.missionlist[i], writer.uint32(
                /* id 13, wireType 2 =*/
                106).fork()).ldelim();
              }
              if (message.ErrorMsg != null && Object.hasOwnProperty.call(message, "ErrorMsg")) writer.uint32(
              /* id 14, wireType 2 =*/
              114).string(message.ErrorMsg);
              return writer;
            };
            /**
            * Encodes the specified ServiceData message, length delimited. Does not implicitly {@link gaiaProto.ServiceData.verify|verify} messages.
            * @function encodeDelimited
            * @memberof gaiaProto.ServiceData
            * @static
            * @param {gaiaProto.IServiceData} message ServiceData message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            ServiceData.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a ServiceData message from the specified reader or buffer.
            * @function decode
            * @memberof gaiaProto.ServiceData
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {gaiaProto.ServiceData} ServiceData
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            ServiceData.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gaiaProto.ServiceData();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.missionReward = reader.uint32();
                    break;

                  case 2:
                    message.jpType = reader.int32();
                    break;

                  case 3:
                    message.jpWin = reader["double"]();
                    break;

                  case 4:
                    message.fullJpWin = reader["double"]();
                    break;

                  case 5:
                    message.trialfinish = reader.int32();
                    break;

                  case 6:
                    message.trialaward = reader.int32();
                    break;

                  case 7:
                    message.freeremain = reader.int32();
                    break;

                  case 8:
                    if (!(message.cardlist && message.cardlist.length)) message.cardlist = [];
                    message.cardlist.push($root.gaiaProto.Card.decode(reader, reader.uint32()));
                    break;

                  case 9:
                    message.buffmul = reader["double"]();
                    break;

                  case 10:
                    message.buffmulwin = reader["double"]();
                    break;

                  case 11:
                    message.buffexbet = reader.int32();
                    break;

                  case 12:
                    message.bufffree = reader.int32();
                    break;

                  case 13:
                    if (!(message.missionlist && message.missionlist.length)) message.missionlist = [];
                    message.missionlist.push($root.gaiaProto.Mission.decode(reader, reader.uint32()));
                    break;

                  case 14:
                    message.ErrorMsg = reader.string();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a ServiceData message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof gaiaProto.ServiceData
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {gaiaProto.ServiceData} ServiceData
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            ServiceData.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a ServiceData message.
            * @function verify
            * @memberof gaiaProto.ServiceData
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            ServiceData.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.missionReward != null && message.hasOwnProperty("missionReward")) if (!$util.isInteger(message.missionReward)) return "missionReward: integer expected";
              if (message.jpType != null && message.hasOwnProperty("jpType")) if (!$util.isInteger(message.jpType)) return "jpType: integer expected";
              if (message.jpWin != null && message.hasOwnProperty("jpWin")) if (typeof message.jpWin !== "number") return "jpWin: number expected";
              if (message.fullJpWin != null && message.hasOwnProperty("fullJpWin")) if (typeof message.fullJpWin !== "number") return "fullJpWin: number expected";
              if (message.trialfinish != null && message.hasOwnProperty("trialfinish")) if (!$util.isInteger(message.trialfinish)) return "trialfinish: integer expected";
              if (message.trialaward != null && message.hasOwnProperty("trialaward")) if (!$util.isInteger(message.trialaward)) return "trialaward: integer expected";
              if (message.freeremain != null && message.hasOwnProperty("freeremain")) if (!$util.isInteger(message.freeremain)) return "freeremain: integer expected";

              if (message.cardlist != null && message.hasOwnProperty("cardlist")) {
                if (!Array.isArray(message.cardlist)) return "cardlist: array expected";

                for (var i = 0; i < message.cardlist.length; ++i) {
                  var error = $root.gaiaProto.Card.verify(message.cardlist[i]);
                  if (error) return "cardlist." + error;
                }
              }

              if (message.buffmul != null && message.hasOwnProperty("buffmul")) if (typeof message.buffmul !== "number") return "buffmul: number expected";
              if (message.buffmulwin != null && message.hasOwnProperty("buffmulwin")) if (typeof message.buffmulwin !== "number") return "buffmulwin: number expected";
              if (message.buffexbet != null && message.hasOwnProperty("buffexbet")) if (!$util.isInteger(message.buffexbet)) return "buffexbet: integer expected";
              if (message.bufffree != null && message.hasOwnProperty("bufffree")) if (!$util.isInteger(message.bufffree)) return "bufffree: integer expected";

              if (message.missionlist != null && message.hasOwnProperty("missionlist")) {
                if (!Array.isArray(message.missionlist)) return "missionlist: array expected";

                for (var i = 0; i < message.missionlist.length; ++i) {
                  var error = $root.gaiaProto.Mission.verify(message.missionlist[i]);
                  if (error) return "missionlist." + error;
                }
              }

              if (message.ErrorMsg != null && message.hasOwnProperty("ErrorMsg")) if (!$util.isString(message.ErrorMsg)) return "ErrorMsg: string expected";
              return null;
            };
            /**
            * Creates a ServiceData message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof gaiaProto.ServiceData
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {gaiaProto.ServiceData} ServiceData
            */


            ServiceData.fromObject = function fromObject(object) {
              if (object instanceof $root.gaiaProto.ServiceData) return object;
              var message = new $root.gaiaProto.ServiceData();
              if (object.missionReward != null) message.missionReward = object.missionReward >>> 0;
              if (object.jpType != null) message.jpType = object.jpType | 0;
              if (object.jpWin != null) message.jpWin = Number(object.jpWin);
              if (object.fullJpWin != null) message.fullJpWin = Number(object.fullJpWin);
              if (object.trialfinish != null) message.trialfinish = object.trialfinish | 0;
              if (object.trialaward != null) message.trialaward = object.trialaward | 0;
              if (object.freeremain != null) message.freeremain = object.freeremain | 0;

              if (object.cardlist) {
                if (!Array.isArray(object.cardlist)) throw TypeError(".gaiaProto.ServiceData.cardlist: array expected");
                message.cardlist = [];

                for (var i = 0; i < object.cardlist.length; ++i) {
                  if (typeof object.cardlist[i] !== "object") throw TypeError(".gaiaProto.ServiceData.cardlist: object expected");
                  message.cardlist[i] = $root.gaiaProto.Card.fromObject(object.cardlist[i]);
                }
              }

              if (object.buffmul != null) message.buffmul = Number(object.buffmul);
              if (object.buffmulwin != null) message.buffmulwin = Number(object.buffmulwin);
              if (object.buffexbet != null) message.buffexbet = object.buffexbet | 0;
              if (object.bufffree != null) message.bufffree = object.bufffree | 0;

              if (object.missionlist) {
                if (!Array.isArray(object.missionlist)) throw TypeError(".gaiaProto.ServiceData.missionlist: array expected");
                message.missionlist = [];

                for (var i = 0; i < object.missionlist.length; ++i) {
                  if (typeof object.missionlist[i] !== "object") throw TypeError(".gaiaProto.ServiceData.missionlist: object expected");
                  message.missionlist[i] = $root.gaiaProto.Mission.fromObject(object.missionlist[i]);
                }
              }

              if (object.ErrorMsg != null) message.ErrorMsg = String(object.ErrorMsg);
              return message;
            };
            /**
            * Creates a plain object from a ServiceData message. Also converts values to other types if specified.
            * @function toObject
            * @memberof gaiaProto.ServiceData
            * @static
            * @param {gaiaProto.ServiceData} message ServiceData
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            ServiceData.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.arrays || options.defaults) {
                object.cardlist = [];
                object.missionlist = [];
              }

              if (options.defaults) {
                object.missionReward = 0;
                object.jpType = 0;
                object.jpWin = 0;
                object.fullJpWin = 0;
                object.trialfinish = 0;
                object.trialaward = 0;
                object.freeremain = 0;
                object.buffmul = 0;
                object.buffmulwin = 0;
                object.buffexbet = 0;
                object.bufffree = 0;
                object.ErrorMsg = "";
              }

              if (message.missionReward != null && message.hasOwnProperty("missionReward")) object.missionReward = message.missionReward;
              if (message.jpType != null && message.hasOwnProperty("jpType")) object.jpType = message.jpType;
              if (message.jpWin != null && message.hasOwnProperty("jpWin")) object.jpWin = options.json && !isFinite(message.jpWin) ? String(message.jpWin) : message.jpWin;
              if (message.fullJpWin != null && message.hasOwnProperty("fullJpWin")) object.fullJpWin = options.json && !isFinite(message.fullJpWin) ? String(message.fullJpWin) : message.fullJpWin;
              if (message.trialfinish != null && message.hasOwnProperty("trialfinish")) object.trialfinish = message.trialfinish;
              if (message.trialaward != null && message.hasOwnProperty("trialaward")) object.trialaward = message.trialaward;
              if (message.freeremain != null && message.hasOwnProperty("freeremain")) object.freeremain = message.freeremain;

              if (message.cardlist && message.cardlist.length) {
                object.cardlist = [];

                for (var j = 0; j < message.cardlist.length; ++j) {
                  object.cardlist[j] = $root.gaiaProto.Card.toObject(message.cardlist[j], options);
                }
              }

              if (message.buffmul != null && message.hasOwnProperty("buffmul")) object.buffmul = options.json && !isFinite(message.buffmul) ? String(message.buffmul) : message.buffmul;
              if (message.buffmulwin != null && message.hasOwnProperty("buffmulwin")) object.buffmulwin = options.json && !isFinite(message.buffmulwin) ? String(message.buffmulwin) : message.buffmulwin;
              if (message.buffexbet != null && message.hasOwnProperty("buffexbet")) object.buffexbet = message.buffexbet;
              if (message.bufffree != null && message.hasOwnProperty("bufffree")) object.bufffree = message.bufffree;

              if (message.missionlist && message.missionlist.length) {
                object.missionlist = [];

                for (var j = 0; j < message.missionlist.length; ++j) {
                  object.missionlist[j] = $root.gaiaProto.Mission.toObject(message.missionlist[j], options);
                }
              }

              if (message.ErrorMsg != null && message.hasOwnProperty("ErrorMsg")) object.ErrorMsg = message.ErrorMsg;
              return object;
            };
            /**
            * Converts this ServiceData to JSON.
            * @function toJSON
            * @memberof gaiaProto.ServiceData
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            ServiceData.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ServiceData;
          }();

          gaiaProto.DebrisAInfoReq = function () {
            /**
            * Properties of a DebrisAInfoReq.
            * @memberof gaiaProto
            * @interface IDebrisAInfoReq
            * @property {number|null} [aid] DebrisAInfoReq aid
            * @property {string|null} [token] DebrisAInfoReq token
            * @property {number|null} [currencynumber] DebrisAInfoReq currencynumber
            * @property {number|null} [lang] DebrisAInfoReq lang
            */

            /**
            * Constructs a new DebrisAInfoReq.
            * @memberof gaiaProto
            * @classdesc Represents a DebrisAInfoReq.
            * @implements IDebrisAInfoReq
            * @constructor
            * @param {gaiaProto.IDebrisAInfoReq=} [properties] Properties to set
            */
            function DebrisAInfoReq(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * DebrisAInfoReq aid.
            * @member {number} aid
            * @memberof gaiaProto.DebrisAInfoReq
            * @instance
            */


            DebrisAInfoReq.prototype.aid = 0;
            /**
            * DebrisAInfoReq token.
            * @member {string} token
            * @memberof gaiaProto.DebrisAInfoReq
            * @instance
            */

            DebrisAInfoReq.prototype.token = "";
            /**
            * DebrisAInfoReq currencynumber.
            * @member {number} currencynumber
            * @memberof gaiaProto.DebrisAInfoReq
            * @instance
            */

            DebrisAInfoReq.prototype.currencynumber = 0;
            /**
            * DebrisAInfoReq lang.
            * @member {number} lang
            * @memberof gaiaProto.DebrisAInfoReq
            * @instance
            */

            DebrisAInfoReq.prototype.lang = 0;
            /**
            * Creates a new DebrisAInfoReq instance using the specified properties.
            * @function create
            * @memberof gaiaProto.DebrisAInfoReq
            * @static
            * @param {gaiaProto.IDebrisAInfoReq=} [properties] Properties to set
            * @returns {gaiaProto.DebrisAInfoReq} DebrisAInfoReq instance
            */

            DebrisAInfoReq.create = function create(properties) {
              return new DebrisAInfoReq(properties);
            };
            /**
            * Encodes the specified DebrisAInfoReq message. Does not implicitly {@link gaiaProto.DebrisAInfoReq.verify|verify} messages.
            * @function encode
            * @memberof gaiaProto.DebrisAInfoReq
            * @static
            * @param {gaiaProto.IDebrisAInfoReq} message DebrisAInfoReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            DebrisAInfoReq.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.aid != null && Object.hasOwnProperty.call(message, "aid")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.aid);
              if (message.token != null && Object.hasOwnProperty.call(message, "token")) writer.uint32(
              /* id 2, wireType 2 =*/
              18).string(message.token);
              if (message.currencynumber != null && Object.hasOwnProperty.call(message, "currencynumber")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.currencynumber);
              if (message.lang != null && Object.hasOwnProperty.call(message, "lang")) writer.uint32(
              /* id 4, wireType 0 =*/
              32).int32(message.lang);
              return writer;
            };
            /**
            * Encodes the specified DebrisAInfoReq message, length delimited. Does not implicitly {@link gaiaProto.DebrisAInfoReq.verify|verify} messages.
            * @function encodeDelimited
            * @memberof gaiaProto.DebrisAInfoReq
            * @static
            * @param {gaiaProto.IDebrisAInfoReq} message DebrisAInfoReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            DebrisAInfoReq.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a DebrisAInfoReq message from the specified reader or buffer.
            * @function decode
            * @memberof gaiaProto.DebrisAInfoReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {gaiaProto.DebrisAInfoReq} DebrisAInfoReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            DebrisAInfoReq.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gaiaProto.DebrisAInfoReq();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.aid = reader.int32();
                    break;

                  case 2:
                    message.token = reader.string();
                    break;

                  case 3:
                    message.currencynumber = reader.int32();
                    break;

                  case 4:
                    message.lang = reader.int32();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a DebrisAInfoReq message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof gaiaProto.DebrisAInfoReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {gaiaProto.DebrisAInfoReq} DebrisAInfoReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            DebrisAInfoReq.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a DebrisAInfoReq message.
            * @function verify
            * @memberof gaiaProto.DebrisAInfoReq
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            DebrisAInfoReq.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.aid != null && message.hasOwnProperty("aid")) if (!$util.isInteger(message.aid)) return "aid: integer expected";
              if (message.token != null && message.hasOwnProperty("token")) if (!$util.isString(message.token)) return "token: string expected";
              if (message.currencynumber != null && message.hasOwnProperty("currencynumber")) if (!$util.isInteger(message.currencynumber)) return "currencynumber: integer expected";
              if (message.lang != null && message.hasOwnProperty("lang")) if (!$util.isInteger(message.lang)) return "lang: integer expected";
              return null;
            };
            /**
            * Creates a DebrisAInfoReq message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof gaiaProto.DebrisAInfoReq
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {gaiaProto.DebrisAInfoReq} DebrisAInfoReq
            */


            DebrisAInfoReq.fromObject = function fromObject(object) {
              if (object instanceof $root.gaiaProto.DebrisAInfoReq) return object;
              var message = new $root.gaiaProto.DebrisAInfoReq();
              if (object.aid != null) message.aid = object.aid | 0;
              if (object.token != null) message.token = String(object.token);
              if (object.currencynumber != null) message.currencynumber = object.currencynumber | 0;
              if (object.lang != null) message.lang = object.lang | 0;
              return message;
            };
            /**
            * Creates a plain object from a DebrisAInfoReq message. Also converts values to other types if specified.
            * @function toObject
            * @memberof gaiaProto.DebrisAInfoReq
            * @static
            * @param {gaiaProto.DebrisAInfoReq} message DebrisAInfoReq
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            DebrisAInfoReq.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.aid = 0;
                object.token = "";
                object.currencynumber = 0;
                object.lang = 0;
              }

              if (message.aid != null && message.hasOwnProperty("aid")) object.aid = message.aid;
              if (message.token != null && message.hasOwnProperty("token")) object.token = message.token;
              if (message.currencynumber != null && message.hasOwnProperty("currencynumber")) object.currencynumber = message.currencynumber;
              if (message.lang != null && message.hasOwnProperty("lang")) object.lang = message.lang;
              return object;
            };
            /**
            * Converts this DebrisAInfoReq to JSON.
            * @function toJSON
            * @memberof gaiaProto.DebrisAInfoReq
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            DebrisAInfoReq.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DebrisAInfoReq;
          }();

          gaiaProto.DebrisPInfoReq = function () {
            /**
            * Properties of a DebrisPInfoReq.
            * @memberof gaiaProto
            * @interface IDebrisPInfoReq
            * @property {number|null} [aid] DebrisPInfoReq aid
            * @property {string|null} [token] DebrisPInfoReq token
            * @property {number|null} [currencynumber] DebrisPInfoReq currencynumber
            * @property {number|null} [ano] DebrisPInfoReq ano
            */

            /**
            * Constructs a new DebrisPInfoReq.
            * @memberof gaiaProto
            * @classdesc Represents a DebrisPInfoReq.
            * @implements IDebrisPInfoReq
            * @constructor
            * @param {gaiaProto.IDebrisPInfoReq=} [properties] Properties to set
            */
            function DebrisPInfoReq(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * DebrisPInfoReq aid.
            * @member {number} aid
            * @memberof gaiaProto.DebrisPInfoReq
            * @instance
            */


            DebrisPInfoReq.prototype.aid = 0;
            /**
            * DebrisPInfoReq token.
            * @member {string} token
            * @memberof gaiaProto.DebrisPInfoReq
            * @instance
            */

            DebrisPInfoReq.prototype.token = "";
            /**
            * DebrisPInfoReq currencynumber.
            * @member {number} currencynumber
            * @memberof gaiaProto.DebrisPInfoReq
            * @instance
            */

            DebrisPInfoReq.prototype.currencynumber = 0;
            /**
            * DebrisPInfoReq ano.
            * @member {number} ano
            * @memberof gaiaProto.DebrisPInfoReq
            * @instance
            */

            DebrisPInfoReq.prototype.ano = 0;
            /**
            * Creates a new DebrisPInfoReq instance using the specified properties.
            * @function create
            * @memberof gaiaProto.DebrisPInfoReq
            * @static
            * @param {gaiaProto.IDebrisPInfoReq=} [properties] Properties to set
            * @returns {gaiaProto.DebrisPInfoReq} DebrisPInfoReq instance
            */

            DebrisPInfoReq.create = function create(properties) {
              return new DebrisPInfoReq(properties);
            };
            /**
            * Encodes the specified DebrisPInfoReq message. Does not implicitly {@link gaiaProto.DebrisPInfoReq.verify|verify} messages.
            * @function encode
            * @memberof gaiaProto.DebrisPInfoReq
            * @static
            * @param {gaiaProto.IDebrisPInfoReq} message DebrisPInfoReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            DebrisPInfoReq.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.aid != null && Object.hasOwnProperty.call(message, "aid")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.aid);
              if (message.token != null && Object.hasOwnProperty.call(message, "token")) writer.uint32(
              /* id 2, wireType 2 =*/
              18).string(message.token);
              if (message.currencynumber != null && Object.hasOwnProperty.call(message, "currencynumber")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.currencynumber);
              if (message.ano != null && Object.hasOwnProperty.call(message, "ano")) writer.uint32(
              /* id 4, wireType 0 =*/
              32).int32(message.ano);
              return writer;
            };
            /**
            * Encodes the specified DebrisPInfoReq message, length delimited. Does not implicitly {@link gaiaProto.DebrisPInfoReq.verify|verify} messages.
            * @function encodeDelimited
            * @memberof gaiaProto.DebrisPInfoReq
            * @static
            * @param {gaiaProto.IDebrisPInfoReq} message DebrisPInfoReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            DebrisPInfoReq.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a DebrisPInfoReq message from the specified reader or buffer.
            * @function decode
            * @memberof gaiaProto.DebrisPInfoReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {gaiaProto.DebrisPInfoReq} DebrisPInfoReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            DebrisPInfoReq.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gaiaProto.DebrisPInfoReq();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.aid = reader.int32();
                    break;

                  case 2:
                    message.token = reader.string();
                    break;

                  case 3:
                    message.currencynumber = reader.int32();
                    break;

                  case 4:
                    message.ano = reader.int32();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a DebrisPInfoReq message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof gaiaProto.DebrisPInfoReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {gaiaProto.DebrisPInfoReq} DebrisPInfoReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            DebrisPInfoReq.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a DebrisPInfoReq message.
            * @function verify
            * @memberof gaiaProto.DebrisPInfoReq
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            DebrisPInfoReq.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.aid != null && message.hasOwnProperty("aid")) if (!$util.isInteger(message.aid)) return "aid: integer expected";
              if (message.token != null && message.hasOwnProperty("token")) if (!$util.isString(message.token)) return "token: string expected";
              if (message.currencynumber != null && message.hasOwnProperty("currencynumber")) if (!$util.isInteger(message.currencynumber)) return "currencynumber: integer expected";
              if (message.ano != null && message.hasOwnProperty("ano")) if (!$util.isInteger(message.ano)) return "ano: integer expected";
              return null;
            };
            /**
            * Creates a DebrisPInfoReq message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof gaiaProto.DebrisPInfoReq
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {gaiaProto.DebrisPInfoReq} DebrisPInfoReq
            */


            DebrisPInfoReq.fromObject = function fromObject(object) {
              if (object instanceof $root.gaiaProto.DebrisPInfoReq) return object;
              var message = new $root.gaiaProto.DebrisPInfoReq();
              if (object.aid != null) message.aid = object.aid | 0;
              if (object.token != null) message.token = String(object.token);
              if (object.currencynumber != null) message.currencynumber = object.currencynumber | 0;
              if (object.ano != null) message.ano = object.ano | 0;
              return message;
            };
            /**
            * Creates a plain object from a DebrisPInfoReq message. Also converts values to other types if specified.
            * @function toObject
            * @memberof gaiaProto.DebrisPInfoReq
            * @static
            * @param {gaiaProto.DebrisPInfoReq} message DebrisPInfoReq
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            DebrisPInfoReq.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.aid = 0;
                object.token = "";
                object.currencynumber = 0;
                object.ano = 0;
              }

              if (message.aid != null && message.hasOwnProperty("aid")) object.aid = message.aid;
              if (message.token != null && message.hasOwnProperty("token")) object.token = message.token;
              if (message.currencynumber != null && message.hasOwnProperty("currencynumber")) object.currencynumber = message.currencynumber;
              if (message.ano != null && message.hasOwnProperty("ano")) object.ano = message.ano;
              return object;
            };
            /**
            * Converts this DebrisPInfoReq to JSON.
            * @function toJSON
            * @memberof gaiaProto.DebrisPInfoReq
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            DebrisPInfoReq.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DebrisPInfoReq;
          }();

          gaiaProto.DebrisPGetReq = function () {
            /**
            * Properties of a DebrisPGetReq.
            * @memberof gaiaProto
            * @interface IDebrisPGetReq
            * @property {number|null} [aid] DebrisPGetReq aid
            * @property {string|null} [token] DebrisPGetReq token
            * @property {number|null} [currencynumber] DebrisPGetReq currencynumber
            */

            /**
            * Constructs a new DebrisPGetReq.
            * @memberof gaiaProto
            * @classdesc Represents a DebrisPGetReq.
            * @implements IDebrisPGetReq
            * @constructor
            * @param {gaiaProto.IDebrisPGetReq=} [properties] Properties to set
            */
            function DebrisPGetReq(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * DebrisPGetReq aid.
            * @member {number} aid
            * @memberof gaiaProto.DebrisPGetReq
            * @instance
            */


            DebrisPGetReq.prototype.aid = 0;
            /**
            * DebrisPGetReq token.
            * @member {string} token
            * @memberof gaiaProto.DebrisPGetReq
            * @instance
            */

            DebrisPGetReq.prototype.token = "";
            /**
            * DebrisPGetReq currencynumber.
            * @member {number} currencynumber
            * @memberof gaiaProto.DebrisPGetReq
            * @instance
            */

            DebrisPGetReq.prototype.currencynumber = 0;
            /**
            * Creates a new DebrisPGetReq instance using the specified properties.
            * @function create
            * @memberof gaiaProto.DebrisPGetReq
            * @static
            * @param {gaiaProto.IDebrisPGetReq=} [properties] Properties to set
            * @returns {gaiaProto.DebrisPGetReq} DebrisPGetReq instance
            */

            DebrisPGetReq.create = function create(properties) {
              return new DebrisPGetReq(properties);
            };
            /**
            * Encodes the specified DebrisPGetReq message. Does not implicitly {@link gaiaProto.DebrisPGetReq.verify|verify} messages.
            * @function encode
            * @memberof gaiaProto.DebrisPGetReq
            * @static
            * @param {gaiaProto.IDebrisPGetReq} message DebrisPGetReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            DebrisPGetReq.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.aid != null && Object.hasOwnProperty.call(message, "aid")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.aid);
              if (message.token != null && Object.hasOwnProperty.call(message, "token")) writer.uint32(
              /* id 2, wireType 2 =*/
              18).string(message.token);
              if (message.currencynumber != null && Object.hasOwnProperty.call(message, "currencynumber")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.currencynumber);
              return writer;
            };
            /**
            * Encodes the specified DebrisPGetReq message, length delimited. Does not implicitly {@link gaiaProto.DebrisPGetReq.verify|verify} messages.
            * @function encodeDelimited
            * @memberof gaiaProto.DebrisPGetReq
            * @static
            * @param {gaiaProto.IDebrisPGetReq} message DebrisPGetReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            DebrisPGetReq.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a DebrisPGetReq message from the specified reader or buffer.
            * @function decode
            * @memberof gaiaProto.DebrisPGetReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {gaiaProto.DebrisPGetReq} DebrisPGetReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            DebrisPGetReq.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gaiaProto.DebrisPGetReq();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.aid = reader.int32();
                    break;

                  case 2:
                    message.token = reader.string();
                    break;

                  case 3:
                    message.currencynumber = reader.int32();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a DebrisPGetReq message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof gaiaProto.DebrisPGetReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {gaiaProto.DebrisPGetReq} DebrisPGetReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            DebrisPGetReq.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a DebrisPGetReq message.
            * @function verify
            * @memberof gaiaProto.DebrisPGetReq
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            DebrisPGetReq.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.aid != null && message.hasOwnProperty("aid")) if (!$util.isInteger(message.aid)) return "aid: integer expected";
              if (message.token != null && message.hasOwnProperty("token")) if (!$util.isString(message.token)) return "token: string expected";
              if (message.currencynumber != null && message.hasOwnProperty("currencynumber")) if (!$util.isInteger(message.currencynumber)) return "currencynumber: integer expected";
              return null;
            };
            /**
            * Creates a DebrisPGetReq message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof gaiaProto.DebrisPGetReq
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {gaiaProto.DebrisPGetReq} DebrisPGetReq
            */


            DebrisPGetReq.fromObject = function fromObject(object) {
              if (object instanceof $root.gaiaProto.DebrisPGetReq) return object;
              var message = new $root.gaiaProto.DebrisPGetReq();
              if (object.aid != null) message.aid = object.aid | 0;
              if (object.token != null) message.token = String(object.token);
              if (object.currencynumber != null) message.currencynumber = object.currencynumber | 0;
              return message;
            };
            /**
            * Creates a plain object from a DebrisPGetReq message. Also converts values to other types if specified.
            * @function toObject
            * @memberof gaiaProto.DebrisPGetReq
            * @static
            * @param {gaiaProto.DebrisPGetReq} message DebrisPGetReq
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            DebrisPGetReq.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.aid = 0;
                object.token = "";
                object.currencynumber = 0;
              }

              if (message.aid != null && message.hasOwnProperty("aid")) object.aid = message.aid;
              if (message.token != null && message.hasOwnProperty("token")) object.token = message.token;
              if (message.currencynumber != null && message.hasOwnProperty("currencynumber")) object.currencynumber = message.currencynumber;
              return object;
            };
            /**
            * Converts this DebrisPGetReq to JSON.
            * @function toJSON
            * @memberof gaiaProto.DebrisPGetReq
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            DebrisPGetReq.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DebrisPGetReq;
          }();

          gaiaProto.DebrisExchangeReq = function () {
            /**
            * Properties of a DebrisExchangeReq.
            * @memberof gaiaProto
            * @interface IDebrisExchangeReq
            * @property {number|null} [aid] DebrisExchangeReq aid
            * @property {string|null} [token] DebrisExchangeReq token
            * @property {number|null} [currencynumber] DebrisExchangeReq currencynumber
            * @property {number|null} [ano] DebrisExchangeReq ano
            * @property {number|null} [fno] DebrisExchangeReq fno
            * @property {number|null} [amount] DebrisExchangeReq amount
            */

            /**
            * Constructs a new DebrisExchangeReq.
            * @memberof gaiaProto
            * @classdesc Represents a DebrisExchangeReq.
            * @implements IDebrisExchangeReq
            * @constructor
            * @param {gaiaProto.IDebrisExchangeReq=} [properties] Properties to set
            */
            function DebrisExchangeReq(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * DebrisExchangeReq aid.
            * @member {number} aid
            * @memberof gaiaProto.DebrisExchangeReq
            * @instance
            */


            DebrisExchangeReq.prototype.aid = 0;
            /**
            * DebrisExchangeReq token.
            * @member {string} token
            * @memberof gaiaProto.DebrisExchangeReq
            * @instance
            */

            DebrisExchangeReq.prototype.token = "";
            /**
            * DebrisExchangeReq currencynumber.
            * @member {number} currencynumber
            * @memberof gaiaProto.DebrisExchangeReq
            * @instance
            */

            DebrisExchangeReq.prototype.currencynumber = 0;
            /**
            * DebrisExchangeReq ano.
            * @member {number} ano
            * @memberof gaiaProto.DebrisExchangeReq
            * @instance
            */

            DebrisExchangeReq.prototype.ano = 0;
            /**
            * DebrisExchangeReq fno.
            * @member {number} fno
            * @memberof gaiaProto.DebrisExchangeReq
            * @instance
            */

            DebrisExchangeReq.prototype.fno = 0;
            /**
            * DebrisExchangeReq amount.
            * @member {number} amount
            * @memberof gaiaProto.DebrisExchangeReq
            * @instance
            */

            DebrisExchangeReq.prototype.amount = 0;
            /**
            * Creates a new DebrisExchangeReq instance using the specified properties.
            * @function create
            * @memberof gaiaProto.DebrisExchangeReq
            * @static
            * @param {gaiaProto.IDebrisExchangeReq=} [properties] Properties to set
            * @returns {gaiaProto.DebrisExchangeReq} DebrisExchangeReq instance
            */

            DebrisExchangeReq.create = function create(properties) {
              return new DebrisExchangeReq(properties);
            };
            /**
            * Encodes the specified DebrisExchangeReq message. Does not implicitly {@link gaiaProto.DebrisExchangeReq.verify|verify} messages.
            * @function encode
            * @memberof gaiaProto.DebrisExchangeReq
            * @static
            * @param {gaiaProto.IDebrisExchangeReq} message DebrisExchangeReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            DebrisExchangeReq.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.aid != null && Object.hasOwnProperty.call(message, "aid")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.aid);
              if (message.token != null && Object.hasOwnProperty.call(message, "token")) writer.uint32(
              /* id 2, wireType 2 =*/
              18).string(message.token);
              if (message.currencynumber != null && Object.hasOwnProperty.call(message, "currencynumber")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.currencynumber);
              if (message.ano != null && Object.hasOwnProperty.call(message, "ano")) writer.uint32(
              /* id 4, wireType 0 =*/
              32).int32(message.ano);
              if (message.fno != null && Object.hasOwnProperty.call(message, "fno")) writer.uint32(
              /* id 5, wireType 0 =*/
              40).int32(message.fno);
              if (message.amount != null && Object.hasOwnProperty.call(message, "amount")) writer.uint32(
              /* id 6, wireType 0 =*/
              48).int32(message.amount);
              return writer;
            };
            /**
            * Encodes the specified DebrisExchangeReq message, length delimited. Does not implicitly {@link gaiaProto.DebrisExchangeReq.verify|verify} messages.
            * @function encodeDelimited
            * @memberof gaiaProto.DebrisExchangeReq
            * @static
            * @param {gaiaProto.IDebrisExchangeReq} message DebrisExchangeReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            DebrisExchangeReq.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a DebrisExchangeReq message from the specified reader or buffer.
            * @function decode
            * @memberof gaiaProto.DebrisExchangeReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {gaiaProto.DebrisExchangeReq} DebrisExchangeReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            DebrisExchangeReq.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gaiaProto.DebrisExchangeReq();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.aid = reader.int32();
                    break;

                  case 2:
                    message.token = reader.string();
                    break;

                  case 3:
                    message.currencynumber = reader.int32();
                    break;

                  case 4:
                    message.ano = reader.int32();
                    break;

                  case 5:
                    message.fno = reader.int32();
                    break;

                  case 6:
                    message.amount = reader.int32();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a DebrisExchangeReq message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof gaiaProto.DebrisExchangeReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {gaiaProto.DebrisExchangeReq} DebrisExchangeReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            DebrisExchangeReq.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a DebrisExchangeReq message.
            * @function verify
            * @memberof gaiaProto.DebrisExchangeReq
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            DebrisExchangeReq.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.aid != null && message.hasOwnProperty("aid")) if (!$util.isInteger(message.aid)) return "aid: integer expected";
              if (message.token != null && message.hasOwnProperty("token")) if (!$util.isString(message.token)) return "token: string expected";
              if (message.currencynumber != null && message.hasOwnProperty("currencynumber")) if (!$util.isInteger(message.currencynumber)) return "currencynumber: integer expected";
              if (message.ano != null && message.hasOwnProperty("ano")) if (!$util.isInteger(message.ano)) return "ano: integer expected";
              if (message.fno != null && message.hasOwnProperty("fno")) if (!$util.isInteger(message.fno)) return "fno: integer expected";
              if (message.amount != null && message.hasOwnProperty("amount")) if (!$util.isInteger(message.amount)) return "amount: integer expected";
              return null;
            };
            /**
            * Creates a DebrisExchangeReq message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof gaiaProto.DebrisExchangeReq
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {gaiaProto.DebrisExchangeReq} DebrisExchangeReq
            */


            DebrisExchangeReq.fromObject = function fromObject(object) {
              if (object instanceof $root.gaiaProto.DebrisExchangeReq) return object;
              var message = new $root.gaiaProto.DebrisExchangeReq();
              if (object.aid != null) message.aid = object.aid | 0;
              if (object.token != null) message.token = String(object.token);
              if (object.currencynumber != null) message.currencynumber = object.currencynumber | 0;
              if (object.ano != null) message.ano = object.ano | 0;
              if (object.fno != null) message.fno = object.fno | 0;
              if (object.amount != null) message.amount = object.amount | 0;
              return message;
            };
            /**
            * Creates a plain object from a DebrisExchangeReq message. Also converts values to other types if specified.
            * @function toObject
            * @memberof gaiaProto.DebrisExchangeReq
            * @static
            * @param {gaiaProto.DebrisExchangeReq} message DebrisExchangeReq
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            DebrisExchangeReq.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.aid = 0;
                object.token = "";
                object.currencynumber = 0;
                object.ano = 0;
                object.fno = 0;
                object.amount = 0;
              }

              if (message.aid != null && message.hasOwnProperty("aid")) object.aid = message.aid;
              if (message.token != null && message.hasOwnProperty("token")) object.token = message.token;
              if (message.currencynumber != null && message.hasOwnProperty("currencynumber")) object.currencynumber = message.currencynumber;
              if (message.ano != null && message.hasOwnProperty("ano")) object.ano = message.ano;
              if (message.fno != null && message.hasOwnProperty("fno")) object.fno = message.fno;
              if (message.amount != null && message.hasOwnProperty("amount")) object.amount = message.amount;
              return object;
            };
            /**
            * Converts this DebrisExchangeReq to JSON.
            * @function toJSON
            * @memberof gaiaProto.DebrisExchangeReq
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            DebrisExchangeReq.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DebrisExchangeReq;
          }();

          gaiaProto.FullJPInfoReq = function () {
            /**
            * Properties of a FullJPInfoReq.
            * @memberof gaiaProto
            * @interface IFullJPInfoReq
            * @property {number|null} [aid] FullJPInfoReq aid
            * @property {string|null} [token] FullJPInfoReq token
            */

            /**
            * Constructs a new FullJPInfoReq.
            * @memberof gaiaProto
            * @classdesc Represents a FullJPInfoReq.
            * @implements IFullJPInfoReq
            * @constructor
            * @param {gaiaProto.IFullJPInfoReq=} [properties] Properties to set
            */
            function FullJPInfoReq(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * FullJPInfoReq aid.
            * @member {number} aid
            * @memberof gaiaProto.FullJPInfoReq
            * @instance
            */


            FullJPInfoReq.prototype.aid = 0;
            /**
            * FullJPInfoReq token.
            * @member {string} token
            * @memberof gaiaProto.FullJPInfoReq
            * @instance
            */

            FullJPInfoReq.prototype.token = "";
            /**
            * Creates a new FullJPInfoReq instance using the specified properties.
            * @function create
            * @memberof gaiaProto.FullJPInfoReq
            * @static
            * @param {gaiaProto.IFullJPInfoReq=} [properties] Properties to set
            * @returns {gaiaProto.FullJPInfoReq} FullJPInfoReq instance
            */

            FullJPInfoReq.create = function create(properties) {
              return new FullJPInfoReq(properties);
            };
            /**
            * Encodes the specified FullJPInfoReq message. Does not implicitly {@link gaiaProto.FullJPInfoReq.verify|verify} messages.
            * @function encode
            * @memberof gaiaProto.FullJPInfoReq
            * @static
            * @param {gaiaProto.IFullJPInfoReq} message FullJPInfoReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            FullJPInfoReq.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.aid != null && Object.hasOwnProperty.call(message, "aid")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.aid);
              if (message.token != null && Object.hasOwnProperty.call(message, "token")) writer.uint32(
              /* id 2, wireType 2 =*/
              18).string(message.token);
              return writer;
            };
            /**
            * Encodes the specified FullJPInfoReq message, length delimited. Does not implicitly {@link gaiaProto.FullJPInfoReq.verify|verify} messages.
            * @function encodeDelimited
            * @memberof gaiaProto.FullJPInfoReq
            * @static
            * @param {gaiaProto.IFullJPInfoReq} message FullJPInfoReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            FullJPInfoReq.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a FullJPInfoReq message from the specified reader or buffer.
            * @function decode
            * @memberof gaiaProto.FullJPInfoReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {gaiaProto.FullJPInfoReq} FullJPInfoReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            FullJPInfoReq.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gaiaProto.FullJPInfoReq();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.aid = reader.int32();
                    break;

                  case 2:
                    message.token = reader.string();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a FullJPInfoReq message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof gaiaProto.FullJPInfoReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {gaiaProto.FullJPInfoReq} FullJPInfoReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            FullJPInfoReq.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a FullJPInfoReq message.
            * @function verify
            * @memberof gaiaProto.FullJPInfoReq
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            FullJPInfoReq.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.aid != null && message.hasOwnProperty("aid")) if (!$util.isInteger(message.aid)) return "aid: integer expected";
              if (message.token != null && message.hasOwnProperty("token")) if (!$util.isString(message.token)) return "token: string expected";
              return null;
            };
            /**
            * Creates a FullJPInfoReq message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof gaiaProto.FullJPInfoReq
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {gaiaProto.FullJPInfoReq} FullJPInfoReq
            */


            FullJPInfoReq.fromObject = function fromObject(object) {
              if (object instanceof $root.gaiaProto.FullJPInfoReq) return object;
              var message = new $root.gaiaProto.FullJPInfoReq();
              if (object.aid != null) message.aid = object.aid | 0;
              if (object.token != null) message.token = String(object.token);
              return message;
            };
            /**
            * Creates a plain object from a FullJPInfoReq message. Also converts values to other types if specified.
            * @function toObject
            * @memberof gaiaProto.FullJPInfoReq
            * @static
            * @param {gaiaProto.FullJPInfoReq} message FullJPInfoReq
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            FullJPInfoReq.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.aid = 0;
                object.token = "";
              }

              if (message.aid != null && message.hasOwnProperty("aid")) object.aid = message.aid;
              if (message.token != null && message.hasOwnProperty("token")) object.token = message.token;
              return object;
            };
            /**
            * Converts this FullJPInfoReq to JSON.
            * @function toJSON
            * @memberof gaiaProto.FullJPInfoReq
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            FullJPInfoReq.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return FullJPInfoReq;
          }();

          gaiaProto.FullJPInfoAllReq = function () {
            /**
            * Properties of a FullJPInfoAllReq.
            * @memberof gaiaProto
            * @interface IFullJPInfoAllReq
            * @property {number|null} [aid] FullJPInfoAllReq aid
            * @property {string|null} [token] FullJPInfoAllReq token
            */

            /**
            * Constructs a new FullJPInfoAllReq.
            * @memberof gaiaProto
            * @classdesc Represents a FullJPInfoAllReq.
            * @implements IFullJPInfoAllReq
            * @constructor
            * @param {gaiaProto.IFullJPInfoAllReq=} [properties] Properties to set
            */
            function FullJPInfoAllReq(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * FullJPInfoAllReq aid.
            * @member {number} aid
            * @memberof gaiaProto.FullJPInfoAllReq
            * @instance
            */


            FullJPInfoAllReq.prototype.aid = 0;
            /**
            * FullJPInfoAllReq token.
            * @member {string} token
            * @memberof gaiaProto.FullJPInfoAllReq
            * @instance
            */

            FullJPInfoAllReq.prototype.token = "";
            /**
            * Creates a new FullJPInfoAllReq instance using the specified properties.
            * @function create
            * @memberof gaiaProto.FullJPInfoAllReq
            * @static
            * @param {gaiaProto.IFullJPInfoAllReq=} [properties] Properties to set
            * @returns {gaiaProto.FullJPInfoAllReq} FullJPInfoAllReq instance
            */

            FullJPInfoAllReq.create = function create(properties) {
              return new FullJPInfoAllReq(properties);
            };
            /**
            * Encodes the specified FullJPInfoAllReq message. Does not implicitly {@link gaiaProto.FullJPInfoAllReq.verify|verify} messages.
            * @function encode
            * @memberof gaiaProto.FullJPInfoAllReq
            * @static
            * @param {gaiaProto.IFullJPInfoAllReq} message FullJPInfoAllReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            FullJPInfoAllReq.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.aid != null && Object.hasOwnProperty.call(message, "aid")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.aid);
              if (message.token != null && Object.hasOwnProperty.call(message, "token")) writer.uint32(
              /* id 2, wireType 2 =*/
              18).string(message.token);
              return writer;
            };
            /**
            * Encodes the specified FullJPInfoAllReq message, length delimited. Does not implicitly {@link gaiaProto.FullJPInfoAllReq.verify|verify} messages.
            * @function encodeDelimited
            * @memberof gaiaProto.FullJPInfoAllReq
            * @static
            * @param {gaiaProto.IFullJPInfoAllReq} message FullJPInfoAllReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            FullJPInfoAllReq.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a FullJPInfoAllReq message from the specified reader or buffer.
            * @function decode
            * @memberof gaiaProto.FullJPInfoAllReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {gaiaProto.FullJPInfoAllReq} FullJPInfoAllReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            FullJPInfoAllReq.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gaiaProto.FullJPInfoAllReq();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.aid = reader.int32();
                    break;

                  case 2:
                    message.token = reader.string();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a FullJPInfoAllReq message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof gaiaProto.FullJPInfoAllReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {gaiaProto.FullJPInfoAllReq} FullJPInfoAllReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            FullJPInfoAllReq.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a FullJPInfoAllReq message.
            * @function verify
            * @memberof gaiaProto.FullJPInfoAllReq
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            FullJPInfoAllReq.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.aid != null && message.hasOwnProperty("aid")) if (!$util.isInteger(message.aid)) return "aid: integer expected";
              if (message.token != null && message.hasOwnProperty("token")) if (!$util.isString(message.token)) return "token: string expected";
              return null;
            };
            /**
            * Creates a FullJPInfoAllReq message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof gaiaProto.FullJPInfoAllReq
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {gaiaProto.FullJPInfoAllReq} FullJPInfoAllReq
            */


            FullJPInfoAllReq.fromObject = function fromObject(object) {
              if (object instanceof $root.gaiaProto.FullJPInfoAllReq) return object;
              var message = new $root.gaiaProto.FullJPInfoAllReq();
              if (object.aid != null) message.aid = object.aid | 0;
              if (object.token != null) message.token = String(object.token);
              return message;
            };
            /**
            * Creates a plain object from a FullJPInfoAllReq message. Also converts values to other types if specified.
            * @function toObject
            * @memberof gaiaProto.FullJPInfoAllReq
            * @static
            * @param {gaiaProto.FullJPInfoAllReq} message FullJPInfoAllReq
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            FullJPInfoAllReq.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.aid = 0;
                object.token = "";
              }

              if (message.aid != null && message.hasOwnProperty("aid")) object.aid = message.aid;
              if (message.token != null && message.hasOwnProperty("token")) object.token = message.token;
              return object;
            };
            /**
            * Converts this FullJPInfoAllReq to JSON.
            * @function toJSON
            * @memberof gaiaProto.FullJPInfoAllReq
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            FullJPInfoAllReq.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return FullJPInfoAllReq;
          }();

          gaiaProto.FullJPHistoryReq = function () {
            /**
            * Properties of a FullJPHistoryReq.
            * @memberof gaiaProto
            * @interface IFullJPHistoryReq
            * @property {number|null} [aid] FullJPHistoryReq aid
            * @property {string|null} [token] FullJPHistoryReq token
            */

            /**
            * Constructs a new FullJPHistoryReq.
            * @memberof gaiaProto
            * @classdesc Represents a FullJPHistoryReq.
            * @implements IFullJPHistoryReq
            * @constructor
            * @param {gaiaProto.IFullJPHistoryReq=} [properties] Properties to set
            */
            function FullJPHistoryReq(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * FullJPHistoryReq aid.
            * @member {number} aid
            * @memberof gaiaProto.FullJPHistoryReq
            * @instance
            */


            FullJPHistoryReq.prototype.aid = 0;
            /**
            * FullJPHistoryReq token.
            * @member {string} token
            * @memberof gaiaProto.FullJPHistoryReq
            * @instance
            */

            FullJPHistoryReq.prototype.token = "";
            /**
            * Creates a new FullJPHistoryReq instance using the specified properties.
            * @function create
            * @memberof gaiaProto.FullJPHistoryReq
            * @static
            * @param {gaiaProto.IFullJPHistoryReq=} [properties] Properties to set
            * @returns {gaiaProto.FullJPHistoryReq} FullJPHistoryReq instance
            */

            FullJPHistoryReq.create = function create(properties) {
              return new FullJPHistoryReq(properties);
            };
            /**
            * Encodes the specified FullJPHistoryReq message. Does not implicitly {@link gaiaProto.FullJPHistoryReq.verify|verify} messages.
            * @function encode
            * @memberof gaiaProto.FullJPHistoryReq
            * @static
            * @param {gaiaProto.IFullJPHistoryReq} message FullJPHistoryReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            FullJPHistoryReq.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.aid != null && Object.hasOwnProperty.call(message, "aid")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.aid);
              if (message.token != null && Object.hasOwnProperty.call(message, "token")) writer.uint32(
              /* id 2, wireType 2 =*/
              18).string(message.token);
              return writer;
            };
            /**
            * Encodes the specified FullJPHistoryReq message, length delimited. Does not implicitly {@link gaiaProto.FullJPHistoryReq.verify|verify} messages.
            * @function encodeDelimited
            * @memberof gaiaProto.FullJPHistoryReq
            * @static
            * @param {gaiaProto.IFullJPHistoryReq} message FullJPHistoryReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            FullJPHistoryReq.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a FullJPHistoryReq message from the specified reader or buffer.
            * @function decode
            * @memberof gaiaProto.FullJPHistoryReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {gaiaProto.FullJPHistoryReq} FullJPHistoryReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            FullJPHistoryReq.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gaiaProto.FullJPHistoryReq();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.aid = reader.int32();
                    break;

                  case 2:
                    message.token = reader.string();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a FullJPHistoryReq message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof gaiaProto.FullJPHistoryReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {gaiaProto.FullJPHistoryReq} FullJPHistoryReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            FullJPHistoryReq.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a FullJPHistoryReq message.
            * @function verify
            * @memberof gaiaProto.FullJPHistoryReq
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            FullJPHistoryReq.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.aid != null && message.hasOwnProperty("aid")) if (!$util.isInteger(message.aid)) return "aid: integer expected";
              if (message.token != null && message.hasOwnProperty("token")) if (!$util.isString(message.token)) return "token: string expected";
              return null;
            };
            /**
            * Creates a FullJPHistoryReq message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof gaiaProto.FullJPHistoryReq
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {gaiaProto.FullJPHistoryReq} FullJPHistoryReq
            */


            FullJPHistoryReq.fromObject = function fromObject(object) {
              if (object instanceof $root.gaiaProto.FullJPHistoryReq) return object;
              var message = new $root.gaiaProto.FullJPHistoryReq();
              if (object.aid != null) message.aid = object.aid | 0;
              if (object.token != null) message.token = String(object.token);
              return message;
            };
            /**
            * Creates a plain object from a FullJPHistoryReq message. Also converts values to other types if specified.
            * @function toObject
            * @memberof gaiaProto.FullJPHistoryReq
            * @static
            * @param {gaiaProto.FullJPHistoryReq} message FullJPHistoryReq
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            FullJPHistoryReq.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.aid = 0;
                object.token = "";
              }

              if (message.aid != null && message.hasOwnProperty("aid")) object.aid = message.aid;
              if (message.token != null && message.hasOwnProperty("token")) object.token = message.token;
              return object;
            };
            /**
            * Converts this FullJPHistoryReq to JSON.
            * @function toJSON
            * @memberof gaiaProto.FullJPHistoryReq
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            FullJPHistoryReq.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return FullJPHistoryReq;
          }();

          gaiaProto.FullJPInfoAck = function () {
            /**
            * Properties of a FullJPInfoAck.
            * @memberof gaiaProto
            * @interface IFullJPInfoAck
            * @property {number|null} [value] FullJPInfoAck value
            * @property {number|null} [full] FullJPInfoAck full
            * @property {number|null} [minvip] FullJPInfoAck minvip
            * @property {number|null} [minbet] FullJPInfoAck minbet
            */

            /**
            * Constructs a new FullJPInfoAck.
            * @memberof gaiaProto
            * @classdesc Represents a FullJPInfoAck.
            * @implements IFullJPInfoAck
            * @constructor
            * @param {gaiaProto.IFullJPInfoAck=} [properties] Properties to set
            */
            function FullJPInfoAck(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * FullJPInfoAck value.
            * @member {number} value
            * @memberof gaiaProto.FullJPInfoAck
            * @instance
            */


            FullJPInfoAck.prototype.value = 0;
            /**
            * FullJPInfoAck full.
            * @member {number} full
            * @memberof gaiaProto.FullJPInfoAck
            * @instance
            */

            FullJPInfoAck.prototype.full = 0;
            /**
            * FullJPInfoAck minvip.
            * @member {number} minvip
            * @memberof gaiaProto.FullJPInfoAck
            * @instance
            */

            FullJPInfoAck.prototype.minvip = 0;
            /**
            * FullJPInfoAck minbet.
            * @member {number} minbet
            * @memberof gaiaProto.FullJPInfoAck
            * @instance
            */

            FullJPInfoAck.prototype.minbet = 0;
            /**
            * Creates a new FullJPInfoAck instance using the specified properties.
            * @function create
            * @memberof gaiaProto.FullJPInfoAck
            * @static
            * @param {gaiaProto.IFullJPInfoAck=} [properties] Properties to set
            * @returns {gaiaProto.FullJPInfoAck} FullJPInfoAck instance
            */

            FullJPInfoAck.create = function create(properties) {
              return new FullJPInfoAck(properties);
            };
            /**
            * Encodes the specified FullJPInfoAck message. Does not implicitly {@link gaiaProto.FullJPInfoAck.verify|verify} messages.
            * @function encode
            * @memberof gaiaProto.FullJPInfoAck
            * @static
            * @param {gaiaProto.IFullJPInfoAck} message FullJPInfoAck message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            FullJPInfoAck.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.value != null && Object.hasOwnProperty.call(message, "value")) writer.uint32(
              /* id 1, wireType 1 =*/
              9)["double"](message.value);
              if (message.full != null && Object.hasOwnProperty.call(message, "full")) writer.uint32(
              /* id 2, wireType 1 =*/
              17)["double"](message.full);
              if (message.minvip != null && Object.hasOwnProperty.call(message, "minvip")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.minvip);
              if (message.minbet != null && Object.hasOwnProperty.call(message, "minbet")) writer.uint32(
              /* id 4, wireType 1 =*/
              33)["double"](message.minbet);
              return writer;
            };
            /**
            * Encodes the specified FullJPInfoAck message, length delimited. Does not implicitly {@link gaiaProto.FullJPInfoAck.verify|verify} messages.
            * @function encodeDelimited
            * @memberof gaiaProto.FullJPInfoAck
            * @static
            * @param {gaiaProto.IFullJPInfoAck} message FullJPInfoAck message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            FullJPInfoAck.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a FullJPInfoAck message from the specified reader or buffer.
            * @function decode
            * @memberof gaiaProto.FullJPInfoAck
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {gaiaProto.FullJPInfoAck} FullJPInfoAck
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            FullJPInfoAck.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gaiaProto.FullJPInfoAck();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.value = reader["double"]();
                    break;

                  case 2:
                    message.full = reader["double"]();
                    break;

                  case 3:
                    message.minvip = reader.int32();
                    break;

                  case 4:
                    message.minbet = reader["double"]();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a FullJPInfoAck message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof gaiaProto.FullJPInfoAck
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {gaiaProto.FullJPInfoAck} FullJPInfoAck
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            FullJPInfoAck.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a FullJPInfoAck message.
            * @function verify
            * @memberof gaiaProto.FullJPInfoAck
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            FullJPInfoAck.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.value != null && message.hasOwnProperty("value")) if (typeof message.value !== "number") return "value: number expected";
              if (message.full != null && message.hasOwnProperty("full")) if (typeof message.full !== "number") return "full: number expected";
              if (message.minvip != null && message.hasOwnProperty("minvip")) if (!$util.isInteger(message.minvip)) return "minvip: integer expected";
              if (message.minbet != null && message.hasOwnProperty("minbet")) if (typeof message.minbet !== "number") return "minbet: number expected";
              return null;
            };
            /**
            * Creates a FullJPInfoAck message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof gaiaProto.FullJPInfoAck
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {gaiaProto.FullJPInfoAck} FullJPInfoAck
            */


            FullJPInfoAck.fromObject = function fromObject(object) {
              if (object instanceof $root.gaiaProto.FullJPInfoAck) return object;
              var message = new $root.gaiaProto.FullJPInfoAck();
              if (object.value != null) message.value = Number(object.value);
              if (object.full != null) message.full = Number(object.full);
              if (object.minvip != null) message.minvip = object.minvip | 0;
              if (object.minbet != null) message.minbet = Number(object.minbet);
              return message;
            };
            /**
            * Creates a plain object from a FullJPInfoAck message. Also converts values to other types if specified.
            * @function toObject
            * @memberof gaiaProto.FullJPInfoAck
            * @static
            * @param {gaiaProto.FullJPInfoAck} message FullJPInfoAck
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            FullJPInfoAck.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.value = 0;
                object.full = 0;
                object.minvip = 0;
                object.minbet = 0;
              }

              if (message.value != null && message.hasOwnProperty("value")) object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
              if (message.full != null && message.hasOwnProperty("full")) object.full = options.json && !isFinite(message.full) ? String(message.full) : message.full;
              if (message.minvip != null && message.hasOwnProperty("minvip")) object.minvip = message.minvip;
              if (message.minbet != null && message.hasOwnProperty("minbet")) object.minbet = options.json && !isFinite(message.minbet) ? String(message.minbet) : message.minbet;
              return object;
            };
            /**
            * Converts this FullJPInfoAck to JSON.
            * @function toJSON
            * @memberof gaiaProto.FullJPInfoAck
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            FullJPInfoAck.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return FullJPInfoAck;
          }();

          gaiaProto.FullJPInfoAllAck = function () {
            /**
            * Properties of a FullJPInfoAllAck.
            * @memberof gaiaProto
            * @interface IFullJPInfoAllAck
            * @property {number|null} [acktype] FullJPInfoAllAck acktype
            * @property {Array.<gaiaProto.IFullJPList>|null} [list] FullJPInfoAllAck list
            */

            /**
            * Constructs a new FullJPInfoAllAck.
            * @memberof gaiaProto
            * @classdesc Represents a FullJPInfoAllAck.
            * @implements IFullJPInfoAllAck
            * @constructor
            * @param {gaiaProto.IFullJPInfoAllAck=} [properties] Properties to set
            */
            function FullJPInfoAllAck(properties) {
              this.list = [];
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * FullJPInfoAllAck acktype.
            * @member {number} acktype
            * @memberof gaiaProto.FullJPInfoAllAck
            * @instance
            */


            FullJPInfoAllAck.prototype.acktype = 0;
            /**
            * FullJPInfoAllAck list.
            * @member {Array.<gaiaProto.IFullJPList>} list
            * @memberof gaiaProto.FullJPInfoAllAck
            * @instance
            */

            FullJPInfoAllAck.prototype.list = $util.emptyArray;
            /**
            * Creates a new FullJPInfoAllAck instance using the specified properties.
            * @function create
            * @memberof gaiaProto.FullJPInfoAllAck
            * @static
            * @param {gaiaProto.IFullJPInfoAllAck=} [properties] Properties to set
            * @returns {gaiaProto.FullJPInfoAllAck} FullJPInfoAllAck instance
            */

            FullJPInfoAllAck.create = function create(properties) {
              return new FullJPInfoAllAck(properties);
            };
            /**
            * Encodes the specified FullJPInfoAllAck message. Does not implicitly {@link gaiaProto.FullJPInfoAllAck.verify|verify} messages.
            * @function encode
            * @memberof gaiaProto.FullJPInfoAllAck
            * @static
            * @param {gaiaProto.IFullJPInfoAllAck} message FullJPInfoAllAck message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            FullJPInfoAllAck.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.acktype != null && Object.hasOwnProperty.call(message, "acktype")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.acktype);
              if (message.list != null && message.list.length) for (var i = 0; i < message.list.length; ++i) {
                $root.gaiaProto.FullJPList.encode(message.list[i], writer.uint32(
                /* id 2, wireType 2 =*/
                18).fork()).ldelim();
              }
              return writer;
            };
            /**
            * Encodes the specified FullJPInfoAllAck message, length delimited. Does not implicitly {@link gaiaProto.FullJPInfoAllAck.verify|verify} messages.
            * @function encodeDelimited
            * @memberof gaiaProto.FullJPInfoAllAck
            * @static
            * @param {gaiaProto.IFullJPInfoAllAck} message FullJPInfoAllAck message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            FullJPInfoAllAck.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a FullJPInfoAllAck message from the specified reader or buffer.
            * @function decode
            * @memberof gaiaProto.FullJPInfoAllAck
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {gaiaProto.FullJPInfoAllAck} FullJPInfoAllAck
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            FullJPInfoAllAck.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gaiaProto.FullJPInfoAllAck();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.acktype = reader.int32();
                    break;

                  case 2:
                    if (!(message.list && message.list.length)) message.list = [];
                    message.list.push($root.gaiaProto.FullJPList.decode(reader, reader.uint32()));
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a FullJPInfoAllAck message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof gaiaProto.FullJPInfoAllAck
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {gaiaProto.FullJPInfoAllAck} FullJPInfoAllAck
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            FullJPInfoAllAck.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a FullJPInfoAllAck message.
            * @function verify
            * @memberof gaiaProto.FullJPInfoAllAck
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            FullJPInfoAllAck.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.acktype != null && message.hasOwnProperty("acktype")) if (!$util.isInteger(message.acktype)) return "acktype: integer expected";

              if (message.list != null && message.hasOwnProperty("list")) {
                if (!Array.isArray(message.list)) return "list: array expected";

                for (var i = 0; i < message.list.length; ++i) {
                  var error = $root.gaiaProto.FullJPList.verify(message.list[i]);
                  if (error) return "list." + error;
                }
              }

              return null;
            };
            /**
            * Creates a FullJPInfoAllAck message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof gaiaProto.FullJPInfoAllAck
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {gaiaProto.FullJPInfoAllAck} FullJPInfoAllAck
            */


            FullJPInfoAllAck.fromObject = function fromObject(object) {
              if (object instanceof $root.gaiaProto.FullJPInfoAllAck) return object;
              var message = new $root.gaiaProto.FullJPInfoAllAck();
              if (object.acktype != null) message.acktype = object.acktype | 0;

              if (object.list) {
                if (!Array.isArray(object.list)) throw TypeError(".gaiaProto.FullJPInfoAllAck.list: array expected");
                message.list = [];

                for (var i = 0; i < object.list.length; ++i) {
                  if (typeof object.list[i] !== "object") throw TypeError(".gaiaProto.FullJPInfoAllAck.list: object expected");
                  message.list[i] = $root.gaiaProto.FullJPList.fromObject(object.list[i]);
                }
              }

              return message;
            };
            /**
            * Creates a plain object from a FullJPInfoAllAck message. Also converts values to other types if specified.
            * @function toObject
            * @memberof gaiaProto.FullJPInfoAllAck
            * @static
            * @param {gaiaProto.FullJPInfoAllAck} message FullJPInfoAllAck
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            FullJPInfoAllAck.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};
              if (options.arrays || options.defaults) object.list = [];
              if (options.defaults) object.acktype = 0;
              if (message.acktype != null && message.hasOwnProperty("acktype")) object.acktype = message.acktype;

              if (message.list && message.list.length) {
                object.list = [];

                for (var j = 0; j < message.list.length; ++j) {
                  object.list[j] = $root.gaiaProto.FullJPList.toObject(message.list[j], options);
                }
              }

              return object;
            };
            /**
            * Converts this FullJPInfoAllAck to JSON.
            * @function toJSON
            * @memberof gaiaProto.FullJPInfoAllAck
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            FullJPInfoAllAck.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return FullJPInfoAllAck;
          }();

          gaiaProto.FullJPList = function () {
            /**
            * Properties of a FullJPList.
            * @memberof gaiaProto
            * @interface IFullJPList
            * @property {number|null} [apiid] FullJPList apiid
            * @property {number|null} [gameid] FullJPList gameid
            * @property {number|null} [value] FullJPList value
            * @property {number|null} [full] FullJPList full
            */

            /**
            * Constructs a new FullJPList.
            * @memberof gaiaProto
            * @classdesc Represents a FullJPList.
            * @implements IFullJPList
            * @constructor
            * @param {gaiaProto.IFullJPList=} [properties] Properties to set
            */
            function FullJPList(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * FullJPList apiid.
            * @member {number} apiid
            * @memberof gaiaProto.FullJPList
            * @instance
            */


            FullJPList.prototype.apiid = 0;
            /**
            * FullJPList gameid.
            * @member {number} gameid
            * @memberof gaiaProto.FullJPList
            * @instance
            */

            FullJPList.prototype.gameid = 0;
            /**
            * FullJPList value.
            * @member {number} value
            * @memberof gaiaProto.FullJPList
            * @instance
            */

            FullJPList.prototype.value = 0;
            /**
            * FullJPList full.
            * @member {number} full
            * @memberof gaiaProto.FullJPList
            * @instance
            */

            FullJPList.prototype.full = 0;
            /**
            * Creates a new FullJPList instance using the specified properties.
            * @function create
            * @memberof gaiaProto.FullJPList
            * @static
            * @param {gaiaProto.IFullJPList=} [properties] Properties to set
            * @returns {gaiaProto.FullJPList} FullJPList instance
            */

            FullJPList.create = function create(properties) {
              return new FullJPList(properties);
            };
            /**
            * Encodes the specified FullJPList message. Does not implicitly {@link gaiaProto.FullJPList.verify|verify} messages.
            * @function encode
            * @memberof gaiaProto.FullJPList
            * @static
            * @param {gaiaProto.IFullJPList} message FullJPList message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            FullJPList.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.apiid != null && Object.hasOwnProperty.call(message, "apiid")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.apiid);
              if (message.gameid != null && Object.hasOwnProperty.call(message, "gameid")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int32(message.gameid);
              if (message.value != null && Object.hasOwnProperty.call(message, "value")) writer.uint32(
              /* id 3, wireType 1 =*/
              25)["double"](message.value);
              if (message.full != null && Object.hasOwnProperty.call(message, "full")) writer.uint32(
              /* id 4, wireType 1 =*/
              33)["double"](message.full);
              return writer;
            };
            /**
            * Encodes the specified FullJPList message, length delimited. Does not implicitly {@link gaiaProto.FullJPList.verify|verify} messages.
            * @function encodeDelimited
            * @memberof gaiaProto.FullJPList
            * @static
            * @param {gaiaProto.IFullJPList} message FullJPList message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            FullJPList.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a FullJPList message from the specified reader or buffer.
            * @function decode
            * @memberof gaiaProto.FullJPList
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {gaiaProto.FullJPList} FullJPList
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            FullJPList.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gaiaProto.FullJPList();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.apiid = reader.int32();
                    break;

                  case 2:
                    message.gameid = reader.int32();
                    break;

                  case 3:
                    message.value = reader["double"]();
                    break;

                  case 4:
                    message.full = reader["double"]();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a FullJPList message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof gaiaProto.FullJPList
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {gaiaProto.FullJPList} FullJPList
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            FullJPList.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a FullJPList message.
            * @function verify
            * @memberof gaiaProto.FullJPList
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            FullJPList.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.apiid != null && message.hasOwnProperty("apiid")) if (!$util.isInteger(message.apiid)) return "apiid: integer expected";
              if (message.gameid != null && message.hasOwnProperty("gameid")) if (!$util.isInteger(message.gameid)) return "gameid: integer expected";
              if (message.value != null && message.hasOwnProperty("value")) if (typeof message.value !== "number") return "value: number expected";
              if (message.full != null && message.hasOwnProperty("full")) if (typeof message.full !== "number") return "full: number expected";
              return null;
            };
            /**
            * Creates a FullJPList message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof gaiaProto.FullJPList
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {gaiaProto.FullJPList} FullJPList
            */


            FullJPList.fromObject = function fromObject(object) {
              if (object instanceof $root.gaiaProto.FullJPList) return object;
              var message = new $root.gaiaProto.FullJPList();
              if (object.apiid != null) message.apiid = object.apiid | 0;
              if (object.gameid != null) message.gameid = object.gameid | 0;
              if (object.value != null) message.value = Number(object.value);
              if (object.full != null) message.full = Number(object.full);
              return message;
            };
            /**
            * Creates a plain object from a FullJPList message. Also converts values to other types if specified.
            * @function toObject
            * @memberof gaiaProto.FullJPList
            * @static
            * @param {gaiaProto.FullJPList} message FullJPList
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            FullJPList.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.apiid = 0;
                object.gameid = 0;
                object.value = 0;
                object.full = 0;
              }

              if (message.apiid != null && message.hasOwnProperty("apiid")) object.apiid = message.apiid;
              if (message.gameid != null && message.hasOwnProperty("gameid")) object.gameid = message.gameid;
              if (message.value != null && message.hasOwnProperty("value")) object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
              if (message.full != null && message.hasOwnProperty("full")) object.full = options.json && !isFinite(message.full) ? String(message.full) : message.full;
              return object;
            };
            /**
            * Converts this FullJPList to JSON.
            * @function toJSON
            * @memberof gaiaProto.FullJPList
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            FullJPList.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return FullJPList;
          }();

          gaiaProto.FullJPHistoryAck = function () {
            /**
            * Properties of a FullJPHistoryAck.
            * @memberof gaiaProto
            * @interface IFullJPHistoryAck
            * @property {Array.<gaiaProto.IFullJPHistoryData>|null} [list] FullJPHistoryAck list
            */

            /**
            * Constructs a new FullJPHistoryAck.
            * @memberof gaiaProto
            * @classdesc Represents a FullJPHistoryAck.
            * @implements IFullJPHistoryAck
            * @constructor
            * @param {gaiaProto.IFullJPHistoryAck=} [properties] Properties to set
            */
            function FullJPHistoryAck(properties) {
              this.list = [];
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * FullJPHistoryAck list.
            * @member {Array.<gaiaProto.IFullJPHistoryData>} list
            * @memberof gaiaProto.FullJPHistoryAck
            * @instance
            */


            FullJPHistoryAck.prototype.list = $util.emptyArray;
            /**
            * Creates a new FullJPHistoryAck instance using the specified properties.
            * @function create
            * @memberof gaiaProto.FullJPHistoryAck
            * @static
            * @param {gaiaProto.IFullJPHistoryAck=} [properties] Properties to set
            * @returns {gaiaProto.FullJPHistoryAck} FullJPHistoryAck instance
            */

            FullJPHistoryAck.create = function create(properties) {
              return new FullJPHistoryAck(properties);
            };
            /**
            * Encodes the specified FullJPHistoryAck message. Does not implicitly {@link gaiaProto.FullJPHistoryAck.verify|verify} messages.
            * @function encode
            * @memberof gaiaProto.FullJPHistoryAck
            * @static
            * @param {gaiaProto.IFullJPHistoryAck} message FullJPHistoryAck message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            FullJPHistoryAck.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.list != null && message.list.length) for (var i = 0; i < message.list.length; ++i) {
                $root.gaiaProto.FullJPHistoryData.encode(message.list[i], writer.uint32(
                /* id 1, wireType 2 =*/
                10).fork()).ldelim();
              }
              return writer;
            };
            /**
            * Encodes the specified FullJPHistoryAck message, length delimited. Does not implicitly {@link gaiaProto.FullJPHistoryAck.verify|verify} messages.
            * @function encodeDelimited
            * @memberof gaiaProto.FullJPHistoryAck
            * @static
            * @param {gaiaProto.IFullJPHistoryAck} message FullJPHistoryAck message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            FullJPHistoryAck.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a FullJPHistoryAck message from the specified reader or buffer.
            * @function decode
            * @memberof gaiaProto.FullJPHistoryAck
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {gaiaProto.FullJPHistoryAck} FullJPHistoryAck
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            FullJPHistoryAck.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gaiaProto.FullJPHistoryAck();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    if (!(message.list && message.list.length)) message.list = [];
                    message.list.push($root.gaiaProto.FullJPHistoryData.decode(reader, reader.uint32()));
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a FullJPHistoryAck message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof gaiaProto.FullJPHistoryAck
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {gaiaProto.FullJPHistoryAck} FullJPHistoryAck
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            FullJPHistoryAck.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a FullJPHistoryAck message.
            * @function verify
            * @memberof gaiaProto.FullJPHistoryAck
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            FullJPHistoryAck.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";

              if (message.list != null && message.hasOwnProperty("list")) {
                if (!Array.isArray(message.list)) return "list: array expected";

                for (var i = 0; i < message.list.length; ++i) {
                  var error = $root.gaiaProto.FullJPHistoryData.verify(message.list[i]);
                  if (error) return "list." + error;
                }
              }

              return null;
            };
            /**
            * Creates a FullJPHistoryAck message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof gaiaProto.FullJPHistoryAck
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {gaiaProto.FullJPHistoryAck} FullJPHistoryAck
            */


            FullJPHistoryAck.fromObject = function fromObject(object) {
              if (object instanceof $root.gaiaProto.FullJPHistoryAck) return object;
              var message = new $root.gaiaProto.FullJPHistoryAck();

              if (object.list) {
                if (!Array.isArray(object.list)) throw TypeError(".gaiaProto.FullJPHistoryAck.list: array expected");
                message.list = [];

                for (var i = 0; i < object.list.length; ++i) {
                  if (typeof object.list[i] !== "object") throw TypeError(".gaiaProto.FullJPHistoryAck.list: object expected");
                  message.list[i] = $root.gaiaProto.FullJPHistoryData.fromObject(object.list[i]);
                }
              }

              return message;
            };
            /**
            * Creates a plain object from a FullJPHistoryAck message. Also converts values to other types if specified.
            * @function toObject
            * @memberof gaiaProto.FullJPHistoryAck
            * @static
            * @param {gaiaProto.FullJPHistoryAck} message FullJPHistoryAck
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            FullJPHistoryAck.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};
              if (options.arrays || options.defaults) object.list = [];

              if (message.list && message.list.length) {
                object.list = [];

                for (var j = 0; j < message.list.length; ++j) {
                  object.list[j] = $root.gaiaProto.FullJPHistoryData.toObject(message.list[j], options);
                }
              }

              return object;
            };
            /**
            * Converts this FullJPHistoryAck to JSON.
            * @function toJSON
            * @memberof gaiaProto.FullJPHistoryAck
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            FullJPHistoryAck.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return FullJPHistoryAck;
          }();

          gaiaProto.FullJPHistoryData = function () {
            /**
            * Properties of a FullJPHistoryData.
            * @memberof gaiaProto
            * @interface IFullJPHistoryData
            * @property {string|null} [winner] FullJPHistoryData winner
            * @property {string|null} [nickname] FullJPHistoryData nickname
            * @property {number|null} [win] FullJPHistoryData win
            * @property {number|null} [time] FullJPHistoryData time
            */

            /**
            * Constructs a new FullJPHistoryData.
            * @memberof gaiaProto
            * @classdesc Represents a FullJPHistoryData.
            * @implements IFullJPHistoryData
            * @constructor
            * @param {gaiaProto.IFullJPHistoryData=} [properties] Properties to set
            */
            function FullJPHistoryData(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * FullJPHistoryData winner.
            * @member {string} winner
            * @memberof gaiaProto.FullJPHistoryData
            * @instance
            */


            FullJPHistoryData.prototype.winner = "";
            /**
            * FullJPHistoryData nickname.
            * @member {string} nickname
            * @memberof gaiaProto.FullJPHistoryData
            * @instance
            */

            FullJPHistoryData.prototype.nickname = "";
            /**
            * FullJPHistoryData win.
            * @member {number} win
            * @memberof gaiaProto.FullJPHistoryData
            * @instance
            */

            FullJPHistoryData.prototype.win = 0;
            /**
            * FullJPHistoryData time.
            * @member {number} time
            * @memberof gaiaProto.FullJPHistoryData
            * @instance
            */

            FullJPHistoryData.prototype.time = 0;
            /**
            * Creates a new FullJPHistoryData instance using the specified properties.
            * @function create
            * @memberof gaiaProto.FullJPHistoryData
            * @static
            * @param {gaiaProto.IFullJPHistoryData=} [properties] Properties to set
            * @returns {gaiaProto.FullJPHistoryData} FullJPHistoryData instance
            */

            FullJPHistoryData.create = function create(properties) {
              return new FullJPHistoryData(properties);
            };
            /**
            * Encodes the specified FullJPHistoryData message. Does not implicitly {@link gaiaProto.FullJPHistoryData.verify|verify} messages.
            * @function encode
            * @memberof gaiaProto.FullJPHistoryData
            * @static
            * @param {gaiaProto.IFullJPHistoryData} message FullJPHistoryData message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            FullJPHistoryData.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.winner != null && Object.hasOwnProperty.call(message, "winner")) writer.uint32(
              /* id 1, wireType 2 =*/
              10).string(message.winner);
              if (message.nickname != null && Object.hasOwnProperty.call(message, "nickname")) writer.uint32(
              /* id 2, wireType 2 =*/
              18).string(message.nickname);
              if (message.win != null && Object.hasOwnProperty.call(message, "win")) writer.uint32(
              /* id 3, wireType 1 =*/
              25)["double"](message.win);
              if (message.time != null && Object.hasOwnProperty.call(message, "time")) writer.uint32(
              /* id 4, wireType 0 =*/
              32).int32(message.time);
              return writer;
            };
            /**
            * Encodes the specified FullJPHistoryData message, length delimited. Does not implicitly {@link gaiaProto.FullJPHistoryData.verify|verify} messages.
            * @function encodeDelimited
            * @memberof gaiaProto.FullJPHistoryData
            * @static
            * @param {gaiaProto.IFullJPHistoryData} message FullJPHistoryData message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            FullJPHistoryData.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a FullJPHistoryData message from the specified reader or buffer.
            * @function decode
            * @memberof gaiaProto.FullJPHistoryData
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {gaiaProto.FullJPHistoryData} FullJPHistoryData
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            FullJPHistoryData.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gaiaProto.FullJPHistoryData();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.winner = reader.string();
                    break;

                  case 2:
                    message.nickname = reader.string();
                    break;

                  case 3:
                    message.win = reader["double"]();
                    break;

                  case 4:
                    message.time = reader.int32();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a FullJPHistoryData message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof gaiaProto.FullJPHistoryData
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {gaiaProto.FullJPHistoryData} FullJPHistoryData
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            FullJPHistoryData.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a FullJPHistoryData message.
            * @function verify
            * @memberof gaiaProto.FullJPHistoryData
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            FullJPHistoryData.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.winner != null && message.hasOwnProperty("winner")) if (!$util.isString(message.winner)) return "winner: string expected";
              if (message.nickname != null && message.hasOwnProperty("nickname")) if (!$util.isString(message.nickname)) return "nickname: string expected";
              if (message.win != null && message.hasOwnProperty("win")) if (typeof message.win !== "number") return "win: number expected";
              if (message.time != null && message.hasOwnProperty("time")) if (!$util.isInteger(message.time)) return "time: integer expected";
              return null;
            };
            /**
            * Creates a FullJPHistoryData message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof gaiaProto.FullJPHistoryData
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {gaiaProto.FullJPHistoryData} FullJPHistoryData
            */


            FullJPHistoryData.fromObject = function fromObject(object) {
              if (object instanceof $root.gaiaProto.FullJPHistoryData) return object;
              var message = new $root.gaiaProto.FullJPHistoryData();
              if (object.winner != null) message.winner = String(object.winner);
              if (object.nickname != null) message.nickname = String(object.nickname);
              if (object.win != null) message.win = Number(object.win);
              if (object.time != null) message.time = object.time | 0;
              return message;
            };
            /**
            * Creates a plain object from a FullJPHistoryData message. Also converts values to other types if specified.
            * @function toObject
            * @memberof gaiaProto.FullJPHistoryData
            * @static
            * @param {gaiaProto.FullJPHistoryData} message FullJPHistoryData
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            FullJPHistoryData.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.winner = "";
                object.nickname = "";
                object.win = 0;
                object.time = 0;
              }

              if (message.winner != null && message.hasOwnProperty("winner")) object.winner = message.winner;
              if (message.nickname != null && message.hasOwnProperty("nickname")) object.nickname = message.nickname;
              if (message.win != null && message.hasOwnProperty("win")) object.win = options.json && !isFinite(message.win) ? String(message.win) : message.win;
              if (message.time != null && message.hasOwnProperty("time")) object.time = message.time;
              return object;
            };
            /**
            * Converts this FullJPHistoryData to JSON.
            * @function toJSON
            * @memberof gaiaProto.FullJPHistoryData
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            FullJPHistoryData.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return FullJPHistoryData;
          }();

          gaiaProto.ItemListReq = function () {
            /**
            * Properties of an ItemListReq.
            * @memberof gaiaProto
            * @interface IItemListReq
            * @property {number|null} [aid] ItemListReq aid
            * @property {string|null} [token] ItemListReq token
            * @property {number|null} [lang] ItemListReq lang
            * @property {number|null} [currencynumber] ItemListReq currencynumber
            */

            /**
            * Constructs a new ItemListReq.
            * @memberof gaiaProto
            * @classdesc Represents an ItemListReq.
            * @implements IItemListReq
            * @constructor
            * @param {gaiaProto.IItemListReq=} [properties] Properties to set
            */
            function ItemListReq(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * ItemListReq aid.
            * @member {number} aid
            * @memberof gaiaProto.ItemListReq
            * @instance
            */


            ItemListReq.prototype.aid = 0;
            /**
            * ItemListReq token.
            * @member {string} token
            * @memberof gaiaProto.ItemListReq
            * @instance
            */

            ItemListReq.prototype.token = "";
            /**
            * ItemListReq lang.
            * @member {number} lang
            * @memberof gaiaProto.ItemListReq
            * @instance
            */

            ItemListReq.prototype.lang = 0;
            /**
            * ItemListReq currencynumber.
            * @member {number} currencynumber
            * @memberof gaiaProto.ItemListReq
            * @instance
            */

            ItemListReq.prototype.currencynumber = 0;
            /**
            * Creates a new ItemListReq instance using the specified properties.
            * @function create
            * @memberof gaiaProto.ItemListReq
            * @static
            * @param {gaiaProto.IItemListReq=} [properties] Properties to set
            * @returns {gaiaProto.ItemListReq} ItemListReq instance
            */

            ItemListReq.create = function create(properties) {
              return new ItemListReq(properties);
            };
            /**
            * Encodes the specified ItemListReq message. Does not implicitly {@link gaiaProto.ItemListReq.verify|verify} messages.
            * @function encode
            * @memberof gaiaProto.ItemListReq
            * @static
            * @param {gaiaProto.IItemListReq} message ItemListReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            ItemListReq.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.aid != null && Object.hasOwnProperty.call(message, "aid")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.aid);
              if (message.token != null && Object.hasOwnProperty.call(message, "token")) writer.uint32(
              /* id 2, wireType 2 =*/
              18).string(message.token);
              if (message.lang != null && Object.hasOwnProperty.call(message, "lang")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.lang);
              if (message.currencynumber != null && Object.hasOwnProperty.call(message, "currencynumber")) writer.uint32(
              /* id 4, wireType 0 =*/
              32).int32(message.currencynumber);
              return writer;
            };
            /**
            * Encodes the specified ItemListReq message, length delimited. Does not implicitly {@link gaiaProto.ItemListReq.verify|verify} messages.
            * @function encodeDelimited
            * @memberof gaiaProto.ItemListReq
            * @static
            * @param {gaiaProto.IItemListReq} message ItemListReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            ItemListReq.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes an ItemListReq message from the specified reader or buffer.
            * @function decode
            * @memberof gaiaProto.ItemListReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {gaiaProto.ItemListReq} ItemListReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            ItemListReq.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gaiaProto.ItemListReq();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.aid = reader.int32();
                    break;

                  case 2:
                    message.token = reader.string();
                    break;

                  case 3:
                    message.lang = reader.int32();
                    break;

                  case 4:
                    message.currencynumber = reader.int32();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes an ItemListReq message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof gaiaProto.ItemListReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {gaiaProto.ItemListReq} ItemListReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            ItemListReq.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies an ItemListReq message.
            * @function verify
            * @memberof gaiaProto.ItemListReq
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            ItemListReq.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.aid != null && message.hasOwnProperty("aid")) if (!$util.isInteger(message.aid)) return "aid: integer expected";
              if (message.token != null && message.hasOwnProperty("token")) if (!$util.isString(message.token)) return "token: string expected";
              if (message.lang != null && message.hasOwnProperty("lang")) if (!$util.isInteger(message.lang)) return "lang: integer expected";
              if (message.currencynumber != null && message.hasOwnProperty("currencynumber")) if (!$util.isInteger(message.currencynumber)) return "currencynumber: integer expected";
              return null;
            };
            /**
            * Creates an ItemListReq message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof gaiaProto.ItemListReq
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {gaiaProto.ItemListReq} ItemListReq
            */


            ItemListReq.fromObject = function fromObject(object) {
              if (object instanceof $root.gaiaProto.ItemListReq) return object;
              var message = new $root.gaiaProto.ItemListReq();
              if (object.aid != null) message.aid = object.aid | 0;
              if (object.token != null) message.token = String(object.token);
              if (object.lang != null) message.lang = object.lang | 0;
              if (object.currencynumber != null) message.currencynumber = object.currencynumber | 0;
              return message;
            };
            /**
            * Creates a plain object from an ItemListReq message. Also converts values to other types if specified.
            * @function toObject
            * @memberof gaiaProto.ItemListReq
            * @static
            * @param {gaiaProto.ItemListReq} message ItemListReq
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            ItemListReq.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.aid = 0;
                object.token = "";
                object.lang = 0;
                object.currencynumber = 0;
              }

              if (message.aid != null && message.hasOwnProperty("aid")) object.aid = message.aid;
              if (message.token != null && message.hasOwnProperty("token")) object.token = message.token;
              if (message.lang != null && message.hasOwnProperty("lang")) object.lang = message.lang;
              if (message.currencynumber != null && message.hasOwnProperty("currencynumber")) object.currencynumber = message.currencynumber;
              return object;
            };
            /**
            * Converts this ItemListReq to JSON.
            * @function toJSON
            * @memberof gaiaProto.ItemListReq
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            ItemListReq.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ItemListReq;
          }();

          gaiaProto.ItemAllGameReq = function () {
            /**
            * Properties of an ItemAllGameReq.
            * @memberof gaiaProto
            * @interface IItemAllGameReq
            * @property {number|null} [aid] ItemAllGameReq aid
            * @property {string|null} [token] ItemAllGameReq token
            * @property {number|null} [lang] ItemAllGameReq lang
            * @property {number|null} [currencynumber] ItemAllGameReq currencynumber
            */

            /**
            * Constructs a new ItemAllGameReq.
            * @memberof gaiaProto
            * @classdesc Represents an ItemAllGameReq.
            * @implements IItemAllGameReq
            * @constructor
            * @param {gaiaProto.IItemAllGameReq=} [properties] Properties to set
            */
            function ItemAllGameReq(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * ItemAllGameReq aid.
            * @member {number} aid
            * @memberof gaiaProto.ItemAllGameReq
            * @instance
            */


            ItemAllGameReq.prototype.aid = 0;
            /**
            * ItemAllGameReq token.
            * @member {string} token
            * @memberof gaiaProto.ItemAllGameReq
            * @instance
            */

            ItemAllGameReq.prototype.token = "";
            /**
            * ItemAllGameReq lang.
            * @member {number} lang
            * @memberof gaiaProto.ItemAllGameReq
            * @instance
            */

            ItemAllGameReq.prototype.lang = 0;
            /**
            * ItemAllGameReq currencynumber.
            * @member {number} currencynumber
            * @memberof gaiaProto.ItemAllGameReq
            * @instance
            */

            ItemAllGameReq.prototype.currencynumber = 0;
            /**
            * Creates a new ItemAllGameReq instance using the specified properties.
            * @function create
            * @memberof gaiaProto.ItemAllGameReq
            * @static
            * @param {gaiaProto.IItemAllGameReq=} [properties] Properties to set
            * @returns {gaiaProto.ItemAllGameReq} ItemAllGameReq instance
            */

            ItemAllGameReq.create = function create(properties) {
              return new ItemAllGameReq(properties);
            };
            /**
            * Encodes the specified ItemAllGameReq message. Does not implicitly {@link gaiaProto.ItemAllGameReq.verify|verify} messages.
            * @function encode
            * @memberof gaiaProto.ItemAllGameReq
            * @static
            * @param {gaiaProto.IItemAllGameReq} message ItemAllGameReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            ItemAllGameReq.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.aid != null && Object.hasOwnProperty.call(message, "aid")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.aid);
              if (message.token != null && Object.hasOwnProperty.call(message, "token")) writer.uint32(
              /* id 2, wireType 2 =*/
              18).string(message.token);
              if (message.lang != null && Object.hasOwnProperty.call(message, "lang")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.lang);
              if (message.currencynumber != null && Object.hasOwnProperty.call(message, "currencynumber")) writer.uint32(
              /* id 4, wireType 0 =*/
              32).int32(message.currencynumber);
              return writer;
            };
            /**
            * Encodes the specified ItemAllGameReq message, length delimited. Does not implicitly {@link gaiaProto.ItemAllGameReq.verify|verify} messages.
            * @function encodeDelimited
            * @memberof gaiaProto.ItemAllGameReq
            * @static
            * @param {gaiaProto.IItemAllGameReq} message ItemAllGameReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            ItemAllGameReq.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes an ItemAllGameReq message from the specified reader or buffer.
            * @function decode
            * @memberof gaiaProto.ItemAllGameReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {gaiaProto.ItemAllGameReq} ItemAllGameReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            ItemAllGameReq.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gaiaProto.ItemAllGameReq();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.aid = reader.int32();
                    break;

                  case 2:
                    message.token = reader.string();
                    break;

                  case 3:
                    message.lang = reader.int32();
                    break;

                  case 4:
                    message.currencynumber = reader.int32();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes an ItemAllGameReq message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof gaiaProto.ItemAllGameReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {gaiaProto.ItemAllGameReq} ItemAllGameReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            ItemAllGameReq.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies an ItemAllGameReq message.
            * @function verify
            * @memberof gaiaProto.ItemAllGameReq
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            ItemAllGameReq.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.aid != null && message.hasOwnProperty("aid")) if (!$util.isInteger(message.aid)) return "aid: integer expected";
              if (message.token != null && message.hasOwnProperty("token")) if (!$util.isString(message.token)) return "token: string expected";
              if (message.lang != null && message.hasOwnProperty("lang")) if (!$util.isInteger(message.lang)) return "lang: integer expected";
              if (message.currencynumber != null && message.hasOwnProperty("currencynumber")) if (!$util.isInteger(message.currencynumber)) return "currencynumber: integer expected";
              return null;
            };
            /**
            * Creates an ItemAllGameReq message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof gaiaProto.ItemAllGameReq
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {gaiaProto.ItemAllGameReq} ItemAllGameReq
            */


            ItemAllGameReq.fromObject = function fromObject(object) {
              if (object instanceof $root.gaiaProto.ItemAllGameReq) return object;
              var message = new $root.gaiaProto.ItemAllGameReq();
              if (object.aid != null) message.aid = object.aid | 0;
              if (object.token != null) message.token = String(object.token);
              if (object.lang != null) message.lang = object.lang | 0;
              if (object.currencynumber != null) message.currencynumber = object.currencynumber | 0;
              return message;
            };
            /**
            * Creates a plain object from an ItemAllGameReq message. Also converts values to other types if specified.
            * @function toObject
            * @memberof gaiaProto.ItemAllGameReq
            * @static
            * @param {gaiaProto.ItemAllGameReq} message ItemAllGameReq
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            ItemAllGameReq.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.aid = 0;
                object.token = "";
                object.lang = 0;
                object.currencynumber = 0;
              }

              if (message.aid != null && message.hasOwnProperty("aid")) object.aid = message.aid;
              if (message.token != null && message.hasOwnProperty("token")) object.token = message.token;
              if (message.lang != null && message.hasOwnProperty("lang")) object.lang = message.lang;
              if (message.currencynumber != null && message.hasOwnProperty("currencynumber")) object.currencynumber = message.currencynumber;
              return object;
            };
            /**
            * Converts this ItemAllGameReq to JSON.
            * @function toJSON
            * @memberof gaiaProto.ItemAllGameReq
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            ItemAllGameReq.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ItemAllGameReq;
          }();

          gaiaProto.ItemUseCardReq = function () {
            /**
            * Properties of an ItemUseCardReq.
            * @memberof gaiaProto
            * @interface IItemUseCardReq
            * @property {number|null} [aid] ItemUseCardReq aid
            * @property {string|null} [token] ItemUseCardReq token
            * @property {number|null} [currencynumber] ItemUseCardReq currencynumber
            * @property {string|null} [itemindex] ItemUseCardReq itemindex
            * @property {string|null} [itemid] ItemUseCardReq itemid
            * @property {string|null} [amount] ItemUseCardReq amount
            */

            /**
            * Constructs a new ItemUseCardReq.
            * @memberof gaiaProto
            * @classdesc Represents an ItemUseCardReq.
            * @implements IItemUseCardReq
            * @constructor
            * @param {gaiaProto.IItemUseCardReq=} [properties] Properties to set
            */
            function ItemUseCardReq(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * ItemUseCardReq aid.
            * @member {number} aid
            * @memberof gaiaProto.ItemUseCardReq
            * @instance
            */


            ItemUseCardReq.prototype.aid = 0;
            /**
            * ItemUseCardReq token.
            * @member {string} token
            * @memberof gaiaProto.ItemUseCardReq
            * @instance
            */

            ItemUseCardReq.prototype.token = "";
            /**
            * ItemUseCardReq currencynumber.
            * @member {number} currencynumber
            * @memberof gaiaProto.ItemUseCardReq
            * @instance
            */

            ItemUseCardReq.prototype.currencynumber = 0;
            /**
            * ItemUseCardReq itemindex.
            * @member {string} itemindex
            * @memberof gaiaProto.ItemUseCardReq
            * @instance
            */

            ItemUseCardReq.prototype.itemindex = "";
            /**
            * ItemUseCardReq itemid.
            * @member {string} itemid
            * @memberof gaiaProto.ItemUseCardReq
            * @instance
            */

            ItemUseCardReq.prototype.itemid = "";
            /**
            * ItemUseCardReq amount.
            * @member {string} amount
            * @memberof gaiaProto.ItemUseCardReq
            * @instance
            */

            ItemUseCardReq.prototype.amount = "";
            /**
            * Creates a new ItemUseCardReq instance using the specified properties.
            * @function create
            * @memberof gaiaProto.ItemUseCardReq
            * @static
            * @param {gaiaProto.IItemUseCardReq=} [properties] Properties to set
            * @returns {gaiaProto.ItemUseCardReq} ItemUseCardReq instance
            */

            ItemUseCardReq.create = function create(properties) {
              return new ItemUseCardReq(properties);
            };
            /**
            * Encodes the specified ItemUseCardReq message. Does not implicitly {@link gaiaProto.ItemUseCardReq.verify|verify} messages.
            * @function encode
            * @memberof gaiaProto.ItemUseCardReq
            * @static
            * @param {gaiaProto.IItemUseCardReq} message ItemUseCardReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            ItemUseCardReq.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.aid != null && Object.hasOwnProperty.call(message, "aid")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.aid);
              if (message.token != null && Object.hasOwnProperty.call(message, "token")) writer.uint32(
              /* id 2, wireType 2 =*/
              18).string(message.token);
              if (message.currencynumber != null && Object.hasOwnProperty.call(message, "currencynumber")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.currencynumber);
              if (message.itemindex != null && Object.hasOwnProperty.call(message, "itemindex")) writer.uint32(
              /* id 4, wireType 2 =*/
              34).string(message.itemindex);
              if (message.itemid != null && Object.hasOwnProperty.call(message, "itemid")) writer.uint32(
              /* id 5, wireType 2 =*/
              42).string(message.itemid);
              if (message.amount != null && Object.hasOwnProperty.call(message, "amount")) writer.uint32(
              /* id 6, wireType 2 =*/
              50).string(message.amount);
              return writer;
            };
            /**
            * Encodes the specified ItemUseCardReq message, length delimited. Does not implicitly {@link gaiaProto.ItemUseCardReq.verify|verify} messages.
            * @function encodeDelimited
            * @memberof gaiaProto.ItemUseCardReq
            * @static
            * @param {gaiaProto.IItemUseCardReq} message ItemUseCardReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            ItemUseCardReq.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes an ItemUseCardReq message from the specified reader or buffer.
            * @function decode
            * @memberof gaiaProto.ItemUseCardReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {gaiaProto.ItemUseCardReq} ItemUseCardReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            ItemUseCardReq.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gaiaProto.ItemUseCardReq();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.aid = reader.int32();
                    break;

                  case 2:
                    message.token = reader.string();
                    break;

                  case 3:
                    message.currencynumber = reader.int32();
                    break;

                  case 4:
                    message.itemindex = reader.string();
                    break;

                  case 5:
                    message.itemid = reader.string();
                    break;

                  case 6:
                    message.amount = reader.string();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes an ItemUseCardReq message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof gaiaProto.ItemUseCardReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {gaiaProto.ItemUseCardReq} ItemUseCardReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            ItemUseCardReq.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies an ItemUseCardReq message.
            * @function verify
            * @memberof gaiaProto.ItemUseCardReq
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            ItemUseCardReq.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.aid != null && message.hasOwnProperty("aid")) if (!$util.isInteger(message.aid)) return "aid: integer expected";
              if (message.token != null && message.hasOwnProperty("token")) if (!$util.isString(message.token)) return "token: string expected";
              if (message.currencynumber != null && message.hasOwnProperty("currencynumber")) if (!$util.isInteger(message.currencynumber)) return "currencynumber: integer expected";
              if (message.itemindex != null && message.hasOwnProperty("itemindex")) if (!$util.isString(message.itemindex)) return "itemindex: string expected";
              if (message.itemid != null && message.hasOwnProperty("itemid")) if (!$util.isString(message.itemid)) return "itemid: string expected";
              if (message.amount != null && message.hasOwnProperty("amount")) if (!$util.isString(message.amount)) return "amount: string expected";
              return null;
            };
            /**
            * Creates an ItemUseCardReq message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof gaiaProto.ItemUseCardReq
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {gaiaProto.ItemUseCardReq} ItemUseCardReq
            */


            ItemUseCardReq.fromObject = function fromObject(object) {
              if (object instanceof $root.gaiaProto.ItemUseCardReq) return object;
              var message = new $root.gaiaProto.ItemUseCardReq();
              if (object.aid != null) message.aid = object.aid | 0;
              if (object.token != null) message.token = String(object.token);
              if (object.currencynumber != null) message.currencynumber = object.currencynumber | 0;
              if (object.itemindex != null) message.itemindex = String(object.itemindex);
              if (object.itemid != null) message.itemid = String(object.itemid);
              if (object.amount != null) message.amount = String(object.amount);
              return message;
            };
            /**
            * Creates a plain object from an ItemUseCardReq message. Also converts values to other types if specified.
            * @function toObject
            * @memberof gaiaProto.ItemUseCardReq
            * @static
            * @param {gaiaProto.ItemUseCardReq} message ItemUseCardReq
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            ItemUseCardReq.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.aid = 0;
                object.token = "";
                object.currencynumber = 0;
                object.itemindex = "";
                object.itemid = "";
                object.amount = "";
              }

              if (message.aid != null && message.hasOwnProperty("aid")) object.aid = message.aid;
              if (message.token != null && message.hasOwnProperty("token")) object.token = message.token;
              if (message.currencynumber != null && message.hasOwnProperty("currencynumber")) object.currencynumber = message.currencynumber;
              if (message.itemindex != null && message.hasOwnProperty("itemindex")) object.itemindex = message.itemindex;
              if (message.itemid != null && message.hasOwnProperty("itemid")) object.itemid = message.itemid;
              if (message.amount != null && message.hasOwnProperty("amount")) object.amount = message.amount;
              return object;
            };
            /**
            * Converts this ItemUseCardReq to JSON.
            * @function toJSON
            * @memberof gaiaProto.ItemUseCardReq
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            ItemUseCardReq.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ItemUseCardReq;
          }();

          gaiaProto.ItemCheckNewReq = function () {
            /**
            * Properties of an ItemCheckNewReq.
            * @memberof gaiaProto
            * @interface IItemCheckNewReq
            * @property {number|null} [aid] ItemCheckNewReq aid
            * @property {string|null} [token] ItemCheckNewReq token
            */

            /**
            * Constructs a new ItemCheckNewReq.
            * @memberof gaiaProto
            * @classdesc Represents an ItemCheckNewReq.
            * @implements IItemCheckNewReq
            * @constructor
            * @param {gaiaProto.IItemCheckNewReq=} [properties] Properties to set
            */
            function ItemCheckNewReq(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * ItemCheckNewReq aid.
            * @member {number} aid
            * @memberof gaiaProto.ItemCheckNewReq
            * @instance
            */


            ItemCheckNewReq.prototype.aid = 0;
            /**
            * ItemCheckNewReq token.
            * @member {string} token
            * @memberof gaiaProto.ItemCheckNewReq
            * @instance
            */

            ItemCheckNewReq.prototype.token = "";
            /**
            * Creates a new ItemCheckNewReq instance using the specified properties.
            * @function create
            * @memberof gaiaProto.ItemCheckNewReq
            * @static
            * @param {gaiaProto.IItemCheckNewReq=} [properties] Properties to set
            * @returns {gaiaProto.ItemCheckNewReq} ItemCheckNewReq instance
            */

            ItemCheckNewReq.create = function create(properties) {
              return new ItemCheckNewReq(properties);
            };
            /**
            * Encodes the specified ItemCheckNewReq message. Does not implicitly {@link gaiaProto.ItemCheckNewReq.verify|verify} messages.
            * @function encode
            * @memberof gaiaProto.ItemCheckNewReq
            * @static
            * @param {gaiaProto.IItemCheckNewReq} message ItemCheckNewReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            ItemCheckNewReq.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.aid != null && Object.hasOwnProperty.call(message, "aid")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.aid);
              if (message.token != null && Object.hasOwnProperty.call(message, "token")) writer.uint32(
              /* id 2, wireType 2 =*/
              18).string(message.token);
              return writer;
            };
            /**
            * Encodes the specified ItemCheckNewReq message, length delimited. Does not implicitly {@link gaiaProto.ItemCheckNewReq.verify|verify} messages.
            * @function encodeDelimited
            * @memberof gaiaProto.ItemCheckNewReq
            * @static
            * @param {gaiaProto.IItemCheckNewReq} message ItemCheckNewReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            ItemCheckNewReq.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes an ItemCheckNewReq message from the specified reader or buffer.
            * @function decode
            * @memberof gaiaProto.ItemCheckNewReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {gaiaProto.ItemCheckNewReq} ItemCheckNewReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            ItemCheckNewReq.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gaiaProto.ItemCheckNewReq();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.aid = reader.int32();
                    break;

                  case 2:
                    message.token = reader.string();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes an ItemCheckNewReq message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof gaiaProto.ItemCheckNewReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {gaiaProto.ItemCheckNewReq} ItemCheckNewReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            ItemCheckNewReq.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies an ItemCheckNewReq message.
            * @function verify
            * @memberof gaiaProto.ItemCheckNewReq
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            ItemCheckNewReq.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.aid != null && message.hasOwnProperty("aid")) if (!$util.isInteger(message.aid)) return "aid: integer expected";
              if (message.token != null && message.hasOwnProperty("token")) if (!$util.isString(message.token)) return "token: string expected";
              return null;
            };
            /**
            * Creates an ItemCheckNewReq message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof gaiaProto.ItemCheckNewReq
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {gaiaProto.ItemCheckNewReq} ItemCheckNewReq
            */


            ItemCheckNewReq.fromObject = function fromObject(object) {
              if (object instanceof $root.gaiaProto.ItemCheckNewReq) return object;
              var message = new $root.gaiaProto.ItemCheckNewReq();
              if (object.aid != null) message.aid = object.aid | 0;
              if (object.token != null) message.token = String(object.token);
              return message;
            };
            /**
            * Creates a plain object from an ItemCheckNewReq message. Also converts values to other types if specified.
            * @function toObject
            * @memberof gaiaProto.ItemCheckNewReq
            * @static
            * @param {gaiaProto.ItemCheckNewReq} message ItemCheckNewReq
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            ItemCheckNewReq.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.aid = 0;
                object.token = "";
              }

              if (message.aid != null && message.hasOwnProperty("aid")) object.aid = message.aid;
              if (message.token != null && message.hasOwnProperty("token")) object.token = message.token;
              return object;
            };
            /**
            * Converts this ItemCheckNewReq to JSON.
            * @function toJSON
            * @memberof gaiaProto.ItemCheckNewReq
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            ItemCheckNewReq.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ItemCheckNewReq;
          }();

          gaiaProto.ItemGetMailReq = function () {
            /**
            * Properties of an ItemGetMailReq.
            * @memberof gaiaProto
            * @interface IItemGetMailReq
            * @property {number|null} [aid] ItemGetMailReq aid
            * @property {string|null} [token] ItemGetMailReq token
            * @property {number|null} [currencynumber] ItemGetMailReq currencynumber
            */

            /**
            * Constructs a new ItemGetMailReq.
            * @memberof gaiaProto
            * @classdesc Represents an ItemGetMailReq.
            * @implements IItemGetMailReq
            * @constructor
            * @param {gaiaProto.IItemGetMailReq=} [properties] Properties to set
            */
            function ItemGetMailReq(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * ItemGetMailReq aid.
            * @member {number} aid
            * @memberof gaiaProto.ItemGetMailReq
            * @instance
            */


            ItemGetMailReq.prototype.aid = 0;
            /**
            * ItemGetMailReq token.
            * @member {string} token
            * @memberof gaiaProto.ItemGetMailReq
            * @instance
            */

            ItemGetMailReq.prototype.token = "";
            /**
            * ItemGetMailReq currencynumber.
            * @member {number} currencynumber
            * @memberof gaiaProto.ItemGetMailReq
            * @instance
            */

            ItemGetMailReq.prototype.currencynumber = 0;
            /**
            * Creates a new ItemGetMailReq instance using the specified properties.
            * @function create
            * @memberof gaiaProto.ItemGetMailReq
            * @static
            * @param {gaiaProto.IItemGetMailReq=} [properties] Properties to set
            * @returns {gaiaProto.ItemGetMailReq} ItemGetMailReq instance
            */

            ItemGetMailReq.create = function create(properties) {
              return new ItemGetMailReq(properties);
            };
            /**
            * Encodes the specified ItemGetMailReq message. Does not implicitly {@link gaiaProto.ItemGetMailReq.verify|verify} messages.
            * @function encode
            * @memberof gaiaProto.ItemGetMailReq
            * @static
            * @param {gaiaProto.IItemGetMailReq} message ItemGetMailReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            ItemGetMailReq.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.aid != null && Object.hasOwnProperty.call(message, "aid")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.aid);
              if (message.token != null && Object.hasOwnProperty.call(message, "token")) writer.uint32(
              /* id 2, wireType 2 =*/
              18).string(message.token);
              if (message.currencynumber != null && Object.hasOwnProperty.call(message, "currencynumber")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.currencynumber);
              return writer;
            };
            /**
            * Encodes the specified ItemGetMailReq message, length delimited. Does not implicitly {@link gaiaProto.ItemGetMailReq.verify|verify} messages.
            * @function encodeDelimited
            * @memberof gaiaProto.ItemGetMailReq
            * @static
            * @param {gaiaProto.IItemGetMailReq} message ItemGetMailReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            ItemGetMailReq.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes an ItemGetMailReq message from the specified reader or buffer.
            * @function decode
            * @memberof gaiaProto.ItemGetMailReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {gaiaProto.ItemGetMailReq} ItemGetMailReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            ItemGetMailReq.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gaiaProto.ItemGetMailReq();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.aid = reader.int32();
                    break;

                  case 2:
                    message.token = reader.string();
                    break;

                  case 3:
                    message.currencynumber = reader.int32();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes an ItemGetMailReq message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof gaiaProto.ItemGetMailReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {gaiaProto.ItemGetMailReq} ItemGetMailReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            ItemGetMailReq.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies an ItemGetMailReq message.
            * @function verify
            * @memberof gaiaProto.ItemGetMailReq
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            ItemGetMailReq.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.aid != null && message.hasOwnProperty("aid")) if (!$util.isInteger(message.aid)) return "aid: integer expected";
              if (message.token != null && message.hasOwnProperty("token")) if (!$util.isString(message.token)) return "token: string expected";
              if (message.currencynumber != null && message.hasOwnProperty("currencynumber")) if (!$util.isInteger(message.currencynumber)) return "currencynumber: integer expected";
              return null;
            };
            /**
            * Creates an ItemGetMailReq message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof gaiaProto.ItemGetMailReq
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {gaiaProto.ItemGetMailReq} ItemGetMailReq
            */


            ItemGetMailReq.fromObject = function fromObject(object) {
              if (object instanceof $root.gaiaProto.ItemGetMailReq) return object;
              var message = new $root.gaiaProto.ItemGetMailReq();
              if (object.aid != null) message.aid = object.aid | 0;
              if (object.token != null) message.token = String(object.token);
              if (object.currencynumber != null) message.currencynumber = object.currencynumber | 0;
              return message;
            };
            /**
            * Creates a plain object from an ItemGetMailReq message. Also converts values to other types if specified.
            * @function toObject
            * @memberof gaiaProto.ItemGetMailReq
            * @static
            * @param {gaiaProto.ItemGetMailReq} message ItemGetMailReq
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            ItemGetMailReq.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.aid = 0;
                object.token = "";
                object.currencynumber = 0;
              }

              if (message.aid != null && message.hasOwnProperty("aid")) object.aid = message.aid;
              if (message.token != null && message.hasOwnProperty("token")) object.token = message.token;
              if (message.currencynumber != null && message.hasOwnProperty("currencynumber")) object.currencynumber = message.currencynumber;
              return object;
            };
            /**
            * Converts this ItemGetMailReq to JSON.
            * @function toJSON
            * @memberof gaiaProto.ItemGetMailReq
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            ItemGetMailReq.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ItemGetMailReq;
          }();

          gaiaProto.ItemSetReadReq = function () {
            /**
            * Properties of an ItemSetReadReq.
            * @memberof gaiaProto
            * @interface IItemSetReadReq
            * @property {number|null} [aid] ItemSetReadReq aid
            * @property {string|null} [token] ItemSetReadReq token
            * @property {number|null} [currencynumber] ItemSetReadReq currencynumber
            */

            /**
            * Constructs a new ItemSetReadReq.
            * @memberof gaiaProto
            * @classdesc Represents an ItemSetReadReq.
            * @implements IItemSetReadReq
            * @constructor
            * @param {gaiaProto.IItemSetReadReq=} [properties] Properties to set
            */
            function ItemSetReadReq(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * ItemSetReadReq aid.
            * @member {number} aid
            * @memberof gaiaProto.ItemSetReadReq
            * @instance
            */


            ItemSetReadReq.prototype.aid = 0;
            /**
            * ItemSetReadReq token.
            * @member {string} token
            * @memberof gaiaProto.ItemSetReadReq
            * @instance
            */

            ItemSetReadReq.prototype.token = "";
            /**
            * ItemSetReadReq currencynumber.
            * @member {number} currencynumber
            * @memberof gaiaProto.ItemSetReadReq
            * @instance
            */

            ItemSetReadReq.prototype.currencynumber = 0;
            /**
            * Creates a new ItemSetReadReq instance using the specified properties.
            * @function create
            * @memberof gaiaProto.ItemSetReadReq
            * @static
            * @param {gaiaProto.IItemSetReadReq=} [properties] Properties to set
            * @returns {gaiaProto.ItemSetReadReq} ItemSetReadReq instance
            */

            ItemSetReadReq.create = function create(properties) {
              return new ItemSetReadReq(properties);
            };
            /**
            * Encodes the specified ItemSetReadReq message. Does not implicitly {@link gaiaProto.ItemSetReadReq.verify|verify} messages.
            * @function encode
            * @memberof gaiaProto.ItemSetReadReq
            * @static
            * @param {gaiaProto.IItemSetReadReq} message ItemSetReadReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            ItemSetReadReq.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.aid != null && Object.hasOwnProperty.call(message, "aid")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.aid);
              if (message.token != null && Object.hasOwnProperty.call(message, "token")) writer.uint32(
              /* id 2, wireType 2 =*/
              18).string(message.token);
              if (message.currencynumber != null && Object.hasOwnProperty.call(message, "currencynumber")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.currencynumber);
              return writer;
            };
            /**
            * Encodes the specified ItemSetReadReq message, length delimited. Does not implicitly {@link gaiaProto.ItemSetReadReq.verify|verify} messages.
            * @function encodeDelimited
            * @memberof gaiaProto.ItemSetReadReq
            * @static
            * @param {gaiaProto.IItemSetReadReq} message ItemSetReadReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            ItemSetReadReq.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes an ItemSetReadReq message from the specified reader or buffer.
            * @function decode
            * @memberof gaiaProto.ItemSetReadReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {gaiaProto.ItemSetReadReq} ItemSetReadReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            ItemSetReadReq.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gaiaProto.ItemSetReadReq();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.aid = reader.int32();
                    break;

                  case 2:
                    message.token = reader.string();
                    break;

                  case 3:
                    message.currencynumber = reader.int32();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes an ItemSetReadReq message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof gaiaProto.ItemSetReadReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {gaiaProto.ItemSetReadReq} ItemSetReadReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            ItemSetReadReq.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies an ItemSetReadReq message.
            * @function verify
            * @memberof gaiaProto.ItemSetReadReq
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            ItemSetReadReq.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.aid != null && message.hasOwnProperty("aid")) if (!$util.isInteger(message.aid)) return "aid: integer expected";
              if (message.token != null && message.hasOwnProperty("token")) if (!$util.isString(message.token)) return "token: string expected";
              if (message.currencynumber != null && message.hasOwnProperty("currencynumber")) if (!$util.isInteger(message.currencynumber)) return "currencynumber: integer expected";
              return null;
            };
            /**
            * Creates an ItemSetReadReq message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof gaiaProto.ItemSetReadReq
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {gaiaProto.ItemSetReadReq} ItemSetReadReq
            */


            ItemSetReadReq.fromObject = function fromObject(object) {
              if (object instanceof $root.gaiaProto.ItemSetReadReq) return object;
              var message = new $root.gaiaProto.ItemSetReadReq();
              if (object.aid != null) message.aid = object.aid | 0;
              if (object.token != null) message.token = String(object.token);
              if (object.currencynumber != null) message.currencynumber = object.currencynumber | 0;
              return message;
            };
            /**
            * Creates a plain object from an ItemSetReadReq message. Also converts values to other types if specified.
            * @function toObject
            * @memberof gaiaProto.ItemSetReadReq
            * @static
            * @param {gaiaProto.ItemSetReadReq} message ItemSetReadReq
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            ItemSetReadReq.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.aid = 0;
                object.token = "";
                object.currencynumber = 0;
              }

              if (message.aid != null && message.hasOwnProperty("aid")) object.aid = message.aid;
              if (message.token != null && message.hasOwnProperty("token")) object.token = message.token;
              if (message.currencynumber != null && message.hasOwnProperty("currencynumber")) object.currencynumber = message.currencynumber;
              return object;
            };
            /**
            * Converts this ItemSetReadReq to JSON.
            * @function toJSON
            * @memberof gaiaProto.ItemSetReadReq
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            ItemSetReadReq.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ItemSetReadReq;
          }();

          gaiaProto.MissionDailyReq = function () {
            /**
            * Properties of a MissionDailyReq.
            * @memberof gaiaProto
            * @interface IMissionDailyReq
            * @property {number|null} [aid] MissionDailyReq aid
            * @property {string|null} [token] MissionDailyReq token
            * @property {string|null} [lang] MissionDailyReq lang
            * @property {number|null} [currencynumber] MissionDailyReq currencynumber
            * @property {boolean|null} [isNow] MissionDailyReq isNow
            * @property {number|null} [level] MissionDailyReq level
            */

            /**
            * Constructs a new MissionDailyReq.
            * @memberof gaiaProto
            * @classdesc Represents a MissionDailyReq.
            * @implements IMissionDailyReq
            * @constructor
            * @param {gaiaProto.IMissionDailyReq=} [properties] Properties to set
            */
            function MissionDailyReq(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * MissionDailyReq aid.
            * @member {number} aid
            * @memberof gaiaProto.MissionDailyReq
            * @instance
            */


            MissionDailyReq.prototype.aid = 0;
            /**
            * MissionDailyReq token.
            * @member {string} token
            * @memberof gaiaProto.MissionDailyReq
            * @instance
            */

            MissionDailyReq.prototype.token = "";
            /**
            * MissionDailyReq lang.
            * @member {string} lang
            * @memberof gaiaProto.MissionDailyReq
            * @instance
            */

            MissionDailyReq.prototype.lang = "";
            /**
            * MissionDailyReq currencynumber.
            * @member {number} currencynumber
            * @memberof gaiaProto.MissionDailyReq
            * @instance
            */

            MissionDailyReq.prototype.currencynumber = 0;
            /**
            * MissionDailyReq isNow.
            * @member {boolean} isNow
            * @memberof gaiaProto.MissionDailyReq
            * @instance
            */

            MissionDailyReq.prototype.isNow = false;
            /**
            * MissionDailyReq level.
            * @member {number} level
            * @memberof gaiaProto.MissionDailyReq
            * @instance
            */

            MissionDailyReq.prototype.level = 0;
            /**
            * Creates a new MissionDailyReq instance using the specified properties.
            * @function create
            * @memberof gaiaProto.MissionDailyReq
            * @static
            * @param {gaiaProto.IMissionDailyReq=} [properties] Properties to set
            * @returns {gaiaProto.MissionDailyReq} MissionDailyReq instance
            */

            MissionDailyReq.create = function create(properties) {
              return new MissionDailyReq(properties);
            };
            /**
            * Encodes the specified MissionDailyReq message. Does not implicitly {@link gaiaProto.MissionDailyReq.verify|verify} messages.
            * @function encode
            * @memberof gaiaProto.MissionDailyReq
            * @static
            * @param {gaiaProto.IMissionDailyReq} message MissionDailyReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            MissionDailyReq.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.aid != null && Object.hasOwnProperty.call(message, "aid")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.aid);
              if (message.token != null && Object.hasOwnProperty.call(message, "token")) writer.uint32(
              /* id 2, wireType 2 =*/
              18).string(message.token);
              if (message.lang != null && Object.hasOwnProperty.call(message, "lang")) writer.uint32(
              /* id 3, wireType 2 =*/
              26).string(message.lang);
              if (message.currencynumber != null && Object.hasOwnProperty.call(message, "currencynumber")) writer.uint32(
              /* id 4, wireType 0 =*/
              32).int32(message.currencynumber);
              if (message.isNow != null && Object.hasOwnProperty.call(message, "isNow")) writer.uint32(
              /* id 5, wireType 0 =*/
              40).bool(message.isNow);
              if (message.level != null && Object.hasOwnProperty.call(message, "level")) writer.uint32(
              /* id 6, wireType 0 =*/
              48).int32(message.level);
              return writer;
            };
            /**
            * Encodes the specified MissionDailyReq message, length delimited. Does not implicitly {@link gaiaProto.MissionDailyReq.verify|verify} messages.
            * @function encodeDelimited
            * @memberof gaiaProto.MissionDailyReq
            * @static
            * @param {gaiaProto.IMissionDailyReq} message MissionDailyReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            MissionDailyReq.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a MissionDailyReq message from the specified reader or buffer.
            * @function decode
            * @memberof gaiaProto.MissionDailyReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {gaiaProto.MissionDailyReq} MissionDailyReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            MissionDailyReq.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gaiaProto.MissionDailyReq();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.aid = reader.int32();
                    break;

                  case 2:
                    message.token = reader.string();
                    break;

                  case 3:
                    message.lang = reader.string();
                    break;

                  case 4:
                    message.currencynumber = reader.int32();
                    break;

                  case 5:
                    message.isNow = reader.bool();
                    break;

                  case 6:
                    message.level = reader.int32();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a MissionDailyReq message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof gaiaProto.MissionDailyReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {gaiaProto.MissionDailyReq} MissionDailyReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            MissionDailyReq.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a MissionDailyReq message.
            * @function verify
            * @memberof gaiaProto.MissionDailyReq
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            MissionDailyReq.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.aid != null && message.hasOwnProperty("aid")) if (!$util.isInteger(message.aid)) return "aid: integer expected";
              if (message.token != null && message.hasOwnProperty("token")) if (!$util.isString(message.token)) return "token: string expected";
              if (message.lang != null && message.hasOwnProperty("lang")) if (!$util.isString(message.lang)) return "lang: string expected";
              if (message.currencynumber != null && message.hasOwnProperty("currencynumber")) if (!$util.isInteger(message.currencynumber)) return "currencynumber: integer expected";
              if (message.isNow != null && message.hasOwnProperty("isNow")) if (typeof message.isNow !== "boolean") return "isNow: boolean expected";
              if (message.level != null && message.hasOwnProperty("level")) if (!$util.isInteger(message.level)) return "level: integer expected";
              return null;
            };
            /**
            * Creates a MissionDailyReq message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof gaiaProto.MissionDailyReq
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {gaiaProto.MissionDailyReq} MissionDailyReq
            */


            MissionDailyReq.fromObject = function fromObject(object) {
              if (object instanceof $root.gaiaProto.MissionDailyReq) return object;
              var message = new $root.gaiaProto.MissionDailyReq();
              if (object.aid != null) message.aid = object.aid | 0;
              if (object.token != null) message.token = String(object.token);
              if (object.lang != null) message.lang = String(object.lang);
              if (object.currencynumber != null) message.currencynumber = object.currencynumber | 0;
              if (object.isNow != null) message.isNow = Boolean(object.isNow);
              if (object.level != null) message.level = object.level | 0;
              return message;
            };
            /**
            * Creates a plain object from a MissionDailyReq message. Also converts values to other types if specified.
            * @function toObject
            * @memberof gaiaProto.MissionDailyReq
            * @static
            * @param {gaiaProto.MissionDailyReq} message MissionDailyReq
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            MissionDailyReq.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.aid = 0;
                object.token = "";
                object.lang = "";
                object.currencynumber = 0;
                object.isNow = false;
                object.level = 0;
              }

              if (message.aid != null && message.hasOwnProperty("aid")) object.aid = message.aid;
              if (message.token != null && message.hasOwnProperty("token")) object.token = message.token;
              if (message.lang != null && message.hasOwnProperty("lang")) object.lang = message.lang;
              if (message.currencynumber != null && message.hasOwnProperty("currencynumber")) object.currencynumber = message.currencynumber;
              if (message.isNow != null && message.hasOwnProperty("isNow")) object.isNow = message.isNow;
              if (message.level != null && message.hasOwnProperty("level")) object.level = message.level;
              return object;
            };
            /**
            * Converts this MissionDailyReq to JSON.
            * @function toJSON
            * @memberof gaiaProto.MissionDailyReq
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            MissionDailyReq.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MissionDailyReq;
          }();

          gaiaProto.ReplayListReq = function () {
            /**
            * Properties of a ReplayListReq.
            * @memberof gaiaProto
            * @interface IReplayListReq
            * @property {number|null} [aid] ReplayListReq aid
            * @property {string|null} [token] ReplayListReq token
            * @property {number|null} [currencynumber] ReplayListReq currencynumber
            */

            /**
            * Constructs a new ReplayListReq.
            * @memberof gaiaProto
            * @classdesc Represents a ReplayListReq.
            * @implements IReplayListReq
            * @constructor
            * @param {gaiaProto.IReplayListReq=} [properties] Properties to set
            */
            function ReplayListReq(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * ReplayListReq aid.
            * @member {number} aid
            * @memberof gaiaProto.ReplayListReq
            * @instance
            */


            ReplayListReq.prototype.aid = 0;
            /**
            * ReplayListReq token.
            * @member {string} token
            * @memberof gaiaProto.ReplayListReq
            * @instance
            */

            ReplayListReq.prototype.token = "";
            /**
            * ReplayListReq currencynumber.
            * @member {number} currencynumber
            * @memberof gaiaProto.ReplayListReq
            * @instance
            */

            ReplayListReq.prototype.currencynumber = 0;
            /**
            * Creates a new ReplayListReq instance using the specified properties.
            * @function create
            * @memberof gaiaProto.ReplayListReq
            * @static
            * @param {gaiaProto.IReplayListReq=} [properties] Properties to set
            * @returns {gaiaProto.ReplayListReq} ReplayListReq instance
            */

            ReplayListReq.create = function create(properties) {
              return new ReplayListReq(properties);
            };
            /**
            * Encodes the specified ReplayListReq message. Does not implicitly {@link gaiaProto.ReplayListReq.verify|verify} messages.
            * @function encode
            * @memberof gaiaProto.ReplayListReq
            * @static
            * @param {gaiaProto.IReplayListReq} message ReplayListReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            ReplayListReq.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.aid != null && Object.hasOwnProperty.call(message, "aid")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.aid);
              if (message.token != null && Object.hasOwnProperty.call(message, "token")) writer.uint32(
              /* id 2, wireType 2 =*/
              18).string(message.token);
              if (message.currencynumber != null && Object.hasOwnProperty.call(message, "currencynumber")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.currencynumber);
              return writer;
            };
            /**
            * Encodes the specified ReplayListReq message, length delimited. Does not implicitly {@link gaiaProto.ReplayListReq.verify|verify} messages.
            * @function encodeDelimited
            * @memberof gaiaProto.ReplayListReq
            * @static
            * @param {gaiaProto.IReplayListReq} message ReplayListReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            ReplayListReq.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a ReplayListReq message from the specified reader or buffer.
            * @function decode
            * @memberof gaiaProto.ReplayListReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {gaiaProto.ReplayListReq} ReplayListReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            ReplayListReq.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gaiaProto.ReplayListReq();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.aid = reader.int32();
                    break;

                  case 2:
                    message.token = reader.string();
                    break;

                  case 3:
                    message.currencynumber = reader.int32();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a ReplayListReq message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof gaiaProto.ReplayListReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {gaiaProto.ReplayListReq} ReplayListReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            ReplayListReq.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a ReplayListReq message.
            * @function verify
            * @memberof gaiaProto.ReplayListReq
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            ReplayListReq.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.aid != null && message.hasOwnProperty("aid")) if (!$util.isInteger(message.aid)) return "aid: integer expected";
              if (message.token != null && message.hasOwnProperty("token")) if (!$util.isString(message.token)) return "token: string expected";
              if (message.currencynumber != null && message.hasOwnProperty("currencynumber")) if (!$util.isInteger(message.currencynumber)) return "currencynumber: integer expected";
              return null;
            };
            /**
            * Creates a ReplayListReq message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof gaiaProto.ReplayListReq
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {gaiaProto.ReplayListReq} ReplayListReq
            */


            ReplayListReq.fromObject = function fromObject(object) {
              if (object instanceof $root.gaiaProto.ReplayListReq) return object;
              var message = new $root.gaiaProto.ReplayListReq();
              if (object.aid != null) message.aid = object.aid | 0;
              if (object.token != null) message.token = String(object.token);
              if (object.currencynumber != null) message.currencynumber = object.currencynumber | 0;
              return message;
            };
            /**
            * Creates a plain object from a ReplayListReq message. Also converts values to other types if specified.
            * @function toObject
            * @memberof gaiaProto.ReplayListReq
            * @static
            * @param {gaiaProto.ReplayListReq} message ReplayListReq
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            ReplayListReq.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.aid = 0;
                object.token = "";
                object.currencynumber = 0;
              }

              if (message.aid != null && message.hasOwnProperty("aid")) object.aid = message.aid;
              if (message.token != null && message.hasOwnProperty("token")) object.token = message.token;
              if (message.currencynumber != null && message.hasOwnProperty("currencynumber")) object.currencynumber = message.currencynumber;
              return object;
            };
            /**
            * Converts this ReplayListReq to JSON.
            * @function toJSON
            * @memberof gaiaProto.ReplayListReq
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            ReplayListReq.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReplayListReq;
          }();

          gaiaProto.ReplayGetReq = function () {
            /**
            * Properties of a ReplayGetReq.
            * @memberof gaiaProto
            * @interface IReplayGetReq
            * @property {number|null} [aid] ReplayGetReq aid
            * @property {string|null} [token] ReplayGetReq token
            * @property {string|null} [index] ReplayGetReq index
            */

            /**
            * Constructs a new ReplayGetReq.
            * @memberof gaiaProto
            * @classdesc Represents a ReplayGetReq.
            * @implements IReplayGetReq
            * @constructor
            * @param {gaiaProto.IReplayGetReq=} [properties] Properties to set
            */
            function ReplayGetReq(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * ReplayGetReq aid.
            * @member {number} aid
            * @memberof gaiaProto.ReplayGetReq
            * @instance
            */


            ReplayGetReq.prototype.aid = 0;
            /**
            * ReplayGetReq token.
            * @member {string} token
            * @memberof gaiaProto.ReplayGetReq
            * @instance
            */

            ReplayGetReq.prototype.token = "";
            /**
            * ReplayGetReq index.
            * @member {string} index
            * @memberof gaiaProto.ReplayGetReq
            * @instance
            */

            ReplayGetReq.prototype.index = "";
            /**
            * Creates a new ReplayGetReq instance using the specified properties.
            * @function create
            * @memberof gaiaProto.ReplayGetReq
            * @static
            * @param {gaiaProto.IReplayGetReq=} [properties] Properties to set
            * @returns {gaiaProto.ReplayGetReq} ReplayGetReq instance
            */

            ReplayGetReq.create = function create(properties) {
              return new ReplayGetReq(properties);
            };
            /**
            * Encodes the specified ReplayGetReq message. Does not implicitly {@link gaiaProto.ReplayGetReq.verify|verify} messages.
            * @function encode
            * @memberof gaiaProto.ReplayGetReq
            * @static
            * @param {gaiaProto.IReplayGetReq} message ReplayGetReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            ReplayGetReq.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.aid != null && Object.hasOwnProperty.call(message, "aid")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.aid);
              if (message.token != null && Object.hasOwnProperty.call(message, "token")) writer.uint32(
              /* id 2, wireType 2 =*/
              18).string(message.token);
              if (message.index != null && Object.hasOwnProperty.call(message, "index")) writer.uint32(
              /* id 3, wireType 2 =*/
              26).string(message.index);
              return writer;
            };
            /**
            * Encodes the specified ReplayGetReq message, length delimited. Does not implicitly {@link gaiaProto.ReplayGetReq.verify|verify} messages.
            * @function encodeDelimited
            * @memberof gaiaProto.ReplayGetReq
            * @static
            * @param {gaiaProto.IReplayGetReq} message ReplayGetReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            ReplayGetReq.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a ReplayGetReq message from the specified reader or buffer.
            * @function decode
            * @memberof gaiaProto.ReplayGetReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {gaiaProto.ReplayGetReq} ReplayGetReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            ReplayGetReq.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gaiaProto.ReplayGetReq();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.aid = reader.int32();
                    break;

                  case 2:
                    message.token = reader.string();
                    break;

                  case 3:
                    message.index = reader.string();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a ReplayGetReq message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof gaiaProto.ReplayGetReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {gaiaProto.ReplayGetReq} ReplayGetReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            ReplayGetReq.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a ReplayGetReq message.
            * @function verify
            * @memberof gaiaProto.ReplayGetReq
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            ReplayGetReq.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.aid != null && message.hasOwnProperty("aid")) if (!$util.isInteger(message.aid)) return "aid: integer expected";
              if (message.token != null && message.hasOwnProperty("token")) if (!$util.isString(message.token)) return "token: string expected";
              if (message.index != null && message.hasOwnProperty("index")) if (!$util.isString(message.index)) return "index: string expected";
              return null;
            };
            /**
            * Creates a ReplayGetReq message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof gaiaProto.ReplayGetReq
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {gaiaProto.ReplayGetReq} ReplayGetReq
            */


            ReplayGetReq.fromObject = function fromObject(object) {
              if (object instanceof $root.gaiaProto.ReplayGetReq) return object;
              var message = new $root.gaiaProto.ReplayGetReq();
              if (object.aid != null) message.aid = object.aid | 0;
              if (object.token != null) message.token = String(object.token);
              if (object.index != null) message.index = String(object.index);
              return message;
            };
            /**
            * Creates a plain object from a ReplayGetReq message. Also converts values to other types if specified.
            * @function toObject
            * @memberof gaiaProto.ReplayGetReq
            * @static
            * @param {gaiaProto.ReplayGetReq} message ReplayGetReq
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            ReplayGetReq.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.aid = 0;
                object.token = "";
                object.index = "";
              }

              if (message.aid != null && message.hasOwnProperty("aid")) object.aid = message.aid;
              if (message.token != null && message.hasOwnProperty("token")) object.token = message.token;
              if (message.index != null && message.hasOwnProperty("index")) object.index = message.index;
              return object;
            };
            /**
            * Converts this ReplayGetReq to JSON.
            * @function toJSON
            * @memberof gaiaProto.ReplayGetReq
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            ReplayGetReq.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReplayGetReq;
          }();

          gaiaProto.ReplayCheckReq = function () {
            /**
            * Properties of a ReplayCheckReq.
            * @memberof gaiaProto
            * @interface IReplayCheckReq
            * @property {number|null} [aid] ReplayCheckReq aid
            * @property {string|null} [token] ReplayCheckReq token
            */

            /**
            * Constructs a new ReplayCheckReq.
            * @memberof gaiaProto
            * @classdesc Represents a ReplayCheckReq.
            * @implements IReplayCheckReq
            * @constructor
            * @param {gaiaProto.IReplayCheckReq=} [properties] Properties to set
            */
            function ReplayCheckReq(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * ReplayCheckReq aid.
            * @member {number} aid
            * @memberof gaiaProto.ReplayCheckReq
            * @instance
            */


            ReplayCheckReq.prototype.aid = 0;
            /**
            * ReplayCheckReq token.
            * @member {string} token
            * @memberof gaiaProto.ReplayCheckReq
            * @instance
            */

            ReplayCheckReq.prototype.token = "";
            /**
            * Creates a new ReplayCheckReq instance using the specified properties.
            * @function create
            * @memberof gaiaProto.ReplayCheckReq
            * @static
            * @param {gaiaProto.IReplayCheckReq=} [properties] Properties to set
            * @returns {gaiaProto.ReplayCheckReq} ReplayCheckReq instance
            */

            ReplayCheckReq.create = function create(properties) {
              return new ReplayCheckReq(properties);
            };
            /**
            * Encodes the specified ReplayCheckReq message. Does not implicitly {@link gaiaProto.ReplayCheckReq.verify|verify} messages.
            * @function encode
            * @memberof gaiaProto.ReplayCheckReq
            * @static
            * @param {gaiaProto.IReplayCheckReq} message ReplayCheckReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            ReplayCheckReq.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.aid != null && Object.hasOwnProperty.call(message, "aid")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.aid);
              if (message.token != null && Object.hasOwnProperty.call(message, "token")) writer.uint32(
              /* id 2, wireType 2 =*/
              18).string(message.token);
              return writer;
            };
            /**
            * Encodes the specified ReplayCheckReq message, length delimited. Does not implicitly {@link gaiaProto.ReplayCheckReq.verify|verify} messages.
            * @function encodeDelimited
            * @memberof gaiaProto.ReplayCheckReq
            * @static
            * @param {gaiaProto.IReplayCheckReq} message ReplayCheckReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            ReplayCheckReq.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a ReplayCheckReq message from the specified reader or buffer.
            * @function decode
            * @memberof gaiaProto.ReplayCheckReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {gaiaProto.ReplayCheckReq} ReplayCheckReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            ReplayCheckReq.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gaiaProto.ReplayCheckReq();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.aid = reader.int32();
                    break;

                  case 2:
                    message.token = reader.string();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a ReplayCheckReq message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof gaiaProto.ReplayCheckReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {gaiaProto.ReplayCheckReq} ReplayCheckReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            ReplayCheckReq.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a ReplayCheckReq message.
            * @function verify
            * @memberof gaiaProto.ReplayCheckReq
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            ReplayCheckReq.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.aid != null && message.hasOwnProperty("aid")) if (!$util.isInteger(message.aid)) return "aid: integer expected";
              if (message.token != null && message.hasOwnProperty("token")) if (!$util.isString(message.token)) return "token: string expected";
              return null;
            };
            /**
            * Creates a ReplayCheckReq message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof gaiaProto.ReplayCheckReq
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {gaiaProto.ReplayCheckReq} ReplayCheckReq
            */


            ReplayCheckReq.fromObject = function fromObject(object) {
              if (object instanceof $root.gaiaProto.ReplayCheckReq) return object;
              var message = new $root.gaiaProto.ReplayCheckReq();
              if (object.aid != null) message.aid = object.aid | 0;
              if (object.token != null) message.token = String(object.token);
              return message;
            };
            /**
            * Creates a plain object from a ReplayCheckReq message. Also converts values to other types if specified.
            * @function toObject
            * @memberof gaiaProto.ReplayCheckReq
            * @static
            * @param {gaiaProto.ReplayCheckReq} message ReplayCheckReq
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            ReplayCheckReq.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.aid = 0;
                object.token = "";
              }

              if (message.aid != null && message.hasOwnProperty("aid")) object.aid = message.aid;
              if (message.token != null && message.hasOwnProperty("token")) object.token = message.token;
              return object;
            };
            /**
            * Converts this ReplayCheckReq to JSON.
            * @function toJSON
            * @memberof gaiaProto.ReplayCheckReq
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            ReplayCheckReq.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReplayCheckReq;
          }();

          gaiaProto.ReplayListAck = function () {
            /**
            * Properties of a ReplayListAck.
            * @memberof gaiaProto
            * @interface IReplayListAck
            * @property {number|null} [acktype] ReplayListAck acktype
            * @property {Array.<gaiaProto.IReplayLDF>|null} [list] ReplayListAck list
            */

            /**
            * Constructs a new ReplayListAck.
            * @memberof gaiaProto
            * @classdesc Represents a ReplayListAck.
            * @implements IReplayListAck
            * @constructor
            * @param {gaiaProto.IReplayListAck=} [properties] Properties to set
            */
            function ReplayListAck(properties) {
              this.list = [];
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * ReplayListAck acktype.
            * @member {number} acktype
            * @memberof gaiaProto.ReplayListAck
            * @instance
            */


            ReplayListAck.prototype.acktype = 0;
            /**
            * ReplayListAck list.
            * @member {Array.<gaiaProto.IReplayLDF>} list
            * @memberof gaiaProto.ReplayListAck
            * @instance
            */

            ReplayListAck.prototype.list = $util.emptyArray;
            /**
            * Creates a new ReplayListAck instance using the specified properties.
            * @function create
            * @memberof gaiaProto.ReplayListAck
            * @static
            * @param {gaiaProto.IReplayListAck=} [properties] Properties to set
            * @returns {gaiaProto.ReplayListAck} ReplayListAck instance
            */

            ReplayListAck.create = function create(properties) {
              return new ReplayListAck(properties);
            };
            /**
            * Encodes the specified ReplayListAck message. Does not implicitly {@link gaiaProto.ReplayListAck.verify|verify} messages.
            * @function encode
            * @memberof gaiaProto.ReplayListAck
            * @static
            * @param {gaiaProto.IReplayListAck} message ReplayListAck message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            ReplayListAck.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.acktype != null && Object.hasOwnProperty.call(message, "acktype")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.acktype);
              if (message.list != null && message.list.length) for (var i = 0; i < message.list.length; ++i) {
                $root.gaiaProto.ReplayLDF.encode(message.list[i], writer.uint32(
                /* id 2, wireType 2 =*/
                18).fork()).ldelim();
              }
              return writer;
            };
            /**
            * Encodes the specified ReplayListAck message, length delimited. Does not implicitly {@link gaiaProto.ReplayListAck.verify|verify} messages.
            * @function encodeDelimited
            * @memberof gaiaProto.ReplayListAck
            * @static
            * @param {gaiaProto.IReplayListAck} message ReplayListAck message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            ReplayListAck.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a ReplayListAck message from the specified reader or buffer.
            * @function decode
            * @memberof gaiaProto.ReplayListAck
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {gaiaProto.ReplayListAck} ReplayListAck
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            ReplayListAck.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gaiaProto.ReplayListAck();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.acktype = reader.int32();
                    break;

                  case 2:
                    if (!(message.list && message.list.length)) message.list = [];
                    message.list.push($root.gaiaProto.ReplayLDF.decode(reader, reader.uint32()));
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a ReplayListAck message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof gaiaProto.ReplayListAck
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {gaiaProto.ReplayListAck} ReplayListAck
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            ReplayListAck.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a ReplayListAck message.
            * @function verify
            * @memberof gaiaProto.ReplayListAck
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            ReplayListAck.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.acktype != null && message.hasOwnProperty("acktype")) if (!$util.isInteger(message.acktype)) return "acktype: integer expected";

              if (message.list != null && message.hasOwnProperty("list")) {
                if (!Array.isArray(message.list)) return "list: array expected";

                for (var i = 0; i < message.list.length; ++i) {
                  var error = $root.gaiaProto.ReplayLDF.verify(message.list[i]);
                  if (error) return "list." + error;
                }
              }

              return null;
            };
            /**
            * Creates a ReplayListAck message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof gaiaProto.ReplayListAck
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {gaiaProto.ReplayListAck} ReplayListAck
            */


            ReplayListAck.fromObject = function fromObject(object) {
              if (object instanceof $root.gaiaProto.ReplayListAck) return object;
              var message = new $root.gaiaProto.ReplayListAck();
              if (object.acktype != null) message.acktype = object.acktype | 0;

              if (object.list) {
                if (!Array.isArray(object.list)) throw TypeError(".gaiaProto.ReplayListAck.list: array expected");
                message.list = [];

                for (var i = 0; i < object.list.length; ++i) {
                  if (typeof object.list[i] !== "object") throw TypeError(".gaiaProto.ReplayListAck.list: object expected");
                  message.list[i] = $root.gaiaProto.ReplayLDF.fromObject(object.list[i]);
                }
              }

              return message;
            };
            /**
            * Creates a plain object from a ReplayListAck message. Also converts values to other types if specified.
            * @function toObject
            * @memberof gaiaProto.ReplayListAck
            * @static
            * @param {gaiaProto.ReplayListAck} message ReplayListAck
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            ReplayListAck.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};
              if (options.arrays || options.defaults) object.list = [];
              if (options.defaults) object.acktype = 0;
              if (message.acktype != null && message.hasOwnProperty("acktype")) object.acktype = message.acktype;

              if (message.list && message.list.length) {
                object.list = [];

                for (var j = 0; j < message.list.length; ++j) {
                  object.list[j] = $root.gaiaProto.ReplayLDF.toObject(message.list[j], options);
                }
              }

              return object;
            };
            /**
            * Converts this ReplayListAck to JSON.
            * @function toJSON
            * @memberof gaiaProto.ReplayListAck
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            ReplayListAck.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReplayListAck;
          }();

          gaiaProto.ReplayLDF = function () {
            /**
            * Properties of a ReplayLDF.
            * @memberof gaiaProto
            * @interface IReplayLDF
            * @property {Array.<gaiaProto.IReplayLClient>|null} [row] ReplayLDF row
            */

            /**
            * Constructs a new ReplayLDF.
            * @memberof gaiaProto
            * @classdesc Represents a ReplayLDF.
            * @implements IReplayLDF
            * @constructor
            * @param {gaiaProto.IReplayLDF=} [properties] Properties to set
            */
            function ReplayLDF(properties) {
              this.row = [];
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * ReplayLDF row.
            * @member {Array.<gaiaProto.IReplayLClient>} row
            * @memberof gaiaProto.ReplayLDF
            * @instance
            */


            ReplayLDF.prototype.row = $util.emptyArray;
            /**
            * Creates a new ReplayLDF instance using the specified properties.
            * @function create
            * @memberof gaiaProto.ReplayLDF
            * @static
            * @param {gaiaProto.IReplayLDF=} [properties] Properties to set
            * @returns {gaiaProto.ReplayLDF} ReplayLDF instance
            */

            ReplayLDF.create = function create(properties) {
              return new ReplayLDF(properties);
            };
            /**
            * Encodes the specified ReplayLDF message. Does not implicitly {@link gaiaProto.ReplayLDF.verify|verify} messages.
            * @function encode
            * @memberof gaiaProto.ReplayLDF
            * @static
            * @param {gaiaProto.IReplayLDF} message ReplayLDF message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            ReplayLDF.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.row != null && message.row.length) for (var i = 0; i < message.row.length; ++i) {
                $root.gaiaProto.ReplayLClient.encode(message.row[i], writer.uint32(
                /* id 1, wireType 2 =*/
                10).fork()).ldelim();
              }
              return writer;
            };
            /**
            * Encodes the specified ReplayLDF message, length delimited. Does not implicitly {@link gaiaProto.ReplayLDF.verify|verify} messages.
            * @function encodeDelimited
            * @memberof gaiaProto.ReplayLDF
            * @static
            * @param {gaiaProto.IReplayLDF} message ReplayLDF message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            ReplayLDF.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a ReplayLDF message from the specified reader or buffer.
            * @function decode
            * @memberof gaiaProto.ReplayLDF
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {gaiaProto.ReplayLDF} ReplayLDF
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            ReplayLDF.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gaiaProto.ReplayLDF();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    if (!(message.row && message.row.length)) message.row = [];
                    message.row.push($root.gaiaProto.ReplayLClient.decode(reader, reader.uint32()));
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a ReplayLDF message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof gaiaProto.ReplayLDF
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {gaiaProto.ReplayLDF} ReplayLDF
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            ReplayLDF.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a ReplayLDF message.
            * @function verify
            * @memberof gaiaProto.ReplayLDF
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            ReplayLDF.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";

              if (message.row != null && message.hasOwnProperty("row")) {
                if (!Array.isArray(message.row)) return "row: array expected";

                for (var i = 0; i < message.row.length; ++i) {
                  var error = $root.gaiaProto.ReplayLClient.verify(message.row[i]);
                  if (error) return "row." + error;
                }
              }

              return null;
            };
            /**
            * Creates a ReplayLDF message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof gaiaProto.ReplayLDF
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {gaiaProto.ReplayLDF} ReplayLDF
            */


            ReplayLDF.fromObject = function fromObject(object) {
              if (object instanceof $root.gaiaProto.ReplayLDF) return object;
              var message = new $root.gaiaProto.ReplayLDF();

              if (object.row) {
                if (!Array.isArray(object.row)) throw TypeError(".gaiaProto.ReplayLDF.row: array expected");
                message.row = [];

                for (var i = 0; i < object.row.length; ++i) {
                  if (typeof object.row[i] !== "object") throw TypeError(".gaiaProto.ReplayLDF.row: object expected");
                  message.row[i] = $root.gaiaProto.ReplayLClient.fromObject(object.row[i]);
                }
              }

              return message;
            };
            /**
            * Creates a plain object from a ReplayLDF message. Also converts values to other types if specified.
            * @function toObject
            * @memberof gaiaProto.ReplayLDF
            * @static
            * @param {gaiaProto.ReplayLDF} message ReplayLDF
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            ReplayLDF.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};
              if (options.arrays || options.defaults) object.row = [];

              if (message.row && message.row.length) {
                object.row = [];

                for (var j = 0; j < message.row.length; ++j) {
                  object.row[j] = $root.gaiaProto.ReplayLClient.toObject(message.row[j], options);
                }
              }

              return object;
            };
            /**
            * Converts this ReplayLDF to JSON.
            * @function toJSON
            * @memberof gaiaProto.ReplayLDF
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            ReplayLDF.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReplayLDF;
          }();

          gaiaProto.ReplayLClient = function () {
            /**
            * Properties of a ReplayLClient.
            * @memberof gaiaProto
            * @interface IReplayLClient
            * @property {number|null} [aid] ReplayLClient aid
            * @property {string|null} [account] ReplayLClient account
            * @property {string|null} [name] ReplayLClient name
            * @property {number|null} [bet] ReplayLClient bet
            * @property {number|null} [win] ReplayLClient win
            * @property {number|null} [odd] ReplayLClient odd
            * @property {number|null} [adjustwin] ReplayLClient adjustwin
            * @property {number|null} [currency] ReplayLClient currency
            * @property {string|null} [currsymbol] ReplayLClient currsymbol
            * @property {number|null} [currunit] ReplayLClient currunit
            * @property {string|null} [time] ReplayLClient time
            * @property {string|null} [index] ReplayLClient index
            */

            /**
            * Constructs a new ReplayLClient.
            * @memberof gaiaProto
            * @classdesc Represents a ReplayLClient.
            * @implements IReplayLClient
            * @constructor
            * @param {gaiaProto.IReplayLClient=} [properties] Properties to set
            */
            function ReplayLClient(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * ReplayLClient aid.
            * @member {number} aid
            * @memberof gaiaProto.ReplayLClient
            * @instance
            */


            ReplayLClient.prototype.aid = 0;
            /**
            * ReplayLClient account.
            * @member {string} account
            * @memberof gaiaProto.ReplayLClient
            * @instance
            */

            ReplayLClient.prototype.account = "";
            /**
            * ReplayLClient name.
            * @member {string} name
            * @memberof gaiaProto.ReplayLClient
            * @instance
            */

            ReplayLClient.prototype.name = "";
            /**
            * ReplayLClient bet.
            * @member {number} bet
            * @memberof gaiaProto.ReplayLClient
            * @instance
            */

            ReplayLClient.prototype.bet = 0;
            /**
            * ReplayLClient win.
            * @member {number} win
            * @memberof gaiaProto.ReplayLClient
            * @instance
            */

            ReplayLClient.prototype.win = 0;
            /**
            * ReplayLClient odd.
            * @member {number} odd
            * @memberof gaiaProto.ReplayLClient
            * @instance
            */

            ReplayLClient.prototype.odd = 0;
            /**
            * ReplayLClient adjustwin.
            * @member {number} adjustwin
            * @memberof gaiaProto.ReplayLClient
            * @instance
            */

            ReplayLClient.prototype.adjustwin = 0;
            /**
            * ReplayLClient currency.
            * @member {number} currency
            * @memberof gaiaProto.ReplayLClient
            * @instance
            */

            ReplayLClient.prototype.currency = 0;
            /**
            * ReplayLClient currsymbol.
            * @member {string} currsymbol
            * @memberof gaiaProto.ReplayLClient
            * @instance
            */

            ReplayLClient.prototype.currsymbol = "";
            /**
            * ReplayLClient currunit.
            * @member {number} currunit
            * @memberof gaiaProto.ReplayLClient
            * @instance
            */

            ReplayLClient.prototype.currunit = 0;
            /**
            * ReplayLClient time.
            * @member {string} time
            * @memberof gaiaProto.ReplayLClient
            * @instance
            */

            ReplayLClient.prototype.time = "";
            /**
            * ReplayLClient index.
            * @member {string} index
            * @memberof gaiaProto.ReplayLClient
            * @instance
            */

            ReplayLClient.prototype.index = "";
            /**
            * Creates a new ReplayLClient instance using the specified properties.
            * @function create
            * @memberof gaiaProto.ReplayLClient
            * @static
            * @param {gaiaProto.IReplayLClient=} [properties] Properties to set
            * @returns {gaiaProto.ReplayLClient} ReplayLClient instance
            */

            ReplayLClient.create = function create(properties) {
              return new ReplayLClient(properties);
            };
            /**
            * Encodes the specified ReplayLClient message. Does not implicitly {@link gaiaProto.ReplayLClient.verify|verify} messages.
            * @function encode
            * @memberof gaiaProto.ReplayLClient
            * @static
            * @param {gaiaProto.IReplayLClient} message ReplayLClient message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            ReplayLClient.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.aid != null && Object.hasOwnProperty.call(message, "aid")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.aid);
              if (message.account != null && Object.hasOwnProperty.call(message, "account")) writer.uint32(
              /* id 2, wireType 2 =*/
              18).string(message.account);
              if (message.name != null && Object.hasOwnProperty.call(message, "name")) writer.uint32(
              /* id 3, wireType 2 =*/
              26).string(message.name);
              if (message.bet != null && Object.hasOwnProperty.call(message, "bet")) writer.uint32(
              /* id 4, wireType 1 =*/
              33)["double"](message.bet);
              if (message.win != null && Object.hasOwnProperty.call(message, "win")) writer.uint32(
              /* id 5, wireType 1 =*/
              41)["double"](message.win);
              if (message.odd != null && Object.hasOwnProperty.call(message, "odd")) writer.uint32(
              /* id 6, wireType 1 =*/
              49)["double"](message.odd);
              if (message.adjustwin != null && Object.hasOwnProperty.call(message, "adjustwin")) writer.uint32(
              /* id 7, wireType 1 =*/
              57)["double"](message.adjustwin);
              if (message.currency != null && Object.hasOwnProperty.call(message, "currency")) writer.uint32(
              /* id 8, wireType 0 =*/
              64).int32(message.currency);
              if (message.currsymbol != null && Object.hasOwnProperty.call(message, "currsymbol")) writer.uint32(
              /* id 9, wireType 2 =*/
              74).string(message.currsymbol);
              if (message.currunit != null && Object.hasOwnProperty.call(message, "currunit")) writer.uint32(
              /* id 10, wireType 1 =*/
              81)["double"](message.currunit);
              if (message.time != null && Object.hasOwnProperty.call(message, "time")) writer.uint32(
              /* id 11, wireType 2 =*/
              90).string(message.time);
              if (message.index != null && Object.hasOwnProperty.call(message, "index")) writer.uint32(
              /* id 12, wireType 2 =*/
              98).string(message.index);
              return writer;
            };
            /**
            * Encodes the specified ReplayLClient message, length delimited. Does not implicitly {@link gaiaProto.ReplayLClient.verify|verify} messages.
            * @function encodeDelimited
            * @memberof gaiaProto.ReplayLClient
            * @static
            * @param {gaiaProto.IReplayLClient} message ReplayLClient message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            ReplayLClient.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a ReplayLClient message from the specified reader or buffer.
            * @function decode
            * @memberof gaiaProto.ReplayLClient
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {gaiaProto.ReplayLClient} ReplayLClient
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            ReplayLClient.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gaiaProto.ReplayLClient();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.aid = reader.int32();
                    break;

                  case 2:
                    message.account = reader.string();
                    break;

                  case 3:
                    message.name = reader.string();
                    break;

                  case 4:
                    message.bet = reader["double"]();
                    break;

                  case 5:
                    message.win = reader["double"]();
                    break;

                  case 6:
                    message.odd = reader["double"]();
                    break;

                  case 7:
                    message.adjustwin = reader["double"]();
                    break;

                  case 8:
                    message.currency = reader.int32();
                    break;

                  case 9:
                    message.currsymbol = reader.string();
                    break;

                  case 10:
                    message.currunit = reader["double"]();
                    break;

                  case 11:
                    message.time = reader.string();
                    break;

                  case 12:
                    message.index = reader.string();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a ReplayLClient message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof gaiaProto.ReplayLClient
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {gaiaProto.ReplayLClient} ReplayLClient
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            ReplayLClient.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a ReplayLClient message.
            * @function verify
            * @memberof gaiaProto.ReplayLClient
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            ReplayLClient.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.aid != null && message.hasOwnProperty("aid")) if (!$util.isInteger(message.aid)) return "aid: integer expected";
              if (message.account != null && message.hasOwnProperty("account")) if (!$util.isString(message.account)) return "account: string expected";
              if (message.name != null && message.hasOwnProperty("name")) if (!$util.isString(message.name)) return "name: string expected";
              if (message.bet != null && message.hasOwnProperty("bet")) if (typeof message.bet !== "number") return "bet: number expected";
              if (message.win != null && message.hasOwnProperty("win")) if (typeof message.win !== "number") return "win: number expected";
              if (message.odd != null && message.hasOwnProperty("odd")) if (typeof message.odd !== "number") return "odd: number expected";
              if (message.adjustwin != null && message.hasOwnProperty("adjustwin")) if (typeof message.adjustwin !== "number") return "adjustwin: number expected";
              if (message.currency != null && message.hasOwnProperty("currency")) if (!$util.isInteger(message.currency)) return "currency: integer expected";
              if (message.currsymbol != null && message.hasOwnProperty("currsymbol")) if (!$util.isString(message.currsymbol)) return "currsymbol: string expected";
              if (message.currunit != null && message.hasOwnProperty("currunit")) if (typeof message.currunit !== "number") return "currunit: number expected";
              if (message.time != null && message.hasOwnProperty("time")) if (!$util.isString(message.time)) return "time: string expected";
              if (message.index != null && message.hasOwnProperty("index")) if (!$util.isString(message.index)) return "index: string expected";
              return null;
            };
            /**
            * Creates a ReplayLClient message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof gaiaProto.ReplayLClient
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {gaiaProto.ReplayLClient} ReplayLClient
            */


            ReplayLClient.fromObject = function fromObject(object) {
              if (object instanceof $root.gaiaProto.ReplayLClient) return object;
              var message = new $root.gaiaProto.ReplayLClient();
              if (object.aid != null) message.aid = object.aid | 0;
              if (object.account != null) message.account = String(object.account);
              if (object.name != null) message.name = String(object.name);
              if (object.bet != null) message.bet = Number(object.bet);
              if (object.win != null) message.win = Number(object.win);
              if (object.odd != null) message.odd = Number(object.odd);
              if (object.adjustwin != null) message.adjustwin = Number(object.adjustwin);
              if (object.currency != null) message.currency = object.currency | 0;
              if (object.currsymbol != null) message.currsymbol = String(object.currsymbol);
              if (object.currunit != null) message.currunit = Number(object.currunit);
              if (object.time != null) message.time = String(object.time);
              if (object.index != null) message.index = String(object.index);
              return message;
            };
            /**
            * Creates a plain object from a ReplayLClient message. Also converts values to other types if specified.
            * @function toObject
            * @memberof gaiaProto.ReplayLClient
            * @static
            * @param {gaiaProto.ReplayLClient} message ReplayLClient
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            ReplayLClient.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.aid = 0;
                object.account = "";
                object.name = "";
                object.bet = 0;
                object.win = 0;
                object.odd = 0;
                object.adjustwin = 0;
                object.currency = 0;
                object.currsymbol = "";
                object.currunit = 0;
                object.time = "";
                object.index = "";
              }

              if (message.aid != null && message.hasOwnProperty("aid")) object.aid = message.aid;
              if (message.account != null && message.hasOwnProperty("account")) object.account = message.account;
              if (message.name != null && message.hasOwnProperty("name")) object.name = message.name;
              if (message.bet != null && message.hasOwnProperty("bet")) object.bet = options.json && !isFinite(message.bet) ? String(message.bet) : message.bet;
              if (message.win != null && message.hasOwnProperty("win")) object.win = options.json && !isFinite(message.win) ? String(message.win) : message.win;
              if (message.odd != null && message.hasOwnProperty("odd")) object.odd = options.json && !isFinite(message.odd) ? String(message.odd) : message.odd;
              if (message.adjustwin != null && message.hasOwnProperty("adjustwin")) object.adjustwin = options.json && !isFinite(message.adjustwin) ? String(message.adjustwin) : message.adjustwin;
              if (message.currency != null && message.hasOwnProperty("currency")) object.currency = message.currency;
              if (message.currsymbol != null && message.hasOwnProperty("currsymbol")) object.currsymbol = message.currsymbol;
              if (message.currunit != null && message.hasOwnProperty("currunit")) object.currunit = options.json && !isFinite(message.currunit) ? String(message.currunit) : message.currunit;
              if (message.time != null && message.hasOwnProperty("time")) object.time = message.time;
              if (message.index != null && message.hasOwnProperty("index")) object.index = message.index;
              return object;
            };
            /**
            * Converts this ReplayLClient to JSON.
            * @function toJSON
            * @memberof gaiaProto.ReplayLClient
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            ReplayLClient.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReplayLClient;
          }();

          gaiaProto.ReplayGetAck = function () {
            /**
            * Properties of a ReplayGetAck.
            * @memberof gaiaProto
            * @interface IReplayGetAck
            * @property {number|null} [acktype] ReplayGetAck acktype
            * @property {string|null} [ack] ReplayGetAck ack
            */

            /**
            * Constructs a new ReplayGetAck.
            * @memberof gaiaProto
            * @classdesc Represents a ReplayGetAck.
            * @implements IReplayGetAck
            * @constructor
            * @param {gaiaProto.IReplayGetAck=} [properties] Properties to set
            */
            function ReplayGetAck(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * ReplayGetAck acktype.
            * @member {number} acktype
            * @memberof gaiaProto.ReplayGetAck
            * @instance
            */


            ReplayGetAck.prototype.acktype = 0;
            /**
            * ReplayGetAck ack.
            * @member {string} ack
            * @memberof gaiaProto.ReplayGetAck
            * @instance
            */

            ReplayGetAck.prototype.ack = "";
            /**
            * Creates a new ReplayGetAck instance using the specified properties.
            * @function create
            * @memberof gaiaProto.ReplayGetAck
            * @static
            * @param {gaiaProto.IReplayGetAck=} [properties] Properties to set
            * @returns {gaiaProto.ReplayGetAck} ReplayGetAck instance
            */

            ReplayGetAck.create = function create(properties) {
              return new ReplayGetAck(properties);
            };
            /**
            * Encodes the specified ReplayGetAck message. Does not implicitly {@link gaiaProto.ReplayGetAck.verify|verify} messages.
            * @function encode
            * @memberof gaiaProto.ReplayGetAck
            * @static
            * @param {gaiaProto.IReplayGetAck} message ReplayGetAck message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            ReplayGetAck.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.acktype != null && Object.hasOwnProperty.call(message, "acktype")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.acktype);
              if (message.ack != null && Object.hasOwnProperty.call(message, "ack")) writer.uint32(
              /* id 2, wireType 2 =*/
              18).string(message.ack);
              return writer;
            };
            /**
            * Encodes the specified ReplayGetAck message, length delimited. Does not implicitly {@link gaiaProto.ReplayGetAck.verify|verify} messages.
            * @function encodeDelimited
            * @memberof gaiaProto.ReplayGetAck
            * @static
            * @param {gaiaProto.IReplayGetAck} message ReplayGetAck message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            ReplayGetAck.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a ReplayGetAck message from the specified reader or buffer.
            * @function decode
            * @memberof gaiaProto.ReplayGetAck
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {gaiaProto.ReplayGetAck} ReplayGetAck
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            ReplayGetAck.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gaiaProto.ReplayGetAck();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.acktype = reader.int32();
                    break;

                  case 2:
                    message.ack = reader.string();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a ReplayGetAck message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof gaiaProto.ReplayGetAck
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {gaiaProto.ReplayGetAck} ReplayGetAck
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            ReplayGetAck.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a ReplayGetAck message.
            * @function verify
            * @memberof gaiaProto.ReplayGetAck
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            ReplayGetAck.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.acktype != null && message.hasOwnProperty("acktype")) if (!$util.isInteger(message.acktype)) return "acktype: integer expected";
              if (message.ack != null && message.hasOwnProperty("ack")) if (!$util.isString(message.ack)) return "ack: string expected";
              return null;
            };
            /**
            * Creates a ReplayGetAck message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof gaiaProto.ReplayGetAck
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {gaiaProto.ReplayGetAck} ReplayGetAck
            */


            ReplayGetAck.fromObject = function fromObject(object) {
              if (object instanceof $root.gaiaProto.ReplayGetAck) return object;
              var message = new $root.gaiaProto.ReplayGetAck();
              if (object.acktype != null) message.acktype = object.acktype | 0;
              if (object.ack != null) message.ack = String(object.ack);
              return message;
            };
            /**
            * Creates a plain object from a ReplayGetAck message. Also converts values to other types if specified.
            * @function toObject
            * @memberof gaiaProto.ReplayGetAck
            * @static
            * @param {gaiaProto.ReplayGetAck} message ReplayGetAck
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            ReplayGetAck.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.acktype = 0;
                object.ack = "";
              }

              if (message.acktype != null && message.hasOwnProperty("acktype")) object.acktype = message.acktype;
              if (message.ack != null && message.hasOwnProperty("ack")) object.ack = message.ack;
              return object;
            };
            /**
            * Converts this ReplayGetAck to JSON.
            * @function toJSON
            * @memberof gaiaProto.ReplayGetAck
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            ReplayGetAck.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReplayGetAck;
          }();

          gaiaProto.ReplayCheckAck = function () {
            /**
            * Properties of a ReplayCheckAck.
            * @memberof gaiaProto
            * @interface IReplayCheckAck
            * @property {number|null} [acktype] ReplayCheckAck acktype
            * @property {boolean|null} [needinit] ReplayCheckAck needinit
            */

            /**
            * Constructs a new ReplayCheckAck.
            * @memberof gaiaProto
            * @classdesc Represents a ReplayCheckAck.
            * @implements IReplayCheckAck
            * @constructor
            * @param {gaiaProto.IReplayCheckAck=} [properties] Properties to set
            */
            function ReplayCheckAck(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * ReplayCheckAck acktype.
            * @member {number} acktype
            * @memberof gaiaProto.ReplayCheckAck
            * @instance
            */


            ReplayCheckAck.prototype.acktype = 0;
            /**
            * ReplayCheckAck needinit.
            * @member {boolean} needinit
            * @memberof gaiaProto.ReplayCheckAck
            * @instance
            */

            ReplayCheckAck.prototype.needinit = false;
            /**
            * Creates a new ReplayCheckAck instance using the specified properties.
            * @function create
            * @memberof gaiaProto.ReplayCheckAck
            * @static
            * @param {gaiaProto.IReplayCheckAck=} [properties] Properties to set
            * @returns {gaiaProto.ReplayCheckAck} ReplayCheckAck instance
            */

            ReplayCheckAck.create = function create(properties) {
              return new ReplayCheckAck(properties);
            };
            /**
            * Encodes the specified ReplayCheckAck message. Does not implicitly {@link gaiaProto.ReplayCheckAck.verify|verify} messages.
            * @function encode
            * @memberof gaiaProto.ReplayCheckAck
            * @static
            * @param {gaiaProto.IReplayCheckAck} message ReplayCheckAck message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            ReplayCheckAck.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.acktype != null && Object.hasOwnProperty.call(message, "acktype")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.acktype);
              if (message.needinit != null && Object.hasOwnProperty.call(message, "needinit")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).bool(message.needinit);
              return writer;
            };
            /**
            * Encodes the specified ReplayCheckAck message, length delimited. Does not implicitly {@link gaiaProto.ReplayCheckAck.verify|verify} messages.
            * @function encodeDelimited
            * @memberof gaiaProto.ReplayCheckAck
            * @static
            * @param {gaiaProto.IReplayCheckAck} message ReplayCheckAck message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            ReplayCheckAck.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a ReplayCheckAck message from the specified reader or buffer.
            * @function decode
            * @memberof gaiaProto.ReplayCheckAck
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {gaiaProto.ReplayCheckAck} ReplayCheckAck
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            ReplayCheckAck.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gaiaProto.ReplayCheckAck();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.acktype = reader.int32();
                    break;

                  case 2:
                    message.needinit = reader.bool();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a ReplayCheckAck message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof gaiaProto.ReplayCheckAck
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {gaiaProto.ReplayCheckAck} ReplayCheckAck
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            ReplayCheckAck.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a ReplayCheckAck message.
            * @function verify
            * @memberof gaiaProto.ReplayCheckAck
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            ReplayCheckAck.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.acktype != null && message.hasOwnProperty("acktype")) if (!$util.isInteger(message.acktype)) return "acktype: integer expected";
              if (message.needinit != null && message.hasOwnProperty("needinit")) if (typeof message.needinit !== "boolean") return "needinit: boolean expected";
              return null;
            };
            /**
            * Creates a ReplayCheckAck message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof gaiaProto.ReplayCheckAck
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {gaiaProto.ReplayCheckAck} ReplayCheckAck
            */


            ReplayCheckAck.fromObject = function fromObject(object) {
              if (object instanceof $root.gaiaProto.ReplayCheckAck) return object;
              var message = new $root.gaiaProto.ReplayCheckAck();
              if (object.acktype != null) message.acktype = object.acktype | 0;
              if (object.needinit != null) message.needinit = Boolean(object.needinit);
              return message;
            };
            /**
            * Creates a plain object from a ReplayCheckAck message. Also converts values to other types if specified.
            * @function toObject
            * @memberof gaiaProto.ReplayCheckAck
            * @static
            * @param {gaiaProto.ReplayCheckAck} message ReplayCheckAck
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            ReplayCheckAck.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.acktype = 0;
                object.needinit = false;
              }

              if (message.acktype != null && message.hasOwnProperty("acktype")) object.acktype = message.acktype;
              if (message.needinit != null && message.hasOwnProperty("needinit")) object.needinit = message.needinit;
              return object;
            };
            /**
            * Converts this ReplayCheckAck to JSON.
            * @function toJSON
            * @memberof gaiaProto.ReplayCheckAck
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            ReplayCheckAck.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReplayCheckAck;
          }();

          gaiaProto.TrialInfoReq = function () {
            /**
            * Properties of a TrialInfoReq.
            * @memberof gaiaProto
            * @interface ITrialInfoReq
            * @property {number|null} [aid] TrialInfoReq aid
            * @property {string|null} [token] TrialInfoReq token
            * @property {number|null} [vip] TrialInfoReq vip
            * @property {number|null} [lang] TrialInfoReq lang
            */

            /**
            * Constructs a new TrialInfoReq.
            * @memberof gaiaProto
            * @classdesc Represents a TrialInfoReq.
            * @implements ITrialInfoReq
            * @constructor
            * @param {gaiaProto.ITrialInfoReq=} [properties] Properties to set
            */
            function TrialInfoReq(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * TrialInfoReq aid.
            * @member {number} aid
            * @memberof gaiaProto.TrialInfoReq
            * @instance
            */


            TrialInfoReq.prototype.aid = 0;
            /**
            * TrialInfoReq token.
            * @member {string} token
            * @memberof gaiaProto.TrialInfoReq
            * @instance
            */

            TrialInfoReq.prototype.token = "";
            /**
            * TrialInfoReq vip.
            * @member {number} vip
            * @memberof gaiaProto.TrialInfoReq
            * @instance
            */

            TrialInfoReq.prototype.vip = 0;
            /**
            * TrialInfoReq lang.
            * @member {number} lang
            * @memberof gaiaProto.TrialInfoReq
            * @instance
            */

            TrialInfoReq.prototype.lang = 0;
            /**
            * Creates a new TrialInfoReq instance using the specified properties.
            * @function create
            * @memberof gaiaProto.TrialInfoReq
            * @static
            * @param {gaiaProto.ITrialInfoReq=} [properties] Properties to set
            * @returns {gaiaProto.TrialInfoReq} TrialInfoReq instance
            */

            TrialInfoReq.create = function create(properties) {
              return new TrialInfoReq(properties);
            };
            /**
            * Encodes the specified TrialInfoReq message. Does not implicitly {@link gaiaProto.TrialInfoReq.verify|verify} messages.
            * @function encode
            * @memberof gaiaProto.TrialInfoReq
            * @static
            * @param {gaiaProto.ITrialInfoReq} message TrialInfoReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            TrialInfoReq.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.aid != null && Object.hasOwnProperty.call(message, "aid")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.aid);
              if (message.token != null && Object.hasOwnProperty.call(message, "token")) writer.uint32(
              /* id 2, wireType 2 =*/
              18).string(message.token);
              if (message.vip != null && Object.hasOwnProperty.call(message, "vip")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.vip);
              if (message.lang != null && Object.hasOwnProperty.call(message, "lang")) writer.uint32(
              /* id 4, wireType 0 =*/
              32).int32(message.lang);
              return writer;
            };
            /**
            * Encodes the specified TrialInfoReq message, length delimited. Does not implicitly {@link gaiaProto.TrialInfoReq.verify|verify} messages.
            * @function encodeDelimited
            * @memberof gaiaProto.TrialInfoReq
            * @static
            * @param {gaiaProto.ITrialInfoReq} message TrialInfoReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            TrialInfoReq.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a TrialInfoReq message from the specified reader or buffer.
            * @function decode
            * @memberof gaiaProto.TrialInfoReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {gaiaProto.TrialInfoReq} TrialInfoReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            TrialInfoReq.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gaiaProto.TrialInfoReq();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.aid = reader.int32();
                    break;

                  case 2:
                    message.token = reader.string();
                    break;

                  case 3:
                    message.vip = reader.int32();
                    break;

                  case 4:
                    message.lang = reader.int32();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a TrialInfoReq message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof gaiaProto.TrialInfoReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {gaiaProto.TrialInfoReq} TrialInfoReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            TrialInfoReq.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a TrialInfoReq message.
            * @function verify
            * @memberof gaiaProto.TrialInfoReq
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            TrialInfoReq.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.aid != null && message.hasOwnProperty("aid")) if (!$util.isInteger(message.aid)) return "aid: integer expected";
              if (message.token != null && message.hasOwnProperty("token")) if (!$util.isString(message.token)) return "token: string expected";
              if (message.vip != null && message.hasOwnProperty("vip")) if (!$util.isInteger(message.vip)) return "vip: integer expected";
              if (message.lang != null && message.hasOwnProperty("lang")) if (!$util.isInteger(message.lang)) return "lang: integer expected";
              return null;
            };
            /**
            * Creates a TrialInfoReq message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof gaiaProto.TrialInfoReq
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {gaiaProto.TrialInfoReq} TrialInfoReq
            */


            TrialInfoReq.fromObject = function fromObject(object) {
              if (object instanceof $root.gaiaProto.TrialInfoReq) return object;
              var message = new $root.gaiaProto.TrialInfoReq();
              if (object.aid != null) message.aid = object.aid | 0;
              if (object.token != null) message.token = String(object.token);
              if (object.vip != null) message.vip = object.vip | 0;
              if (object.lang != null) message.lang = object.lang | 0;
              return message;
            };
            /**
            * Creates a plain object from a TrialInfoReq message. Also converts values to other types if specified.
            * @function toObject
            * @memberof gaiaProto.TrialInfoReq
            * @static
            * @param {gaiaProto.TrialInfoReq} message TrialInfoReq
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            TrialInfoReq.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.aid = 0;
                object.token = "";
                object.vip = 0;
                object.lang = 0;
              }

              if (message.aid != null && message.hasOwnProperty("aid")) object.aid = message.aid;
              if (message.token != null && message.hasOwnProperty("token")) object.token = message.token;
              if (message.vip != null && message.hasOwnProperty("vip")) object.vip = message.vip;
              if (message.lang != null && message.hasOwnProperty("lang")) object.lang = message.lang;
              return object;
            };
            /**
            * Converts this TrialInfoReq to JSON.
            * @function toJSON
            * @memberof gaiaProto.TrialInfoReq
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            TrialInfoReq.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TrialInfoReq;
          }();

          gaiaProto.TrialSignUpReq = function () {
            /**
            * Properties of a TrialSignUpReq.
            * @memberof gaiaProto
            * @interface ITrialSignUpReq
            * @property {number|null} [aid] TrialSignUpReq aid
            * @property {string|null} [token] TrialSignUpReq token
            * @property {number|null} [vip] TrialSignUpReq vip
            * @property {number|null} [actno] TrialSignUpReq actno
            */

            /**
            * Constructs a new TrialSignUpReq.
            * @memberof gaiaProto
            * @classdesc Represents a TrialSignUpReq.
            * @implements ITrialSignUpReq
            * @constructor
            * @param {gaiaProto.ITrialSignUpReq=} [properties] Properties to set
            */
            function TrialSignUpReq(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * TrialSignUpReq aid.
            * @member {number} aid
            * @memberof gaiaProto.TrialSignUpReq
            * @instance
            */


            TrialSignUpReq.prototype.aid = 0;
            /**
            * TrialSignUpReq token.
            * @member {string} token
            * @memberof gaiaProto.TrialSignUpReq
            * @instance
            */

            TrialSignUpReq.prototype.token = "";
            /**
            * TrialSignUpReq vip.
            * @member {number} vip
            * @memberof gaiaProto.TrialSignUpReq
            * @instance
            */

            TrialSignUpReq.prototype.vip = 0;
            /**
            * TrialSignUpReq actno.
            * @member {number} actno
            * @memberof gaiaProto.TrialSignUpReq
            * @instance
            */

            TrialSignUpReq.prototype.actno = 0;
            /**
            * Creates a new TrialSignUpReq instance using the specified properties.
            * @function create
            * @memberof gaiaProto.TrialSignUpReq
            * @static
            * @param {gaiaProto.ITrialSignUpReq=} [properties] Properties to set
            * @returns {gaiaProto.TrialSignUpReq} TrialSignUpReq instance
            */

            TrialSignUpReq.create = function create(properties) {
              return new TrialSignUpReq(properties);
            };
            /**
            * Encodes the specified TrialSignUpReq message. Does not implicitly {@link gaiaProto.TrialSignUpReq.verify|verify} messages.
            * @function encode
            * @memberof gaiaProto.TrialSignUpReq
            * @static
            * @param {gaiaProto.ITrialSignUpReq} message TrialSignUpReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            TrialSignUpReq.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.aid != null && Object.hasOwnProperty.call(message, "aid")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.aid);
              if (message.token != null && Object.hasOwnProperty.call(message, "token")) writer.uint32(
              /* id 2, wireType 2 =*/
              18).string(message.token);
              if (message.vip != null && Object.hasOwnProperty.call(message, "vip")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.vip);
              if (message.actno != null && Object.hasOwnProperty.call(message, "actno")) writer.uint32(
              /* id 4, wireType 0 =*/
              32).int32(message.actno);
              return writer;
            };
            /**
            * Encodes the specified TrialSignUpReq message, length delimited. Does not implicitly {@link gaiaProto.TrialSignUpReq.verify|verify} messages.
            * @function encodeDelimited
            * @memberof gaiaProto.TrialSignUpReq
            * @static
            * @param {gaiaProto.ITrialSignUpReq} message TrialSignUpReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            TrialSignUpReq.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a TrialSignUpReq message from the specified reader or buffer.
            * @function decode
            * @memberof gaiaProto.TrialSignUpReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {gaiaProto.TrialSignUpReq} TrialSignUpReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            TrialSignUpReq.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gaiaProto.TrialSignUpReq();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.aid = reader.int32();
                    break;

                  case 2:
                    message.token = reader.string();
                    break;

                  case 3:
                    message.vip = reader.int32();
                    break;

                  case 4:
                    message.actno = reader.int32();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a TrialSignUpReq message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof gaiaProto.TrialSignUpReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {gaiaProto.TrialSignUpReq} TrialSignUpReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            TrialSignUpReq.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a TrialSignUpReq message.
            * @function verify
            * @memberof gaiaProto.TrialSignUpReq
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            TrialSignUpReq.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.aid != null && message.hasOwnProperty("aid")) if (!$util.isInteger(message.aid)) return "aid: integer expected";
              if (message.token != null && message.hasOwnProperty("token")) if (!$util.isString(message.token)) return "token: string expected";
              if (message.vip != null && message.hasOwnProperty("vip")) if (!$util.isInteger(message.vip)) return "vip: integer expected";
              if (message.actno != null && message.hasOwnProperty("actno")) if (!$util.isInteger(message.actno)) return "actno: integer expected";
              return null;
            };
            /**
            * Creates a TrialSignUpReq message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof gaiaProto.TrialSignUpReq
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {gaiaProto.TrialSignUpReq} TrialSignUpReq
            */


            TrialSignUpReq.fromObject = function fromObject(object) {
              if (object instanceof $root.gaiaProto.TrialSignUpReq) return object;
              var message = new $root.gaiaProto.TrialSignUpReq();
              if (object.aid != null) message.aid = object.aid | 0;
              if (object.token != null) message.token = String(object.token);
              if (object.vip != null) message.vip = object.vip | 0;
              if (object.actno != null) message.actno = object.actno | 0;
              return message;
            };
            /**
            * Creates a plain object from a TrialSignUpReq message. Also converts values to other types if specified.
            * @function toObject
            * @memberof gaiaProto.TrialSignUpReq
            * @static
            * @param {gaiaProto.TrialSignUpReq} message TrialSignUpReq
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            TrialSignUpReq.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.aid = 0;
                object.token = "";
                object.vip = 0;
                object.actno = 0;
              }

              if (message.aid != null && message.hasOwnProperty("aid")) object.aid = message.aid;
              if (message.token != null && message.hasOwnProperty("token")) object.token = message.token;
              if (message.vip != null && message.hasOwnProperty("vip")) object.vip = message.vip;
              if (message.actno != null && message.hasOwnProperty("actno")) object.actno = message.actno;
              return object;
            };
            /**
            * Converts this TrialSignUpReq to JSON.
            * @function toJSON
            * @memberof gaiaProto.TrialSignUpReq
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            TrialSignUpReq.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TrialSignUpReq;
          }();

          gaiaProto.TrialGiveUpReq = function () {
            /**
            * Properties of a TrialGiveUpReq.
            * @memberof gaiaProto
            * @interface ITrialGiveUpReq
            * @property {number|null} [aid] TrialGiveUpReq aid
            * @property {string|null} [token] TrialGiveUpReq token
            * @property {number|null} [actno] TrialGiveUpReq actno
            */

            /**
            * Constructs a new TrialGiveUpReq.
            * @memberof gaiaProto
            * @classdesc Represents a TrialGiveUpReq.
            * @implements ITrialGiveUpReq
            * @constructor
            * @param {gaiaProto.ITrialGiveUpReq=} [properties] Properties to set
            */
            function TrialGiveUpReq(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * TrialGiveUpReq aid.
            * @member {number} aid
            * @memberof gaiaProto.TrialGiveUpReq
            * @instance
            */


            TrialGiveUpReq.prototype.aid = 0;
            /**
            * TrialGiveUpReq token.
            * @member {string} token
            * @memberof gaiaProto.TrialGiveUpReq
            * @instance
            */

            TrialGiveUpReq.prototype.token = "";
            /**
            * TrialGiveUpReq actno.
            * @member {number} actno
            * @memberof gaiaProto.TrialGiveUpReq
            * @instance
            */

            TrialGiveUpReq.prototype.actno = 0;
            /**
            * Creates a new TrialGiveUpReq instance using the specified properties.
            * @function create
            * @memberof gaiaProto.TrialGiveUpReq
            * @static
            * @param {gaiaProto.ITrialGiveUpReq=} [properties] Properties to set
            * @returns {gaiaProto.TrialGiveUpReq} TrialGiveUpReq instance
            */

            TrialGiveUpReq.create = function create(properties) {
              return new TrialGiveUpReq(properties);
            };
            /**
            * Encodes the specified TrialGiveUpReq message. Does not implicitly {@link gaiaProto.TrialGiveUpReq.verify|verify} messages.
            * @function encode
            * @memberof gaiaProto.TrialGiveUpReq
            * @static
            * @param {gaiaProto.ITrialGiveUpReq} message TrialGiveUpReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            TrialGiveUpReq.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.aid != null && Object.hasOwnProperty.call(message, "aid")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.aid);
              if (message.token != null && Object.hasOwnProperty.call(message, "token")) writer.uint32(
              /* id 2, wireType 2 =*/
              18).string(message.token);
              if (message.actno != null && Object.hasOwnProperty.call(message, "actno")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.actno);
              return writer;
            };
            /**
            * Encodes the specified TrialGiveUpReq message, length delimited. Does not implicitly {@link gaiaProto.TrialGiveUpReq.verify|verify} messages.
            * @function encodeDelimited
            * @memberof gaiaProto.TrialGiveUpReq
            * @static
            * @param {gaiaProto.ITrialGiveUpReq} message TrialGiveUpReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            TrialGiveUpReq.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a TrialGiveUpReq message from the specified reader or buffer.
            * @function decode
            * @memberof gaiaProto.TrialGiveUpReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {gaiaProto.TrialGiveUpReq} TrialGiveUpReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            TrialGiveUpReq.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gaiaProto.TrialGiveUpReq();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.aid = reader.int32();
                    break;

                  case 2:
                    message.token = reader.string();
                    break;

                  case 3:
                    message.actno = reader.int32();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a TrialGiveUpReq message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof gaiaProto.TrialGiveUpReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {gaiaProto.TrialGiveUpReq} TrialGiveUpReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            TrialGiveUpReq.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a TrialGiveUpReq message.
            * @function verify
            * @memberof gaiaProto.TrialGiveUpReq
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            TrialGiveUpReq.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.aid != null && message.hasOwnProperty("aid")) if (!$util.isInteger(message.aid)) return "aid: integer expected";
              if (message.token != null && message.hasOwnProperty("token")) if (!$util.isString(message.token)) return "token: string expected";
              if (message.actno != null && message.hasOwnProperty("actno")) if (!$util.isInteger(message.actno)) return "actno: integer expected";
              return null;
            };
            /**
            * Creates a TrialGiveUpReq message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof gaiaProto.TrialGiveUpReq
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {gaiaProto.TrialGiveUpReq} TrialGiveUpReq
            */


            TrialGiveUpReq.fromObject = function fromObject(object) {
              if (object instanceof $root.gaiaProto.TrialGiveUpReq) return object;
              var message = new $root.gaiaProto.TrialGiveUpReq();
              if (object.aid != null) message.aid = object.aid | 0;
              if (object.token != null) message.token = String(object.token);
              if (object.actno != null) message.actno = object.actno | 0;
              return message;
            };
            /**
            * Creates a plain object from a TrialGiveUpReq message. Also converts values to other types if specified.
            * @function toObject
            * @memberof gaiaProto.TrialGiveUpReq
            * @static
            * @param {gaiaProto.TrialGiveUpReq} message TrialGiveUpReq
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            TrialGiveUpReq.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.aid = 0;
                object.token = "";
                object.actno = 0;
              }

              if (message.aid != null && message.hasOwnProperty("aid")) object.aid = message.aid;
              if (message.token != null && message.hasOwnProperty("token")) object.token = message.token;
              if (message.actno != null && message.hasOwnProperty("actno")) object.actno = message.actno;
              return object;
            };
            /**
            * Converts this TrialGiveUpReq to JSON.
            * @function toJSON
            * @memberof gaiaProto.TrialGiveUpReq
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            TrialGiveUpReq.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TrialGiveUpReq;
          }();

          gaiaProto.TrialInfoAck = function () {
            /**
            * Properties of a TrialInfoAck.
            * @memberof gaiaProto
            * @interface ITrialInfoAck
            * @property {number|null} [acktype] TrialInfoAck acktype
            * @property {number|null} [nowactno] TrialInfoAck nowactno
            * @property {number|null} [targettype] TrialInfoAck targettype
            * @property {Array.<gaiaProto.ITrialAward>|null} [awarddesc] TrialInfoAck awarddesc
            * @property {number|null} [pstate] TrialInfoAck pstate
            * @property {gaiaProto.ITrialPData|null} [trialinfo] TrialInfoAck trialinfo
            * @property {Array.<number>|null} [bet] TrialInfoAck bet
            * @property {boolean|null} [remind] TrialInfoAck remind
            * @property {gaiaProto.ITrialAward|null} [remindinfo] TrialInfoAck remindinfo
            * @property {Array.<number>|null} [rtags] TrialInfoAck rtags
            * @property {string|null} [start] TrialInfoAck start
            * @property {string|null} [end] TrialInfoAck end
            */

            /**
            * Constructs a new TrialInfoAck.
            * @memberof gaiaProto
            * @classdesc Represents a TrialInfoAck.
            * @implements ITrialInfoAck
            * @constructor
            * @param {gaiaProto.ITrialInfoAck=} [properties] Properties to set
            */
            function TrialInfoAck(properties) {
              this.awarddesc = [];
              this.bet = [];
              this.rtags = [];
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * TrialInfoAck acktype.
            * @member {number} acktype
            * @memberof gaiaProto.TrialInfoAck
            * @instance
            */


            TrialInfoAck.prototype.acktype = 0;
            /**
            * TrialInfoAck nowactno.
            * @member {number} nowactno
            * @memberof gaiaProto.TrialInfoAck
            * @instance
            */

            TrialInfoAck.prototype.nowactno = 0;
            /**
            * TrialInfoAck targettype.
            * @member {number} targettype
            * @memberof gaiaProto.TrialInfoAck
            * @instance
            */

            TrialInfoAck.prototype.targettype = 0;
            /**
            * TrialInfoAck awarddesc.
            * @member {Array.<gaiaProto.ITrialAward>} awarddesc
            * @memberof gaiaProto.TrialInfoAck
            * @instance
            */

            TrialInfoAck.prototype.awarddesc = $util.emptyArray;
            /**
            * TrialInfoAck pstate.
            * @member {number} pstate
            * @memberof gaiaProto.TrialInfoAck
            * @instance
            */

            TrialInfoAck.prototype.pstate = 0;
            /**
            * TrialInfoAck trialinfo.
            * @member {gaiaProto.ITrialPData|null|undefined} trialinfo
            * @memberof gaiaProto.TrialInfoAck
            * @instance
            */

            TrialInfoAck.prototype.trialinfo = null;
            /**
            * TrialInfoAck bet.
            * @member {Array.<number>} bet
            * @memberof gaiaProto.TrialInfoAck
            * @instance
            */

            TrialInfoAck.prototype.bet = $util.emptyArray;
            /**
            * TrialInfoAck remind.
            * @member {boolean} remind
            * @memberof gaiaProto.TrialInfoAck
            * @instance
            */

            TrialInfoAck.prototype.remind = false;
            /**
            * TrialInfoAck remindinfo.
            * @member {gaiaProto.ITrialAward|null|undefined} remindinfo
            * @memberof gaiaProto.TrialInfoAck
            * @instance
            */

            TrialInfoAck.prototype.remindinfo = null;
            /**
            * TrialInfoAck rtags.
            * @member {Array.<number>} rtags
            * @memberof gaiaProto.TrialInfoAck
            * @instance
            */

            TrialInfoAck.prototype.rtags = $util.emptyArray;
            /**
            * TrialInfoAck start.
            * @member {string} start
            * @memberof gaiaProto.TrialInfoAck
            * @instance
            */

            TrialInfoAck.prototype.start = "";
            /**
            * TrialInfoAck end.
            * @member {string} end
            * @memberof gaiaProto.TrialInfoAck
            * @instance
            */

            TrialInfoAck.prototype.end = "";
            /**
            * Creates a new TrialInfoAck instance using the specified properties.
            * @function create
            * @memberof gaiaProto.TrialInfoAck
            * @static
            * @param {gaiaProto.ITrialInfoAck=} [properties] Properties to set
            * @returns {gaiaProto.TrialInfoAck} TrialInfoAck instance
            */

            TrialInfoAck.create = function create(properties) {
              return new TrialInfoAck(properties);
            };
            /**
            * Encodes the specified TrialInfoAck message. Does not implicitly {@link gaiaProto.TrialInfoAck.verify|verify} messages.
            * @function encode
            * @memberof gaiaProto.TrialInfoAck
            * @static
            * @param {gaiaProto.ITrialInfoAck} message TrialInfoAck message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            TrialInfoAck.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.acktype != null && Object.hasOwnProperty.call(message, "acktype")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.acktype);
              if (message.nowactno != null && Object.hasOwnProperty.call(message, "nowactno")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int32(message.nowactno);
              if (message.targettype != null && Object.hasOwnProperty.call(message, "targettype")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.targettype);
              if (message.awarddesc != null && message.awarddesc.length) for (var i = 0; i < message.awarddesc.length; ++i) {
                $root.gaiaProto.TrialAward.encode(message.awarddesc[i], writer.uint32(
                /* id 4, wireType 2 =*/
                34).fork()).ldelim();
              }
              if (message.pstate != null && Object.hasOwnProperty.call(message, "pstate")) writer.uint32(
              /* id 5, wireType 0 =*/
              40).int32(message.pstate);
              if (message.trialinfo != null && Object.hasOwnProperty.call(message, "trialinfo")) $root.gaiaProto.TrialPData.encode(message.trialinfo, writer.uint32(
              /* id 6, wireType 2 =*/
              50).fork()).ldelim();

              if (message.bet != null && message.bet.length) {
                writer.uint32(
                /* id 7, wireType 2 =*/
                58).fork();

                for (var i = 0; i < message.bet.length; ++i) {
                  writer["double"](message.bet[i]);
                }

                writer.ldelim();
              }

              if (message.remind != null && Object.hasOwnProperty.call(message, "remind")) writer.uint32(
              /* id 8, wireType 0 =*/
              64).bool(message.remind);
              if (message.remindinfo != null && Object.hasOwnProperty.call(message, "remindinfo")) $root.gaiaProto.TrialAward.encode(message.remindinfo, writer.uint32(
              /* id 9, wireType 2 =*/
              74).fork()).ldelim();

              if (message.rtags != null && message.rtags.length) {
                writer.uint32(
                /* id 10, wireType 2 =*/
                82).fork();

                for (var i = 0; i < message.rtags.length; ++i) {
                  writer.int32(message.rtags[i]);
                }

                writer.ldelim();
              }

              if (message.start != null && Object.hasOwnProperty.call(message, "start")) writer.uint32(
              /* id 11, wireType 2 =*/
              90).string(message.start);
              if (message.end != null && Object.hasOwnProperty.call(message, "end")) writer.uint32(
              /* id 12, wireType 2 =*/
              98).string(message.end);
              return writer;
            };
            /**
            * Encodes the specified TrialInfoAck message, length delimited. Does not implicitly {@link gaiaProto.TrialInfoAck.verify|verify} messages.
            * @function encodeDelimited
            * @memberof gaiaProto.TrialInfoAck
            * @static
            * @param {gaiaProto.ITrialInfoAck} message TrialInfoAck message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            TrialInfoAck.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a TrialInfoAck message from the specified reader or buffer.
            * @function decode
            * @memberof gaiaProto.TrialInfoAck
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {gaiaProto.TrialInfoAck} TrialInfoAck
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            TrialInfoAck.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gaiaProto.TrialInfoAck();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.acktype = reader.int32();
                    break;

                  case 2:
                    message.nowactno = reader.int32();
                    break;

                  case 3:
                    message.targettype = reader.int32();
                    break;

                  case 4:
                    if (!(message.awarddesc && message.awarddesc.length)) message.awarddesc = [];
                    message.awarddesc.push($root.gaiaProto.TrialAward.decode(reader, reader.uint32()));
                    break;

                  case 5:
                    message.pstate = reader.int32();
                    break;

                  case 6:
                    message.trialinfo = $root.gaiaProto.TrialPData.decode(reader, reader.uint32());
                    break;

                  case 7:
                    if (!(message.bet && message.bet.length)) message.bet = [];

                    if ((tag & 7) === 2) {
                      var end2 = reader.uint32() + reader.pos;

                      while (reader.pos < end2) {
                        message.bet.push(reader["double"]());
                      }
                    } else message.bet.push(reader["double"]());

                    break;

                  case 8:
                    message.remind = reader.bool();
                    break;

                  case 9:
                    message.remindinfo = $root.gaiaProto.TrialAward.decode(reader, reader.uint32());
                    break;

                  case 10:
                    if (!(message.rtags && message.rtags.length)) message.rtags = [];

                    if ((tag & 7) === 2) {
                      var end2 = reader.uint32() + reader.pos;

                      while (reader.pos < end2) {
                        message.rtags.push(reader.int32());
                      }
                    } else message.rtags.push(reader.int32());

                    break;

                  case 11:
                    message.start = reader.string();
                    break;

                  case 12:
                    message.end = reader.string();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a TrialInfoAck message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof gaiaProto.TrialInfoAck
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {gaiaProto.TrialInfoAck} TrialInfoAck
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            TrialInfoAck.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a TrialInfoAck message.
            * @function verify
            * @memberof gaiaProto.TrialInfoAck
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            TrialInfoAck.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.acktype != null && message.hasOwnProperty("acktype")) if (!$util.isInteger(message.acktype)) return "acktype: integer expected";
              if (message.nowactno != null && message.hasOwnProperty("nowactno")) if (!$util.isInteger(message.nowactno)) return "nowactno: integer expected";
              if (message.targettype != null && message.hasOwnProperty("targettype")) if (!$util.isInteger(message.targettype)) return "targettype: integer expected";

              if (message.awarddesc != null && message.hasOwnProperty("awarddesc")) {
                if (!Array.isArray(message.awarddesc)) return "awarddesc: array expected";

                for (var i = 0; i < message.awarddesc.length; ++i) {
                  var error = $root.gaiaProto.TrialAward.verify(message.awarddesc[i]);
                  if (error) return "awarddesc." + error;
                }
              }

              if (message.pstate != null && message.hasOwnProperty("pstate")) if (!$util.isInteger(message.pstate)) return "pstate: integer expected";

              if (message.trialinfo != null && message.hasOwnProperty("trialinfo")) {
                var error = $root.gaiaProto.TrialPData.verify(message.trialinfo);
                if (error) return "trialinfo." + error;
              }

              if (message.bet != null && message.hasOwnProperty("bet")) {
                if (!Array.isArray(message.bet)) return "bet: array expected";

                for (var i = 0; i < message.bet.length; ++i) {
                  if (typeof message.bet[i] !== "number") return "bet: number[] expected";
                }
              }

              if (message.remind != null && message.hasOwnProperty("remind")) if (typeof message.remind !== "boolean") return "remind: boolean expected";

              if (message.remindinfo != null && message.hasOwnProperty("remindinfo")) {
                var error = $root.gaiaProto.TrialAward.verify(message.remindinfo);
                if (error) return "remindinfo." + error;
              }

              if (message.rtags != null && message.hasOwnProperty("rtags")) {
                if (!Array.isArray(message.rtags)) return "rtags: array expected";

                for (var i = 0; i < message.rtags.length; ++i) {
                  if (!$util.isInteger(message.rtags[i])) return "rtags: integer[] expected";
                }
              }

              if (message.start != null && message.hasOwnProperty("start")) if (!$util.isString(message.start)) return "start: string expected";
              if (message.end != null && message.hasOwnProperty("end")) if (!$util.isString(message.end)) return "end: string expected";
              return null;
            };
            /**
            * Creates a TrialInfoAck message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof gaiaProto.TrialInfoAck
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {gaiaProto.TrialInfoAck} TrialInfoAck
            */


            TrialInfoAck.fromObject = function fromObject(object) {
              if (object instanceof $root.gaiaProto.TrialInfoAck) return object;
              var message = new $root.gaiaProto.TrialInfoAck();
              if (object.acktype != null) message.acktype = object.acktype | 0;
              if (object.nowactno != null) message.nowactno = object.nowactno | 0;
              if (object.targettype != null) message.targettype = object.targettype | 0;

              if (object.awarddesc) {
                if (!Array.isArray(object.awarddesc)) throw TypeError(".gaiaProto.TrialInfoAck.awarddesc: array expected");
                message.awarddesc = [];

                for (var i = 0; i < object.awarddesc.length; ++i) {
                  if (typeof object.awarddesc[i] !== "object") throw TypeError(".gaiaProto.TrialInfoAck.awarddesc: object expected");
                  message.awarddesc[i] = $root.gaiaProto.TrialAward.fromObject(object.awarddesc[i]);
                }
              }

              if (object.pstate != null) message.pstate = object.pstate | 0;

              if (object.trialinfo != null) {
                if (typeof object.trialinfo !== "object") throw TypeError(".gaiaProto.TrialInfoAck.trialinfo: object expected");
                message.trialinfo = $root.gaiaProto.TrialPData.fromObject(object.trialinfo);
              }

              if (object.bet) {
                if (!Array.isArray(object.bet)) throw TypeError(".gaiaProto.TrialInfoAck.bet: array expected");
                message.bet = [];

                for (var i = 0; i < object.bet.length; ++i) {
                  message.bet[i] = Number(object.bet[i]);
                }
              }

              if (object.remind != null) message.remind = Boolean(object.remind);

              if (object.remindinfo != null) {
                if (typeof object.remindinfo !== "object") throw TypeError(".gaiaProto.TrialInfoAck.remindinfo: object expected");
                message.remindinfo = $root.gaiaProto.TrialAward.fromObject(object.remindinfo);
              }

              if (object.rtags) {
                if (!Array.isArray(object.rtags)) throw TypeError(".gaiaProto.TrialInfoAck.rtags: array expected");
                message.rtags = [];

                for (var i = 0; i < object.rtags.length; ++i) {
                  message.rtags[i] = object.rtags[i] | 0;
                }
              }

              if (object.start != null) message.start = String(object.start);
              if (object.end != null) message.end = String(object.end);
              return message;
            };
            /**
            * Creates a plain object from a TrialInfoAck message. Also converts values to other types if specified.
            * @function toObject
            * @memberof gaiaProto.TrialInfoAck
            * @static
            * @param {gaiaProto.TrialInfoAck} message TrialInfoAck
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            TrialInfoAck.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.arrays || options.defaults) {
                object.awarddesc = [];
                object.bet = [];
                object.rtags = [];
              }

              if (options.defaults) {
                object.acktype = 0;
                object.nowactno = 0;
                object.targettype = 0;
                object.pstate = 0;
                object.trialinfo = null;
                object.remind = false;
                object.remindinfo = null;
                object.start = "";
                object.end = "";
              }

              if (message.acktype != null && message.hasOwnProperty("acktype")) object.acktype = message.acktype;
              if (message.nowactno != null && message.hasOwnProperty("nowactno")) object.nowactno = message.nowactno;
              if (message.targettype != null && message.hasOwnProperty("targettype")) object.targettype = message.targettype;

              if (message.awarddesc && message.awarddesc.length) {
                object.awarddesc = [];

                for (var j = 0; j < message.awarddesc.length; ++j) {
                  object.awarddesc[j] = $root.gaiaProto.TrialAward.toObject(message.awarddesc[j], options);
                }
              }

              if (message.pstate != null && message.hasOwnProperty("pstate")) object.pstate = message.pstate;
              if (message.trialinfo != null && message.hasOwnProperty("trialinfo")) object.trialinfo = $root.gaiaProto.TrialPData.toObject(message.trialinfo, options);

              if (message.bet && message.bet.length) {
                object.bet = [];

                for (var j = 0; j < message.bet.length; ++j) {
                  object.bet[j] = options.json && !isFinite(message.bet[j]) ? String(message.bet[j]) : message.bet[j];
                }
              }

              if (message.remind != null && message.hasOwnProperty("remind")) object.remind = message.remind;
              if (message.remindinfo != null && message.hasOwnProperty("remindinfo")) object.remindinfo = $root.gaiaProto.TrialAward.toObject(message.remindinfo, options);

              if (message.rtags && message.rtags.length) {
                object.rtags = [];

                for (var j = 0; j < message.rtags.length; ++j) {
                  object.rtags[j] = message.rtags[j];
                }
              }

              if (message.start != null && message.hasOwnProperty("start")) object.start = message.start;
              if (message.end != null && message.hasOwnProperty("end")) object.end = message.end;
              return object;
            };
            /**
            * Converts this TrialInfoAck to JSON.
            * @function toJSON
            * @memberof gaiaProto.TrialInfoAck
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            TrialInfoAck.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TrialInfoAck;
          }();

          gaiaProto.TrialAward = function () {
            /**
            * Properties of a TrialAward.
            * @memberof gaiaProto
            * @interface ITrialAward
            * @property {number|null} [award] TrialAward award
            * @property {number|null} [type] TrialAward type
            * @property {number|null} [gate] TrialAward gate
            * @property {number|null} [gameid] TrialAward gameid
            * @property {number|null} [itemid] TrialAward itemid
            * @property {number|null} [amount] TrialAward amount
            * @property {gaiaProto.ITrialItem|null} [data] TrialAward data
            * @property {number|null} [money] TrialAward money
            */

            /**
            * Constructs a new TrialAward.
            * @memberof gaiaProto
            * @classdesc Represents a TrialAward.
            * @implements ITrialAward
            * @constructor
            * @param {gaiaProto.ITrialAward=} [properties] Properties to set
            */
            function TrialAward(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * TrialAward award.
            * @member {number} award
            * @memberof gaiaProto.TrialAward
            * @instance
            */


            TrialAward.prototype.award = 0;
            /**
            * TrialAward type.
            * @member {number} type
            * @memberof gaiaProto.TrialAward
            * @instance
            */

            TrialAward.prototype.type = 0;
            /**
            * TrialAward gate.
            * @member {number} gate
            * @memberof gaiaProto.TrialAward
            * @instance
            */

            TrialAward.prototype.gate = 0;
            /**
            * TrialAward gameid.
            * @member {number} gameid
            * @memberof gaiaProto.TrialAward
            * @instance
            */

            TrialAward.prototype.gameid = 0;
            /**
            * TrialAward itemid.
            * @member {number} itemid
            * @memberof gaiaProto.TrialAward
            * @instance
            */

            TrialAward.prototype.itemid = 0;
            /**
            * TrialAward amount.
            * @member {number} amount
            * @memberof gaiaProto.TrialAward
            * @instance
            */

            TrialAward.prototype.amount = 0;
            /**
            * TrialAward data.
            * @member {gaiaProto.ITrialItem|null|undefined} data
            * @memberof gaiaProto.TrialAward
            * @instance
            */

            TrialAward.prototype.data = null;
            /**
            * TrialAward money.
            * @member {number} money
            * @memberof gaiaProto.TrialAward
            * @instance
            */

            TrialAward.prototype.money = 0;
            /**
            * Creates a new TrialAward instance using the specified properties.
            * @function create
            * @memberof gaiaProto.TrialAward
            * @static
            * @param {gaiaProto.ITrialAward=} [properties] Properties to set
            * @returns {gaiaProto.TrialAward} TrialAward instance
            */

            TrialAward.create = function create(properties) {
              return new TrialAward(properties);
            };
            /**
            * Encodes the specified TrialAward message. Does not implicitly {@link gaiaProto.TrialAward.verify|verify} messages.
            * @function encode
            * @memberof gaiaProto.TrialAward
            * @static
            * @param {gaiaProto.ITrialAward} message TrialAward message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            TrialAward.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.award != null && Object.hasOwnProperty.call(message, "award")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.award);
              if (message.type != null && Object.hasOwnProperty.call(message, "type")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int32(message.type);
              if (message.gate != null && Object.hasOwnProperty.call(message, "gate")) writer.uint32(
              /* id 3, wireType 1 =*/
              25)["double"](message.gate);
              if (message.gameid != null && Object.hasOwnProperty.call(message, "gameid")) writer.uint32(
              /* id 4, wireType 0 =*/
              32).int32(message.gameid);
              if (message.itemid != null && Object.hasOwnProperty.call(message, "itemid")) writer.uint32(
              /* id 5, wireType 0 =*/
              40).int32(message.itemid);
              if (message.amount != null && Object.hasOwnProperty.call(message, "amount")) writer.uint32(
              /* id 6, wireType 0 =*/
              48).int32(message.amount);
              if (message.data != null && Object.hasOwnProperty.call(message, "data")) $root.gaiaProto.TrialItem.encode(message.data, writer.uint32(
              /* id 7, wireType 2 =*/
              58).fork()).ldelim();
              if (message.money != null && Object.hasOwnProperty.call(message, "money")) writer.uint32(
              /* id 8, wireType 1 =*/
              65)["double"](message.money);
              return writer;
            };
            /**
            * Encodes the specified TrialAward message, length delimited. Does not implicitly {@link gaiaProto.TrialAward.verify|verify} messages.
            * @function encodeDelimited
            * @memberof gaiaProto.TrialAward
            * @static
            * @param {gaiaProto.ITrialAward} message TrialAward message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            TrialAward.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a TrialAward message from the specified reader or buffer.
            * @function decode
            * @memberof gaiaProto.TrialAward
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {gaiaProto.TrialAward} TrialAward
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            TrialAward.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gaiaProto.TrialAward();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.award = reader.int32();
                    break;

                  case 2:
                    message.type = reader.int32();
                    break;

                  case 3:
                    message.gate = reader["double"]();
                    break;

                  case 4:
                    message.gameid = reader.int32();
                    break;

                  case 5:
                    message.itemid = reader.int32();
                    break;

                  case 6:
                    message.amount = reader.int32();
                    break;

                  case 7:
                    message.data = $root.gaiaProto.TrialItem.decode(reader, reader.uint32());
                    break;

                  case 8:
                    message.money = reader["double"]();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a TrialAward message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof gaiaProto.TrialAward
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {gaiaProto.TrialAward} TrialAward
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            TrialAward.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a TrialAward message.
            * @function verify
            * @memberof gaiaProto.TrialAward
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            TrialAward.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.award != null && message.hasOwnProperty("award")) if (!$util.isInteger(message.award)) return "award: integer expected";
              if (message.type != null && message.hasOwnProperty("type")) if (!$util.isInteger(message.type)) return "type: integer expected";
              if (message.gate != null && message.hasOwnProperty("gate")) if (typeof message.gate !== "number") return "gate: number expected";
              if (message.gameid != null && message.hasOwnProperty("gameid")) if (!$util.isInteger(message.gameid)) return "gameid: integer expected";
              if (message.itemid != null && message.hasOwnProperty("itemid")) if (!$util.isInteger(message.itemid)) return "itemid: integer expected";
              if (message.amount != null && message.hasOwnProperty("amount")) if (!$util.isInteger(message.amount)) return "amount: integer expected";

              if (message.data != null && message.hasOwnProperty("data")) {
                var error = $root.gaiaProto.TrialItem.verify(message.data);
                if (error) return "data." + error;
              }

              if (message.money != null && message.hasOwnProperty("money")) if (typeof message.money !== "number") return "money: number expected";
              return null;
            };
            /**
            * Creates a TrialAward message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof gaiaProto.TrialAward
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {gaiaProto.TrialAward} TrialAward
            */


            TrialAward.fromObject = function fromObject(object) {
              if (object instanceof $root.gaiaProto.TrialAward) return object;
              var message = new $root.gaiaProto.TrialAward();
              if (object.award != null) message.award = object.award | 0;
              if (object.type != null) message.type = object.type | 0;
              if (object.gate != null) message.gate = Number(object.gate);
              if (object.gameid != null) message.gameid = object.gameid | 0;
              if (object.itemid != null) message.itemid = object.itemid | 0;
              if (object.amount != null) message.amount = object.amount | 0;

              if (object.data != null) {
                if (typeof object.data !== "object") throw TypeError(".gaiaProto.TrialAward.data: object expected");
                message.data = $root.gaiaProto.TrialItem.fromObject(object.data);
              }

              if (object.money != null) message.money = Number(object.money);
              return message;
            };
            /**
            * Creates a plain object from a TrialAward message. Also converts values to other types if specified.
            * @function toObject
            * @memberof gaiaProto.TrialAward
            * @static
            * @param {gaiaProto.TrialAward} message TrialAward
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            TrialAward.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.award = 0;
                object.type = 0;
                object.gate = 0;
                object.gameid = 0;
                object.itemid = 0;
                object.amount = 0;
                object.data = null;
                object.money = 0;
              }

              if (message.award != null && message.hasOwnProperty("award")) object.award = message.award;
              if (message.type != null && message.hasOwnProperty("type")) object.type = message.type;
              if (message.gate != null && message.hasOwnProperty("gate")) object.gate = options.json && !isFinite(message.gate) ? String(message.gate) : message.gate;
              if (message.gameid != null && message.hasOwnProperty("gameid")) object.gameid = message.gameid;
              if (message.itemid != null && message.hasOwnProperty("itemid")) object.itemid = message.itemid;
              if (message.amount != null && message.hasOwnProperty("amount")) object.amount = message.amount;
              if (message.data != null && message.hasOwnProperty("data")) object.data = $root.gaiaProto.TrialItem.toObject(message.data, options);
              if (message.money != null && message.hasOwnProperty("money")) object.money = options.json && !isFinite(message.money) ? String(message.money) : message.money;
              return object;
            };
            /**
            * Converts this TrialAward to JSON.
            * @function toJSON
            * @memberof gaiaProto.TrialAward
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            TrialAward.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TrialAward;
          }();

          gaiaProto.TrialItem = function () {
            /**
            * Properties of a TrialItem.
            * @memberof gaiaProto
            * @interface ITrialItem
            * @property {number|null} [star] TrialItem star
            * @property {number|null} [icon] TrialItem icon
            * @property {number|null} [type] TrialItem type
            * @property {number|null} [bet] TrialItem bet
            * @property {string|null} [gamename] TrialItem gamename
            */

            /**
            * Constructs a new TrialItem.
            * @memberof gaiaProto
            * @classdesc Represents a TrialItem.
            * @implements ITrialItem
            * @constructor
            * @param {gaiaProto.ITrialItem=} [properties] Properties to set
            */
            function TrialItem(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * TrialItem star.
            * @member {number} star
            * @memberof gaiaProto.TrialItem
            * @instance
            */


            TrialItem.prototype.star = 0;
            /**
            * TrialItem icon.
            * @member {number} icon
            * @memberof gaiaProto.TrialItem
            * @instance
            */

            TrialItem.prototype.icon = 0;
            /**
            * TrialItem type.
            * @member {number} type
            * @memberof gaiaProto.TrialItem
            * @instance
            */

            TrialItem.prototype.type = 0;
            /**
            * TrialItem bet.
            * @member {number} bet
            * @memberof gaiaProto.TrialItem
            * @instance
            */

            TrialItem.prototype.bet = 0;
            /**
            * TrialItem gamename.
            * @member {string} gamename
            * @memberof gaiaProto.TrialItem
            * @instance
            */

            TrialItem.prototype.gamename = "";
            /**
            * Creates a new TrialItem instance using the specified properties.
            * @function create
            * @memberof gaiaProto.TrialItem
            * @static
            * @param {gaiaProto.ITrialItem=} [properties] Properties to set
            * @returns {gaiaProto.TrialItem} TrialItem instance
            */

            TrialItem.create = function create(properties) {
              return new TrialItem(properties);
            };
            /**
            * Encodes the specified TrialItem message. Does not implicitly {@link gaiaProto.TrialItem.verify|verify} messages.
            * @function encode
            * @memberof gaiaProto.TrialItem
            * @static
            * @param {gaiaProto.ITrialItem} message TrialItem message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            TrialItem.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.star != null && Object.hasOwnProperty.call(message, "star")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.star);
              if (message.icon != null && Object.hasOwnProperty.call(message, "icon")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int32(message.icon);
              if (message.type != null && Object.hasOwnProperty.call(message, "type")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.type);
              if (message.bet != null && Object.hasOwnProperty.call(message, "bet")) writer.uint32(
              /* id 4, wireType 1 =*/
              33)["double"](message.bet);
              if (message.gamename != null && Object.hasOwnProperty.call(message, "gamename")) writer.uint32(
              /* id 5, wireType 2 =*/
              42).string(message.gamename);
              return writer;
            };
            /**
            * Encodes the specified TrialItem message, length delimited. Does not implicitly {@link gaiaProto.TrialItem.verify|verify} messages.
            * @function encodeDelimited
            * @memberof gaiaProto.TrialItem
            * @static
            * @param {gaiaProto.ITrialItem} message TrialItem message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            TrialItem.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a TrialItem message from the specified reader or buffer.
            * @function decode
            * @memberof gaiaProto.TrialItem
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {gaiaProto.TrialItem} TrialItem
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            TrialItem.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gaiaProto.TrialItem();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.star = reader.int32();
                    break;

                  case 2:
                    message.icon = reader.int32();
                    break;

                  case 3:
                    message.type = reader.int32();
                    break;

                  case 4:
                    message.bet = reader["double"]();
                    break;

                  case 5:
                    message.gamename = reader.string();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a TrialItem message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof gaiaProto.TrialItem
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {gaiaProto.TrialItem} TrialItem
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            TrialItem.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a TrialItem message.
            * @function verify
            * @memberof gaiaProto.TrialItem
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            TrialItem.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.star != null && message.hasOwnProperty("star")) if (!$util.isInteger(message.star)) return "star: integer expected";
              if (message.icon != null && message.hasOwnProperty("icon")) if (!$util.isInteger(message.icon)) return "icon: integer expected";
              if (message.type != null && message.hasOwnProperty("type")) if (!$util.isInteger(message.type)) return "type: integer expected";
              if (message.bet != null && message.hasOwnProperty("bet")) if (typeof message.bet !== "number") return "bet: number expected";
              if (message.gamename != null && message.hasOwnProperty("gamename")) if (!$util.isString(message.gamename)) return "gamename: string expected";
              return null;
            };
            /**
            * Creates a TrialItem message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof gaiaProto.TrialItem
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {gaiaProto.TrialItem} TrialItem
            */


            TrialItem.fromObject = function fromObject(object) {
              if (object instanceof $root.gaiaProto.TrialItem) return object;
              var message = new $root.gaiaProto.TrialItem();
              if (object.star != null) message.star = object.star | 0;
              if (object.icon != null) message.icon = object.icon | 0;
              if (object.type != null) message.type = object.type | 0;
              if (object.bet != null) message.bet = Number(object.bet);
              if (object.gamename != null) message.gamename = String(object.gamename);
              return message;
            };
            /**
            * Creates a plain object from a TrialItem message. Also converts values to other types if specified.
            * @function toObject
            * @memberof gaiaProto.TrialItem
            * @static
            * @param {gaiaProto.TrialItem} message TrialItem
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            TrialItem.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.star = 0;
                object.icon = 0;
                object.type = 0;
                object.bet = 0;
                object.gamename = "";
              }

              if (message.star != null && message.hasOwnProperty("star")) object.star = message.star;
              if (message.icon != null && message.hasOwnProperty("icon")) object.icon = message.icon;
              if (message.type != null && message.hasOwnProperty("type")) object.type = message.type;
              if (message.bet != null && message.hasOwnProperty("bet")) object.bet = options.json && !isFinite(message.bet) ? String(message.bet) : message.bet;
              if (message.gamename != null && message.hasOwnProperty("gamename")) object.gamename = message.gamename;
              return object;
            };
            /**
            * Converts this TrialItem to JSON.
            * @function toJSON
            * @memberof gaiaProto.TrialItem
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            TrialItem.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TrialItem;
          }();

          gaiaProto.TrialPData = function () {
            /**
            * Properties of a TrialPData.
            * @memberof gaiaProto
            * @interface ITrialPData
            * @property {number|null} [apiid] TrialPData apiid
            * @property {number|null} [gameid] TrialPData gameid
            * @property {number|null} [sac] TrialPData sac
            * @property {number|null} [activityno] TrialPData activityno
            * @property {number|null} [totalbet] TrialPData totalbet
            * @property {number|null} [totalwin] TrialPData totalwin
            * @property {number|null} [property] TrialPData property
            */

            /**
            * Constructs a new TrialPData.
            * @memberof gaiaProto
            * @classdesc Represents a TrialPData.
            * @implements ITrialPData
            * @constructor
            * @param {gaiaProto.ITrialPData=} [properties] Properties to set
            */
            function TrialPData(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * TrialPData apiid.
            * @member {number} apiid
            * @memberof gaiaProto.TrialPData
            * @instance
            */


            TrialPData.prototype.apiid = 0;
            /**
            * TrialPData gameid.
            * @member {number} gameid
            * @memberof gaiaProto.TrialPData
            * @instance
            */

            TrialPData.prototype.gameid = 0;
            /**
            * TrialPData sac.
            * @member {number} sac
            * @memberof gaiaProto.TrialPData
            * @instance
            */

            TrialPData.prototype.sac = 0;
            /**
            * TrialPData activityno.
            * @member {number} activityno
            * @memberof gaiaProto.TrialPData
            * @instance
            */

            TrialPData.prototype.activityno = 0;
            /**
            * TrialPData totalbet.
            * @member {number} totalbet
            * @memberof gaiaProto.TrialPData
            * @instance
            */

            TrialPData.prototype.totalbet = 0;
            /**
            * TrialPData totalwin.
            * @member {number} totalwin
            * @memberof gaiaProto.TrialPData
            * @instance
            */

            TrialPData.prototype.totalwin = 0;
            /**
            * TrialPData property.
            * @member {number} property
            * @memberof gaiaProto.TrialPData
            * @instance
            */

            TrialPData.prototype.property = 0;
            /**
            * Creates a new TrialPData instance using the specified properties.
            * @function create
            * @memberof gaiaProto.TrialPData
            * @static
            * @param {gaiaProto.ITrialPData=} [properties] Properties to set
            * @returns {gaiaProto.TrialPData} TrialPData instance
            */

            TrialPData.create = function create(properties) {
              return new TrialPData(properties);
            };
            /**
            * Encodes the specified TrialPData message. Does not implicitly {@link gaiaProto.TrialPData.verify|verify} messages.
            * @function encode
            * @memberof gaiaProto.TrialPData
            * @static
            * @param {gaiaProto.ITrialPData} message TrialPData message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            TrialPData.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.apiid != null && Object.hasOwnProperty.call(message, "apiid")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.apiid);
              if (message.gameid != null && Object.hasOwnProperty.call(message, "gameid")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int32(message.gameid);
              if (message.sac != null && Object.hasOwnProperty.call(message, "sac")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.sac);
              if (message.activityno != null && Object.hasOwnProperty.call(message, "activityno")) writer.uint32(
              /* id 4, wireType 0 =*/
              32).int32(message.activityno);
              if (message.totalbet != null && Object.hasOwnProperty.call(message, "totalbet")) writer.uint32(
              /* id 5, wireType 1 =*/
              41)["double"](message.totalbet);
              if (message.totalwin != null && Object.hasOwnProperty.call(message, "totalwin")) writer.uint32(
              /* id 6, wireType 1 =*/
              49)["double"](message.totalwin);
              if (message.property != null && Object.hasOwnProperty.call(message, "property")) writer.uint32(
              /* id 7, wireType 1 =*/
              57)["double"](message.property);
              return writer;
            };
            /**
            * Encodes the specified TrialPData message, length delimited. Does not implicitly {@link gaiaProto.TrialPData.verify|verify} messages.
            * @function encodeDelimited
            * @memberof gaiaProto.TrialPData
            * @static
            * @param {gaiaProto.ITrialPData} message TrialPData message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            TrialPData.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a TrialPData message from the specified reader or buffer.
            * @function decode
            * @memberof gaiaProto.TrialPData
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {gaiaProto.TrialPData} TrialPData
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            TrialPData.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gaiaProto.TrialPData();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.apiid = reader.int32();
                    break;

                  case 2:
                    message.gameid = reader.int32();
                    break;

                  case 3:
                    message.sac = reader.int32();
                    break;

                  case 4:
                    message.activityno = reader.int32();
                    break;

                  case 5:
                    message.totalbet = reader["double"]();
                    break;

                  case 6:
                    message.totalwin = reader["double"]();
                    break;

                  case 7:
                    message.property = reader["double"]();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a TrialPData message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof gaiaProto.TrialPData
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {gaiaProto.TrialPData} TrialPData
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            TrialPData.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a TrialPData message.
            * @function verify
            * @memberof gaiaProto.TrialPData
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            TrialPData.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.apiid != null && message.hasOwnProperty("apiid")) if (!$util.isInteger(message.apiid)) return "apiid: integer expected";
              if (message.gameid != null && message.hasOwnProperty("gameid")) if (!$util.isInteger(message.gameid)) return "gameid: integer expected";
              if (message.sac != null && message.hasOwnProperty("sac")) if (!$util.isInteger(message.sac)) return "sac: integer expected";
              if (message.activityno != null && message.hasOwnProperty("activityno")) if (!$util.isInteger(message.activityno)) return "activityno: integer expected";
              if (message.totalbet != null && message.hasOwnProperty("totalbet")) if (typeof message.totalbet !== "number") return "totalbet: number expected";
              if (message.totalwin != null && message.hasOwnProperty("totalwin")) if (typeof message.totalwin !== "number") return "totalwin: number expected";
              if (message.property != null && message.hasOwnProperty("property")) if (typeof message.property !== "number") return "property: number expected";
              return null;
            };
            /**
            * Creates a TrialPData message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof gaiaProto.TrialPData
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {gaiaProto.TrialPData} TrialPData
            */


            TrialPData.fromObject = function fromObject(object) {
              if (object instanceof $root.gaiaProto.TrialPData) return object;
              var message = new $root.gaiaProto.TrialPData();
              if (object.apiid != null) message.apiid = object.apiid | 0;
              if (object.gameid != null) message.gameid = object.gameid | 0;
              if (object.sac != null) message.sac = object.sac | 0;
              if (object.activityno != null) message.activityno = object.activityno | 0;
              if (object.totalbet != null) message.totalbet = Number(object.totalbet);
              if (object.totalwin != null) message.totalwin = Number(object.totalwin);
              if (object.property != null) message.property = Number(object.property);
              return message;
            };
            /**
            * Creates a plain object from a TrialPData message. Also converts values to other types if specified.
            * @function toObject
            * @memberof gaiaProto.TrialPData
            * @static
            * @param {gaiaProto.TrialPData} message TrialPData
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            TrialPData.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.apiid = 0;
                object.gameid = 0;
                object.sac = 0;
                object.activityno = 0;
                object.totalbet = 0;
                object.totalwin = 0;
                object.property = 0;
              }

              if (message.apiid != null && message.hasOwnProperty("apiid")) object.apiid = message.apiid;
              if (message.gameid != null && message.hasOwnProperty("gameid")) object.gameid = message.gameid;
              if (message.sac != null && message.hasOwnProperty("sac")) object.sac = message.sac;
              if (message.activityno != null && message.hasOwnProperty("activityno")) object.activityno = message.activityno;
              if (message.totalbet != null && message.hasOwnProperty("totalbet")) object.totalbet = options.json && !isFinite(message.totalbet) ? String(message.totalbet) : message.totalbet;
              if (message.totalwin != null && message.hasOwnProperty("totalwin")) object.totalwin = options.json && !isFinite(message.totalwin) ? String(message.totalwin) : message.totalwin;
              if (message.property != null && message.hasOwnProperty("property")) object.property = options.json && !isFinite(message.property) ? String(message.property) : message.property;
              return object;
            };
            /**
            * Converts this TrialPData to JSON.
            * @function toJSON
            * @memberof gaiaProto.TrialPData
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            TrialPData.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TrialPData;
          }();

          gaiaProto.TrialSignUpAck = function () {
            /**
            * Properties of a TrialSignUpAck.
            * @memberof gaiaProto
            * @interface ITrialSignUpAck
            * @property {number|null} [acktype] TrialSignUpAck acktype
            * @property {gaiaProto.ITrialPData|null} [trialinfo] TrialSignUpAck trialinfo
            */

            /**
            * Constructs a new TrialSignUpAck.
            * @memberof gaiaProto
            * @classdesc Represents a TrialSignUpAck.
            * @implements ITrialSignUpAck
            * @constructor
            * @param {gaiaProto.ITrialSignUpAck=} [properties] Properties to set
            */
            function TrialSignUpAck(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * TrialSignUpAck acktype.
            * @member {number} acktype
            * @memberof gaiaProto.TrialSignUpAck
            * @instance
            */


            TrialSignUpAck.prototype.acktype = 0;
            /**
            * TrialSignUpAck trialinfo.
            * @member {gaiaProto.ITrialPData|null|undefined} trialinfo
            * @memberof gaiaProto.TrialSignUpAck
            * @instance
            */

            TrialSignUpAck.prototype.trialinfo = null;
            /**
            * Creates a new TrialSignUpAck instance using the specified properties.
            * @function create
            * @memberof gaiaProto.TrialSignUpAck
            * @static
            * @param {gaiaProto.ITrialSignUpAck=} [properties] Properties to set
            * @returns {gaiaProto.TrialSignUpAck} TrialSignUpAck instance
            */

            TrialSignUpAck.create = function create(properties) {
              return new TrialSignUpAck(properties);
            };
            /**
            * Encodes the specified TrialSignUpAck message. Does not implicitly {@link gaiaProto.TrialSignUpAck.verify|verify} messages.
            * @function encode
            * @memberof gaiaProto.TrialSignUpAck
            * @static
            * @param {gaiaProto.ITrialSignUpAck} message TrialSignUpAck message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            TrialSignUpAck.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.acktype != null && Object.hasOwnProperty.call(message, "acktype")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.acktype);
              if (message.trialinfo != null && Object.hasOwnProperty.call(message, "trialinfo")) $root.gaiaProto.TrialPData.encode(message.trialinfo, writer.uint32(
              /* id 2, wireType 2 =*/
              18).fork()).ldelim();
              return writer;
            };
            /**
            * Encodes the specified TrialSignUpAck message, length delimited. Does not implicitly {@link gaiaProto.TrialSignUpAck.verify|verify} messages.
            * @function encodeDelimited
            * @memberof gaiaProto.TrialSignUpAck
            * @static
            * @param {gaiaProto.ITrialSignUpAck} message TrialSignUpAck message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            TrialSignUpAck.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a TrialSignUpAck message from the specified reader or buffer.
            * @function decode
            * @memberof gaiaProto.TrialSignUpAck
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {gaiaProto.TrialSignUpAck} TrialSignUpAck
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            TrialSignUpAck.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gaiaProto.TrialSignUpAck();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.acktype = reader.int32();
                    break;

                  case 2:
                    message.trialinfo = $root.gaiaProto.TrialPData.decode(reader, reader.uint32());
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a TrialSignUpAck message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof gaiaProto.TrialSignUpAck
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {gaiaProto.TrialSignUpAck} TrialSignUpAck
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            TrialSignUpAck.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a TrialSignUpAck message.
            * @function verify
            * @memberof gaiaProto.TrialSignUpAck
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            TrialSignUpAck.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.acktype != null && message.hasOwnProperty("acktype")) if (!$util.isInteger(message.acktype)) return "acktype: integer expected";

              if (message.trialinfo != null && message.hasOwnProperty("trialinfo")) {
                var error = $root.gaiaProto.TrialPData.verify(message.trialinfo);
                if (error) return "trialinfo." + error;
              }

              return null;
            };
            /**
            * Creates a TrialSignUpAck message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof gaiaProto.TrialSignUpAck
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {gaiaProto.TrialSignUpAck} TrialSignUpAck
            */


            TrialSignUpAck.fromObject = function fromObject(object) {
              if (object instanceof $root.gaiaProto.TrialSignUpAck) return object;
              var message = new $root.gaiaProto.TrialSignUpAck();
              if (object.acktype != null) message.acktype = object.acktype | 0;

              if (object.trialinfo != null) {
                if (typeof object.trialinfo !== "object") throw TypeError(".gaiaProto.TrialSignUpAck.trialinfo: object expected");
                message.trialinfo = $root.gaiaProto.TrialPData.fromObject(object.trialinfo);
              }

              return message;
            };
            /**
            * Creates a plain object from a TrialSignUpAck message. Also converts values to other types if specified.
            * @function toObject
            * @memberof gaiaProto.TrialSignUpAck
            * @static
            * @param {gaiaProto.TrialSignUpAck} message TrialSignUpAck
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            TrialSignUpAck.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.acktype = 0;
                object.trialinfo = null;
              }

              if (message.acktype != null && message.hasOwnProperty("acktype")) object.acktype = message.acktype;
              if (message.trialinfo != null && message.hasOwnProperty("trialinfo")) object.trialinfo = $root.gaiaProto.TrialPData.toObject(message.trialinfo, options);
              return object;
            };
            /**
            * Converts this TrialSignUpAck to JSON.
            * @function toJSON
            * @memberof gaiaProto.TrialSignUpAck
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            TrialSignUpAck.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TrialSignUpAck;
          }();

          gaiaProto.TrialGiveUpAck = function () {
            /**
            * Properties of a TrialGiveUpAck.
            * @memberof gaiaProto
            * @interface ITrialGiveUpAck
            * @property {number|null} [acktype] TrialGiveUpAck acktype
            * @property {number|null} [award] TrialGiveUpAck award
            */

            /**
            * Constructs a new TrialGiveUpAck.
            * @memberof gaiaProto
            * @classdesc Represents a TrialGiveUpAck.
            * @implements ITrialGiveUpAck
            * @constructor
            * @param {gaiaProto.ITrialGiveUpAck=} [properties] Properties to set
            */
            function TrialGiveUpAck(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * TrialGiveUpAck acktype.
            * @member {number} acktype
            * @memberof gaiaProto.TrialGiveUpAck
            * @instance
            */


            TrialGiveUpAck.prototype.acktype = 0;
            /**
            * TrialGiveUpAck award.
            * @member {number} award
            * @memberof gaiaProto.TrialGiveUpAck
            * @instance
            */

            TrialGiveUpAck.prototype.award = 0;
            /**
            * Creates a new TrialGiveUpAck instance using the specified properties.
            * @function create
            * @memberof gaiaProto.TrialGiveUpAck
            * @static
            * @param {gaiaProto.ITrialGiveUpAck=} [properties] Properties to set
            * @returns {gaiaProto.TrialGiveUpAck} TrialGiveUpAck instance
            */

            TrialGiveUpAck.create = function create(properties) {
              return new TrialGiveUpAck(properties);
            };
            /**
            * Encodes the specified TrialGiveUpAck message. Does not implicitly {@link gaiaProto.TrialGiveUpAck.verify|verify} messages.
            * @function encode
            * @memberof gaiaProto.TrialGiveUpAck
            * @static
            * @param {gaiaProto.ITrialGiveUpAck} message TrialGiveUpAck message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            TrialGiveUpAck.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.acktype != null && Object.hasOwnProperty.call(message, "acktype")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.acktype);
              if (message.award != null && Object.hasOwnProperty.call(message, "award")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int32(message.award);
              return writer;
            };
            /**
            * Encodes the specified TrialGiveUpAck message, length delimited. Does not implicitly {@link gaiaProto.TrialGiveUpAck.verify|verify} messages.
            * @function encodeDelimited
            * @memberof gaiaProto.TrialGiveUpAck
            * @static
            * @param {gaiaProto.ITrialGiveUpAck} message TrialGiveUpAck message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            TrialGiveUpAck.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a TrialGiveUpAck message from the specified reader or buffer.
            * @function decode
            * @memberof gaiaProto.TrialGiveUpAck
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {gaiaProto.TrialGiveUpAck} TrialGiveUpAck
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            TrialGiveUpAck.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gaiaProto.TrialGiveUpAck();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.acktype = reader.int32();
                    break;

                  case 2:
                    message.award = reader.int32();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a TrialGiveUpAck message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof gaiaProto.TrialGiveUpAck
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {gaiaProto.TrialGiveUpAck} TrialGiveUpAck
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            TrialGiveUpAck.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a TrialGiveUpAck message.
            * @function verify
            * @memberof gaiaProto.TrialGiveUpAck
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            TrialGiveUpAck.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.acktype != null && message.hasOwnProperty("acktype")) if (!$util.isInteger(message.acktype)) return "acktype: integer expected";
              if (message.award != null && message.hasOwnProperty("award")) if (!$util.isInteger(message.award)) return "award: integer expected";
              return null;
            };
            /**
            * Creates a TrialGiveUpAck message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof gaiaProto.TrialGiveUpAck
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {gaiaProto.TrialGiveUpAck} TrialGiveUpAck
            */


            TrialGiveUpAck.fromObject = function fromObject(object) {
              if (object instanceof $root.gaiaProto.TrialGiveUpAck) return object;
              var message = new $root.gaiaProto.TrialGiveUpAck();
              if (object.acktype != null) message.acktype = object.acktype | 0;
              if (object.award != null) message.award = object.award | 0;
              return message;
            };
            /**
            * Creates a plain object from a TrialGiveUpAck message. Also converts values to other types if specified.
            * @function toObject
            * @memberof gaiaProto.TrialGiveUpAck
            * @static
            * @param {gaiaProto.TrialGiveUpAck} message TrialGiveUpAck
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            TrialGiveUpAck.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.acktype = 0;
                object.award = 0;
              }

              if (message.acktype != null && message.hasOwnProperty("acktype")) object.acktype = message.acktype;
              if (message.award != null && message.hasOwnProperty("award")) object.award = message.award;
              return object;
            };
            /**
            * Converts this TrialGiveUpAck to JSON.
            * @function toJSON
            * @memberof gaiaProto.TrialGiveUpAck
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            TrialGiveUpAck.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TrialGiveUpAck;
          }();

          gaiaProto.UnionJPInfoReq = function () {
            /**
            * Properties of an UnionJPInfoReq.
            * @memberof gaiaProto
            * @interface IUnionJPInfoReq
            * @property {number|null} [aid] UnionJPInfoReq aid
            * @property {string|null} [token] UnionJPInfoReq token
            */

            /**
            * Constructs a new UnionJPInfoReq.
            * @memberof gaiaProto
            * @classdesc Represents an UnionJPInfoReq.
            * @implements IUnionJPInfoReq
            * @constructor
            * @param {gaiaProto.IUnionJPInfoReq=} [properties] Properties to set
            */
            function UnionJPInfoReq(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * UnionJPInfoReq aid.
            * @member {number} aid
            * @memberof gaiaProto.UnionJPInfoReq
            * @instance
            */


            UnionJPInfoReq.prototype.aid = 0;
            /**
            * UnionJPInfoReq token.
            * @member {string} token
            * @memberof gaiaProto.UnionJPInfoReq
            * @instance
            */

            UnionJPInfoReq.prototype.token = "";
            /**
            * Creates a new UnionJPInfoReq instance using the specified properties.
            * @function create
            * @memberof gaiaProto.UnionJPInfoReq
            * @static
            * @param {gaiaProto.IUnionJPInfoReq=} [properties] Properties to set
            * @returns {gaiaProto.UnionJPInfoReq} UnionJPInfoReq instance
            */

            UnionJPInfoReq.create = function create(properties) {
              return new UnionJPInfoReq(properties);
            };
            /**
            * Encodes the specified UnionJPInfoReq message. Does not implicitly {@link gaiaProto.UnionJPInfoReq.verify|verify} messages.
            * @function encode
            * @memberof gaiaProto.UnionJPInfoReq
            * @static
            * @param {gaiaProto.IUnionJPInfoReq} message UnionJPInfoReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            UnionJPInfoReq.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.aid != null && Object.hasOwnProperty.call(message, "aid")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.aid);
              if (message.token != null && Object.hasOwnProperty.call(message, "token")) writer.uint32(
              /* id 2, wireType 2 =*/
              18).string(message.token);
              return writer;
            };
            /**
            * Encodes the specified UnionJPInfoReq message, length delimited. Does not implicitly {@link gaiaProto.UnionJPInfoReq.verify|verify} messages.
            * @function encodeDelimited
            * @memberof gaiaProto.UnionJPInfoReq
            * @static
            * @param {gaiaProto.IUnionJPInfoReq} message UnionJPInfoReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            UnionJPInfoReq.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes an UnionJPInfoReq message from the specified reader or buffer.
            * @function decode
            * @memberof gaiaProto.UnionJPInfoReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {gaiaProto.UnionJPInfoReq} UnionJPInfoReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            UnionJPInfoReq.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gaiaProto.UnionJPInfoReq();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.aid = reader.int32();
                    break;

                  case 2:
                    message.token = reader.string();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes an UnionJPInfoReq message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof gaiaProto.UnionJPInfoReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {gaiaProto.UnionJPInfoReq} UnionJPInfoReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            UnionJPInfoReq.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies an UnionJPInfoReq message.
            * @function verify
            * @memberof gaiaProto.UnionJPInfoReq
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            UnionJPInfoReq.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.aid != null && message.hasOwnProperty("aid")) if (!$util.isInteger(message.aid)) return "aid: integer expected";
              if (message.token != null && message.hasOwnProperty("token")) if (!$util.isString(message.token)) return "token: string expected";
              return null;
            };
            /**
            * Creates an UnionJPInfoReq message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof gaiaProto.UnionJPInfoReq
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {gaiaProto.UnionJPInfoReq} UnionJPInfoReq
            */


            UnionJPInfoReq.fromObject = function fromObject(object) {
              if (object instanceof $root.gaiaProto.UnionJPInfoReq) return object;
              var message = new $root.gaiaProto.UnionJPInfoReq();
              if (object.aid != null) message.aid = object.aid | 0;
              if (object.token != null) message.token = String(object.token);
              return message;
            };
            /**
            * Creates a plain object from an UnionJPInfoReq message. Also converts values to other types if specified.
            * @function toObject
            * @memberof gaiaProto.UnionJPInfoReq
            * @static
            * @param {gaiaProto.UnionJPInfoReq} message UnionJPInfoReq
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            UnionJPInfoReq.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.aid = 0;
                object.token = "";
              }

              if (message.aid != null && message.hasOwnProperty("aid")) object.aid = message.aid;
              if (message.token != null && message.hasOwnProperty("token")) object.token = message.token;
              return object;
            };
            /**
            * Converts this UnionJPInfoReq to JSON.
            * @function toJSON
            * @memberof gaiaProto.UnionJPInfoReq
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            UnionJPInfoReq.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return UnionJPInfoReq;
          }();

          gaiaProto.UnionJPInfoAllReq = function () {
            /**
            * Properties of an UnionJPInfoAllReq.
            * @memberof gaiaProto
            * @interface IUnionJPInfoAllReq
            * @property {number|null} [aid] UnionJPInfoAllReq aid
            * @property {string|null} [token] UnionJPInfoAllReq token
            */

            /**
            * Constructs a new UnionJPInfoAllReq.
            * @memberof gaiaProto
            * @classdesc Represents an UnionJPInfoAllReq.
            * @implements IUnionJPInfoAllReq
            * @constructor
            * @param {gaiaProto.IUnionJPInfoAllReq=} [properties] Properties to set
            */
            function UnionJPInfoAllReq(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * UnionJPInfoAllReq aid.
            * @member {number} aid
            * @memberof gaiaProto.UnionJPInfoAllReq
            * @instance
            */


            UnionJPInfoAllReq.prototype.aid = 0;
            /**
            * UnionJPInfoAllReq token.
            * @member {string} token
            * @memberof gaiaProto.UnionJPInfoAllReq
            * @instance
            */

            UnionJPInfoAllReq.prototype.token = "";
            /**
            * Creates a new UnionJPInfoAllReq instance using the specified properties.
            * @function create
            * @memberof gaiaProto.UnionJPInfoAllReq
            * @static
            * @param {gaiaProto.IUnionJPInfoAllReq=} [properties] Properties to set
            * @returns {gaiaProto.UnionJPInfoAllReq} UnionJPInfoAllReq instance
            */

            UnionJPInfoAllReq.create = function create(properties) {
              return new UnionJPInfoAllReq(properties);
            };
            /**
            * Encodes the specified UnionJPInfoAllReq message. Does not implicitly {@link gaiaProto.UnionJPInfoAllReq.verify|verify} messages.
            * @function encode
            * @memberof gaiaProto.UnionJPInfoAllReq
            * @static
            * @param {gaiaProto.IUnionJPInfoAllReq} message UnionJPInfoAllReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            UnionJPInfoAllReq.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.aid != null && Object.hasOwnProperty.call(message, "aid")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.aid);
              if (message.token != null && Object.hasOwnProperty.call(message, "token")) writer.uint32(
              /* id 2, wireType 2 =*/
              18).string(message.token);
              return writer;
            };
            /**
            * Encodes the specified UnionJPInfoAllReq message, length delimited. Does not implicitly {@link gaiaProto.UnionJPInfoAllReq.verify|verify} messages.
            * @function encodeDelimited
            * @memberof gaiaProto.UnionJPInfoAllReq
            * @static
            * @param {gaiaProto.IUnionJPInfoAllReq} message UnionJPInfoAllReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            UnionJPInfoAllReq.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes an UnionJPInfoAllReq message from the specified reader or buffer.
            * @function decode
            * @memberof gaiaProto.UnionJPInfoAllReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {gaiaProto.UnionJPInfoAllReq} UnionJPInfoAllReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            UnionJPInfoAllReq.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gaiaProto.UnionJPInfoAllReq();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.aid = reader.int32();
                    break;

                  case 2:
                    message.token = reader.string();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes an UnionJPInfoAllReq message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof gaiaProto.UnionJPInfoAllReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {gaiaProto.UnionJPInfoAllReq} UnionJPInfoAllReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            UnionJPInfoAllReq.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies an UnionJPInfoAllReq message.
            * @function verify
            * @memberof gaiaProto.UnionJPInfoAllReq
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            UnionJPInfoAllReq.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.aid != null && message.hasOwnProperty("aid")) if (!$util.isInteger(message.aid)) return "aid: integer expected";
              if (message.token != null && message.hasOwnProperty("token")) if (!$util.isString(message.token)) return "token: string expected";
              return null;
            };
            /**
            * Creates an UnionJPInfoAllReq message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof gaiaProto.UnionJPInfoAllReq
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {gaiaProto.UnionJPInfoAllReq} UnionJPInfoAllReq
            */


            UnionJPInfoAllReq.fromObject = function fromObject(object) {
              if (object instanceof $root.gaiaProto.UnionJPInfoAllReq) return object;
              var message = new $root.gaiaProto.UnionJPInfoAllReq();
              if (object.aid != null) message.aid = object.aid | 0;
              if (object.token != null) message.token = String(object.token);
              return message;
            };
            /**
            * Creates a plain object from an UnionJPInfoAllReq message. Also converts values to other types if specified.
            * @function toObject
            * @memberof gaiaProto.UnionJPInfoAllReq
            * @static
            * @param {gaiaProto.UnionJPInfoAllReq} message UnionJPInfoAllReq
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            UnionJPInfoAllReq.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.aid = 0;
                object.token = "";
              }

              if (message.aid != null && message.hasOwnProperty("aid")) object.aid = message.aid;
              if (message.token != null && message.hasOwnProperty("token")) object.token = message.token;
              return object;
            };
            /**
            * Converts this UnionJPInfoAllReq to JSON.
            * @function toJSON
            * @memberof gaiaProto.UnionJPInfoAllReq
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            UnionJPInfoAllReq.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return UnionJPInfoAllReq;
          }();

          gaiaProto.UnionJPHistoryReq = function () {
            /**
            * Properties of an UnionJPHistoryReq.
            * @memberof gaiaProto
            * @interface IUnionJPHistoryReq
            * @property {number|null} [aid] UnionJPHistoryReq aid
            * @property {string|null} [token] UnionJPHistoryReq token
            */

            /**
            * Constructs a new UnionJPHistoryReq.
            * @memberof gaiaProto
            * @classdesc Represents an UnionJPHistoryReq.
            * @implements IUnionJPHistoryReq
            * @constructor
            * @param {gaiaProto.IUnionJPHistoryReq=} [properties] Properties to set
            */
            function UnionJPHistoryReq(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * UnionJPHistoryReq aid.
            * @member {number} aid
            * @memberof gaiaProto.UnionJPHistoryReq
            * @instance
            */


            UnionJPHistoryReq.prototype.aid = 0;
            /**
            * UnionJPHistoryReq token.
            * @member {string} token
            * @memberof gaiaProto.UnionJPHistoryReq
            * @instance
            */

            UnionJPHistoryReq.prototype.token = "";
            /**
            * Creates a new UnionJPHistoryReq instance using the specified properties.
            * @function create
            * @memberof gaiaProto.UnionJPHistoryReq
            * @static
            * @param {gaiaProto.IUnionJPHistoryReq=} [properties] Properties to set
            * @returns {gaiaProto.UnionJPHistoryReq} UnionJPHistoryReq instance
            */

            UnionJPHistoryReq.create = function create(properties) {
              return new UnionJPHistoryReq(properties);
            };
            /**
            * Encodes the specified UnionJPHistoryReq message. Does not implicitly {@link gaiaProto.UnionJPHistoryReq.verify|verify} messages.
            * @function encode
            * @memberof gaiaProto.UnionJPHistoryReq
            * @static
            * @param {gaiaProto.IUnionJPHistoryReq} message UnionJPHistoryReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            UnionJPHistoryReq.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.aid != null && Object.hasOwnProperty.call(message, "aid")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.aid);
              if (message.token != null && Object.hasOwnProperty.call(message, "token")) writer.uint32(
              /* id 2, wireType 2 =*/
              18).string(message.token);
              return writer;
            };
            /**
            * Encodes the specified UnionJPHistoryReq message, length delimited. Does not implicitly {@link gaiaProto.UnionJPHistoryReq.verify|verify} messages.
            * @function encodeDelimited
            * @memberof gaiaProto.UnionJPHistoryReq
            * @static
            * @param {gaiaProto.IUnionJPHistoryReq} message UnionJPHistoryReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            UnionJPHistoryReq.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes an UnionJPHistoryReq message from the specified reader or buffer.
            * @function decode
            * @memberof gaiaProto.UnionJPHistoryReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {gaiaProto.UnionJPHistoryReq} UnionJPHistoryReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            UnionJPHistoryReq.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gaiaProto.UnionJPHistoryReq();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.aid = reader.int32();
                    break;

                  case 2:
                    message.token = reader.string();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes an UnionJPHistoryReq message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof gaiaProto.UnionJPHistoryReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {gaiaProto.UnionJPHistoryReq} UnionJPHistoryReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            UnionJPHistoryReq.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies an UnionJPHistoryReq message.
            * @function verify
            * @memberof gaiaProto.UnionJPHistoryReq
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            UnionJPHistoryReq.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.aid != null && message.hasOwnProperty("aid")) if (!$util.isInteger(message.aid)) return "aid: integer expected";
              if (message.token != null && message.hasOwnProperty("token")) if (!$util.isString(message.token)) return "token: string expected";
              return null;
            };
            /**
            * Creates an UnionJPHistoryReq message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof gaiaProto.UnionJPHistoryReq
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {gaiaProto.UnionJPHistoryReq} UnionJPHistoryReq
            */


            UnionJPHistoryReq.fromObject = function fromObject(object) {
              if (object instanceof $root.gaiaProto.UnionJPHistoryReq) return object;
              var message = new $root.gaiaProto.UnionJPHistoryReq();
              if (object.aid != null) message.aid = object.aid | 0;
              if (object.token != null) message.token = String(object.token);
              return message;
            };
            /**
            * Creates a plain object from an UnionJPHistoryReq message. Also converts values to other types if specified.
            * @function toObject
            * @memberof gaiaProto.UnionJPHistoryReq
            * @static
            * @param {gaiaProto.UnionJPHistoryReq} message UnionJPHistoryReq
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            UnionJPHistoryReq.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.aid = 0;
                object.token = "";
              }

              if (message.aid != null && message.hasOwnProperty("aid")) object.aid = message.aid;
              if (message.token != null && message.hasOwnProperty("token")) object.token = message.token;
              return object;
            };
            /**
            * Converts this UnionJPHistoryReq to JSON.
            * @function toJSON
            * @memberof gaiaProto.UnionJPHistoryReq
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            UnionJPHistoryReq.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return UnionJPHistoryReq;
          }();

          gaiaProto.UnionJPBlockReq = function () {
            /**
            * Properties of an UnionJPBlockReq.
            * @memberof gaiaProto
            * @interface IUnionJPBlockReq
            * @property {number|null} [aid] UnionJPBlockReq aid
            * @property {string|null} [token] UnionJPBlockReq token
            * @property {number|null} [currencynumber] UnionJPBlockReq currencynumber
            */

            /**
            * Constructs a new UnionJPBlockReq.
            * @memberof gaiaProto
            * @classdesc Represents an UnionJPBlockReq.
            * @implements IUnionJPBlockReq
            * @constructor
            * @param {gaiaProto.IUnionJPBlockReq=} [properties] Properties to set
            */
            function UnionJPBlockReq(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * UnionJPBlockReq aid.
            * @member {number} aid
            * @memberof gaiaProto.UnionJPBlockReq
            * @instance
            */


            UnionJPBlockReq.prototype.aid = 0;
            /**
            * UnionJPBlockReq token.
            * @member {string} token
            * @memberof gaiaProto.UnionJPBlockReq
            * @instance
            */

            UnionJPBlockReq.prototype.token = "";
            /**
            * UnionJPBlockReq currencynumber.
            * @member {number} currencynumber
            * @memberof gaiaProto.UnionJPBlockReq
            * @instance
            */

            UnionJPBlockReq.prototype.currencynumber = 0;
            /**
            * Creates a new UnionJPBlockReq instance using the specified properties.
            * @function create
            * @memberof gaiaProto.UnionJPBlockReq
            * @static
            * @param {gaiaProto.IUnionJPBlockReq=} [properties] Properties to set
            * @returns {gaiaProto.UnionJPBlockReq} UnionJPBlockReq instance
            */

            UnionJPBlockReq.create = function create(properties) {
              return new UnionJPBlockReq(properties);
            };
            /**
            * Encodes the specified UnionJPBlockReq message. Does not implicitly {@link gaiaProto.UnionJPBlockReq.verify|verify} messages.
            * @function encode
            * @memberof gaiaProto.UnionJPBlockReq
            * @static
            * @param {gaiaProto.IUnionJPBlockReq} message UnionJPBlockReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            UnionJPBlockReq.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.aid != null && Object.hasOwnProperty.call(message, "aid")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.aid);
              if (message.token != null && Object.hasOwnProperty.call(message, "token")) writer.uint32(
              /* id 2, wireType 2 =*/
              18).string(message.token);
              if (message.currencynumber != null && Object.hasOwnProperty.call(message, "currencynumber")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.currencynumber);
              return writer;
            };
            /**
            * Encodes the specified UnionJPBlockReq message, length delimited. Does not implicitly {@link gaiaProto.UnionJPBlockReq.verify|verify} messages.
            * @function encodeDelimited
            * @memberof gaiaProto.UnionJPBlockReq
            * @static
            * @param {gaiaProto.IUnionJPBlockReq} message UnionJPBlockReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            UnionJPBlockReq.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes an UnionJPBlockReq message from the specified reader or buffer.
            * @function decode
            * @memberof gaiaProto.UnionJPBlockReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {gaiaProto.UnionJPBlockReq} UnionJPBlockReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            UnionJPBlockReq.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gaiaProto.UnionJPBlockReq();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.aid = reader.int32();
                    break;

                  case 2:
                    message.token = reader.string();
                    break;

                  case 3:
                    message.currencynumber = reader.int32();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes an UnionJPBlockReq message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof gaiaProto.UnionJPBlockReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {gaiaProto.UnionJPBlockReq} UnionJPBlockReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            UnionJPBlockReq.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies an UnionJPBlockReq message.
            * @function verify
            * @memberof gaiaProto.UnionJPBlockReq
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            UnionJPBlockReq.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.aid != null && message.hasOwnProperty("aid")) if (!$util.isInteger(message.aid)) return "aid: integer expected";
              if (message.token != null && message.hasOwnProperty("token")) if (!$util.isString(message.token)) return "token: string expected";
              if (message.currencynumber != null && message.hasOwnProperty("currencynumber")) if (!$util.isInteger(message.currencynumber)) return "currencynumber: integer expected";
              return null;
            };
            /**
            * Creates an UnionJPBlockReq message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof gaiaProto.UnionJPBlockReq
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {gaiaProto.UnionJPBlockReq} UnionJPBlockReq
            */


            UnionJPBlockReq.fromObject = function fromObject(object) {
              if (object instanceof $root.gaiaProto.UnionJPBlockReq) return object;
              var message = new $root.gaiaProto.UnionJPBlockReq();
              if (object.aid != null) message.aid = object.aid | 0;
              if (object.token != null) message.token = String(object.token);
              if (object.currencynumber != null) message.currencynumber = object.currencynumber | 0;
              return message;
            };
            /**
            * Creates a plain object from an UnionJPBlockReq message. Also converts values to other types if specified.
            * @function toObject
            * @memberof gaiaProto.UnionJPBlockReq
            * @static
            * @param {gaiaProto.UnionJPBlockReq} message UnionJPBlockReq
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            UnionJPBlockReq.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.aid = 0;
                object.token = "";
                object.currencynumber = 0;
              }

              if (message.aid != null && message.hasOwnProperty("aid")) object.aid = message.aid;
              if (message.token != null && message.hasOwnProperty("token")) object.token = message.token;
              if (message.currencynumber != null && message.hasOwnProperty("currencynumber")) object.currencynumber = message.currencynumber;
              return object;
            };
            /**
            * Converts this UnionJPBlockReq to JSON.
            * @function toJSON
            * @memberof gaiaProto.UnionJPBlockReq
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            UnionJPBlockReq.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return UnionJPBlockReq;
          }();

          gaiaProto.UnionJPInfoAck = function () {
            /**
            * Properties of an UnionJPInfoAck.
            * @memberof gaiaProto
            * @interface IUnionJPInfoAck
            * @property {Array.<gaiaProto.IUnionJPPool>|null} [list] UnionJPInfoAck list
            */

            /**
            * Constructs a new UnionJPInfoAck.
            * @memberof gaiaProto
            * @classdesc Represents an UnionJPInfoAck.
            * @implements IUnionJPInfoAck
            * @constructor
            * @param {gaiaProto.IUnionJPInfoAck=} [properties] Properties to set
            */
            function UnionJPInfoAck(properties) {
              this.list = [];
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * UnionJPInfoAck list.
            * @member {Array.<gaiaProto.IUnionJPPool>} list
            * @memberof gaiaProto.UnionJPInfoAck
            * @instance
            */


            UnionJPInfoAck.prototype.list = $util.emptyArray;
            /**
            * Creates a new UnionJPInfoAck instance using the specified properties.
            * @function create
            * @memberof gaiaProto.UnionJPInfoAck
            * @static
            * @param {gaiaProto.IUnionJPInfoAck=} [properties] Properties to set
            * @returns {gaiaProto.UnionJPInfoAck} UnionJPInfoAck instance
            */

            UnionJPInfoAck.create = function create(properties) {
              return new UnionJPInfoAck(properties);
            };
            /**
            * Encodes the specified UnionJPInfoAck message. Does not implicitly {@link gaiaProto.UnionJPInfoAck.verify|verify} messages.
            * @function encode
            * @memberof gaiaProto.UnionJPInfoAck
            * @static
            * @param {gaiaProto.IUnionJPInfoAck} message UnionJPInfoAck message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            UnionJPInfoAck.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.list != null && message.list.length) for (var i = 0; i < message.list.length; ++i) {
                $root.gaiaProto.UnionJPPool.encode(message.list[i], writer.uint32(
                /* id 1, wireType 2 =*/
                10).fork()).ldelim();
              }
              return writer;
            };
            /**
            * Encodes the specified UnionJPInfoAck message, length delimited. Does not implicitly {@link gaiaProto.UnionJPInfoAck.verify|verify} messages.
            * @function encodeDelimited
            * @memberof gaiaProto.UnionJPInfoAck
            * @static
            * @param {gaiaProto.IUnionJPInfoAck} message UnionJPInfoAck message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            UnionJPInfoAck.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes an UnionJPInfoAck message from the specified reader or buffer.
            * @function decode
            * @memberof gaiaProto.UnionJPInfoAck
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {gaiaProto.UnionJPInfoAck} UnionJPInfoAck
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            UnionJPInfoAck.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gaiaProto.UnionJPInfoAck();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    if (!(message.list && message.list.length)) message.list = [];
                    message.list.push($root.gaiaProto.UnionJPPool.decode(reader, reader.uint32()));
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes an UnionJPInfoAck message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof gaiaProto.UnionJPInfoAck
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {gaiaProto.UnionJPInfoAck} UnionJPInfoAck
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            UnionJPInfoAck.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies an UnionJPInfoAck message.
            * @function verify
            * @memberof gaiaProto.UnionJPInfoAck
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            UnionJPInfoAck.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";

              if (message.list != null && message.hasOwnProperty("list")) {
                if (!Array.isArray(message.list)) return "list: array expected";

                for (var i = 0; i < message.list.length; ++i) {
                  var error = $root.gaiaProto.UnionJPPool.verify(message.list[i]);
                  if (error) return "list." + error;
                }
              }

              return null;
            };
            /**
            * Creates an UnionJPInfoAck message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof gaiaProto.UnionJPInfoAck
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {gaiaProto.UnionJPInfoAck} UnionJPInfoAck
            */


            UnionJPInfoAck.fromObject = function fromObject(object) {
              if (object instanceof $root.gaiaProto.UnionJPInfoAck) return object;
              var message = new $root.gaiaProto.UnionJPInfoAck();

              if (object.list) {
                if (!Array.isArray(object.list)) throw TypeError(".gaiaProto.UnionJPInfoAck.list: array expected");
                message.list = [];

                for (var i = 0; i < object.list.length; ++i) {
                  if (typeof object.list[i] !== "object") throw TypeError(".gaiaProto.UnionJPInfoAck.list: object expected");
                  message.list[i] = $root.gaiaProto.UnionJPPool.fromObject(object.list[i]);
                }
              }

              return message;
            };
            /**
            * Creates a plain object from an UnionJPInfoAck message. Also converts values to other types if specified.
            * @function toObject
            * @memberof gaiaProto.UnionJPInfoAck
            * @static
            * @param {gaiaProto.UnionJPInfoAck} message UnionJPInfoAck
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            UnionJPInfoAck.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};
              if (options.arrays || options.defaults) object.list = [];

              if (message.list && message.list.length) {
                object.list = [];

                for (var j = 0; j < message.list.length; ++j) {
                  object.list[j] = $root.gaiaProto.UnionJPPool.toObject(message.list[j], options);
                }
              }

              return object;
            };
            /**
            * Converts this UnionJPInfoAck to JSON.
            * @function toJSON
            * @memberof gaiaProto.UnionJPInfoAck
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            UnionJPInfoAck.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return UnionJPInfoAck;
          }();

          gaiaProto.UnionJPPool = function () {
            /**
            * Properties of an UnionJPPool.
            * @memberof gaiaProto
            * @interface IUnionJPPool
            * @property {number|null} [type] UnionJPPool type
            * @property {number|null} [value] UnionJPPool value
            */

            /**
            * Constructs a new UnionJPPool.
            * @memberof gaiaProto
            * @classdesc Represents an UnionJPPool.
            * @implements IUnionJPPool
            * @constructor
            * @param {gaiaProto.IUnionJPPool=} [properties] Properties to set
            */
            function UnionJPPool(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * UnionJPPool type.
            * @member {number} type
            * @memberof gaiaProto.UnionJPPool
            * @instance
            */


            UnionJPPool.prototype.type = 0;
            /**
            * UnionJPPool value.
            * @member {number} value
            * @memberof gaiaProto.UnionJPPool
            * @instance
            */

            UnionJPPool.prototype.value = 0;
            /**
            * Creates a new UnionJPPool instance using the specified properties.
            * @function create
            * @memberof gaiaProto.UnionJPPool
            * @static
            * @param {gaiaProto.IUnionJPPool=} [properties] Properties to set
            * @returns {gaiaProto.UnionJPPool} UnionJPPool instance
            */

            UnionJPPool.create = function create(properties) {
              return new UnionJPPool(properties);
            };
            /**
            * Encodes the specified UnionJPPool message. Does not implicitly {@link gaiaProto.UnionJPPool.verify|verify} messages.
            * @function encode
            * @memberof gaiaProto.UnionJPPool
            * @static
            * @param {gaiaProto.IUnionJPPool} message UnionJPPool message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            UnionJPPool.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.type != null && Object.hasOwnProperty.call(message, "type")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.type);
              if (message.value != null && Object.hasOwnProperty.call(message, "value")) writer.uint32(
              /* id 2, wireType 1 =*/
              17)["double"](message.value);
              return writer;
            };
            /**
            * Encodes the specified UnionJPPool message, length delimited. Does not implicitly {@link gaiaProto.UnionJPPool.verify|verify} messages.
            * @function encodeDelimited
            * @memberof gaiaProto.UnionJPPool
            * @static
            * @param {gaiaProto.IUnionJPPool} message UnionJPPool message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            UnionJPPool.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes an UnionJPPool message from the specified reader or buffer.
            * @function decode
            * @memberof gaiaProto.UnionJPPool
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {gaiaProto.UnionJPPool} UnionJPPool
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            UnionJPPool.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gaiaProto.UnionJPPool();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.type = reader.int32();
                    break;

                  case 2:
                    message.value = reader["double"]();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes an UnionJPPool message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof gaiaProto.UnionJPPool
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {gaiaProto.UnionJPPool} UnionJPPool
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            UnionJPPool.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies an UnionJPPool message.
            * @function verify
            * @memberof gaiaProto.UnionJPPool
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            UnionJPPool.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.type != null && message.hasOwnProperty("type")) if (!$util.isInteger(message.type)) return "type: integer expected";
              if (message.value != null && message.hasOwnProperty("value")) if (typeof message.value !== "number") return "value: number expected";
              return null;
            };
            /**
            * Creates an UnionJPPool message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof gaiaProto.UnionJPPool
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {gaiaProto.UnionJPPool} UnionJPPool
            */


            UnionJPPool.fromObject = function fromObject(object) {
              if (object instanceof $root.gaiaProto.UnionJPPool) return object;
              var message = new $root.gaiaProto.UnionJPPool();
              if (object.type != null) message.type = object.type | 0;
              if (object.value != null) message.value = Number(object.value);
              return message;
            };
            /**
            * Creates a plain object from an UnionJPPool message. Also converts values to other types if specified.
            * @function toObject
            * @memberof gaiaProto.UnionJPPool
            * @static
            * @param {gaiaProto.UnionJPPool} message UnionJPPool
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            UnionJPPool.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.type = 0;
                object.value = 0;
              }

              if (message.type != null && message.hasOwnProperty("type")) object.type = message.type;
              if (message.value != null && message.hasOwnProperty("value")) object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
              return object;
            };
            /**
            * Converts this UnionJPPool to JSON.
            * @function toJSON
            * @memberof gaiaProto.UnionJPPool
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            UnionJPPool.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return UnionJPPool;
          }();

          gaiaProto.UnionJPInfoAllAck = function () {
            /**
            * Properties of an UnionJPInfoAllAck.
            * @memberof gaiaProto
            * @interface IUnionJPInfoAllAck
            * @property {Array.<gaiaProto.IUnionJPPool>|null} [plist] UnionJPInfoAllAck plist
            * @property {Array.<number>|null} [glist] UnionJPInfoAllAck glist
            */

            /**
            * Constructs a new UnionJPInfoAllAck.
            * @memberof gaiaProto
            * @classdesc Represents an UnionJPInfoAllAck.
            * @implements IUnionJPInfoAllAck
            * @constructor
            * @param {gaiaProto.IUnionJPInfoAllAck=} [properties] Properties to set
            */
            function UnionJPInfoAllAck(properties) {
              this.plist = [];
              this.glist = [];
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * UnionJPInfoAllAck plist.
            * @member {Array.<gaiaProto.IUnionJPPool>} plist
            * @memberof gaiaProto.UnionJPInfoAllAck
            * @instance
            */


            UnionJPInfoAllAck.prototype.plist = $util.emptyArray;
            /**
            * UnionJPInfoAllAck glist.
            * @member {Array.<number>} glist
            * @memberof gaiaProto.UnionJPInfoAllAck
            * @instance
            */

            UnionJPInfoAllAck.prototype.glist = $util.emptyArray;
            /**
            * Creates a new UnionJPInfoAllAck instance using the specified properties.
            * @function create
            * @memberof gaiaProto.UnionJPInfoAllAck
            * @static
            * @param {gaiaProto.IUnionJPInfoAllAck=} [properties] Properties to set
            * @returns {gaiaProto.UnionJPInfoAllAck} UnionJPInfoAllAck instance
            */

            UnionJPInfoAllAck.create = function create(properties) {
              return new UnionJPInfoAllAck(properties);
            };
            /**
            * Encodes the specified UnionJPInfoAllAck message. Does not implicitly {@link gaiaProto.UnionJPInfoAllAck.verify|verify} messages.
            * @function encode
            * @memberof gaiaProto.UnionJPInfoAllAck
            * @static
            * @param {gaiaProto.IUnionJPInfoAllAck} message UnionJPInfoAllAck message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            UnionJPInfoAllAck.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.plist != null && message.plist.length) for (var i = 0; i < message.plist.length; ++i) {
                $root.gaiaProto.UnionJPPool.encode(message.plist[i], writer.uint32(
                /* id 1, wireType 2 =*/
                10).fork()).ldelim();
              }

              if (message.glist != null && message.glist.length) {
                writer.uint32(
                /* id 2, wireType 2 =*/
                18).fork();

                for (var i = 0; i < message.glist.length; ++i) {
                  writer.int32(message.glist[i]);
                }

                writer.ldelim();
              }

              return writer;
            };
            /**
            * Encodes the specified UnionJPInfoAllAck message, length delimited. Does not implicitly {@link gaiaProto.UnionJPInfoAllAck.verify|verify} messages.
            * @function encodeDelimited
            * @memberof gaiaProto.UnionJPInfoAllAck
            * @static
            * @param {gaiaProto.IUnionJPInfoAllAck} message UnionJPInfoAllAck message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            UnionJPInfoAllAck.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes an UnionJPInfoAllAck message from the specified reader or buffer.
            * @function decode
            * @memberof gaiaProto.UnionJPInfoAllAck
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {gaiaProto.UnionJPInfoAllAck} UnionJPInfoAllAck
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            UnionJPInfoAllAck.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gaiaProto.UnionJPInfoAllAck();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    if (!(message.plist && message.plist.length)) message.plist = [];
                    message.plist.push($root.gaiaProto.UnionJPPool.decode(reader, reader.uint32()));
                    break;

                  case 2:
                    if (!(message.glist && message.glist.length)) message.glist = [];

                    if ((tag & 7) === 2) {
                      var end2 = reader.uint32() + reader.pos;

                      while (reader.pos < end2) {
                        message.glist.push(reader.int32());
                      }
                    } else message.glist.push(reader.int32());

                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes an UnionJPInfoAllAck message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof gaiaProto.UnionJPInfoAllAck
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {gaiaProto.UnionJPInfoAllAck} UnionJPInfoAllAck
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            UnionJPInfoAllAck.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies an UnionJPInfoAllAck message.
            * @function verify
            * @memberof gaiaProto.UnionJPInfoAllAck
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            UnionJPInfoAllAck.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";

              if (message.plist != null && message.hasOwnProperty("plist")) {
                if (!Array.isArray(message.plist)) return "plist: array expected";

                for (var i = 0; i < message.plist.length; ++i) {
                  var error = $root.gaiaProto.UnionJPPool.verify(message.plist[i]);
                  if (error) return "plist." + error;
                }
              }

              if (message.glist != null && message.hasOwnProperty("glist")) {
                if (!Array.isArray(message.glist)) return "glist: array expected";

                for (var i = 0; i < message.glist.length; ++i) {
                  if (!$util.isInteger(message.glist[i])) return "glist: integer[] expected";
                }
              }

              return null;
            };
            /**
            * Creates an UnionJPInfoAllAck message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof gaiaProto.UnionJPInfoAllAck
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {gaiaProto.UnionJPInfoAllAck} UnionJPInfoAllAck
            */


            UnionJPInfoAllAck.fromObject = function fromObject(object) {
              if (object instanceof $root.gaiaProto.UnionJPInfoAllAck) return object;
              var message = new $root.gaiaProto.UnionJPInfoAllAck();

              if (object.plist) {
                if (!Array.isArray(object.plist)) throw TypeError(".gaiaProto.UnionJPInfoAllAck.plist: array expected");
                message.plist = [];

                for (var i = 0; i < object.plist.length; ++i) {
                  if (typeof object.plist[i] !== "object") throw TypeError(".gaiaProto.UnionJPInfoAllAck.plist: object expected");
                  message.plist[i] = $root.gaiaProto.UnionJPPool.fromObject(object.plist[i]);
                }
              }

              if (object.glist) {
                if (!Array.isArray(object.glist)) throw TypeError(".gaiaProto.UnionJPInfoAllAck.glist: array expected");
                message.glist = [];

                for (var i = 0; i < object.glist.length; ++i) {
                  message.glist[i] = object.glist[i] | 0;
                }
              }

              return message;
            };
            /**
            * Creates a plain object from an UnionJPInfoAllAck message. Also converts values to other types if specified.
            * @function toObject
            * @memberof gaiaProto.UnionJPInfoAllAck
            * @static
            * @param {gaiaProto.UnionJPInfoAllAck} message UnionJPInfoAllAck
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            UnionJPInfoAllAck.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.arrays || options.defaults) {
                object.plist = [];
                object.glist = [];
              }

              if (message.plist && message.plist.length) {
                object.plist = [];

                for (var j = 0; j < message.plist.length; ++j) {
                  object.plist[j] = $root.gaiaProto.UnionJPPool.toObject(message.plist[j], options);
                }
              }

              if (message.glist && message.glist.length) {
                object.glist = [];

                for (var j = 0; j < message.glist.length; ++j) {
                  object.glist[j] = message.glist[j];
                }
              }

              return object;
            };
            /**
            * Converts this UnionJPInfoAllAck to JSON.
            * @function toJSON
            * @memberof gaiaProto.UnionJPInfoAllAck
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            UnionJPInfoAllAck.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return UnionJPInfoAllAck;
          }();

          gaiaProto.UnionJPHistoryAck = function () {
            /**
            * Properties of an UnionJPHistoryAck.
            * @memberof gaiaProto
            * @interface IUnionJPHistoryAck
            * @property {Array.<gaiaProto.IUnionJPHistoryData>|null} [list] UnionJPHistoryAck list
            */

            /**
            * Constructs a new UnionJPHistoryAck.
            * @memberof gaiaProto
            * @classdesc Represents an UnionJPHistoryAck.
            * @implements IUnionJPHistoryAck
            * @constructor
            * @param {gaiaProto.IUnionJPHistoryAck=} [properties] Properties to set
            */
            function UnionJPHistoryAck(properties) {
              this.list = [];
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * UnionJPHistoryAck list.
            * @member {Array.<gaiaProto.IUnionJPHistoryData>} list
            * @memberof gaiaProto.UnionJPHistoryAck
            * @instance
            */


            UnionJPHistoryAck.prototype.list = $util.emptyArray;
            /**
            * Creates a new UnionJPHistoryAck instance using the specified properties.
            * @function create
            * @memberof gaiaProto.UnionJPHistoryAck
            * @static
            * @param {gaiaProto.IUnionJPHistoryAck=} [properties] Properties to set
            * @returns {gaiaProto.UnionJPHistoryAck} UnionJPHistoryAck instance
            */

            UnionJPHistoryAck.create = function create(properties) {
              return new UnionJPHistoryAck(properties);
            };
            /**
            * Encodes the specified UnionJPHistoryAck message. Does not implicitly {@link gaiaProto.UnionJPHistoryAck.verify|verify} messages.
            * @function encode
            * @memberof gaiaProto.UnionJPHistoryAck
            * @static
            * @param {gaiaProto.IUnionJPHistoryAck} message UnionJPHistoryAck message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            UnionJPHistoryAck.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.list != null && message.list.length) for (var i = 0; i < message.list.length; ++i) {
                $root.gaiaProto.UnionJPHistoryData.encode(message.list[i], writer.uint32(
                /* id 1, wireType 2 =*/
                10).fork()).ldelim();
              }
              return writer;
            };
            /**
            * Encodes the specified UnionJPHistoryAck message, length delimited. Does not implicitly {@link gaiaProto.UnionJPHistoryAck.verify|verify} messages.
            * @function encodeDelimited
            * @memberof gaiaProto.UnionJPHistoryAck
            * @static
            * @param {gaiaProto.IUnionJPHistoryAck} message UnionJPHistoryAck message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            UnionJPHistoryAck.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes an UnionJPHistoryAck message from the specified reader or buffer.
            * @function decode
            * @memberof gaiaProto.UnionJPHistoryAck
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {gaiaProto.UnionJPHistoryAck} UnionJPHistoryAck
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            UnionJPHistoryAck.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gaiaProto.UnionJPHistoryAck();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    if (!(message.list && message.list.length)) message.list = [];
                    message.list.push($root.gaiaProto.UnionJPHistoryData.decode(reader, reader.uint32()));
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes an UnionJPHistoryAck message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof gaiaProto.UnionJPHistoryAck
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {gaiaProto.UnionJPHistoryAck} UnionJPHistoryAck
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            UnionJPHistoryAck.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies an UnionJPHistoryAck message.
            * @function verify
            * @memberof gaiaProto.UnionJPHistoryAck
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            UnionJPHistoryAck.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";

              if (message.list != null && message.hasOwnProperty("list")) {
                if (!Array.isArray(message.list)) return "list: array expected";

                for (var i = 0; i < message.list.length; ++i) {
                  var error = $root.gaiaProto.UnionJPHistoryData.verify(message.list[i]);
                  if (error) return "list." + error;
                }
              }

              return null;
            };
            /**
            * Creates an UnionJPHistoryAck message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof gaiaProto.UnionJPHistoryAck
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {gaiaProto.UnionJPHistoryAck} UnionJPHistoryAck
            */


            UnionJPHistoryAck.fromObject = function fromObject(object) {
              if (object instanceof $root.gaiaProto.UnionJPHistoryAck) return object;
              var message = new $root.gaiaProto.UnionJPHistoryAck();

              if (object.list) {
                if (!Array.isArray(object.list)) throw TypeError(".gaiaProto.UnionJPHistoryAck.list: array expected");
                message.list = [];

                for (var i = 0; i < object.list.length; ++i) {
                  if (typeof object.list[i] !== "object") throw TypeError(".gaiaProto.UnionJPHistoryAck.list: object expected");
                  message.list[i] = $root.gaiaProto.UnionJPHistoryData.fromObject(object.list[i]);
                }
              }

              return message;
            };
            /**
            * Creates a plain object from an UnionJPHistoryAck message. Also converts values to other types if specified.
            * @function toObject
            * @memberof gaiaProto.UnionJPHistoryAck
            * @static
            * @param {gaiaProto.UnionJPHistoryAck} message UnionJPHistoryAck
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            UnionJPHistoryAck.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};
              if (options.arrays || options.defaults) object.list = [];

              if (message.list && message.list.length) {
                object.list = [];

                for (var j = 0; j < message.list.length; ++j) {
                  object.list[j] = $root.gaiaProto.UnionJPHistoryData.toObject(message.list[j], options);
                }
              }

              return object;
            };
            /**
            * Converts this UnionJPHistoryAck to JSON.
            * @function toJSON
            * @memberof gaiaProto.UnionJPHistoryAck
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            UnionJPHistoryAck.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return UnionJPHistoryAck;
          }();

          gaiaProto.UnionJPHistoryData = function () {
            /**
            * Properties of an UnionJPHistoryData.
            * @memberof gaiaProto
            * @interface IUnionJPHistoryData
            * @property {number|null} [type] UnionJPHistoryData type
            * @property {string|null} [winner] UnionJPHistoryData winner
            * @property {string|null} [nickname] UnionJPHistoryData nickname
            * @property {number|null} [win] UnionJPHistoryData win
            * @property {number|null} [gameID] UnionJPHistoryData gameID
            */

            /**
            * Constructs a new UnionJPHistoryData.
            * @memberof gaiaProto
            * @classdesc Represents an UnionJPHistoryData.
            * @implements IUnionJPHistoryData
            * @constructor
            * @param {gaiaProto.IUnionJPHistoryData=} [properties] Properties to set
            */
            function UnionJPHistoryData(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * UnionJPHistoryData type.
            * @member {number} type
            * @memberof gaiaProto.UnionJPHistoryData
            * @instance
            */


            UnionJPHistoryData.prototype.type = 0;
            /**
            * UnionJPHistoryData winner.
            * @member {string} winner
            * @memberof gaiaProto.UnionJPHistoryData
            * @instance
            */

            UnionJPHistoryData.prototype.winner = "";
            /**
            * UnionJPHistoryData nickname.
            * @member {string} nickname
            * @memberof gaiaProto.UnionJPHistoryData
            * @instance
            */

            UnionJPHistoryData.prototype.nickname = "";
            /**
            * UnionJPHistoryData win.
            * @member {number} win
            * @memberof gaiaProto.UnionJPHistoryData
            * @instance
            */

            UnionJPHistoryData.prototype.win = 0;
            /**
            * UnionJPHistoryData gameID.
            * @member {number} gameID
            * @memberof gaiaProto.UnionJPHistoryData
            * @instance
            */

            UnionJPHistoryData.prototype.gameID = 0;
            /**
            * Creates a new UnionJPHistoryData instance using the specified properties.
            * @function create
            * @memberof gaiaProto.UnionJPHistoryData
            * @static
            * @param {gaiaProto.IUnionJPHistoryData=} [properties] Properties to set
            * @returns {gaiaProto.UnionJPHistoryData} UnionJPHistoryData instance
            */

            UnionJPHistoryData.create = function create(properties) {
              return new UnionJPHistoryData(properties);
            };
            /**
            * Encodes the specified UnionJPHistoryData message. Does not implicitly {@link gaiaProto.UnionJPHistoryData.verify|verify} messages.
            * @function encode
            * @memberof gaiaProto.UnionJPHistoryData
            * @static
            * @param {gaiaProto.IUnionJPHistoryData} message UnionJPHistoryData message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            UnionJPHistoryData.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.type != null && Object.hasOwnProperty.call(message, "type")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.type);
              if (message.winner != null && Object.hasOwnProperty.call(message, "winner")) writer.uint32(
              /* id 2, wireType 2 =*/
              18).string(message.winner);
              if (message.nickname != null && Object.hasOwnProperty.call(message, "nickname")) writer.uint32(
              /* id 3, wireType 2 =*/
              26).string(message.nickname);
              if (message.win != null && Object.hasOwnProperty.call(message, "win")) writer.uint32(
              /* id 4, wireType 1 =*/
              33)["double"](message.win);
              if (message.gameID != null && Object.hasOwnProperty.call(message, "gameID")) writer.uint32(
              /* id 5, wireType 0 =*/
              40).int32(message.gameID);
              return writer;
            };
            /**
            * Encodes the specified UnionJPHistoryData message, length delimited. Does not implicitly {@link gaiaProto.UnionJPHistoryData.verify|verify} messages.
            * @function encodeDelimited
            * @memberof gaiaProto.UnionJPHistoryData
            * @static
            * @param {gaiaProto.IUnionJPHistoryData} message UnionJPHistoryData message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            UnionJPHistoryData.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes an UnionJPHistoryData message from the specified reader or buffer.
            * @function decode
            * @memberof gaiaProto.UnionJPHistoryData
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {gaiaProto.UnionJPHistoryData} UnionJPHistoryData
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            UnionJPHistoryData.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gaiaProto.UnionJPHistoryData();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.type = reader.int32();
                    break;

                  case 2:
                    message.winner = reader.string();
                    break;

                  case 3:
                    message.nickname = reader.string();
                    break;

                  case 4:
                    message.win = reader["double"]();
                    break;

                  case 5:
                    message.gameID = reader.int32();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes an UnionJPHistoryData message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof gaiaProto.UnionJPHistoryData
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {gaiaProto.UnionJPHistoryData} UnionJPHistoryData
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            UnionJPHistoryData.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies an UnionJPHistoryData message.
            * @function verify
            * @memberof gaiaProto.UnionJPHistoryData
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            UnionJPHistoryData.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.type != null && message.hasOwnProperty("type")) if (!$util.isInteger(message.type)) return "type: integer expected";
              if (message.winner != null && message.hasOwnProperty("winner")) if (!$util.isString(message.winner)) return "winner: string expected";
              if (message.nickname != null && message.hasOwnProperty("nickname")) if (!$util.isString(message.nickname)) return "nickname: string expected";
              if (message.win != null && message.hasOwnProperty("win")) if (typeof message.win !== "number") return "win: number expected";
              if (message.gameID != null && message.hasOwnProperty("gameID")) if (!$util.isInteger(message.gameID)) return "gameID: integer expected";
              return null;
            };
            /**
            * Creates an UnionJPHistoryData message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof gaiaProto.UnionJPHistoryData
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {gaiaProto.UnionJPHistoryData} UnionJPHistoryData
            */


            UnionJPHistoryData.fromObject = function fromObject(object) {
              if (object instanceof $root.gaiaProto.UnionJPHistoryData) return object;
              var message = new $root.gaiaProto.UnionJPHistoryData();
              if (object.type != null) message.type = object.type | 0;
              if (object.winner != null) message.winner = String(object.winner);
              if (object.nickname != null) message.nickname = String(object.nickname);
              if (object.win != null) message.win = Number(object.win);
              if (object.gameID != null) message.gameID = object.gameID | 0;
              return message;
            };
            /**
            * Creates a plain object from an UnionJPHistoryData message. Also converts values to other types if specified.
            * @function toObject
            * @memberof gaiaProto.UnionJPHistoryData
            * @static
            * @param {gaiaProto.UnionJPHistoryData} message UnionJPHistoryData
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            UnionJPHistoryData.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.type = 0;
                object.winner = "";
                object.nickname = "";
                object.win = 0;
                object.gameID = 0;
              }

              if (message.type != null && message.hasOwnProperty("type")) object.type = message.type;
              if (message.winner != null && message.hasOwnProperty("winner")) object.winner = message.winner;
              if (message.nickname != null && message.hasOwnProperty("nickname")) object.nickname = message.nickname;
              if (message.win != null && message.hasOwnProperty("win")) object.win = options.json && !isFinite(message.win) ? String(message.win) : message.win;
              if (message.gameID != null && message.hasOwnProperty("gameID")) object.gameID = message.gameID;
              return object;
            };
            /**
            * Converts this UnionJPHistoryData to JSON.
            * @function toJSON
            * @memberof gaiaProto.UnionJPHistoryData
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            UnionJPHistoryData.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return UnionJPHistoryData;
          }();

          gaiaProto.UnionJPBlockAck = function () {
            /**
            * Properties of an UnionJPBlockAck.
            * @memberof gaiaProto
            * @interface IUnionJPBlockAck
            * @property {Array.<number>|null} [list] UnionJPBlockAck list
            */

            /**
            * Constructs a new UnionJPBlockAck.
            * @memberof gaiaProto
            * @classdesc Represents an UnionJPBlockAck.
            * @implements IUnionJPBlockAck
            * @constructor
            * @param {gaiaProto.IUnionJPBlockAck=} [properties] Properties to set
            */
            function UnionJPBlockAck(properties) {
              this.list = [];
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * UnionJPBlockAck list.
            * @member {Array.<number>} list
            * @memberof gaiaProto.UnionJPBlockAck
            * @instance
            */


            UnionJPBlockAck.prototype.list = $util.emptyArray;
            /**
            * Creates a new UnionJPBlockAck instance using the specified properties.
            * @function create
            * @memberof gaiaProto.UnionJPBlockAck
            * @static
            * @param {gaiaProto.IUnionJPBlockAck=} [properties] Properties to set
            * @returns {gaiaProto.UnionJPBlockAck} UnionJPBlockAck instance
            */

            UnionJPBlockAck.create = function create(properties) {
              return new UnionJPBlockAck(properties);
            };
            /**
            * Encodes the specified UnionJPBlockAck message. Does not implicitly {@link gaiaProto.UnionJPBlockAck.verify|verify} messages.
            * @function encode
            * @memberof gaiaProto.UnionJPBlockAck
            * @static
            * @param {gaiaProto.IUnionJPBlockAck} message UnionJPBlockAck message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            UnionJPBlockAck.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();

              if (message.list != null && message.list.length) {
                writer.uint32(
                /* id 1, wireType 2 =*/
                10).fork();

                for (var i = 0; i < message.list.length; ++i) {
                  writer["double"](message.list[i]);
                }

                writer.ldelim();
              }

              return writer;
            };
            /**
            * Encodes the specified UnionJPBlockAck message, length delimited. Does not implicitly {@link gaiaProto.UnionJPBlockAck.verify|verify} messages.
            * @function encodeDelimited
            * @memberof gaiaProto.UnionJPBlockAck
            * @static
            * @param {gaiaProto.IUnionJPBlockAck} message UnionJPBlockAck message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            UnionJPBlockAck.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes an UnionJPBlockAck message from the specified reader or buffer.
            * @function decode
            * @memberof gaiaProto.UnionJPBlockAck
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {gaiaProto.UnionJPBlockAck} UnionJPBlockAck
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            UnionJPBlockAck.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gaiaProto.UnionJPBlockAck();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    if (!(message.list && message.list.length)) message.list = [];

                    if ((tag & 7) === 2) {
                      var end2 = reader.uint32() + reader.pos;

                      while (reader.pos < end2) {
                        message.list.push(reader["double"]());
                      }
                    } else message.list.push(reader["double"]());

                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes an UnionJPBlockAck message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof gaiaProto.UnionJPBlockAck
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {gaiaProto.UnionJPBlockAck} UnionJPBlockAck
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            UnionJPBlockAck.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies an UnionJPBlockAck message.
            * @function verify
            * @memberof gaiaProto.UnionJPBlockAck
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            UnionJPBlockAck.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";

              if (message.list != null && message.hasOwnProperty("list")) {
                if (!Array.isArray(message.list)) return "list: array expected";

                for (var i = 0; i < message.list.length; ++i) {
                  if (typeof message.list[i] !== "number") return "list: number[] expected";
                }
              }

              return null;
            };
            /**
            * Creates an UnionJPBlockAck message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof gaiaProto.UnionJPBlockAck
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {gaiaProto.UnionJPBlockAck} UnionJPBlockAck
            */


            UnionJPBlockAck.fromObject = function fromObject(object) {
              if (object instanceof $root.gaiaProto.UnionJPBlockAck) return object;
              var message = new $root.gaiaProto.UnionJPBlockAck();

              if (object.list) {
                if (!Array.isArray(object.list)) throw TypeError(".gaiaProto.UnionJPBlockAck.list: array expected");
                message.list = [];

                for (var i = 0; i < object.list.length; ++i) {
                  message.list[i] = Number(object.list[i]);
                }
              }

              return message;
            };
            /**
            * Creates a plain object from an UnionJPBlockAck message. Also converts values to other types if specified.
            * @function toObject
            * @memberof gaiaProto.UnionJPBlockAck
            * @static
            * @param {gaiaProto.UnionJPBlockAck} message UnionJPBlockAck
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            UnionJPBlockAck.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};
              if (options.arrays || options.defaults) object.list = [];

              if (message.list && message.list.length) {
                object.list = [];

                for (var j = 0; j < message.list.length; ++j) {
                  object.list[j] = options.json && !isFinite(message.list[j]) ? String(message.list[j]) : message.list[j];
                }
              }

              return object;
            };
            /**
            * Converts this UnionJPBlockAck to JSON.
            * @function toJSON
            * @memberof gaiaProto.UnionJPBlockAck
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            UnionJPBlockAck.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return UnionJPBlockAck;
          }();

          gaiaProto.VipSignInfoReq = function () {
            /**
            * Properties of a VipSignInfoReq.
            * @memberof gaiaProto
            * @interface IVipSignInfoReq
            * @property {number|null} [aid] VipSignInfoReq aid
            * @property {string|null} [token] VipSignInfoReq token
            * @property {number|null} [currencynumber] VipSignInfoReq currencynumber
            */

            /**
            * Constructs a new VipSignInfoReq.
            * @memberof gaiaProto
            * @classdesc Represents a VipSignInfoReq.
            * @implements IVipSignInfoReq
            * @constructor
            * @param {gaiaProto.IVipSignInfoReq=} [properties] Properties to set
            */
            function VipSignInfoReq(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * VipSignInfoReq aid.
            * @member {number} aid
            * @memberof gaiaProto.VipSignInfoReq
            * @instance
            */


            VipSignInfoReq.prototype.aid = 0;
            /**
            * VipSignInfoReq token.
            * @member {string} token
            * @memberof gaiaProto.VipSignInfoReq
            * @instance
            */

            VipSignInfoReq.prototype.token = "";
            /**
            * VipSignInfoReq currencynumber.
            * @member {number} currencynumber
            * @memberof gaiaProto.VipSignInfoReq
            * @instance
            */

            VipSignInfoReq.prototype.currencynumber = 0;
            /**
            * Creates a new VipSignInfoReq instance using the specified properties.
            * @function create
            * @memberof gaiaProto.VipSignInfoReq
            * @static
            * @param {gaiaProto.IVipSignInfoReq=} [properties] Properties to set
            * @returns {gaiaProto.VipSignInfoReq} VipSignInfoReq instance
            */

            VipSignInfoReq.create = function create(properties) {
              return new VipSignInfoReq(properties);
            };
            /**
            * Encodes the specified VipSignInfoReq message. Does not implicitly {@link gaiaProto.VipSignInfoReq.verify|verify} messages.
            * @function encode
            * @memberof gaiaProto.VipSignInfoReq
            * @static
            * @param {gaiaProto.IVipSignInfoReq} message VipSignInfoReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            VipSignInfoReq.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.aid != null && Object.hasOwnProperty.call(message, "aid")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.aid);
              if (message.token != null && Object.hasOwnProperty.call(message, "token")) writer.uint32(
              /* id 2, wireType 2 =*/
              18).string(message.token);
              if (message.currencynumber != null && Object.hasOwnProperty.call(message, "currencynumber")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.currencynumber);
              return writer;
            };
            /**
            * Encodes the specified VipSignInfoReq message, length delimited. Does not implicitly {@link gaiaProto.VipSignInfoReq.verify|verify} messages.
            * @function encodeDelimited
            * @memberof gaiaProto.VipSignInfoReq
            * @static
            * @param {gaiaProto.IVipSignInfoReq} message VipSignInfoReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            VipSignInfoReq.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a VipSignInfoReq message from the specified reader or buffer.
            * @function decode
            * @memberof gaiaProto.VipSignInfoReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {gaiaProto.VipSignInfoReq} VipSignInfoReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            VipSignInfoReq.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gaiaProto.VipSignInfoReq();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.aid = reader.int32();
                    break;

                  case 2:
                    message.token = reader.string();
                    break;

                  case 3:
                    message.currencynumber = reader.int32();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a VipSignInfoReq message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof gaiaProto.VipSignInfoReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {gaiaProto.VipSignInfoReq} VipSignInfoReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            VipSignInfoReq.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a VipSignInfoReq message.
            * @function verify
            * @memberof gaiaProto.VipSignInfoReq
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            VipSignInfoReq.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.aid != null && message.hasOwnProperty("aid")) if (!$util.isInteger(message.aid)) return "aid: integer expected";
              if (message.token != null && message.hasOwnProperty("token")) if (!$util.isString(message.token)) return "token: string expected";
              if (message.currencynumber != null && message.hasOwnProperty("currencynumber")) if (!$util.isInteger(message.currencynumber)) return "currencynumber: integer expected";
              return null;
            };
            /**
            * Creates a VipSignInfoReq message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof gaiaProto.VipSignInfoReq
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {gaiaProto.VipSignInfoReq} VipSignInfoReq
            */


            VipSignInfoReq.fromObject = function fromObject(object) {
              if (object instanceof $root.gaiaProto.VipSignInfoReq) return object;
              var message = new $root.gaiaProto.VipSignInfoReq();
              if (object.aid != null) message.aid = object.aid | 0;
              if (object.token != null) message.token = String(object.token);
              if (object.currencynumber != null) message.currencynumber = object.currencynumber | 0;
              return message;
            };
            /**
            * Creates a plain object from a VipSignInfoReq message. Also converts values to other types if specified.
            * @function toObject
            * @memberof gaiaProto.VipSignInfoReq
            * @static
            * @param {gaiaProto.VipSignInfoReq} message VipSignInfoReq
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            VipSignInfoReq.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.aid = 0;
                object.token = "";
                object.currencynumber = 0;
              }

              if (message.aid != null && message.hasOwnProperty("aid")) object.aid = message.aid;
              if (message.token != null && message.hasOwnProperty("token")) object.token = message.token;
              if (message.currencynumber != null && message.hasOwnProperty("currencynumber")) object.currencynumber = message.currencynumber;
              return object;
            };
            /**
            * Converts this VipSignInfoReq to JSON.
            * @function toJSON
            * @memberof gaiaProto.VipSignInfoReq
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            VipSignInfoReq.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return VipSignInfoReq;
          }();

          gaiaProto.VipSignRewardReq = function () {
            /**
            * Properties of a VipSignRewardReq.
            * @memberof gaiaProto
            * @interface IVipSignRewardReq
            * @property {number|null} [aid] VipSignRewardReq aid
            * @property {string|null} [token] VipSignRewardReq token
            * @property {number|null} [currencynumber] VipSignRewardReq currencynumber
            * @property {string|null} [index] VipSignRewardReq index
            */

            /**
            * Constructs a new VipSignRewardReq.
            * @memberof gaiaProto
            * @classdesc Represents a VipSignRewardReq.
            * @implements IVipSignRewardReq
            * @constructor
            * @param {gaiaProto.IVipSignRewardReq=} [properties] Properties to set
            */
            function VipSignRewardReq(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * VipSignRewardReq aid.
            * @member {number} aid
            * @memberof gaiaProto.VipSignRewardReq
            * @instance
            */


            VipSignRewardReq.prototype.aid = 0;
            /**
            * VipSignRewardReq token.
            * @member {string} token
            * @memberof gaiaProto.VipSignRewardReq
            * @instance
            */

            VipSignRewardReq.prototype.token = "";
            /**
            * VipSignRewardReq currencynumber.
            * @member {number} currencynumber
            * @memberof gaiaProto.VipSignRewardReq
            * @instance
            */

            VipSignRewardReq.prototype.currencynumber = 0;
            /**
            * VipSignRewardReq index.
            * @member {string} index
            * @memberof gaiaProto.VipSignRewardReq
            * @instance
            */

            VipSignRewardReq.prototype.index = "";
            /**
            * Creates a new VipSignRewardReq instance using the specified properties.
            * @function create
            * @memberof gaiaProto.VipSignRewardReq
            * @static
            * @param {gaiaProto.IVipSignRewardReq=} [properties] Properties to set
            * @returns {gaiaProto.VipSignRewardReq} VipSignRewardReq instance
            */

            VipSignRewardReq.create = function create(properties) {
              return new VipSignRewardReq(properties);
            };
            /**
            * Encodes the specified VipSignRewardReq message. Does not implicitly {@link gaiaProto.VipSignRewardReq.verify|verify} messages.
            * @function encode
            * @memberof gaiaProto.VipSignRewardReq
            * @static
            * @param {gaiaProto.IVipSignRewardReq} message VipSignRewardReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            VipSignRewardReq.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.aid != null && Object.hasOwnProperty.call(message, "aid")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.aid);
              if (message.token != null && Object.hasOwnProperty.call(message, "token")) writer.uint32(
              /* id 2, wireType 2 =*/
              18).string(message.token);
              if (message.currencynumber != null && Object.hasOwnProperty.call(message, "currencynumber")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.currencynumber);
              if (message.index != null && Object.hasOwnProperty.call(message, "index")) writer.uint32(
              /* id 4, wireType 2 =*/
              34).string(message.index);
              return writer;
            };
            /**
            * Encodes the specified VipSignRewardReq message, length delimited. Does not implicitly {@link gaiaProto.VipSignRewardReq.verify|verify} messages.
            * @function encodeDelimited
            * @memberof gaiaProto.VipSignRewardReq
            * @static
            * @param {gaiaProto.IVipSignRewardReq} message VipSignRewardReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            VipSignRewardReq.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a VipSignRewardReq message from the specified reader or buffer.
            * @function decode
            * @memberof gaiaProto.VipSignRewardReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {gaiaProto.VipSignRewardReq} VipSignRewardReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            VipSignRewardReq.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gaiaProto.VipSignRewardReq();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.aid = reader.int32();
                    break;

                  case 2:
                    message.token = reader.string();
                    break;

                  case 3:
                    message.currencynumber = reader.int32();
                    break;

                  case 4:
                    message.index = reader.string();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a VipSignRewardReq message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof gaiaProto.VipSignRewardReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {gaiaProto.VipSignRewardReq} VipSignRewardReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            VipSignRewardReq.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a VipSignRewardReq message.
            * @function verify
            * @memberof gaiaProto.VipSignRewardReq
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            VipSignRewardReq.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.aid != null && message.hasOwnProperty("aid")) if (!$util.isInteger(message.aid)) return "aid: integer expected";
              if (message.token != null && message.hasOwnProperty("token")) if (!$util.isString(message.token)) return "token: string expected";
              if (message.currencynumber != null && message.hasOwnProperty("currencynumber")) if (!$util.isInteger(message.currencynumber)) return "currencynumber: integer expected";
              if (message.index != null && message.hasOwnProperty("index")) if (!$util.isString(message.index)) return "index: string expected";
              return null;
            };
            /**
            * Creates a VipSignRewardReq message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof gaiaProto.VipSignRewardReq
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {gaiaProto.VipSignRewardReq} VipSignRewardReq
            */


            VipSignRewardReq.fromObject = function fromObject(object) {
              if (object instanceof $root.gaiaProto.VipSignRewardReq) return object;
              var message = new $root.gaiaProto.VipSignRewardReq();
              if (object.aid != null) message.aid = object.aid | 0;
              if (object.token != null) message.token = String(object.token);
              if (object.currencynumber != null) message.currencynumber = object.currencynumber | 0;
              if (object.index != null) message.index = String(object.index);
              return message;
            };
            /**
            * Creates a plain object from a VipSignRewardReq message. Also converts values to other types if specified.
            * @function toObject
            * @memberof gaiaProto.VipSignRewardReq
            * @static
            * @param {gaiaProto.VipSignRewardReq} message VipSignRewardReq
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            VipSignRewardReq.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.aid = 0;
                object.token = "";
                object.currencynumber = 0;
                object.index = "";
              }

              if (message.aid != null && message.hasOwnProperty("aid")) object.aid = message.aid;
              if (message.token != null && message.hasOwnProperty("token")) object.token = message.token;
              if (message.currencynumber != null && message.hasOwnProperty("currencynumber")) object.currencynumber = message.currencynumber;
              if (message.index != null && message.hasOwnProperty("index")) object.index = message.index;
              return object;
            };
            /**
            * Converts this VipSignRewardReq to JSON.
            * @function toJSON
            * @memberof gaiaProto.VipSignRewardReq
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            VipSignRewardReq.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return VipSignRewardReq;
          }();

          gaiaProto.VipSignInfoAck = function () {
            /**
            * Properties of a VipSignInfoAck.
            * @memberof gaiaProto
            * @interface IVipSignInfoAck
            * @property {gaiaProto.IVipSignInfoData|null} [info] VipSignInfoAck info
            * @property {number|null} [result] VipSignInfoAck result
            */

            /**
            * Constructs a new VipSignInfoAck.
            * @memberof gaiaProto
            * @classdesc Represents a VipSignInfoAck.
            * @implements IVipSignInfoAck
            * @constructor
            * @param {gaiaProto.IVipSignInfoAck=} [properties] Properties to set
            */
            function VipSignInfoAck(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * VipSignInfoAck info.
            * @member {gaiaProto.IVipSignInfoData|null|undefined} info
            * @memberof gaiaProto.VipSignInfoAck
            * @instance
            */


            VipSignInfoAck.prototype.info = null;
            /**
            * VipSignInfoAck result.
            * @member {number} result
            * @memberof gaiaProto.VipSignInfoAck
            * @instance
            */

            VipSignInfoAck.prototype.result = 0;
            /**
            * Creates a new VipSignInfoAck instance using the specified properties.
            * @function create
            * @memberof gaiaProto.VipSignInfoAck
            * @static
            * @param {gaiaProto.IVipSignInfoAck=} [properties] Properties to set
            * @returns {gaiaProto.VipSignInfoAck} VipSignInfoAck instance
            */

            VipSignInfoAck.create = function create(properties) {
              return new VipSignInfoAck(properties);
            };
            /**
            * Encodes the specified VipSignInfoAck message. Does not implicitly {@link gaiaProto.VipSignInfoAck.verify|verify} messages.
            * @function encode
            * @memberof gaiaProto.VipSignInfoAck
            * @static
            * @param {gaiaProto.IVipSignInfoAck} message VipSignInfoAck message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            VipSignInfoAck.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.info != null && Object.hasOwnProperty.call(message, "info")) $root.gaiaProto.VipSignInfoData.encode(message.info, writer.uint32(
              /* id 1, wireType 2 =*/
              10).fork()).ldelim();
              if (message.result != null && Object.hasOwnProperty.call(message, "result")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int32(message.result);
              return writer;
            };
            /**
            * Encodes the specified VipSignInfoAck message, length delimited. Does not implicitly {@link gaiaProto.VipSignInfoAck.verify|verify} messages.
            * @function encodeDelimited
            * @memberof gaiaProto.VipSignInfoAck
            * @static
            * @param {gaiaProto.IVipSignInfoAck} message VipSignInfoAck message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            VipSignInfoAck.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a VipSignInfoAck message from the specified reader or buffer.
            * @function decode
            * @memberof gaiaProto.VipSignInfoAck
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {gaiaProto.VipSignInfoAck} VipSignInfoAck
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            VipSignInfoAck.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gaiaProto.VipSignInfoAck();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.info = $root.gaiaProto.VipSignInfoData.decode(reader, reader.uint32());
                    break;

                  case 2:
                    message.result = reader.int32();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a VipSignInfoAck message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof gaiaProto.VipSignInfoAck
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {gaiaProto.VipSignInfoAck} VipSignInfoAck
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            VipSignInfoAck.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a VipSignInfoAck message.
            * @function verify
            * @memberof gaiaProto.VipSignInfoAck
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            VipSignInfoAck.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";

              if (message.info != null && message.hasOwnProperty("info")) {
                var error = $root.gaiaProto.VipSignInfoData.verify(message.info);
                if (error) return "info." + error;
              }

              if (message.result != null && message.hasOwnProperty("result")) if (!$util.isInteger(message.result)) return "result: integer expected";
              return null;
            };
            /**
            * Creates a VipSignInfoAck message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof gaiaProto.VipSignInfoAck
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {gaiaProto.VipSignInfoAck} VipSignInfoAck
            */


            VipSignInfoAck.fromObject = function fromObject(object) {
              if (object instanceof $root.gaiaProto.VipSignInfoAck) return object;
              var message = new $root.gaiaProto.VipSignInfoAck();

              if (object.info != null) {
                if (typeof object.info !== "object") throw TypeError(".gaiaProto.VipSignInfoAck.info: object expected");
                message.info = $root.gaiaProto.VipSignInfoData.fromObject(object.info);
              }

              if (object.result != null) message.result = object.result | 0;
              return message;
            };
            /**
            * Creates a plain object from a VipSignInfoAck message. Also converts values to other types if specified.
            * @function toObject
            * @memberof gaiaProto.VipSignInfoAck
            * @static
            * @param {gaiaProto.VipSignInfoAck} message VipSignInfoAck
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            VipSignInfoAck.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.info = null;
                object.result = 0;
              }

              if (message.info != null && message.hasOwnProperty("info")) object.info = $root.gaiaProto.VipSignInfoData.toObject(message.info, options);
              if (message.result != null && message.hasOwnProperty("result")) object.result = message.result;
              return object;
            };
            /**
            * Converts this VipSignInfoAck to JSON.
            * @function toJSON
            * @memberof gaiaProto.VipSignInfoAck
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            VipSignInfoAck.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return VipSignInfoAck;
          }();

          gaiaProto.VipSignInfoData = function () {
            /**
            * Properties of a VipSignInfoData.
            * @memberof gaiaProto
            * @interface IVipSignInfoData
            * @property {Array.<gaiaProto.IVipSignTreasure>|null} [treasurelist] VipSignInfoData treasurelist
            * @property {string|null} [expiredtime] VipSignInfoData expiredtime
            * @property {number|null} [error] VipSignInfoData error
            */

            /**
            * Constructs a new VipSignInfoData.
            * @memberof gaiaProto
            * @classdesc Represents a VipSignInfoData.
            * @implements IVipSignInfoData
            * @constructor
            * @param {gaiaProto.IVipSignInfoData=} [properties] Properties to set
            */
            function VipSignInfoData(properties) {
              this.treasurelist = [];
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * VipSignInfoData treasurelist.
            * @member {Array.<gaiaProto.IVipSignTreasure>} treasurelist
            * @memberof gaiaProto.VipSignInfoData
            * @instance
            */


            VipSignInfoData.prototype.treasurelist = $util.emptyArray;
            /**
            * VipSignInfoData expiredtime.
            * @member {string} expiredtime
            * @memberof gaiaProto.VipSignInfoData
            * @instance
            */

            VipSignInfoData.prototype.expiredtime = "";
            /**
            * VipSignInfoData error.
            * @member {number} error
            * @memberof gaiaProto.VipSignInfoData
            * @instance
            */

            VipSignInfoData.prototype.error = 0;
            /**
            * Creates a new VipSignInfoData instance using the specified properties.
            * @function create
            * @memberof gaiaProto.VipSignInfoData
            * @static
            * @param {gaiaProto.IVipSignInfoData=} [properties] Properties to set
            * @returns {gaiaProto.VipSignInfoData} VipSignInfoData instance
            */

            VipSignInfoData.create = function create(properties) {
              return new VipSignInfoData(properties);
            };
            /**
            * Encodes the specified VipSignInfoData message. Does not implicitly {@link gaiaProto.VipSignInfoData.verify|verify} messages.
            * @function encode
            * @memberof gaiaProto.VipSignInfoData
            * @static
            * @param {gaiaProto.IVipSignInfoData} message VipSignInfoData message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            VipSignInfoData.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.treasurelist != null && message.treasurelist.length) for (var i = 0; i < message.treasurelist.length; ++i) {
                $root.gaiaProto.VipSignTreasure.encode(message.treasurelist[i], writer.uint32(
                /* id 1, wireType 2 =*/
                10).fork()).ldelim();
              }
              if (message.expiredtime != null && Object.hasOwnProperty.call(message, "expiredtime")) writer.uint32(
              /* id 2, wireType 2 =*/
              18).string(message.expiredtime);
              if (message.error != null && Object.hasOwnProperty.call(message, "error")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.error);
              return writer;
            };
            /**
            * Encodes the specified VipSignInfoData message, length delimited. Does not implicitly {@link gaiaProto.VipSignInfoData.verify|verify} messages.
            * @function encodeDelimited
            * @memberof gaiaProto.VipSignInfoData
            * @static
            * @param {gaiaProto.IVipSignInfoData} message VipSignInfoData message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            VipSignInfoData.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a VipSignInfoData message from the specified reader or buffer.
            * @function decode
            * @memberof gaiaProto.VipSignInfoData
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {gaiaProto.VipSignInfoData} VipSignInfoData
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            VipSignInfoData.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gaiaProto.VipSignInfoData();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    if (!(message.treasurelist && message.treasurelist.length)) message.treasurelist = [];
                    message.treasurelist.push($root.gaiaProto.VipSignTreasure.decode(reader, reader.uint32()));
                    break;

                  case 2:
                    message.expiredtime = reader.string();
                    break;

                  case 3:
                    message.error = reader.int32();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a VipSignInfoData message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof gaiaProto.VipSignInfoData
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {gaiaProto.VipSignInfoData} VipSignInfoData
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            VipSignInfoData.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a VipSignInfoData message.
            * @function verify
            * @memberof gaiaProto.VipSignInfoData
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            VipSignInfoData.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";

              if (message.treasurelist != null && message.hasOwnProperty("treasurelist")) {
                if (!Array.isArray(message.treasurelist)) return "treasurelist: array expected";

                for (var i = 0; i < message.treasurelist.length; ++i) {
                  var error = $root.gaiaProto.VipSignTreasure.verify(message.treasurelist[i]);
                  if (error) return "treasurelist." + error;
                }
              }

              if (message.expiredtime != null && message.hasOwnProperty("expiredtime")) if (!$util.isString(message.expiredtime)) return "expiredtime: string expected";
              if (message.error != null && message.hasOwnProperty("error")) if (!$util.isInteger(message.error)) return "error: integer expected";
              return null;
            };
            /**
            * Creates a VipSignInfoData message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof gaiaProto.VipSignInfoData
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {gaiaProto.VipSignInfoData} VipSignInfoData
            */


            VipSignInfoData.fromObject = function fromObject(object) {
              if (object instanceof $root.gaiaProto.VipSignInfoData) return object;
              var message = new $root.gaiaProto.VipSignInfoData();

              if (object.treasurelist) {
                if (!Array.isArray(object.treasurelist)) throw TypeError(".gaiaProto.VipSignInfoData.treasurelist: array expected");
                message.treasurelist = [];

                for (var i = 0; i < object.treasurelist.length; ++i) {
                  if (typeof object.treasurelist[i] !== "object") throw TypeError(".gaiaProto.VipSignInfoData.treasurelist: object expected");
                  message.treasurelist[i] = $root.gaiaProto.VipSignTreasure.fromObject(object.treasurelist[i]);
                }
              }

              if (object.expiredtime != null) message.expiredtime = String(object.expiredtime);
              if (object.error != null) message.error = object.error | 0;
              return message;
            };
            /**
            * Creates a plain object from a VipSignInfoData message. Also converts values to other types if specified.
            * @function toObject
            * @memberof gaiaProto.VipSignInfoData
            * @static
            * @param {gaiaProto.VipSignInfoData} message VipSignInfoData
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            VipSignInfoData.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};
              if (options.arrays || options.defaults) object.treasurelist = [];

              if (options.defaults) {
                object.expiredtime = "";
                object.error = 0;
              }

              if (message.treasurelist && message.treasurelist.length) {
                object.treasurelist = [];

                for (var j = 0; j < message.treasurelist.length; ++j) {
                  object.treasurelist[j] = $root.gaiaProto.VipSignTreasure.toObject(message.treasurelist[j], options);
                }
              }

              if (message.expiredtime != null && message.hasOwnProperty("expiredtime")) object.expiredtime = message.expiredtime;
              if (message.error != null && message.hasOwnProperty("error")) object.error = message.error;
              return object;
            };
            /**
            * Converts this VipSignInfoData to JSON.
            * @function toJSON
            * @memberof gaiaProto.VipSignInfoData
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            VipSignInfoData.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return VipSignInfoData;
          }();

          gaiaProto.VipSignTreasure = function () {
            /**
            * Properties of a VipSignTreasure.
            * @memberof gaiaProto
            * @interface IVipSignTreasure
            * @property {string|null} [index] VipSignTreasure index
            * @property {number|null} [minvip] VipSignTreasure minvip
            * @property {number|null} [exp] VipSignTreasure exp
            * @property {boolean|null} [isopen] VipSignTreasure isopen
            */

            /**
            * Constructs a new VipSignTreasure.
            * @memberof gaiaProto
            * @classdesc Represents a VipSignTreasure.
            * @implements IVipSignTreasure
            * @constructor
            * @param {gaiaProto.IVipSignTreasure=} [properties] Properties to set
            */
            function VipSignTreasure(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * VipSignTreasure index.
            * @member {string} index
            * @memberof gaiaProto.VipSignTreasure
            * @instance
            */


            VipSignTreasure.prototype.index = "";
            /**
            * VipSignTreasure minvip.
            * @member {number} minvip
            * @memberof gaiaProto.VipSignTreasure
            * @instance
            */

            VipSignTreasure.prototype.minvip = 0;
            /**
            * VipSignTreasure exp.
            * @member {number} exp
            * @memberof gaiaProto.VipSignTreasure
            * @instance
            */

            VipSignTreasure.prototype.exp = 0;
            /**
            * VipSignTreasure isopen.
            * @member {boolean} isopen
            * @memberof gaiaProto.VipSignTreasure
            * @instance
            */

            VipSignTreasure.prototype.isopen = false;
            /**
            * Creates a new VipSignTreasure instance using the specified properties.
            * @function create
            * @memberof gaiaProto.VipSignTreasure
            * @static
            * @param {gaiaProto.IVipSignTreasure=} [properties] Properties to set
            * @returns {gaiaProto.VipSignTreasure} VipSignTreasure instance
            */

            VipSignTreasure.create = function create(properties) {
              return new VipSignTreasure(properties);
            };
            /**
            * Encodes the specified VipSignTreasure message. Does not implicitly {@link gaiaProto.VipSignTreasure.verify|verify} messages.
            * @function encode
            * @memberof gaiaProto.VipSignTreasure
            * @static
            * @param {gaiaProto.IVipSignTreasure} message VipSignTreasure message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            VipSignTreasure.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.index != null && Object.hasOwnProperty.call(message, "index")) writer.uint32(
              /* id 1, wireType 2 =*/
              10).string(message.index);
              if (message.minvip != null && Object.hasOwnProperty.call(message, "minvip")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int32(message.minvip);
              if (message.exp != null && Object.hasOwnProperty.call(message, "exp")) writer.uint32(
              /* id 3, wireType 1 =*/
              25)["double"](message.exp);
              if (message.isopen != null && Object.hasOwnProperty.call(message, "isopen")) writer.uint32(
              /* id 4, wireType 0 =*/
              32).bool(message.isopen);
              return writer;
            };
            /**
            * Encodes the specified VipSignTreasure message, length delimited. Does not implicitly {@link gaiaProto.VipSignTreasure.verify|verify} messages.
            * @function encodeDelimited
            * @memberof gaiaProto.VipSignTreasure
            * @static
            * @param {gaiaProto.IVipSignTreasure} message VipSignTreasure message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            VipSignTreasure.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a VipSignTreasure message from the specified reader or buffer.
            * @function decode
            * @memberof gaiaProto.VipSignTreasure
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {gaiaProto.VipSignTreasure} VipSignTreasure
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            VipSignTreasure.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gaiaProto.VipSignTreasure();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.index = reader.string();
                    break;

                  case 2:
                    message.minvip = reader.int32();
                    break;

                  case 3:
                    message.exp = reader["double"]();
                    break;

                  case 4:
                    message.isopen = reader.bool();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a VipSignTreasure message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof gaiaProto.VipSignTreasure
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {gaiaProto.VipSignTreasure} VipSignTreasure
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            VipSignTreasure.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a VipSignTreasure message.
            * @function verify
            * @memberof gaiaProto.VipSignTreasure
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            VipSignTreasure.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.index != null && message.hasOwnProperty("index")) if (!$util.isString(message.index)) return "index: string expected";
              if (message.minvip != null && message.hasOwnProperty("minvip")) if (!$util.isInteger(message.minvip)) return "minvip: integer expected";
              if (message.exp != null && message.hasOwnProperty("exp")) if (typeof message.exp !== "number") return "exp: number expected";
              if (message.isopen != null && message.hasOwnProperty("isopen")) if (typeof message.isopen !== "boolean") return "isopen: boolean expected";
              return null;
            };
            /**
            * Creates a VipSignTreasure message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof gaiaProto.VipSignTreasure
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {gaiaProto.VipSignTreasure} VipSignTreasure
            */


            VipSignTreasure.fromObject = function fromObject(object) {
              if (object instanceof $root.gaiaProto.VipSignTreasure) return object;
              var message = new $root.gaiaProto.VipSignTreasure();
              if (object.index != null) message.index = String(object.index);
              if (object.minvip != null) message.minvip = object.minvip | 0;
              if (object.exp != null) message.exp = Number(object.exp);
              if (object.isopen != null) message.isopen = Boolean(object.isopen);
              return message;
            };
            /**
            * Creates a plain object from a VipSignTreasure message. Also converts values to other types if specified.
            * @function toObject
            * @memberof gaiaProto.VipSignTreasure
            * @static
            * @param {gaiaProto.VipSignTreasure} message VipSignTreasure
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            VipSignTreasure.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.index = "";
                object.minvip = 0;
                object.exp = 0;
                object.isopen = false;
              }

              if (message.index != null && message.hasOwnProperty("index")) object.index = message.index;
              if (message.minvip != null && message.hasOwnProperty("minvip")) object.minvip = message.minvip;
              if (message.exp != null && message.hasOwnProperty("exp")) object.exp = options.json && !isFinite(message.exp) ? String(message.exp) : message.exp;
              if (message.isopen != null && message.hasOwnProperty("isopen")) object.isopen = message.isopen;
              return object;
            };
            /**
            * Converts this VipSignTreasure to JSON.
            * @function toJSON
            * @memberof gaiaProto.VipSignTreasure
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            VipSignTreasure.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return VipSignTreasure;
          }();

          gaiaProto.VipSignRewardAck = function () {
            /**
            * Properties of a VipSignRewardAck.
            * @memberof gaiaProto
            * @interface IVipSignRewardAck
            * @property {gaiaProto.IVipSignRewardData|null} [info] VipSignRewardAck info
            * @property {number|null} [result] VipSignRewardAck result
            */

            /**
            * Constructs a new VipSignRewardAck.
            * @memberof gaiaProto
            * @classdesc Represents a VipSignRewardAck.
            * @implements IVipSignRewardAck
            * @constructor
            * @param {gaiaProto.IVipSignRewardAck=} [properties] Properties to set
            */
            function VipSignRewardAck(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * VipSignRewardAck info.
            * @member {gaiaProto.IVipSignRewardData|null|undefined} info
            * @memberof gaiaProto.VipSignRewardAck
            * @instance
            */


            VipSignRewardAck.prototype.info = null;
            /**
            * VipSignRewardAck result.
            * @member {number} result
            * @memberof gaiaProto.VipSignRewardAck
            * @instance
            */

            VipSignRewardAck.prototype.result = 0;
            /**
            * Creates a new VipSignRewardAck instance using the specified properties.
            * @function create
            * @memberof gaiaProto.VipSignRewardAck
            * @static
            * @param {gaiaProto.IVipSignRewardAck=} [properties] Properties to set
            * @returns {gaiaProto.VipSignRewardAck} VipSignRewardAck instance
            */

            VipSignRewardAck.create = function create(properties) {
              return new VipSignRewardAck(properties);
            };
            /**
            * Encodes the specified VipSignRewardAck message. Does not implicitly {@link gaiaProto.VipSignRewardAck.verify|verify} messages.
            * @function encode
            * @memberof gaiaProto.VipSignRewardAck
            * @static
            * @param {gaiaProto.IVipSignRewardAck} message VipSignRewardAck message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            VipSignRewardAck.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.info != null && Object.hasOwnProperty.call(message, "info")) $root.gaiaProto.VipSignRewardData.encode(message.info, writer.uint32(
              /* id 1, wireType 2 =*/
              10).fork()).ldelim();
              if (message.result != null && Object.hasOwnProperty.call(message, "result")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int32(message.result);
              return writer;
            };
            /**
            * Encodes the specified VipSignRewardAck message, length delimited. Does not implicitly {@link gaiaProto.VipSignRewardAck.verify|verify} messages.
            * @function encodeDelimited
            * @memberof gaiaProto.VipSignRewardAck
            * @static
            * @param {gaiaProto.IVipSignRewardAck} message VipSignRewardAck message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            VipSignRewardAck.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a VipSignRewardAck message from the specified reader or buffer.
            * @function decode
            * @memberof gaiaProto.VipSignRewardAck
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {gaiaProto.VipSignRewardAck} VipSignRewardAck
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            VipSignRewardAck.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gaiaProto.VipSignRewardAck();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.info = $root.gaiaProto.VipSignRewardData.decode(reader, reader.uint32());
                    break;

                  case 2:
                    message.result = reader.int32();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a VipSignRewardAck message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof gaiaProto.VipSignRewardAck
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {gaiaProto.VipSignRewardAck} VipSignRewardAck
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            VipSignRewardAck.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a VipSignRewardAck message.
            * @function verify
            * @memberof gaiaProto.VipSignRewardAck
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            VipSignRewardAck.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";

              if (message.info != null && message.hasOwnProperty("info")) {
                var error = $root.gaiaProto.VipSignRewardData.verify(message.info);
                if (error) return "info." + error;
              }

              if (message.result != null && message.hasOwnProperty("result")) if (!$util.isInteger(message.result)) return "result: integer expected";
              return null;
            };
            /**
            * Creates a VipSignRewardAck message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof gaiaProto.VipSignRewardAck
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {gaiaProto.VipSignRewardAck} VipSignRewardAck
            */


            VipSignRewardAck.fromObject = function fromObject(object) {
              if (object instanceof $root.gaiaProto.VipSignRewardAck) return object;
              var message = new $root.gaiaProto.VipSignRewardAck();

              if (object.info != null) {
                if (typeof object.info !== "object") throw TypeError(".gaiaProto.VipSignRewardAck.info: object expected");
                message.info = $root.gaiaProto.VipSignRewardData.fromObject(object.info);
              }

              if (object.result != null) message.result = object.result | 0;
              return message;
            };
            /**
            * Creates a plain object from a VipSignRewardAck message. Also converts values to other types if specified.
            * @function toObject
            * @memberof gaiaProto.VipSignRewardAck
            * @static
            * @param {gaiaProto.VipSignRewardAck} message VipSignRewardAck
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            VipSignRewardAck.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.info = null;
                object.result = 0;
              }

              if (message.info != null && message.hasOwnProperty("info")) object.info = $root.gaiaProto.VipSignRewardData.toObject(message.info, options);
              if (message.result != null && message.hasOwnProperty("result")) object.result = message.result;
              return object;
            };
            /**
            * Converts this VipSignRewardAck to JSON.
            * @function toJSON
            * @memberof gaiaProto.VipSignRewardAck
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            VipSignRewardAck.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return VipSignRewardAck;
          }();

          gaiaProto.VipSignRewardData = function () {
            /**
            * Properties of a VipSignRewardData.
            * @memberof gaiaProto
            * @interface IVipSignRewardData
            * @property {number|null} [itemid] VipSignRewardData itemid
            * @property {number|null} [count] VipSignRewardData count
            * @property {number|null} [error] VipSignRewardData error
            * @property {number|null} [icon] VipSignRewardData icon
            */

            /**
            * Constructs a new VipSignRewardData.
            * @memberof gaiaProto
            * @classdesc Represents a VipSignRewardData.
            * @implements IVipSignRewardData
            * @constructor
            * @param {gaiaProto.IVipSignRewardData=} [properties] Properties to set
            */
            function VipSignRewardData(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * VipSignRewardData itemid.
            * @member {number} itemid
            * @memberof gaiaProto.VipSignRewardData
            * @instance
            */


            VipSignRewardData.prototype.itemid = 0;
            /**
            * VipSignRewardData count.
            * @member {number} count
            * @memberof gaiaProto.VipSignRewardData
            * @instance
            */

            VipSignRewardData.prototype.count = 0;
            /**
            * VipSignRewardData error.
            * @member {number} error
            * @memberof gaiaProto.VipSignRewardData
            * @instance
            */

            VipSignRewardData.prototype.error = 0;
            /**
            * VipSignRewardData icon.
            * @member {number} icon
            * @memberof gaiaProto.VipSignRewardData
            * @instance
            */

            VipSignRewardData.prototype.icon = 0;
            /**
            * Creates a new VipSignRewardData instance using the specified properties.
            * @function create
            * @memberof gaiaProto.VipSignRewardData
            * @static
            * @param {gaiaProto.IVipSignRewardData=} [properties] Properties to set
            * @returns {gaiaProto.VipSignRewardData} VipSignRewardData instance
            */

            VipSignRewardData.create = function create(properties) {
              return new VipSignRewardData(properties);
            };
            /**
            * Encodes the specified VipSignRewardData message. Does not implicitly {@link gaiaProto.VipSignRewardData.verify|verify} messages.
            * @function encode
            * @memberof gaiaProto.VipSignRewardData
            * @static
            * @param {gaiaProto.IVipSignRewardData} message VipSignRewardData message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            VipSignRewardData.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.itemid != null && Object.hasOwnProperty.call(message, "itemid")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.itemid);
              if (message.count != null && Object.hasOwnProperty.call(message, "count")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int32(message.count);
              if (message.error != null && Object.hasOwnProperty.call(message, "error")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.error);
              if (message.icon != null && Object.hasOwnProperty.call(message, "icon")) writer.uint32(
              /* id 4, wireType 0 =*/
              32).int32(message.icon);
              return writer;
            };
            /**
            * Encodes the specified VipSignRewardData message, length delimited. Does not implicitly {@link gaiaProto.VipSignRewardData.verify|verify} messages.
            * @function encodeDelimited
            * @memberof gaiaProto.VipSignRewardData
            * @static
            * @param {gaiaProto.IVipSignRewardData} message VipSignRewardData message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            VipSignRewardData.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a VipSignRewardData message from the specified reader or buffer.
            * @function decode
            * @memberof gaiaProto.VipSignRewardData
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {gaiaProto.VipSignRewardData} VipSignRewardData
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            VipSignRewardData.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gaiaProto.VipSignRewardData();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.itemid = reader.int32();
                    break;

                  case 2:
                    message.count = reader.int32();
                    break;

                  case 3:
                    message.error = reader.int32();
                    break;

                  case 4:
                    message.icon = reader.int32();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a VipSignRewardData message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof gaiaProto.VipSignRewardData
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {gaiaProto.VipSignRewardData} VipSignRewardData
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            VipSignRewardData.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a VipSignRewardData message.
            * @function verify
            * @memberof gaiaProto.VipSignRewardData
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            VipSignRewardData.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.itemid != null && message.hasOwnProperty("itemid")) if (!$util.isInteger(message.itemid)) return "itemid: integer expected";
              if (message.count != null && message.hasOwnProperty("count")) if (!$util.isInteger(message.count)) return "count: integer expected";
              if (message.error != null && message.hasOwnProperty("error")) if (!$util.isInteger(message.error)) return "error: integer expected";
              if (message.icon != null && message.hasOwnProperty("icon")) if (!$util.isInteger(message.icon)) return "icon: integer expected";
              return null;
            };
            /**
            * Creates a VipSignRewardData message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof gaiaProto.VipSignRewardData
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {gaiaProto.VipSignRewardData} VipSignRewardData
            */


            VipSignRewardData.fromObject = function fromObject(object) {
              if (object instanceof $root.gaiaProto.VipSignRewardData) return object;
              var message = new $root.gaiaProto.VipSignRewardData();
              if (object.itemid != null) message.itemid = object.itemid | 0;
              if (object.count != null) message.count = object.count | 0;
              if (object.error != null) message.error = object.error | 0;
              if (object.icon != null) message.icon = object.icon | 0;
              return message;
            };
            /**
            * Creates a plain object from a VipSignRewardData message. Also converts values to other types if specified.
            * @function toObject
            * @memberof gaiaProto.VipSignRewardData
            * @static
            * @param {gaiaProto.VipSignRewardData} message VipSignRewardData
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            VipSignRewardData.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.itemid = 0;
                object.count = 0;
                object.error = 0;
                object.icon = 0;
              }

              if (message.itemid != null && message.hasOwnProperty("itemid")) object.itemid = message.itemid;
              if (message.count != null && message.hasOwnProperty("count")) object.count = message.count;
              if (message.error != null && message.hasOwnProperty("error")) object.error = message.error;
              if (message.icon != null && message.hasOwnProperty("icon")) object.icon = message.icon;
              return object;
            };
            /**
            * Converts this VipSignRewardData to JSON.
            * @function toJSON
            * @memberof gaiaProto.VipSignRewardData
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            VipSignRewardData.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return VipSignRewardData;
          }();

          gaiaProto.CheckMallReq = function () {
            /**
            * Properties of a CheckMallReq.
            * @memberof gaiaProto
            * @interface ICheckMallReq
            * @property {number|null} [aid] CheckMallReq aid
            * @property {string|null} [token] CheckMallReq token
            * @property {number|null} [apiid] CheckMallReq apiid
            * @property {boolean|null} [isvol] CheckMallReq isvol
            * @property {number|null} [voltype] CheckMallReq voltype
            */

            /**
            * Constructs a new CheckMallReq.
            * @memberof gaiaProto
            * @classdesc Represents a CheckMallReq.
            * @implements ICheckMallReq
            * @constructor
            * @param {gaiaProto.ICheckMallReq=} [properties] Properties to set
            */
            function CheckMallReq(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * CheckMallReq aid.
            * @member {number} aid
            * @memberof gaiaProto.CheckMallReq
            * @instance
            */


            CheckMallReq.prototype.aid = 0;
            /**
            * CheckMallReq token.
            * @member {string} token
            * @memberof gaiaProto.CheckMallReq
            * @instance
            */

            CheckMallReq.prototype.token = "";
            /**
            * CheckMallReq apiid.
            * @member {number} apiid
            * @memberof gaiaProto.CheckMallReq
            * @instance
            */

            CheckMallReq.prototype.apiid = 0;
            /**
            * CheckMallReq isvol.
            * @member {boolean} isvol
            * @memberof gaiaProto.CheckMallReq
            * @instance
            */

            CheckMallReq.prototype.isvol = false;
            /**
            * CheckMallReq voltype.
            * @member {number} voltype
            * @memberof gaiaProto.CheckMallReq
            * @instance
            */

            CheckMallReq.prototype.voltype = 0;
            /**
            * Creates a new CheckMallReq instance using the specified properties.
            * @function create
            * @memberof gaiaProto.CheckMallReq
            * @static
            * @param {gaiaProto.ICheckMallReq=} [properties] Properties to set
            * @returns {gaiaProto.CheckMallReq} CheckMallReq instance
            */

            CheckMallReq.create = function create(properties) {
              return new CheckMallReq(properties);
            };
            /**
            * Encodes the specified CheckMallReq message. Does not implicitly {@link gaiaProto.CheckMallReq.verify|verify} messages.
            * @function encode
            * @memberof gaiaProto.CheckMallReq
            * @static
            * @param {gaiaProto.ICheckMallReq} message CheckMallReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            CheckMallReq.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.aid != null && Object.hasOwnProperty.call(message, "aid")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.aid);
              if (message.token != null && Object.hasOwnProperty.call(message, "token")) writer.uint32(
              /* id 2, wireType 2 =*/
              18).string(message.token);
              if (message.apiid != null && Object.hasOwnProperty.call(message, "apiid")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.apiid);
              if (message.isvol != null && Object.hasOwnProperty.call(message, "isvol")) writer.uint32(
              /* id 4, wireType 0 =*/
              32).bool(message.isvol);
              if (message.voltype != null && Object.hasOwnProperty.call(message, "voltype")) writer.uint32(
              /* id 5, wireType 0 =*/
              40).int32(message.voltype);
              return writer;
            };
            /**
            * Encodes the specified CheckMallReq message, length delimited. Does not implicitly {@link gaiaProto.CheckMallReq.verify|verify} messages.
            * @function encodeDelimited
            * @memberof gaiaProto.CheckMallReq
            * @static
            * @param {gaiaProto.ICheckMallReq} message CheckMallReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            CheckMallReq.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a CheckMallReq message from the specified reader or buffer.
            * @function decode
            * @memberof gaiaProto.CheckMallReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {gaiaProto.CheckMallReq} CheckMallReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            CheckMallReq.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gaiaProto.CheckMallReq();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.aid = reader.int32();
                    break;

                  case 2:
                    message.token = reader.string();
                    break;

                  case 3:
                    message.apiid = reader.int32();
                    break;

                  case 4:
                    message.isvol = reader.bool();
                    break;

                  case 5:
                    message.voltype = reader.int32();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a CheckMallReq message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof gaiaProto.CheckMallReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {gaiaProto.CheckMallReq} CheckMallReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            CheckMallReq.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a CheckMallReq message.
            * @function verify
            * @memberof gaiaProto.CheckMallReq
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            CheckMallReq.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.aid != null && message.hasOwnProperty("aid")) if (!$util.isInteger(message.aid)) return "aid: integer expected";
              if (message.token != null && message.hasOwnProperty("token")) if (!$util.isString(message.token)) return "token: string expected";
              if (message.apiid != null && message.hasOwnProperty("apiid")) if (!$util.isInteger(message.apiid)) return "apiid: integer expected";
              if (message.isvol != null && message.hasOwnProperty("isvol")) if (typeof message.isvol !== "boolean") return "isvol: boolean expected";
              if (message.voltype != null && message.hasOwnProperty("voltype")) if (!$util.isInteger(message.voltype)) return "voltype: integer expected";
              return null;
            };
            /**
            * Creates a CheckMallReq message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof gaiaProto.CheckMallReq
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {gaiaProto.CheckMallReq} CheckMallReq
            */


            CheckMallReq.fromObject = function fromObject(object) {
              if (object instanceof $root.gaiaProto.CheckMallReq) return object;
              var message = new $root.gaiaProto.CheckMallReq();
              if (object.aid != null) message.aid = object.aid | 0;
              if (object.token != null) message.token = String(object.token);
              if (object.apiid != null) message.apiid = object.apiid | 0;
              if (object.isvol != null) message.isvol = Boolean(object.isvol);
              if (object.voltype != null) message.voltype = object.voltype | 0;
              return message;
            };
            /**
            * Creates a plain object from a CheckMallReq message. Also converts values to other types if specified.
            * @function toObject
            * @memberof gaiaProto.CheckMallReq
            * @static
            * @param {gaiaProto.CheckMallReq} message CheckMallReq
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            CheckMallReq.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.aid = 0;
                object.token = "";
                object.apiid = 0;
                object.isvol = false;
                object.voltype = 0;
              }

              if (message.aid != null && message.hasOwnProperty("aid")) object.aid = message.aid;
              if (message.token != null && message.hasOwnProperty("token")) object.token = message.token;
              if (message.apiid != null && message.hasOwnProperty("apiid")) object.apiid = message.apiid;
              if (message.isvol != null && message.hasOwnProperty("isvol")) object.isvol = message.isvol;
              if (message.voltype != null && message.hasOwnProperty("voltype")) object.voltype = message.voltype;
              return object;
            };
            /**
            * Converts this CheckMallReq to JSON.
            * @function toJSON
            * @memberof gaiaProto.CheckMallReq
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            CheckMallReq.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CheckMallReq;
          }();

          gaiaProto.CheckMallAck = function () {
            /**
            * Properties of a CheckMallAck.
            * @memberof gaiaProto
            * @interface ICheckMallAck
            * @property {Array.<gaiaProto.IGameMallSetting>|null} [Settings] CheckMallAck Settings
            * @property {number|null} [Show] CheckMallAck Show
            */

            /**
            * Constructs a new CheckMallAck.
            * @memberof gaiaProto
            * @classdesc Represents a CheckMallAck.
            * @implements ICheckMallAck
            * @constructor
            * @param {gaiaProto.ICheckMallAck=} [properties] Properties to set
            */
            function CheckMallAck(properties) {
              this.Settings = [];
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * CheckMallAck Settings.
            * @member {Array.<gaiaProto.IGameMallSetting>} Settings
            * @memberof gaiaProto.CheckMallAck
            * @instance
            */


            CheckMallAck.prototype.Settings = $util.emptyArray;
            /**
            * CheckMallAck Show.
            * @member {number} Show
            * @memberof gaiaProto.CheckMallAck
            * @instance
            */

            CheckMallAck.prototype.Show = 0;
            /**
            * Creates a new CheckMallAck instance using the specified properties.
            * @function create
            * @memberof gaiaProto.CheckMallAck
            * @static
            * @param {gaiaProto.ICheckMallAck=} [properties] Properties to set
            * @returns {gaiaProto.CheckMallAck} CheckMallAck instance
            */

            CheckMallAck.create = function create(properties) {
              return new CheckMallAck(properties);
            };
            /**
            * Encodes the specified CheckMallAck message. Does not implicitly {@link gaiaProto.CheckMallAck.verify|verify} messages.
            * @function encode
            * @memberof gaiaProto.CheckMallAck
            * @static
            * @param {gaiaProto.ICheckMallAck} message CheckMallAck message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            CheckMallAck.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.Settings != null && message.Settings.length) for (var i = 0; i < message.Settings.length; ++i) {
                $root.gaiaProto.GameMallSetting.encode(message.Settings[i], writer.uint32(
                /* id 1, wireType 2 =*/
                10).fork()).ldelim();
              }
              if (message.Show != null && Object.hasOwnProperty.call(message, "Show")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int32(message.Show);
              return writer;
            };
            /**
            * Encodes the specified CheckMallAck message, length delimited. Does not implicitly {@link gaiaProto.CheckMallAck.verify|verify} messages.
            * @function encodeDelimited
            * @memberof gaiaProto.CheckMallAck
            * @static
            * @param {gaiaProto.ICheckMallAck} message CheckMallAck message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            CheckMallAck.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a CheckMallAck message from the specified reader or buffer.
            * @function decode
            * @memberof gaiaProto.CheckMallAck
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {gaiaProto.CheckMallAck} CheckMallAck
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            CheckMallAck.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gaiaProto.CheckMallAck();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    if (!(message.Settings && message.Settings.length)) message.Settings = [];
                    message.Settings.push($root.gaiaProto.GameMallSetting.decode(reader, reader.uint32()));
                    break;

                  case 2:
                    message.Show = reader.int32();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a CheckMallAck message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof gaiaProto.CheckMallAck
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {gaiaProto.CheckMallAck} CheckMallAck
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            CheckMallAck.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a CheckMallAck message.
            * @function verify
            * @memberof gaiaProto.CheckMallAck
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            CheckMallAck.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";

              if (message.Settings != null && message.hasOwnProperty("Settings")) {
                if (!Array.isArray(message.Settings)) return "Settings: array expected";

                for (var i = 0; i < message.Settings.length; ++i) {
                  var error = $root.gaiaProto.GameMallSetting.verify(message.Settings[i]);
                  if (error) return "Settings." + error;
                }
              }

              if (message.Show != null && message.hasOwnProperty("Show")) if (!$util.isInteger(message.Show)) return "Show: integer expected";
              return null;
            };
            /**
            * Creates a CheckMallAck message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof gaiaProto.CheckMallAck
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {gaiaProto.CheckMallAck} CheckMallAck
            */


            CheckMallAck.fromObject = function fromObject(object) {
              if (object instanceof $root.gaiaProto.CheckMallAck) return object;
              var message = new $root.gaiaProto.CheckMallAck();

              if (object.Settings) {
                if (!Array.isArray(object.Settings)) throw TypeError(".gaiaProto.CheckMallAck.Settings: array expected");
                message.Settings = [];

                for (var i = 0; i < object.Settings.length; ++i) {
                  if (typeof object.Settings[i] !== "object") throw TypeError(".gaiaProto.CheckMallAck.Settings: object expected");
                  message.Settings[i] = $root.gaiaProto.GameMallSetting.fromObject(object.Settings[i]);
                }
              }

              if (object.Show != null) message.Show = object.Show | 0;
              return message;
            };
            /**
            * Creates a plain object from a CheckMallAck message. Also converts values to other types if specified.
            * @function toObject
            * @memberof gaiaProto.CheckMallAck
            * @static
            * @param {gaiaProto.CheckMallAck} message CheckMallAck
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            CheckMallAck.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};
              if (options.arrays || options.defaults) object.Settings = [];
              if (options.defaults) object.Show = 0;

              if (message.Settings && message.Settings.length) {
                object.Settings = [];

                for (var j = 0; j < message.Settings.length; ++j) {
                  object.Settings[j] = $root.gaiaProto.GameMallSetting.toObject(message.Settings[j], options);
                }
              }

              if (message.Show != null && message.hasOwnProperty("Show")) object.Show = message.Show;
              return object;
            };
            /**
            * Converts this CheckMallAck to JSON.
            * @function toJSON
            * @memberof gaiaProto.CheckMallAck
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            CheckMallAck.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CheckMallAck;
          }();

          gaiaProto.GameMallSetting = function () {
            /**
            * Properties of a GameMallSetting.
            * @memberof gaiaProto
            * @interface IGameMallSetting
            * @property {number|null} [GameID] GameMallSetting GameID
            * @property {number|null} [APIID] GameMallSetting APIID
            * @property {number|null} [AlterID] GameMallSetting AlterID
            * @property {number|null} [DescType] GameMallSetting DescType
            * @property {number|null} [DescRounds] GameMallSetting DescRounds
            * @property {number|null} [MaxBet] GameMallSetting MaxBet
            * @property {number|null} [PriceOdd] GameMallSetting PriceOdd
            * @property {boolean|null} [ForSale] GameMallSetting ForSale
            * @property {Array.<number>|null} [BetVec] GameMallSetting BetVec
            * @property {number|null} [ReelNo] GameMallSetting ReelNo
            * @property {number|null} [BetNo] GameMallSetting BetNo
            * @property {boolean|null} [Event] GameMallSetting Event
            */

            /**
            * Constructs a new GameMallSetting.
            * @memberof gaiaProto
            * @classdesc Represents a GameMallSetting.
            * @implements IGameMallSetting
            * @constructor
            * @param {gaiaProto.IGameMallSetting=} [properties] Properties to set
            */
            function GameMallSetting(properties) {
              this.BetVec = [];
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * GameMallSetting GameID.
            * @member {number} GameID
            * @memberof gaiaProto.GameMallSetting
            * @instance
            */


            GameMallSetting.prototype.GameID = 0;
            /**
            * GameMallSetting APIID.
            * @member {number} APIID
            * @memberof gaiaProto.GameMallSetting
            * @instance
            */

            GameMallSetting.prototype.APIID = 0;
            /**
            * GameMallSetting AlterID.
            * @member {number} AlterID
            * @memberof gaiaProto.GameMallSetting
            * @instance
            */

            GameMallSetting.prototype.AlterID = 0;
            /**
            * GameMallSetting DescType.
            * @member {number} DescType
            * @memberof gaiaProto.GameMallSetting
            * @instance
            */

            GameMallSetting.prototype.DescType = 0;
            /**
            * GameMallSetting DescRounds.
            * @member {number} DescRounds
            * @memberof gaiaProto.GameMallSetting
            * @instance
            */

            GameMallSetting.prototype.DescRounds = 0;
            /**
            * GameMallSetting MaxBet.
            * @member {number} MaxBet
            * @memberof gaiaProto.GameMallSetting
            * @instance
            */

            GameMallSetting.prototype.MaxBet = 0;
            /**
            * GameMallSetting PriceOdd.
            * @member {number} PriceOdd
            * @memberof gaiaProto.GameMallSetting
            * @instance
            */

            GameMallSetting.prototype.PriceOdd = 0;
            /**
            * GameMallSetting ForSale.
            * @member {boolean} ForSale
            * @memberof gaiaProto.GameMallSetting
            * @instance
            */

            GameMallSetting.prototype.ForSale = false;
            /**
            * GameMallSetting BetVec.
            * @member {Array.<number>} BetVec
            * @memberof gaiaProto.GameMallSetting
            * @instance
            */

            GameMallSetting.prototype.BetVec = $util.emptyArray;
            /**
            * GameMallSetting ReelNo.
            * @member {number} ReelNo
            * @memberof gaiaProto.GameMallSetting
            * @instance
            */

            GameMallSetting.prototype.ReelNo = 0;
            /**
            * GameMallSetting BetNo.
            * @member {number} BetNo
            * @memberof gaiaProto.GameMallSetting
            * @instance
            */

            GameMallSetting.prototype.BetNo = 0;
            /**
            * GameMallSetting Event.
            * @member {boolean} Event
            * @memberof gaiaProto.GameMallSetting
            * @instance
            */

            GameMallSetting.prototype.Event = false;
            /**
            * Creates a new GameMallSetting instance using the specified properties.
            * @function create
            * @memberof gaiaProto.GameMallSetting
            * @static
            * @param {gaiaProto.IGameMallSetting=} [properties] Properties to set
            * @returns {gaiaProto.GameMallSetting} GameMallSetting instance
            */

            GameMallSetting.create = function create(properties) {
              return new GameMallSetting(properties);
            };
            /**
            * Encodes the specified GameMallSetting message. Does not implicitly {@link gaiaProto.GameMallSetting.verify|verify} messages.
            * @function encode
            * @memberof gaiaProto.GameMallSetting
            * @static
            * @param {gaiaProto.IGameMallSetting} message GameMallSetting message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            GameMallSetting.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.GameID != null && Object.hasOwnProperty.call(message, "GameID")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.GameID);
              if (message.APIID != null && Object.hasOwnProperty.call(message, "APIID")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int32(message.APIID);
              if (message.AlterID != null && Object.hasOwnProperty.call(message, "AlterID")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.AlterID);
              if (message.DescType != null && Object.hasOwnProperty.call(message, "DescType")) writer.uint32(
              /* id 4, wireType 0 =*/
              32).int32(message.DescType);
              if (message.DescRounds != null && Object.hasOwnProperty.call(message, "DescRounds")) writer.uint32(
              /* id 5, wireType 0 =*/
              40).int32(message.DescRounds);
              if (message.MaxBet != null && Object.hasOwnProperty.call(message, "MaxBet")) writer.uint32(
              /* id 6, wireType 1 =*/
              49)["double"](message.MaxBet);
              if (message.PriceOdd != null && Object.hasOwnProperty.call(message, "PriceOdd")) writer.uint32(
              /* id 7, wireType 1 =*/
              57)["double"](message.PriceOdd);
              if (message.ForSale != null && Object.hasOwnProperty.call(message, "ForSale")) writer.uint32(
              /* id 8, wireType 0 =*/
              64).bool(message.ForSale);

              if (message.BetVec != null && message.BetVec.length) {
                writer.uint32(
                /* id 9, wireType 2 =*/
                74).fork();

                for (var i = 0; i < message.BetVec.length; ++i) {
                  writer["double"](message.BetVec[i]);
                }

                writer.ldelim();
              }

              if (message.ReelNo != null && Object.hasOwnProperty.call(message, "ReelNo")) writer.uint32(
              /* id 10, wireType 0 =*/
              80).int32(message.ReelNo);
              if (message.BetNo != null && Object.hasOwnProperty.call(message, "BetNo")) writer.uint32(
              /* id 11, wireType 0 =*/
              88).int32(message.BetNo);
              if (message.Event != null && Object.hasOwnProperty.call(message, "Event")) writer.uint32(
              /* id 12, wireType 0 =*/
              96).bool(message.Event);
              return writer;
            };
            /**
            * Encodes the specified GameMallSetting message, length delimited. Does not implicitly {@link gaiaProto.GameMallSetting.verify|verify} messages.
            * @function encodeDelimited
            * @memberof gaiaProto.GameMallSetting
            * @static
            * @param {gaiaProto.IGameMallSetting} message GameMallSetting message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            GameMallSetting.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a GameMallSetting message from the specified reader or buffer.
            * @function decode
            * @memberof gaiaProto.GameMallSetting
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {gaiaProto.GameMallSetting} GameMallSetting
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            GameMallSetting.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gaiaProto.GameMallSetting();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.GameID = reader.int32();
                    break;

                  case 2:
                    message.APIID = reader.int32();
                    break;

                  case 3:
                    message.AlterID = reader.int32();
                    break;

                  case 4:
                    message.DescType = reader.int32();
                    break;

                  case 5:
                    message.DescRounds = reader.int32();
                    break;

                  case 6:
                    message.MaxBet = reader["double"]();
                    break;

                  case 7:
                    message.PriceOdd = reader["double"]();
                    break;

                  case 8:
                    message.ForSale = reader.bool();
                    break;

                  case 9:
                    if (!(message.BetVec && message.BetVec.length)) message.BetVec = [];

                    if ((tag & 7) === 2) {
                      var end2 = reader.uint32() + reader.pos;

                      while (reader.pos < end2) {
                        message.BetVec.push(reader["double"]());
                      }
                    } else message.BetVec.push(reader["double"]());

                    break;

                  case 10:
                    message.ReelNo = reader.int32();
                    break;

                  case 11:
                    message.BetNo = reader.int32();
                    break;

                  case 12:
                    message.Event = reader.bool();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a GameMallSetting message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof gaiaProto.GameMallSetting
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {gaiaProto.GameMallSetting} GameMallSetting
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            GameMallSetting.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a GameMallSetting message.
            * @function verify
            * @memberof gaiaProto.GameMallSetting
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            GameMallSetting.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.GameID != null && message.hasOwnProperty("GameID")) if (!$util.isInteger(message.GameID)) return "GameID: integer expected";
              if (message.APIID != null && message.hasOwnProperty("APIID")) if (!$util.isInteger(message.APIID)) return "APIID: integer expected";
              if (message.AlterID != null && message.hasOwnProperty("AlterID")) if (!$util.isInteger(message.AlterID)) return "AlterID: integer expected";
              if (message.DescType != null && message.hasOwnProperty("DescType")) if (!$util.isInteger(message.DescType)) return "DescType: integer expected";
              if (message.DescRounds != null && message.hasOwnProperty("DescRounds")) if (!$util.isInteger(message.DescRounds)) return "DescRounds: integer expected";
              if (message.MaxBet != null && message.hasOwnProperty("MaxBet")) if (typeof message.MaxBet !== "number") return "MaxBet: number expected";
              if (message.PriceOdd != null && message.hasOwnProperty("PriceOdd")) if (typeof message.PriceOdd !== "number") return "PriceOdd: number expected";
              if (message.ForSale != null && message.hasOwnProperty("ForSale")) if (typeof message.ForSale !== "boolean") return "ForSale: boolean expected";

              if (message.BetVec != null && message.hasOwnProperty("BetVec")) {
                if (!Array.isArray(message.BetVec)) return "BetVec: array expected";

                for (var i = 0; i < message.BetVec.length; ++i) {
                  if (typeof message.BetVec[i] !== "number") return "BetVec: number[] expected";
                }
              }

              if (message.ReelNo != null && message.hasOwnProperty("ReelNo")) if (!$util.isInteger(message.ReelNo)) return "ReelNo: integer expected";
              if (message.BetNo != null && message.hasOwnProperty("BetNo")) if (!$util.isInteger(message.BetNo)) return "BetNo: integer expected";
              if (message.Event != null && message.hasOwnProperty("Event")) if (typeof message.Event !== "boolean") return "Event: boolean expected";
              return null;
            };
            /**
            * Creates a GameMallSetting message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof gaiaProto.GameMallSetting
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {gaiaProto.GameMallSetting} GameMallSetting
            */


            GameMallSetting.fromObject = function fromObject(object) {
              if (object instanceof $root.gaiaProto.GameMallSetting) return object;
              var message = new $root.gaiaProto.GameMallSetting();
              if (object.GameID != null) message.GameID = object.GameID | 0;
              if (object.APIID != null) message.APIID = object.APIID | 0;
              if (object.AlterID != null) message.AlterID = object.AlterID | 0;
              if (object.DescType != null) message.DescType = object.DescType | 0;
              if (object.DescRounds != null) message.DescRounds = object.DescRounds | 0;
              if (object.MaxBet != null) message.MaxBet = Number(object.MaxBet);
              if (object.PriceOdd != null) message.PriceOdd = Number(object.PriceOdd);
              if (object.ForSale != null) message.ForSale = Boolean(object.ForSale);

              if (object.BetVec) {
                if (!Array.isArray(object.BetVec)) throw TypeError(".gaiaProto.GameMallSetting.BetVec: array expected");
                message.BetVec = [];

                for (var i = 0; i < object.BetVec.length; ++i) {
                  message.BetVec[i] = Number(object.BetVec[i]);
                }
              }

              if (object.ReelNo != null) message.ReelNo = object.ReelNo | 0;
              if (object.BetNo != null) message.BetNo = object.BetNo | 0;
              if (object.Event != null) message.Event = Boolean(object.Event);
              return message;
            };
            /**
            * Creates a plain object from a GameMallSetting message. Also converts values to other types if specified.
            * @function toObject
            * @memberof gaiaProto.GameMallSetting
            * @static
            * @param {gaiaProto.GameMallSetting} message GameMallSetting
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            GameMallSetting.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};
              if (options.arrays || options.defaults) object.BetVec = [];

              if (options.defaults) {
                object.GameID = 0;
                object.APIID = 0;
                object.AlterID = 0;
                object.DescType = 0;
                object.DescRounds = 0;
                object.MaxBet = 0;
                object.PriceOdd = 0;
                object.ForSale = false;
                object.ReelNo = 0;
                object.BetNo = 0;
                object.Event = false;
              }

              if (message.GameID != null && message.hasOwnProperty("GameID")) object.GameID = message.GameID;
              if (message.APIID != null && message.hasOwnProperty("APIID")) object.APIID = message.APIID;
              if (message.AlterID != null && message.hasOwnProperty("AlterID")) object.AlterID = message.AlterID;
              if (message.DescType != null && message.hasOwnProperty("DescType")) object.DescType = message.DescType;
              if (message.DescRounds != null && message.hasOwnProperty("DescRounds")) object.DescRounds = message.DescRounds;
              if (message.MaxBet != null && message.hasOwnProperty("MaxBet")) object.MaxBet = options.json && !isFinite(message.MaxBet) ? String(message.MaxBet) : message.MaxBet;
              if (message.PriceOdd != null && message.hasOwnProperty("PriceOdd")) object.PriceOdd = options.json && !isFinite(message.PriceOdd) ? String(message.PriceOdd) : message.PriceOdd;
              if (message.ForSale != null && message.hasOwnProperty("ForSale")) object.ForSale = message.ForSale;

              if (message.BetVec && message.BetVec.length) {
                object.BetVec = [];

                for (var j = 0; j < message.BetVec.length; ++j) {
                  object.BetVec[j] = options.json && !isFinite(message.BetVec[j]) ? String(message.BetVec[j]) : message.BetVec[j];
                }
              }

              if (message.ReelNo != null && message.hasOwnProperty("ReelNo")) object.ReelNo = message.ReelNo;
              if (message.BetNo != null && message.hasOwnProperty("BetNo")) object.BetNo = message.BetNo;
              if (message.Event != null && message.hasOwnProperty("Event")) object.Event = message.Event;
              return object;
            };
            /**
            * Converts this GameMallSetting to JSON.
            * @function toJSON
            * @memberof gaiaProto.GameMallSetting
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            GameMallSetting.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GameMallSetting;
          }();

          gaiaProto.LevelReq = function () {
            /**
            * Properties of a LevelReq.
            * @memberof gaiaProto
            * @interface ILevelReq
            * @property {number|null} [aid] LevelReq aid
            * @property {string|null} [token] LevelReq token
            * @property {number|null} [currencynumber] LevelReq currencynumber
            */

            /**
            * Constructs a new LevelReq.
            * @memberof gaiaProto
            * @classdesc Represents a LevelReq.
            * @implements ILevelReq
            * @constructor
            * @param {gaiaProto.ILevelReq=} [properties] Properties to set
            */
            function LevelReq(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * LevelReq aid.
            * @member {number} aid
            * @memberof gaiaProto.LevelReq
            * @instance
            */


            LevelReq.prototype.aid = 0;
            /**
            * LevelReq token.
            * @member {string} token
            * @memberof gaiaProto.LevelReq
            * @instance
            */

            LevelReq.prototype.token = "";
            /**
            * LevelReq currencynumber.
            * @member {number} currencynumber
            * @memberof gaiaProto.LevelReq
            * @instance
            */

            LevelReq.prototype.currencynumber = 0;
            /**
            * Creates a new LevelReq instance using the specified properties.
            * @function create
            * @memberof gaiaProto.LevelReq
            * @static
            * @param {gaiaProto.ILevelReq=} [properties] Properties to set
            * @returns {gaiaProto.LevelReq} LevelReq instance
            */

            LevelReq.create = function create(properties) {
              return new LevelReq(properties);
            };
            /**
            * Encodes the specified LevelReq message. Does not implicitly {@link gaiaProto.LevelReq.verify|verify} messages.
            * @function encode
            * @memberof gaiaProto.LevelReq
            * @static
            * @param {gaiaProto.ILevelReq} message LevelReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            LevelReq.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.aid != null && Object.hasOwnProperty.call(message, "aid")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.aid);
              if (message.token != null && Object.hasOwnProperty.call(message, "token")) writer.uint32(
              /* id 2, wireType 2 =*/
              18).string(message.token);
              if (message.currencynumber != null && Object.hasOwnProperty.call(message, "currencynumber")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.currencynumber);
              return writer;
            };
            /**
            * Encodes the specified LevelReq message, length delimited. Does not implicitly {@link gaiaProto.LevelReq.verify|verify} messages.
            * @function encodeDelimited
            * @memberof gaiaProto.LevelReq
            * @static
            * @param {gaiaProto.ILevelReq} message LevelReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            LevelReq.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a LevelReq message from the specified reader or buffer.
            * @function decode
            * @memberof gaiaProto.LevelReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {gaiaProto.LevelReq} LevelReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            LevelReq.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gaiaProto.LevelReq();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.aid = reader.int32();
                    break;

                  case 2:
                    message.token = reader.string();
                    break;

                  case 3:
                    message.currencynumber = reader.int32();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a LevelReq message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof gaiaProto.LevelReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {gaiaProto.LevelReq} LevelReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            LevelReq.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a LevelReq message.
            * @function verify
            * @memberof gaiaProto.LevelReq
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            LevelReq.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.aid != null && message.hasOwnProperty("aid")) if (!$util.isInteger(message.aid)) return "aid: integer expected";
              if (message.token != null && message.hasOwnProperty("token")) if (!$util.isString(message.token)) return "token: string expected";
              if (message.currencynumber != null && message.hasOwnProperty("currencynumber")) if (!$util.isInteger(message.currencynumber)) return "currencynumber: integer expected";
              return null;
            };
            /**
            * Creates a LevelReq message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof gaiaProto.LevelReq
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {gaiaProto.LevelReq} LevelReq
            */


            LevelReq.fromObject = function fromObject(object) {
              if (object instanceof $root.gaiaProto.LevelReq) return object;
              var message = new $root.gaiaProto.LevelReq();
              if (object.aid != null) message.aid = object.aid | 0;
              if (object.token != null) message.token = String(object.token);
              if (object.currencynumber != null) message.currencynumber = object.currencynumber | 0;
              return message;
            };
            /**
            * Creates a plain object from a LevelReq message. Also converts values to other types if specified.
            * @function toObject
            * @memberof gaiaProto.LevelReq
            * @static
            * @param {gaiaProto.LevelReq} message LevelReq
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            LevelReq.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.aid = 0;
                object.token = "";
                object.currencynumber = 0;
              }

              if (message.aid != null && message.hasOwnProperty("aid")) object.aid = message.aid;
              if (message.token != null && message.hasOwnProperty("token")) object.token = message.token;
              if (message.currencynumber != null && message.hasOwnProperty("currencynumber")) object.currencynumber = message.currencynumber;
              return object;
            };
            /**
            * Converts this LevelReq to JSON.
            * @function toJSON
            * @memberof gaiaProto.LevelReq
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            LevelReq.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return LevelReq;
          }();

          gaiaProto.BuffBackReq = function () {
            /**
            * Properties of a BuffBackReq.
            * @memberof gaiaProto
            * @interface IBuffBackReq
            * @property {number|null} [aid] BuffBackReq aid
            * @property {string|null} [token] BuffBackReq token
            * @property {number|null} [apiid] BuffBackReq apiid
            * @property {number|null} [lang] BuffBackReq lang
            */

            /**
            * Constructs a new BuffBackReq.
            * @memberof gaiaProto
            * @classdesc Represents a BuffBackReq.
            * @implements IBuffBackReq
            * @constructor
            * @param {gaiaProto.IBuffBackReq=} [properties] Properties to set
            */
            function BuffBackReq(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * BuffBackReq aid.
            * @member {number} aid
            * @memberof gaiaProto.BuffBackReq
            * @instance
            */


            BuffBackReq.prototype.aid = 0;
            /**
            * BuffBackReq token.
            * @member {string} token
            * @memberof gaiaProto.BuffBackReq
            * @instance
            */

            BuffBackReq.prototype.token = "";
            /**
            * BuffBackReq apiid.
            * @member {number} apiid
            * @memberof gaiaProto.BuffBackReq
            * @instance
            */

            BuffBackReq.prototype.apiid = 0;
            /**
            * BuffBackReq lang.
            * @member {number} lang
            * @memberof gaiaProto.BuffBackReq
            * @instance
            */

            BuffBackReq.prototype.lang = 0;
            /**
            * Creates a new BuffBackReq instance using the specified properties.
            * @function create
            * @memberof gaiaProto.BuffBackReq
            * @static
            * @param {gaiaProto.IBuffBackReq=} [properties] Properties to set
            * @returns {gaiaProto.BuffBackReq} BuffBackReq instance
            */

            BuffBackReq.create = function create(properties) {
              return new BuffBackReq(properties);
            };
            /**
            * Encodes the specified BuffBackReq message. Does not implicitly {@link gaiaProto.BuffBackReq.verify|verify} messages.
            * @function encode
            * @memberof gaiaProto.BuffBackReq
            * @static
            * @param {gaiaProto.IBuffBackReq} message BuffBackReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            BuffBackReq.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.aid != null && Object.hasOwnProperty.call(message, "aid")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.aid);
              if (message.token != null && Object.hasOwnProperty.call(message, "token")) writer.uint32(
              /* id 2, wireType 2 =*/
              18).string(message.token);
              if (message.apiid != null && Object.hasOwnProperty.call(message, "apiid")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.apiid);
              if (message.lang != null && Object.hasOwnProperty.call(message, "lang")) writer.uint32(
              /* id 4, wireType 0 =*/
              32).int32(message.lang);
              return writer;
            };
            /**
            * Encodes the specified BuffBackReq message, length delimited. Does not implicitly {@link gaiaProto.BuffBackReq.verify|verify} messages.
            * @function encodeDelimited
            * @memberof gaiaProto.BuffBackReq
            * @static
            * @param {gaiaProto.IBuffBackReq} message BuffBackReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            BuffBackReq.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a BuffBackReq message from the specified reader or buffer.
            * @function decode
            * @memberof gaiaProto.BuffBackReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {gaiaProto.BuffBackReq} BuffBackReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            BuffBackReq.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gaiaProto.BuffBackReq();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.aid = reader.int32();
                    break;

                  case 2:
                    message.token = reader.string();
                    break;

                  case 3:
                    message.apiid = reader.int32();
                    break;

                  case 4:
                    message.lang = reader.int32();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a BuffBackReq message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof gaiaProto.BuffBackReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {gaiaProto.BuffBackReq} BuffBackReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            BuffBackReq.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a BuffBackReq message.
            * @function verify
            * @memberof gaiaProto.BuffBackReq
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            BuffBackReq.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.aid != null && message.hasOwnProperty("aid")) if (!$util.isInteger(message.aid)) return "aid: integer expected";
              if (message.token != null && message.hasOwnProperty("token")) if (!$util.isString(message.token)) return "token: string expected";
              if (message.apiid != null && message.hasOwnProperty("apiid")) if (!$util.isInteger(message.apiid)) return "apiid: integer expected";
              if (message.lang != null && message.hasOwnProperty("lang")) if (!$util.isInteger(message.lang)) return "lang: integer expected";
              return null;
            };
            /**
            * Creates a BuffBackReq message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof gaiaProto.BuffBackReq
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {gaiaProto.BuffBackReq} BuffBackReq
            */


            BuffBackReq.fromObject = function fromObject(object) {
              if (object instanceof $root.gaiaProto.BuffBackReq) return object;
              var message = new $root.gaiaProto.BuffBackReq();
              if (object.aid != null) message.aid = object.aid | 0;
              if (object.token != null) message.token = String(object.token);
              if (object.apiid != null) message.apiid = object.apiid | 0;
              if (object.lang != null) message.lang = object.lang | 0;
              return message;
            };
            /**
            * Creates a plain object from a BuffBackReq message. Also converts values to other types if specified.
            * @function toObject
            * @memberof gaiaProto.BuffBackReq
            * @static
            * @param {gaiaProto.BuffBackReq} message BuffBackReq
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            BuffBackReq.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.aid = 0;
                object.token = "";
                object.apiid = 0;
                object.lang = 0;
              }

              if (message.aid != null && message.hasOwnProperty("aid")) object.aid = message.aid;
              if (message.token != null && message.hasOwnProperty("token")) object.token = message.token;
              if (message.apiid != null && message.hasOwnProperty("apiid")) object.apiid = message.apiid;
              if (message.lang != null && message.hasOwnProperty("lang")) object.lang = message.lang;
              return object;
            };
            /**
            * Converts this BuffBackReq to JSON.
            * @function toJSON
            * @memberof gaiaProto.BuffBackReq
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            BuffBackReq.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BuffBackReq;
          }();

          gaiaProto.BuffNowReq = function () {
            /**
            * Properties of a BuffNowReq.
            * @memberof gaiaProto
            * @interface IBuffNowReq
            * @property {number|null} [aid] BuffNowReq aid
            * @property {string|null} [token] BuffNowReq token
            * @property {number|null} [apiid] BuffNowReq apiid
            * @property {number|null} [gameid] BuffNowReq gameid
            */

            /**
            * Constructs a new BuffNowReq.
            * @memberof gaiaProto
            * @classdesc Represents a BuffNowReq.
            * @implements IBuffNowReq
            * @constructor
            * @param {gaiaProto.IBuffNowReq=} [properties] Properties to set
            */
            function BuffNowReq(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * BuffNowReq aid.
            * @member {number} aid
            * @memberof gaiaProto.BuffNowReq
            * @instance
            */


            BuffNowReq.prototype.aid = 0;
            /**
            * BuffNowReq token.
            * @member {string} token
            * @memberof gaiaProto.BuffNowReq
            * @instance
            */

            BuffNowReq.prototype.token = "";
            /**
            * BuffNowReq apiid.
            * @member {number} apiid
            * @memberof gaiaProto.BuffNowReq
            * @instance
            */

            BuffNowReq.prototype.apiid = 0;
            /**
            * BuffNowReq gameid.
            * @member {number} gameid
            * @memberof gaiaProto.BuffNowReq
            * @instance
            */

            BuffNowReq.prototype.gameid = 0;
            /**
            * Creates a new BuffNowReq instance using the specified properties.
            * @function create
            * @memberof gaiaProto.BuffNowReq
            * @static
            * @param {gaiaProto.IBuffNowReq=} [properties] Properties to set
            * @returns {gaiaProto.BuffNowReq} BuffNowReq instance
            */

            BuffNowReq.create = function create(properties) {
              return new BuffNowReq(properties);
            };
            /**
            * Encodes the specified BuffNowReq message. Does not implicitly {@link gaiaProto.BuffNowReq.verify|verify} messages.
            * @function encode
            * @memberof gaiaProto.BuffNowReq
            * @static
            * @param {gaiaProto.IBuffNowReq} message BuffNowReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            BuffNowReq.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.aid != null && Object.hasOwnProperty.call(message, "aid")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.aid);
              if (message.token != null && Object.hasOwnProperty.call(message, "token")) writer.uint32(
              /* id 2, wireType 2 =*/
              18).string(message.token);
              if (message.apiid != null && Object.hasOwnProperty.call(message, "apiid")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.apiid);
              if (message.gameid != null && Object.hasOwnProperty.call(message, "gameid")) writer.uint32(
              /* id 4, wireType 0 =*/
              32).int32(message.gameid);
              return writer;
            };
            /**
            * Encodes the specified BuffNowReq message, length delimited. Does not implicitly {@link gaiaProto.BuffNowReq.verify|verify} messages.
            * @function encodeDelimited
            * @memberof gaiaProto.BuffNowReq
            * @static
            * @param {gaiaProto.IBuffNowReq} message BuffNowReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            BuffNowReq.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a BuffNowReq message from the specified reader or buffer.
            * @function decode
            * @memberof gaiaProto.BuffNowReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {gaiaProto.BuffNowReq} BuffNowReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            BuffNowReq.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gaiaProto.BuffNowReq();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.aid = reader.int32();
                    break;

                  case 2:
                    message.token = reader.string();
                    break;

                  case 3:
                    message.apiid = reader.int32();
                    break;

                  case 4:
                    message.gameid = reader.int32();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a BuffNowReq message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof gaiaProto.BuffNowReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {gaiaProto.BuffNowReq} BuffNowReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            BuffNowReq.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a BuffNowReq message.
            * @function verify
            * @memberof gaiaProto.BuffNowReq
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            BuffNowReq.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.aid != null && message.hasOwnProperty("aid")) if (!$util.isInteger(message.aid)) return "aid: integer expected";
              if (message.token != null && message.hasOwnProperty("token")) if (!$util.isString(message.token)) return "token: string expected";
              if (message.apiid != null && message.hasOwnProperty("apiid")) if (!$util.isInteger(message.apiid)) return "apiid: integer expected";
              if (message.gameid != null && message.hasOwnProperty("gameid")) if (!$util.isInteger(message.gameid)) return "gameid: integer expected";
              return null;
            };
            /**
            * Creates a BuffNowReq message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof gaiaProto.BuffNowReq
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {gaiaProto.BuffNowReq} BuffNowReq
            */


            BuffNowReq.fromObject = function fromObject(object) {
              if (object instanceof $root.gaiaProto.BuffNowReq) return object;
              var message = new $root.gaiaProto.BuffNowReq();
              if (object.aid != null) message.aid = object.aid | 0;
              if (object.token != null) message.token = String(object.token);
              if (object.apiid != null) message.apiid = object.apiid | 0;
              if (object.gameid != null) message.gameid = object.gameid | 0;
              return message;
            };
            /**
            * Creates a plain object from a BuffNowReq message. Also converts values to other types if specified.
            * @function toObject
            * @memberof gaiaProto.BuffNowReq
            * @static
            * @param {gaiaProto.BuffNowReq} message BuffNowReq
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            BuffNowReq.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.aid = 0;
                object.token = "";
                object.apiid = 0;
                object.gameid = 0;
              }

              if (message.aid != null && message.hasOwnProperty("aid")) object.aid = message.aid;
              if (message.token != null && message.hasOwnProperty("token")) object.token = message.token;
              if (message.apiid != null && message.hasOwnProperty("apiid")) object.apiid = message.apiid;
              if (message.gameid != null && message.hasOwnProperty("gameid")) object.gameid = message.gameid;
              return object;
            };
            /**
            * Converts this BuffNowReq to JSON.
            * @function toJSON
            * @memberof gaiaProto.BuffNowReq
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            BuffNowReq.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BuffNowReq;
          }();

          gaiaProto.BuffUseReq = function () {
            /**
            * Properties of a BuffUseReq.
            * @memberof gaiaProto
            * @interface IBuffUseReq
            * @property {number|null} [aid] BuffUseReq aid
            * @property {string|null} [token] BuffUseReq token
            * @property {number|null} [apiid] BuffUseReq apiid
            * @property {number|null} [gameid] BuffUseReq gameid
            * @property {Long|null} [buffidx] BuffUseReq buffidx
            * @property {Long|null} [buffid] BuffUseReq buffid
            * @property {number|null} [currency] BuffUseReq currency
            */

            /**
            * Constructs a new BuffUseReq.
            * @memberof gaiaProto
            * @classdesc Represents a BuffUseReq.
            * @implements IBuffUseReq
            * @constructor
            * @param {gaiaProto.IBuffUseReq=} [properties] Properties to set
            */
            function BuffUseReq(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * BuffUseReq aid.
            * @member {number} aid
            * @memberof gaiaProto.BuffUseReq
            * @instance
            */


            BuffUseReq.prototype.aid = 0;
            /**
            * BuffUseReq token.
            * @member {string} token
            * @memberof gaiaProto.BuffUseReq
            * @instance
            */

            BuffUseReq.prototype.token = "";
            /**
            * BuffUseReq apiid.
            * @member {number} apiid
            * @memberof gaiaProto.BuffUseReq
            * @instance
            */

            BuffUseReq.prototype.apiid = 0;
            /**
            * BuffUseReq gameid.
            * @member {number} gameid
            * @memberof gaiaProto.BuffUseReq
            * @instance
            */

            BuffUseReq.prototype.gameid = 0;
            /**
            * BuffUseReq buffidx.
            * @member {Long} buffidx
            * @memberof gaiaProto.BuffUseReq
            * @instance
            */

            BuffUseReq.prototype.buffidx = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
            * BuffUseReq buffid.
            * @member {Long} buffid
            * @memberof gaiaProto.BuffUseReq
            * @instance
            */

            BuffUseReq.prototype.buffid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
            * BuffUseReq currency.
            * @member {number} currency
            * @memberof gaiaProto.BuffUseReq
            * @instance
            */

            BuffUseReq.prototype.currency = 0;
            /**
            * Creates a new BuffUseReq instance using the specified properties.
            * @function create
            * @memberof gaiaProto.BuffUseReq
            * @static
            * @param {gaiaProto.IBuffUseReq=} [properties] Properties to set
            * @returns {gaiaProto.BuffUseReq} BuffUseReq instance
            */

            BuffUseReq.create = function create(properties) {
              return new BuffUseReq(properties);
            };
            /**
            * Encodes the specified BuffUseReq message. Does not implicitly {@link gaiaProto.BuffUseReq.verify|verify} messages.
            * @function encode
            * @memberof gaiaProto.BuffUseReq
            * @static
            * @param {gaiaProto.IBuffUseReq} message BuffUseReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            BuffUseReq.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.aid != null && Object.hasOwnProperty.call(message, "aid")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.aid);
              if (message.token != null && Object.hasOwnProperty.call(message, "token")) writer.uint32(
              /* id 2, wireType 2 =*/
              18).string(message.token);
              if (message.apiid != null && Object.hasOwnProperty.call(message, "apiid")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.apiid);
              if (message.gameid != null && Object.hasOwnProperty.call(message, "gameid")) writer.uint32(
              /* id 4, wireType 0 =*/
              32).int32(message.gameid);
              if (message.buffidx != null && Object.hasOwnProperty.call(message, "buffidx")) writer.uint32(
              /* id 5, wireType 0 =*/
              40).int64(message.buffidx);
              if (message.buffid != null && Object.hasOwnProperty.call(message, "buffid")) writer.uint32(
              /* id 6, wireType 0 =*/
              48).int64(message.buffid);
              if (message.currency != null && Object.hasOwnProperty.call(message, "currency")) writer.uint32(
              /* id 7, wireType 0 =*/
              56).int32(message.currency);
              return writer;
            };
            /**
            * Encodes the specified BuffUseReq message, length delimited. Does not implicitly {@link gaiaProto.BuffUseReq.verify|verify} messages.
            * @function encodeDelimited
            * @memberof gaiaProto.BuffUseReq
            * @static
            * @param {gaiaProto.IBuffUseReq} message BuffUseReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            BuffUseReq.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a BuffUseReq message from the specified reader or buffer.
            * @function decode
            * @memberof gaiaProto.BuffUseReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {gaiaProto.BuffUseReq} BuffUseReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            BuffUseReq.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gaiaProto.BuffUseReq();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.aid = reader.int32();
                    break;

                  case 2:
                    message.token = reader.string();
                    break;

                  case 3:
                    message.apiid = reader.int32();
                    break;

                  case 4:
                    message.gameid = reader.int32();
                    break;

                  case 5:
                    message.buffidx = reader.int64();
                    break;

                  case 6:
                    message.buffid = reader.int64();
                    break;

                  case 7:
                    message.currency = reader.int32();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a BuffUseReq message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof gaiaProto.BuffUseReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {gaiaProto.BuffUseReq} BuffUseReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            BuffUseReq.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a BuffUseReq message.
            * @function verify
            * @memberof gaiaProto.BuffUseReq
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            BuffUseReq.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.aid != null && message.hasOwnProperty("aid")) if (!$util.isInteger(message.aid)) return "aid: integer expected";
              if (message.token != null && message.hasOwnProperty("token")) if (!$util.isString(message.token)) return "token: string expected";
              if (message.apiid != null && message.hasOwnProperty("apiid")) if (!$util.isInteger(message.apiid)) return "apiid: integer expected";
              if (message.gameid != null && message.hasOwnProperty("gameid")) if (!$util.isInteger(message.gameid)) return "gameid: integer expected";
              if (message.buffidx != null && message.hasOwnProperty("buffidx")) if (!$util.isInteger(message.buffidx) && !(message.buffidx && $util.isInteger(message.buffidx.low) && $util.isInteger(message.buffidx.high))) return "buffidx: integer|Long expected";
              if (message.buffid != null && message.hasOwnProperty("buffid")) if (!$util.isInteger(message.buffid) && !(message.buffid && $util.isInteger(message.buffid.low) && $util.isInteger(message.buffid.high))) return "buffid: integer|Long expected";
              if (message.currency != null && message.hasOwnProperty("currency")) if (!$util.isInteger(message.currency)) return "currency: integer expected";
              return null;
            };
            /**
            * Creates a BuffUseReq message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof gaiaProto.BuffUseReq
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {gaiaProto.BuffUseReq} BuffUseReq
            */


            BuffUseReq.fromObject = function fromObject(object) {
              if (object instanceof $root.gaiaProto.BuffUseReq) return object;
              var message = new $root.gaiaProto.BuffUseReq();
              if (object.aid != null) message.aid = object.aid | 0;
              if (object.token != null) message.token = String(object.token);
              if (object.apiid != null) message.apiid = object.apiid | 0;
              if (object.gameid != null) message.gameid = object.gameid | 0;
              if (object.buffidx != null) if ($util.Long) (message.buffidx = $util.Long.fromValue(object.buffidx)).unsigned = false;else if (typeof object.buffidx === "string") message.buffidx = parseInt(object.buffidx, 10);else if (typeof object.buffidx === "number") message.buffidx = object.buffidx;else if (typeof object.buffidx === "object") message.buffidx = new $util.LongBits(object.buffidx.low >>> 0, object.buffidx.high >>> 0).toNumber();
              if (object.buffid != null) if ($util.Long) (message.buffid = $util.Long.fromValue(object.buffid)).unsigned = false;else if (typeof object.buffid === "string") message.buffid = parseInt(object.buffid, 10);else if (typeof object.buffid === "number") message.buffid = object.buffid;else if (typeof object.buffid === "object") message.buffid = new $util.LongBits(object.buffid.low >>> 0, object.buffid.high >>> 0).toNumber();
              if (object.currency != null) message.currency = object.currency | 0;
              return message;
            };
            /**
            * Creates a plain object from a BuffUseReq message. Also converts values to other types if specified.
            * @function toObject
            * @memberof gaiaProto.BuffUseReq
            * @static
            * @param {gaiaProto.BuffUseReq} message BuffUseReq
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            BuffUseReq.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.aid = 0;
                object.token = "";
                object.apiid = 0;
                object.gameid = 0;

                if ($util.Long) {
                  var _long2 = new $util.Long(0, 0, false);

                  object.buffidx = options.longs === String ? _long2.toString() : options.longs === Number ? _long2.toNumber() : _long2;
                } else object.buffidx = options.longs === String ? "0" : 0;

                if ($util.Long) {
                  var _long2 = new $util.Long(0, 0, false);

                  object.buffid = options.longs === String ? _long2.toString() : options.longs === Number ? _long2.toNumber() : _long2;
                } else object.buffid = options.longs === String ? "0" : 0;

                object.currency = 0;
              }

              if (message.aid != null && message.hasOwnProperty("aid")) object.aid = message.aid;
              if (message.token != null && message.hasOwnProperty("token")) object.token = message.token;
              if (message.apiid != null && message.hasOwnProperty("apiid")) object.apiid = message.apiid;
              if (message.gameid != null && message.hasOwnProperty("gameid")) object.gameid = message.gameid;
              if (message.buffidx != null && message.hasOwnProperty("buffidx")) if (typeof message.buffidx === "number") object.buffidx = options.longs === String ? String(message.buffidx) : message.buffidx;else object.buffidx = options.longs === String ? $util.Long.prototype.toString.call(message.buffidx) : options.longs === Number ? new $util.LongBits(message.buffidx.low >>> 0, message.buffidx.high >>> 0).toNumber() : message.buffidx;
              if (message.buffid != null && message.hasOwnProperty("buffid")) if (typeof message.buffid === "number") object.buffid = options.longs === String ? String(message.buffid) : message.buffid;else object.buffid = options.longs === String ? $util.Long.prototype.toString.call(message.buffid) : options.longs === Number ? new $util.LongBits(message.buffid.low >>> 0, message.buffid.high >>> 0).toNumber() : message.buffid;
              if (message.currency != null && message.hasOwnProperty("currency")) object.currency = message.currency;
              return object;
            };
            /**
            * Converts this BuffUseReq to JSON.
            * @function toJSON
            * @memberof gaiaProto.BuffUseReq
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            BuffUseReq.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BuffUseReq;
          }();

          gaiaProto.BuffParamReq = function () {
            /**
            * Properties of a BuffParamReq.
            * @memberof gaiaProto
            * @interface IBuffParamReq
            * @property {number|null} [aid] BuffParamReq aid
            * @property {string|null} [token] BuffParamReq token
            * @property {Array.<Long>|null} [idlist] BuffParamReq idlist
            */

            /**
            * Constructs a new BuffParamReq.
            * @memberof gaiaProto
            * @classdesc Represents a BuffParamReq.
            * @implements IBuffParamReq
            * @constructor
            * @param {gaiaProto.IBuffParamReq=} [properties] Properties to set
            */
            function BuffParamReq(properties) {
              this.idlist = [];
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * BuffParamReq aid.
            * @member {number} aid
            * @memberof gaiaProto.BuffParamReq
            * @instance
            */


            BuffParamReq.prototype.aid = 0;
            /**
            * BuffParamReq token.
            * @member {string} token
            * @memberof gaiaProto.BuffParamReq
            * @instance
            */

            BuffParamReq.prototype.token = "";
            /**
            * BuffParamReq idlist.
            * @member {Array.<Long>} idlist
            * @memberof gaiaProto.BuffParamReq
            * @instance
            */

            BuffParamReq.prototype.idlist = $util.emptyArray;
            /**
            * Creates a new BuffParamReq instance using the specified properties.
            * @function create
            * @memberof gaiaProto.BuffParamReq
            * @static
            * @param {gaiaProto.IBuffParamReq=} [properties] Properties to set
            * @returns {gaiaProto.BuffParamReq} BuffParamReq instance
            */

            BuffParamReq.create = function create(properties) {
              return new BuffParamReq(properties);
            };
            /**
            * Encodes the specified BuffParamReq message. Does not implicitly {@link gaiaProto.BuffParamReq.verify|verify} messages.
            * @function encode
            * @memberof gaiaProto.BuffParamReq
            * @static
            * @param {gaiaProto.IBuffParamReq} message BuffParamReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            BuffParamReq.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.aid != null && Object.hasOwnProperty.call(message, "aid")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.aid);
              if (message.token != null && Object.hasOwnProperty.call(message, "token")) writer.uint32(
              /* id 2, wireType 2 =*/
              18).string(message.token);

              if (message.idlist != null && message.idlist.length) {
                writer.uint32(
                /* id 3, wireType 2 =*/
                26).fork();

                for (var i = 0; i < message.idlist.length; ++i) {
                  writer.int64(message.idlist[i]);
                }

                writer.ldelim();
              }

              return writer;
            };
            /**
            * Encodes the specified BuffParamReq message, length delimited. Does not implicitly {@link gaiaProto.BuffParamReq.verify|verify} messages.
            * @function encodeDelimited
            * @memberof gaiaProto.BuffParamReq
            * @static
            * @param {gaiaProto.IBuffParamReq} message BuffParamReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            BuffParamReq.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a BuffParamReq message from the specified reader or buffer.
            * @function decode
            * @memberof gaiaProto.BuffParamReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {gaiaProto.BuffParamReq} BuffParamReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            BuffParamReq.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gaiaProto.BuffParamReq();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.aid = reader.int32();
                    break;

                  case 2:
                    message.token = reader.string();
                    break;

                  case 3:
                    if (!(message.idlist && message.idlist.length)) message.idlist = [];

                    if ((tag & 7) === 2) {
                      var end2 = reader.uint32() + reader.pos;

                      while (reader.pos < end2) {
                        message.idlist.push(reader.int64());
                      }
                    } else message.idlist.push(reader.int64());

                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a BuffParamReq message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof gaiaProto.BuffParamReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {gaiaProto.BuffParamReq} BuffParamReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            BuffParamReq.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a BuffParamReq message.
            * @function verify
            * @memberof gaiaProto.BuffParamReq
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            BuffParamReq.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.aid != null && message.hasOwnProperty("aid")) if (!$util.isInteger(message.aid)) return "aid: integer expected";
              if (message.token != null && message.hasOwnProperty("token")) if (!$util.isString(message.token)) return "token: string expected";

              if (message.idlist != null && message.hasOwnProperty("idlist")) {
                if (!Array.isArray(message.idlist)) return "idlist: array expected";

                for (var i = 0; i < message.idlist.length; ++i) {
                  if (!$util.isInteger(message.idlist[i]) && !(message.idlist[i] && $util.isInteger(message.idlist[i].low) && $util.isInteger(message.idlist[i].high))) return "idlist: integer|Long[] expected";
                }
              }

              return null;
            };
            /**
            * Creates a BuffParamReq message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof gaiaProto.BuffParamReq
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {gaiaProto.BuffParamReq} BuffParamReq
            */


            BuffParamReq.fromObject = function fromObject(object) {
              if (object instanceof $root.gaiaProto.BuffParamReq) return object;
              var message = new $root.gaiaProto.BuffParamReq();
              if (object.aid != null) message.aid = object.aid | 0;
              if (object.token != null) message.token = String(object.token);

              if (object.idlist) {
                if (!Array.isArray(object.idlist)) throw TypeError(".gaiaProto.BuffParamReq.idlist: array expected");
                message.idlist = [];

                for (var i = 0; i < object.idlist.length; ++i) {
                  if ($util.Long) (message.idlist[i] = $util.Long.fromValue(object.idlist[i])).unsigned = false;else if (typeof object.idlist[i] === "string") message.idlist[i] = parseInt(object.idlist[i], 10);else if (typeof object.idlist[i] === "number") message.idlist[i] = object.idlist[i];else if (typeof object.idlist[i] === "object") message.idlist[i] = new $util.LongBits(object.idlist[i].low >>> 0, object.idlist[i].high >>> 0).toNumber();
                }
              }

              return message;
            };
            /**
            * Creates a plain object from a BuffParamReq message. Also converts values to other types if specified.
            * @function toObject
            * @memberof gaiaProto.BuffParamReq
            * @static
            * @param {gaiaProto.BuffParamReq} message BuffParamReq
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            BuffParamReq.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};
              if (options.arrays || options.defaults) object.idlist = [];

              if (options.defaults) {
                object.aid = 0;
                object.token = "";
              }

              if (message.aid != null && message.hasOwnProperty("aid")) object.aid = message.aid;
              if (message.token != null && message.hasOwnProperty("token")) object.token = message.token;

              if (message.idlist && message.idlist.length) {
                object.idlist = [];

                for (var j = 0; j < message.idlist.length; ++j) {
                  if (typeof message.idlist[j] === "number") object.idlist[j] = options.longs === String ? String(message.idlist[j]) : message.idlist[j];else object.idlist[j] = options.longs === String ? $util.Long.prototype.toString.call(message.idlist[j]) : options.longs === Number ? new $util.LongBits(message.idlist[j].low >>> 0, message.idlist[j].high >>> 0).toNumber() : message.idlist[j];
                }
              }

              return object;
            };
            /**
            * Converts this BuffParamReq to JSON.
            * @function toJSON
            * @memberof gaiaProto.BuffParamReq
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            BuffParamReq.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BuffParamReq;
          }();

          gaiaProto.VerifyGiftCodeReq = function () {
            /**
            * Properties of a VerifyGiftCodeReq.
            * @memberof gaiaProto
            * @interface IVerifyGiftCodeReq
            * @property {number|null} [aid] VerifyGiftCodeReq aid
            * @property {string|null} [token] VerifyGiftCodeReq token
            * @property {number|null} [apiid] VerifyGiftCodeReq apiid
            * @property {string|null} [giftcode] VerifyGiftCodeReq giftcode
            */

            /**
            * Constructs a new VerifyGiftCodeReq.
            * @memberof gaiaProto
            * @classdesc Represents a VerifyGiftCodeReq.
            * @implements IVerifyGiftCodeReq
            * @constructor
            * @param {gaiaProto.IVerifyGiftCodeReq=} [properties] Properties to set
            */
            function VerifyGiftCodeReq(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * VerifyGiftCodeReq aid.
            * @member {number} aid
            * @memberof gaiaProto.VerifyGiftCodeReq
            * @instance
            */


            VerifyGiftCodeReq.prototype.aid = 0;
            /**
            * VerifyGiftCodeReq token.
            * @member {string} token
            * @memberof gaiaProto.VerifyGiftCodeReq
            * @instance
            */

            VerifyGiftCodeReq.prototype.token = "";
            /**
            * VerifyGiftCodeReq apiid.
            * @member {number} apiid
            * @memberof gaiaProto.VerifyGiftCodeReq
            * @instance
            */

            VerifyGiftCodeReq.prototype.apiid = 0;
            /**
            * VerifyGiftCodeReq giftcode.
            * @member {string} giftcode
            * @memberof gaiaProto.VerifyGiftCodeReq
            * @instance
            */

            VerifyGiftCodeReq.prototype.giftcode = "";
            /**
            * Creates a new VerifyGiftCodeReq instance using the specified properties.
            * @function create
            * @memberof gaiaProto.VerifyGiftCodeReq
            * @static
            * @param {gaiaProto.IVerifyGiftCodeReq=} [properties] Properties to set
            * @returns {gaiaProto.VerifyGiftCodeReq} VerifyGiftCodeReq instance
            */

            VerifyGiftCodeReq.create = function create(properties) {
              return new VerifyGiftCodeReq(properties);
            };
            /**
            * Encodes the specified VerifyGiftCodeReq message. Does not implicitly {@link gaiaProto.VerifyGiftCodeReq.verify|verify} messages.
            * @function encode
            * @memberof gaiaProto.VerifyGiftCodeReq
            * @static
            * @param {gaiaProto.IVerifyGiftCodeReq} message VerifyGiftCodeReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            VerifyGiftCodeReq.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.aid != null && Object.hasOwnProperty.call(message, "aid")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.aid);
              if (message.token != null && Object.hasOwnProperty.call(message, "token")) writer.uint32(
              /* id 2, wireType 2 =*/
              18).string(message.token);
              if (message.apiid != null && Object.hasOwnProperty.call(message, "apiid")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.apiid);
              if (message.giftcode != null && Object.hasOwnProperty.call(message, "giftcode")) writer.uint32(
              /* id 4, wireType 2 =*/
              34).string(message.giftcode);
              return writer;
            };
            /**
            * Encodes the specified VerifyGiftCodeReq message, length delimited. Does not implicitly {@link gaiaProto.VerifyGiftCodeReq.verify|verify} messages.
            * @function encodeDelimited
            * @memberof gaiaProto.VerifyGiftCodeReq
            * @static
            * @param {gaiaProto.IVerifyGiftCodeReq} message VerifyGiftCodeReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            VerifyGiftCodeReq.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a VerifyGiftCodeReq message from the specified reader or buffer.
            * @function decode
            * @memberof gaiaProto.VerifyGiftCodeReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {gaiaProto.VerifyGiftCodeReq} VerifyGiftCodeReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            VerifyGiftCodeReq.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gaiaProto.VerifyGiftCodeReq();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.aid = reader.int32();
                    break;

                  case 2:
                    message.token = reader.string();
                    break;

                  case 3:
                    message.apiid = reader.int32();
                    break;

                  case 4:
                    message.giftcode = reader.string();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a VerifyGiftCodeReq message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof gaiaProto.VerifyGiftCodeReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {gaiaProto.VerifyGiftCodeReq} VerifyGiftCodeReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            VerifyGiftCodeReq.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a VerifyGiftCodeReq message.
            * @function verify
            * @memberof gaiaProto.VerifyGiftCodeReq
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            VerifyGiftCodeReq.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.aid != null && message.hasOwnProperty("aid")) if (!$util.isInteger(message.aid)) return "aid: integer expected";
              if (message.token != null && message.hasOwnProperty("token")) if (!$util.isString(message.token)) return "token: string expected";
              if (message.apiid != null && message.hasOwnProperty("apiid")) if (!$util.isInteger(message.apiid)) return "apiid: integer expected";
              if (message.giftcode != null && message.hasOwnProperty("giftcode")) if (!$util.isString(message.giftcode)) return "giftcode: string expected";
              return null;
            };
            /**
            * Creates a VerifyGiftCodeReq message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof gaiaProto.VerifyGiftCodeReq
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {gaiaProto.VerifyGiftCodeReq} VerifyGiftCodeReq
            */


            VerifyGiftCodeReq.fromObject = function fromObject(object) {
              if (object instanceof $root.gaiaProto.VerifyGiftCodeReq) return object;
              var message = new $root.gaiaProto.VerifyGiftCodeReq();
              if (object.aid != null) message.aid = object.aid | 0;
              if (object.token != null) message.token = String(object.token);
              if (object.apiid != null) message.apiid = object.apiid | 0;
              if (object.giftcode != null) message.giftcode = String(object.giftcode);
              return message;
            };
            /**
            * Creates a plain object from a VerifyGiftCodeReq message. Also converts values to other types if specified.
            * @function toObject
            * @memberof gaiaProto.VerifyGiftCodeReq
            * @static
            * @param {gaiaProto.VerifyGiftCodeReq} message VerifyGiftCodeReq
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            VerifyGiftCodeReq.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.aid = 0;
                object.token = "";
                object.apiid = 0;
                object.giftcode = "";
              }

              if (message.aid != null && message.hasOwnProperty("aid")) object.aid = message.aid;
              if (message.token != null && message.hasOwnProperty("token")) object.token = message.token;
              if (message.apiid != null && message.hasOwnProperty("apiid")) object.apiid = message.apiid;
              if (message.giftcode != null && message.hasOwnProperty("giftcode")) object.giftcode = message.giftcode;
              return object;
            };
            /**
            * Converts this VerifyGiftCodeReq to JSON.
            * @function toJSON
            * @memberof gaiaProto.VerifyGiftCodeReq
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            VerifyGiftCodeReq.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return VerifyGiftCodeReq;
          }();

          gaiaProto.CheckBlockGiftCodeReq = function () {
            /**
            * Properties of a CheckBlockGiftCodeReq.
            * @memberof gaiaProto
            * @interface ICheckBlockGiftCodeReq
            * @property {number|null} [aid] CheckBlockGiftCodeReq aid
            * @property {string|null} [token] CheckBlockGiftCodeReq token
            */

            /**
            * Constructs a new CheckBlockGiftCodeReq.
            * @memberof gaiaProto
            * @classdesc Represents a CheckBlockGiftCodeReq.
            * @implements ICheckBlockGiftCodeReq
            * @constructor
            * @param {gaiaProto.ICheckBlockGiftCodeReq=} [properties] Properties to set
            */
            function CheckBlockGiftCodeReq(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * CheckBlockGiftCodeReq aid.
            * @member {number} aid
            * @memberof gaiaProto.CheckBlockGiftCodeReq
            * @instance
            */


            CheckBlockGiftCodeReq.prototype.aid = 0;
            /**
            * CheckBlockGiftCodeReq token.
            * @member {string} token
            * @memberof gaiaProto.CheckBlockGiftCodeReq
            * @instance
            */

            CheckBlockGiftCodeReq.prototype.token = "";
            /**
            * Creates a new CheckBlockGiftCodeReq instance using the specified properties.
            * @function create
            * @memberof gaiaProto.CheckBlockGiftCodeReq
            * @static
            * @param {gaiaProto.ICheckBlockGiftCodeReq=} [properties] Properties to set
            * @returns {gaiaProto.CheckBlockGiftCodeReq} CheckBlockGiftCodeReq instance
            */

            CheckBlockGiftCodeReq.create = function create(properties) {
              return new CheckBlockGiftCodeReq(properties);
            };
            /**
            * Encodes the specified CheckBlockGiftCodeReq message. Does not implicitly {@link gaiaProto.CheckBlockGiftCodeReq.verify|verify} messages.
            * @function encode
            * @memberof gaiaProto.CheckBlockGiftCodeReq
            * @static
            * @param {gaiaProto.ICheckBlockGiftCodeReq} message CheckBlockGiftCodeReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            CheckBlockGiftCodeReq.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.aid != null && Object.hasOwnProperty.call(message, "aid")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.aid);
              if (message.token != null && Object.hasOwnProperty.call(message, "token")) writer.uint32(
              /* id 2, wireType 2 =*/
              18).string(message.token);
              return writer;
            };
            /**
            * Encodes the specified CheckBlockGiftCodeReq message, length delimited. Does not implicitly {@link gaiaProto.CheckBlockGiftCodeReq.verify|verify} messages.
            * @function encodeDelimited
            * @memberof gaiaProto.CheckBlockGiftCodeReq
            * @static
            * @param {gaiaProto.ICheckBlockGiftCodeReq} message CheckBlockGiftCodeReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            CheckBlockGiftCodeReq.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a CheckBlockGiftCodeReq message from the specified reader or buffer.
            * @function decode
            * @memberof gaiaProto.CheckBlockGiftCodeReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {gaiaProto.CheckBlockGiftCodeReq} CheckBlockGiftCodeReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            CheckBlockGiftCodeReq.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gaiaProto.CheckBlockGiftCodeReq();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.aid = reader.int32();
                    break;

                  case 2:
                    message.token = reader.string();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a CheckBlockGiftCodeReq message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof gaiaProto.CheckBlockGiftCodeReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {gaiaProto.CheckBlockGiftCodeReq} CheckBlockGiftCodeReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            CheckBlockGiftCodeReq.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a CheckBlockGiftCodeReq message.
            * @function verify
            * @memberof gaiaProto.CheckBlockGiftCodeReq
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            CheckBlockGiftCodeReq.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.aid != null && message.hasOwnProperty("aid")) if (!$util.isInteger(message.aid)) return "aid: integer expected";
              if (message.token != null && message.hasOwnProperty("token")) if (!$util.isString(message.token)) return "token: string expected";
              return null;
            };
            /**
            * Creates a CheckBlockGiftCodeReq message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof gaiaProto.CheckBlockGiftCodeReq
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {gaiaProto.CheckBlockGiftCodeReq} CheckBlockGiftCodeReq
            */


            CheckBlockGiftCodeReq.fromObject = function fromObject(object) {
              if (object instanceof $root.gaiaProto.CheckBlockGiftCodeReq) return object;
              var message = new $root.gaiaProto.CheckBlockGiftCodeReq();
              if (object.aid != null) message.aid = object.aid | 0;
              if (object.token != null) message.token = String(object.token);
              return message;
            };
            /**
            * Creates a plain object from a CheckBlockGiftCodeReq message. Also converts values to other types if specified.
            * @function toObject
            * @memberof gaiaProto.CheckBlockGiftCodeReq
            * @static
            * @param {gaiaProto.CheckBlockGiftCodeReq} message CheckBlockGiftCodeReq
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            CheckBlockGiftCodeReq.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.aid = 0;
                object.token = "";
              }

              if (message.aid != null && message.hasOwnProperty("aid")) object.aid = message.aid;
              if (message.token != null && message.hasOwnProperty("token")) object.token = message.token;
              return object;
            };
            /**
            * Converts this CheckBlockGiftCodeReq to JSON.
            * @function toJSON
            * @memberof gaiaProto.CheckBlockGiftCodeReq
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            CheckBlockGiftCodeReq.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CheckBlockGiftCodeReq;
          }();

          gaiaProto.VerifyGiftCodeAck = function () {
            /**
            * Properties of a VerifyGiftCodeAck.
            * @memberof gaiaProto
            * @interface IVerifyGiftCodeAck
            * @property {number|null} [Code] VerifyGiftCodeAck Code
            * @property {number|null} [Type] VerifyGiftCodeAck Type
            * @property {number|null} [Round] VerifyGiftCodeAck Round
            */

            /**
            * Constructs a new VerifyGiftCodeAck.
            * @memberof gaiaProto
            * @classdesc Represents a VerifyGiftCodeAck.
            * @implements IVerifyGiftCodeAck
            * @constructor
            * @param {gaiaProto.IVerifyGiftCodeAck=} [properties] Properties to set
            */
            function VerifyGiftCodeAck(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * VerifyGiftCodeAck Code.
            * @member {number} Code
            * @memberof gaiaProto.VerifyGiftCodeAck
            * @instance
            */


            VerifyGiftCodeAck.prototype.Code = 0;
            /**
            * VerifyGiftCodeAck Type.
            * @member {number} Type
            * @memberof gaiaProto.VerifyGiftCodeAck
            * @instance
            */

            VerifyGiftCodeAck.prototype.Type = 0;
            /**
            * VerifyGiftCodeAck Round.
            * @member {number} Round
            * @memberof gaiaProto.VerifyGiftCodeAck
            * @instance
            */

            VerifyGiftCodeAck.prototype.Round = 0;
            /**
            * Creates a new VerifyGiftCodeAck instance using the specified properties.
            * @function create
            * @memberof gaiaProto.VerifyGiftCodeAck
            * @static
            * @param {gaiaProto.IVerifyGiftCodeAck=} [properties] Properties to set
            * @returns {gaiaProto.VerifyGiftCodeAck} VerifyGiftCodeAck instance
            */

            VerifyGiftCodeAck.create = function create(properties) {
              return new VerifyGiftCodeAck(properties);
            };
            /**
            * Encodes the specified VerifyGiftCodeAck message. Does not implicitly {@link gaiaProto.VerifyGiftCodeAck.verify|verify} messages.
            * @function encode
            * @memberof gaiaProto.VerifyGiftCodeAck
            * @static
            * @param {gaiaProto.IVerifyGiftCodeAck} message VerifyGiftCodeAck message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            VerifyGiftCodeAck.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.Code != null && Object.hasOwnProperty.call(message, "Code")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.Code);
              if (message.Type != null && Object.hasOwnProperty.call(message, "Type")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int32(message.Type);
              if (message.Round != null && Object.hasOwnProperty.call(message, "Round")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.Round);
              return writer;
            };
            /**
            * Encodes the specified VerifyGiftCodeAck message, length delimited. Does not implicitly {@link gaiaProto.VerifyGiftCodeAck.verify|verify} messages.
            * @function encodeDelimited
            * @memberof gaiaProto.VerifyGiftCodeAck
            * @static
            * @param {gaiaProto.IVerifyGiftCodeAck} message VerifyGiftCodeAck message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            VerifyGiftCodeAck.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a VerifyGiftCodeAck message from the specified reader or buffer.
            * @function decode
            * @memberof gaiaProto.VerifyGiftCodeAck
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {gaiaProto.VerifyGiftCodeAck} VerifyGiftCodeAck
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            VerifyGiftCodeAck.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gaiaProto.VerifyGiftCodeAck();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.Code = reader.int32();
                    break;

                  case 2:
                    message.Type = reader.int32();
                    break;

                  case 3:
                    message.Round = reader.int32();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a VerifyGiftCodeAck message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof gaiaProto.VerifyGiftCodeAck
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {gaiaProto.VerifyGiftCodeAck} VerifyGiftCodeAck
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            VerifyGiftCodeAck.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a VerifyGiftCodeAck message.
            * @function verify
            * @memberof gaiaProto.VerifyGiftCodeAck
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            VerifyGiftCodeAck.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.Code != null && message.hasOwnProperty("Code")) if (!$util.isInteger(message.Code)) return "Code: integer expected";
              if (message.Type != null && message.hasOwnProperty("Type")) if (!$util.isInteger(message.Type)) return "Type: integer expected";
              if (message.Round != null && message.hasOwnProperty("Round")) if (!$util.isInteger(message.Round)) return "Round: integer expected";
              return null;
            };
            /**
            * Creates a VerifyGiftCodeAck message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof gaiaProto.VerifyGiftCodeAck
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {gaiaProto.VerifyGiftCodeAck} VerifyGiftCodeAck
            */


            VerifyGiftCodeAck.fromObject = function fromObject(object) {
              if (object instanceof $root.gaiaProto.VerifyGiftCodeAck) return object;
              var message = new $root.gaiaProto.VerifyGiftCodeAck();
              if (object.Code != null) message.Code = object.Code | 0;
              if (object.Type != null) message.Type = object.Type | 0;
              if (object.Round != null) message.Round = object.Round | 0;
              return message;
            };
            /**
            * Creates a plain object from a VerifyGiftCodeAck message. Also converts values to other types if specified.
            * @function toObject
            * @memberof gaiaProto.VerifyGiftCodeAck
            * @static
            * @param {gaiaProto.VerifyGiftCodeAck} message VerifyGiftCodeAck
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            VerifyGiftCodeAck.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.Code = 0;
                object.Type = 0;
                object.Round = 0;
              }

              if (message.Code != null && message.hasOwnProperty("Code")) object.Code = message.Code;
              if (message.Type != null && message.hasOwnProperty("Type")) object.Type = message.Type;
              if (message.Round != null && message.hasOwnProperty("Round")) object.Round = message.Round;
              return object;
            };
            /**
            * Converts this VerifyGiftCodeAck to JSON.
            * @function toJSON
            * @memberof gaiaProto.VerifyGiftCodeAck
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            VerifyGiftCodeAck.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return VerifyGiftCodeAck;
          }();

          gaiaProto.CheckBlockGiftCodeAck = function () {
            /**
            * Properties of a CheckBlockGiftCodeAck.
            * @memberof gaiaProto
            * @interface ICheckBlockGiftCodeAck
            * @property {number|null} [Code] CheckBlockGiftCodeAck Code
            * @property {string|null} [Message] CheckBlockGiftCodeAck Message
            * @property {boolean|null} [IsBlock] CheckBlockGiftCodeAck IsBlock
            * @property {number|null} [BlockDuration] CheckBlockGiftCodeAck BlockDuration
            * @property {number|null} [ErrorInputAmount] CheckBlockGiftCodeAck ErrorInputAmount
            */

            /**
            * Constructs a new CheckBlockGiftCodeAck.
            * @memberof gaiaProto
            * @classdesc Represents a CheckBlockGiftCodeAck.
            * @implements ICheckBlockGiftCodeAck
            * @constructor
            * @param {gaiaProto.ICheckBlockGiftCodeAck=} [properties] Properties to set
            */
            function CheckBlockGiftCodeAck(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * CheckBlockGiftCodeAck Code.
            * @member {number} Code
            * @memberof gaiaProto.CheckBlockGiftCodeAck
            * @instance
            */


            CheckBlockGiftCodeAck.prototype.Code = 0;
            /**
            * CheckBlockGiftCodeAck Message.
            * @member {string} Message
            * @memberof gaiaProto.CheckBlockGiftCodeAck
            * @instance
            */

            CheckBlockGiftCodeAck.prototype.Message = "";
            /**
            * CheckBlockGiftCodeAck IsBlock.
            * @member {boolean} IsBlock
            * @memberof gaiaProto.CheckBlockGiftCodeAck
            * @instance
            */

            CheckBlockGiftCodeAck.prototype.IsBlock = false;
            /**
            * CheckBlockGiftCodeAck BlockDuration.
            * @member {number} BlockDuration
            * @memberof gaiaProto.CheckBlockGiftCodeAck
            * @instance
            */

            CheckBlockGiftCodeAck.prototype.BlockDuration = 0;
            /**
            * CheckBlockGiftCodeAck ErrorInputAmount.
            * @member {number} ErrorInputAmount
            * @memberof gaiaProto.CheckBlockGiftCodeAck
            * @instance
            */

            CheckBlockGiftCodeAck.prototype.ErrorInputAmount = 0;
            /**
            * Creates a new CheckBlockGiftCodeAck instance using the specified properties.
            * @function create
            * @memberof gaiaProto.CheckBlockGiftCodeAck
            * @static
            * @param {gaiaProto.ICheckBlockGiftCodeAck=} [properties] Properties to set
            * @returns {gaiaProto.CheckBlockGiftCodeAck} CheckBlockGiftCodeAck instance
            */

            CheckBlockGiftCodeAck.create = function create(properties) {
              return new CheckBlockGiftCodeAck(properties);
            };
            /**
            * Encodes the specified CheckBlockGiftCodeAck message. Does not implicitly {@link gaiaProto.CheckBlockGiftCodeAck.verify|verify} messages.
            * @function encode
            * @memberof gaiaProto.CheckBlockGiftCodeAck
            * @static
            * @param {gaiaProto.ICheckBlockGiftCodeAck} message CheckBlockGiftCodeAck message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            CheckBlockGiftCodeAck.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.Code != null && Object.hasOwnProperty.call(message, "Code")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.Code);
              if (message.Message != null && Object.hasOwnProperty.call(message, "Message")) writer.uint32(
              /* id 2, wireType 2 =*/
              18).string(message.Message);
              if (message.IsBlock != null && Object.hasOwnProperty.call(message, "IsBlock")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).bool(message.IsBlock);
              if (message.BlockDuration != null && Object.hasOwnProperty.call(message, "BlockDuration")) writer.uint32(
              /* id 4, wireType 0 =*/
              32).int32(message.BlockDuration);
              if (message.ErrorInputAmount != null && Object.hasOwnProperty.call(message, "ErrorInputAmount")) writer.uint32(
              /* id 5, wireType 0 =*/
              40).int32(message.ErrorInputAmount);
              return writer;
            };
            /**
            * Encodes the specified CheckBlockGiftCodeAck message, length delimited. Does not implicitly {@link gaiaProto.CheckBlockGiftCodeAck.verify|verify} messages.
            * @function encodeDelimited
            * @memberof gaiaProto.CheckBlockGiftCodeAck
            * @static
            * @param {gaiaProto.ICheckBlockGiftCodeAck} message CheckBlockGiftCodeAck message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            CheckBlockGiftCodeAck.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a CheckBlockGiftCodeAck message from the specified reader or buffer.
            * @function decode
            * @memberof gaiaProto.CheckBlockGiftCodeAck
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {gaiaProto.CheckBlockGiftCodeAck} CheckBlockGiftCodeAck
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            CheckBlockGiftCodeAck.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gaiaProto.CheckBlockGiftCodeAck();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.Code = reader.int32();
                    break;

                  case 2:
                    message.Message = reader.string();
                    break;

                  case 3:
                    message.IsBlock = reader.bool();
                    break;

                  case 4:
                    message.BlockDuration = reader.int32();
                    break;

                  case 5:
                    message.ErrorInputAmount = reader.int32();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a CheckBlockGiftCodeAck message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof gaiaProto.CheckBlockGiftCodeAck
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {gaiaProto.CheckBlockGiftCodeAck} CheckBlockGiftCodeAck
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            CheckBlockGiftCodeAck.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a CheckBlockGiftCodeAck message.
            * @function verify
            * @memberof gaiaProto.CheckBlockGiftCodeAck
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            CheckBlockGiftCodeAck.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.Code != null && message.hasOwnProperty("Code")) if (!$util.isInteger(message.Code)) return "Code: integer expected";
              if (message.Message != null && message.hasOwnProperty("Message")) if (!$util.isString(message.Message)) return "Message: string expected";
              if (message.IsBlock != null && message.hasOwnProperty("IsBlock")) if (typeof message.IsBlock !== "boolean") return "IsBlock: boolean expected";
              if (message.BlockDuration != null && message.hasOwnProperty("BlockDuration")) if (!$util.isInteger(message.BlockDuration)) return "BlockDuration: integer expected";
              if (message.ErrorInputAmount != null && message.hasOwnProperty("ErrorInputAmount")) if (!$util.isInteger(message.ErrorInputAmount)) return "ErrorInputAmount: integer expected";
              return null;
            };
            /**
            * Creates a CheckBlockGiftCodeAck message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof gaiaProto.CheckBlockGiftCodeAck
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {gaiaProto.CheckBlockGiftCodeAck} CheckBlockGiftCodeAck
            */


            CheckBlockGiftCodeAck.fromObject = function fromObject(object) {
              if (object instanceof $root.gaiaProto.CheckBlockGiftCodeAck) return object;
              var message = new $root.gaiaProto.CheckBlockGiftCodeAck();
              if (object.Code != null) message.Code = object.Code | 0;
              if (object.Message != null) message.Message = String(object.Message);
              if (object.IsBlock != null) message.IsBlock = Boolean(object.IsBlock);
              if (object.BlockDuration != null) message.BlockDuration = object.BlockDuration | 0;
              if (object.ErrorInputAmount != null) message.ErrorInputAmount = object.ErrorInputAmount | 0;
              return message;
            };
            /**
            * Creates a plain object from a CheckBlockGiftCodeAck message. Also converts values to other types if specified.
            * @function toObject
            * @memberof gaiaProto.CheckBlockGiftCodeAck
            * @static
            * @param {gaiaProto.CheckBlockGiftCodeAck} message CheckBlockGiftCodeAck
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            CheckBlockGiftCodeAck.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.Code = 0;
                object.Message = "";
                object.IsBlock = false;
                object.BlockDuration = 0;
                object.ErrorInputAmount = 0;
              }

              if (message.Code != null && message.hasOwnProperty("Code")) object.Code = message.Code;
              if (message.Message != null && message.hasOwnProperty("Message")) object.Message = message.Message;
              if (message.IsBlock != null && message.hasOwnProperty("IsBlock")) object.IsBlock = message.IsBlock;
              if (message.BlockDuration != null && message.hasOwnProperty("BlockDuration")) object.BlockDuration = message.BlockDuration;
              if (message.ErrorInputAmount != null && message.hasOwnProperty("ErrorInputAmount")) object.ErrorInputAmount = message.ErrorInputAmount;
              return object;
            };
            /**
            * Converts this CheckBlockGiftCodeAck to JSON.
            * @function toJSON
            * @memberof gaiaProto.CheckBlockGiftCodeAck
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            CheckBlockGiftCodeAck.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CheckBlockGiftCodeAck;
          }();

          return gaiaProto;
        }();

        module.exports = $root; // #endregion ORIGINAL CODE

        _cjsExports = exports('default', module.exports);
      }, function () {
        return {
          'protobufjs/minimal': __cjsMetaURL$1
        };
      });
    }
  };
});

System.register("chunks:///_virtual/gaiaProto.mjs_cjs=&original=.js", ['./gaiaProto.js', './cjs-loader.mjs'], function (exports, module) {
  'use strict';

  var __cjsMetaURL, loader;

  return {
    setters: [function (module) {
      __cjsMetaURL = module.__cjsMetaURL;
      var _setter = {};
      _setter.__cjsMetaURL = module.__cjsMetaURL;
      _setter.default = module.default;
      exports(_setter);
    }, function (module) {
      loader = module.default;
    }],
    execute: function () {
      // I am the facade module who provides access to the CommonJS module './gaiaProto.js'~
      if (!__cjsMetaURL) {
        loader.throwInvalidWrapper('./gaiaProto.js', module.meta.url);
      }

      loader.require(__cjsMetaURL);
    }
  };
});

System.register("chunks:///_virtual/gem3Proto.js", ['./cjs-loader.mjs', './minimal.js'], function (exports, module) {
  'use strict';

  var loader, __cjsMetaURL$1;

  return {
    setters: [function (module) {
      loader = module.default;
    }, function (module) {
      __cjsMetaURL$1 = module.__cjsMetaURL;
    }],
    execute: function () {
      exports('default', void 0);

      var _cjsExports;

      var __cjsMetaURL = exports('__cjsMetaURL', module.meta.url);

      loader.define(__cjsMetaURL, function (exports$1, require, module, __filename, __dirname) {
        var $protobuf = require("protobufjs/minimal"); // Common aliases


        var $Reader = $protobuf.Reader,
            $Writer = $protobuf.Writer,
            $util = $protobuf.util; // Exported root namespace

        var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

        $root.gem3Proto = function () {
          /**
           * Namespace gem3Proto.
           * @exports gem3Proto
           * @namespace
           */
          var gem3Proto = {};

          gem3Proto.AwardData = function () {
            /**
             * Properties of an AwardData.
             * @memberof gem3Proto
             * @interface IAwardData
             * @property {number|null} [Symbol] AwardData Symbol
             * @property {number|null} [Tag] AwardData Tag
             * @property {number|null} [Win] AwardData Win
             * @property {number|null} [Count] AwardData Count
             */

            /**
             * Constructs a new AwardData.
             * @memberof gem3Proto
             * @classdesc Represents an AwardData.
             * @implements IAwardData
             * @constructor
             * @param {gem3Proto.IAwardData=} [properties] Properties to set
             */
            function AwardData(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * AwardData Symbol.
             * @member {number} Symbol
             * @memberof gem3Proto.AwardData
             * @instance
             */


            AwardData.prototype.Symbol = 0;
            /**
             * AwardData Tag.
             * @member {number} Tag
             * @memberof gem3Proto.AwardData
             * @instance
             */

            AwardData.prototype.Tag = 0;
            /**
             * AwardData Win.
             * @member {number} Win
             * @memberof gem3Proto.AwardData
             * @instance
             */

            AwardData.prototype.Win = 0;
            /**
             * AwardData Count.
             * @member {number} Count
             * @memberof gem3Proto.AwardData
             * @instance
             */

            AwardData.prototype.Count = 0;
            /**
             * Encodes the specified AwardData message. Does not implicitly {@link gem3Proto.AwardData.verify|verify} messages.
             * @function encode
             * @memberof gem3Proto.AwardData
             * @static
             * @param {gem3Proto.IAwardData} message AwardData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */

            AwardData.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.Symbol != null && Object.hasOwnProperty.call(message, "Symbol")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.Symbol);
              if (message.Tag != null && Object.hasOwnProperty.call(message, "Tag")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int32(message.Tag);
              if (message.Win != null && Object.hasOwnProperty.call(message, "Win")) writer.uint32(
              /* id 3, wireType 1 =*/
              25)["double"](message.Win);
              if (message.Count != null && Object.hasOwnProperty.call(message, "Count")) writer.uint32(
              /* id 4, wireType 0 =*/
              32).int32(message.Count);
              return writer;
            };
            /**
             * Decodes an AwardData message from the specified reader or buffer.
             * @function decode
             * @memberof gem3Proto.AwardData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gem3Proto.AwardData} AwardData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            AwardData.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gem3Proto.AwardData();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.Symbol = reader.int32();
                    break;

                  case 2:
                    message.Tag = reader.int32();
                    break;

                  case 3:
                    message.Win = reader["double"]();
                    break;

                  case 4:
                    message.Count = reader.int32();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };

            return AwardData;
          }();

          gem3Proto.SingleGem = function () {
            /**
             * Properties of a SingleGem.
             * @memberof gem3Proto
             * @interface ISingleGem
             * @property {Array.<string>|null} [PlateSymbol] SingleGem PlateSymbol
             * @property {Array.<string>|null} [PlateTag] SingleGem PlateTag
             * @property {Array.<gem3Proto.IAwardData>|null} [AwardInfos] SingleGem AwardInfos
             * @property {number|null} [SingleWin] SingleGem SingleWin
             * @property {boolean|null} [HasUp] SingleGem HasUp
             */

            /**
             * Constructs a new SingleGem.
             * @memberof gem3Proto
             * @classdesc Represents a SingleGem.
             * @implements ISingleGem
             * @constructor
             * @param {gem3Proto.ISingleGem=} [properties] Properties to set
             */
            function SingleGem(properties) {
              this.PlateSymbol = [];
              this.PlateTag = [];
              this.AwardInfos = [];
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * SingleGem PlateSymbol.
             * @member {Array.<string>} PlateSymbol
             * @memberof gem3Proto.SingleGem
             * @instance
             */


            SingleGem.prototype.PlateSymbol = $util.emptyArray;
            /**
             * SingleGem PlateTag.
             * @member {Array.<string>} PlateTag
             * @memberof gem3Proto.SingleGem
             * @instance
             */

            SingleGem.prototype.PlateTag = $util.emptyArray;
            /**
             * SingleGem AwardInfos.
             * @member {Array.<gem3Proto.IAwardData>} AwardInfos
             * @memberof gem3Proto.SingleGem
             * @instance
             */

            SingleGem.prototype.AwardInfos = $util.emptyArray;
            /**
             * SingleGem SingleWin.
             * @member {number} SingleWin
             * @memberof gem3Proto.SingleGem
             * @instance
             */

            SingleGem.prototype.SingleWin = 0;
            /**
             * SingleGem HasUp.
             * @member {boolean} HasUp
             * @memberof gem3Proto.SingleGem
             * @instance
             */

            SingleGem.prototype.HasUp = false;
            /**
             * Encodes the specified SingleGem message. Does not implicitly {@link gem3Proto.SingleGem.verify|verify} messages.
             * @function encode
             * @memberof gem3Proto.SingleGem
             * @static
             * @param {gem3Proto.ISingleGem} message SingleGem message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */

            SingleGem.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.PlateSymbol != null && message.PlateSymbol.length) for (var i = 0; i < message.PlateSymbol.length; ++i) {
                writer.uint32(
                /* id 1, wireType 2 =*/
                10).string(message.PlateSymbol[i]);
              }
              if (message.PlateTag != null && message.PlateTag.length) for (var i = 0; i < message.PlateTag.length; ++i) {
                writer.uint32(
                /* id 2, wireType 2 =*/
                18).string(message.PlateTag[i]);
              }
              if (message.AwardInfos != null && message.AwardInfos.length) for (var i = 0; i < message.AwardInfos.length; ++i) {
                $root.gem3Proto.AwardData.encode(message.AwardInfos[i], writer.uint32(
                /* id 3, wireType 2 =*/
                26).fork()).ldelim();
              }
              if (message.SingleWin != null && Object.hasOwnProperty.call(message, "SingleWin")) writer.uint32(
              /* id 4, wireType 1 =*/
              33)["double"](message.SingleWin);
              if (message.HasUp != null && Object.hasOwnProperty.call(message, "HasUp")) writer.uint32(
              /* id 5, wireType 0 =*/
              40).bool(message.HasUp);
              return writer;
            };
            /**
             * Decodes a SingleGem message from the specified reader or buffer.
             * @function decode
             * @memberof gem3Proto.SingleGem
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gem3Proto.SingleGem} SingleGem
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            SingleGem.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gem3Proto.SingleGem();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    if (!(message.PlateSymbol && message.PlateSymbol.length)) message.PlateSymbol = [];
                    message.PlateSymbol.push(reader.string());
                    break;

                  case 2:
                    if (!(message.PlateTag && message.PlateTag.length)) message.PlateTag = [];
                    message.PlateTag.push(reader.string());
                    break;

                  case 3:
                    if (!(message.AwardInfos && message.AwardInfos.length)) message.AwardInfos = [];
                    message.AwardInfos.push($root.gem3Proto.AwardData.decode(reader, reader.uint32()));
                    break;

                  case 4:
                    message.SingleWin = reader["double"]();
                    break;

                  case 5:
                    message.HasUp = reader.bool();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };

            return SingleGem;
          }();

          gem3Proto.GemData = function () {
            /**
             * Properties of a GemData.
             * @memberof gem3Proto
             * @interface IGemData
             * @property {Array.<gem3Proto.ISingleGem>|null} [PlateQueue] GemData PlateQueue
             * @property {number|null} [Count] GemData Count
             * @property {number|null} [GemWin] GemData GemWin
             */

            /**
             * Constructs a new GemData.
             * @memberof gem3Proto
             * @classdesc Represents a GemData.
             * @implements IGemData
             * @constructor
             * @param {gem3Proto.IGemData=} [properties] Properties to set
             */
            function GemData(properties) {
              this.PlateQueue = [];
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * GemData PlateQueue.
             * @member {Array.<gem3Proto.ISingleGem>} PlateQueue
             * @memberof gem3Proto.GemData
             * @instance
             */


            GemData.prototype.PlateQueue = $util.emptyArray;
            /**
             * GemData Count.
             * @member {number} Count
             * @memberof gem3Proto.GemData
             * @instance
             */

            GemData.prototype.Count = 0;
            /**
             * GemData GemWin.
             * @member {number} GemWin
             * @memberof gem3Proto.GemData
             * @instance
             */

            GemData.prototype.GemWin = 0;
            /**
             * Encodes the specified GemData message. Does not implicitly {@link gem3Proto.GemData.verify|verify} messages.
             * @function encode
             * @memberof gem3Proto.GemData
             * @static
             * @param {gem3Proto.IGemData} message GemData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */

            GemData.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.PlateQueue != null && message.PlateQueue.length) for (var i = 0; i < message.PlateQueue.length; ++i) {
                $root.gem3Proto.SingleGem.encode(message.PlateQueue[i], writer.uint32(
                /* id 1, wireType 2 =*/
                10).fork()).ldelim();
              }
              if (message.Count != null && Object.hasOwnProperty.call(message, "Count")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int32(message.Count);
              if (message.GemWin != null && Object.hasOwnProperty.call(message, "GemWin")) writer.uint32(
              /* id 3, wireType 1 =*/
              25)["double"](message.GemWin);
              return writer;
            };
            /**
             * Decodes a GemData message from the specified reader or buffer.
             * @function decode
             * @memberof gem3Proto.GemData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gem3Proto.GemData} GemData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            GemData.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gem3Proto.GemData();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    if (!(message.PlateQueue && message.PlateQueue.length)) message.PlateQueue = [];
                    message.PlateQueue.push($root.gem3Proto.SingleGem.decode(reader, reader.uint32()));
                    break;

                  case 2:
                    message.Count = reader.int32();
                    break;

                  case 3:
                    message.GemWin = reader["double"]();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };

            return GemData;
          }();

          gem3Proto.SingleFree = function () {
            /**
             * Properties of a SingleFree.
             * @memberof gem3Proto
             * @interface ISingleFree
             * @property {gem3Proto.IGemData|null} [FreeGemInfo] SingleFree FreeGemInfo
             * @property {number|null} [FreeSingleWin] SingleFree FreeSingleWin
             * @property {number|null} [AwardType] SingleFree AwardType
             * @property {number|null} [NowMoney] SingleFree NowMoney
             */

            /**
             * Constructs a new SingleFree.
             * @memberof gem3Proto
             * @classdesc Represents a SingleFree.
             * @implements ISingleFree
             * @constructor
             * @param {gem3Proto.ISingleFree=} [properties] Properties to set
             */
            function SingleFree(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * SingleFree FreeGemInfo.
             * @member {gem3Proto.IGemData|null|undefined} FreeGemInfo
             * @memberof gem3Proto.SingleFree
             * @instance
             */


            SingleFree.prototype.FreeGemInfo = null;
            /**
             * SingleFree FreeSingleWin.
             * @member {number} FreeSingleWin
             * @memberof gem3Proto.SingleFree
             * @instance
             */

            SingleFree.prototype.FreeSingleWin = 0;
            /**
             * SingleFree AwardType.
             * @member {number} AwardType
             * @memberof gem3Proto.SingleFree
             * @instance
             */

            SingleFree.prototype.AwardType = 0;
            /**
             * SingleFree NowMoney.
             * @member {number} NowMoney
             * @memberof gem3Proto.SingleFree
             * @instance
             */

            SingleFree.prototype.NowMoney = 0;
            /**
             * Encodes the specified SingleFree message. Does not implicitly {@link gem3Proto.SingleFree.verify|verify} messages.
             * @function encode
             * @memberof gem3Proto.SingleFree
             * @static
             * @param {gem3Proto.ISingleFree} message SingleFree message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */

            SingleFree.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.FreeGemInfo != null && Object.hasOwnProperty.call(message, "FreeGemInfo")) $root.gem3Proto.GemData.encode(message.FreeGemInfo, writer.uint32(
              /* id 1, wireType 2 =*/
              10).fork()).ldelim();
              if (message.FreeSingleWin != null && Object.hasOwnProperty.call(message, "FreeSingleWin")) writer.uint32(
              /* id 2, wireType 1 =*/
              17)["double"](message.FreeSingleWin);
              if (message.AwardType != null && Object.hasOwnProperty.call(message, "AwardType")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.AwardType);
              if (message.NowMoney != null && Object.hasOwnProperty.call(message, "NowMoney")) writer.uint32(
              /* id 4, wireType 1 =*/
              33)["double"](message.NowMoney);
              return writer;
            };
            /**
             * Decodes a SingleFree message from the specified reader or buffer.
             * @function decode
             * @memberof gem3Proto.SingleFree
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gem3Proto.SingleFree} SingleFree
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            SingleFree.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gem3Proto.SingleFree();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.FreeGemInfo = $root.gem3Proto.GemData.decode(reader, reader.uint32());
                    break;

                  case 2:
                    message.FreeSingleWin = reader["double"]();
                    break;

                  case 3:
                    message.AwardType = reader.int32();
                    break;

                  case 4:
                    message.NowMoney = reader["double"]();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };

            return SingleFree;
          }();

          gem3Proto.FreeData = function () {
            /**
             * Properties of a FreeData.
             * @memberof gem3Proto
             * @interface IFreeData
             * @property {Array.<gem3Proto.ISingleFree>|null} [FreeQueue] FreeData FreeQueue
             * @property {number|null} [FreeMul] FreeData FreeMul
             * @property {number|null} [FreeTotalWin] FreeData FreeTotalWin
             */

            /**
             * Constructs a new FreeData.
             * @memberof gem3Proto
             * @classdesc Represents a FreeData.
             * @implements IFreeData
             * @constructor
             * @param {gem3Proto.IFreeData=} [properties] Properties to set
             */
            function FreeData(properties) {
              this.FreeQueue = [];
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * FreeData FreeQueue.
             * @member {Array.<gem3Proto.ISingleFree>} FreeQueue
             * @memberof gem3Proto.FreeData
             * @instance
             */


            FreeData.prototype.FreeQueue = $util.emptyArray;
            /**
             * FreeData FreeMul.
             * @member {number} FreeMul
             * @memberof gem3Proto.FreeData
             * @instance
             */

            FreeData.prototype.FreeMul = 0;
            /**
             * FreeData FreeTotalWin.
             * @member {number} FreeTotalWin
             * @memberof gem3Proto.FreeData
             * @instance
             */

            FreeData.prototype.FreeTotalWin = 0;
            /**
             * Encodes the specified FreeData message. Does not implicitly {@link gem3Proto.FreeData.verify|verify} messages.
             * @function encode
             * @memberof gem3Proto.FreeData
             * @static
             * @param {gem3Proto.IFreeData} message FreeData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */

            FreeData.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.FreeQueue != null && message.FreeQueue.length) for (var i = 0; i < message.FreeQueue.length; ++i) {
                $root.gem3Proto.SingleFree.encode(message.FreeQueue[i], writer.uint32(
                /* id 1, wireType 2 =*/
                10).fork()).ldelim();
              }
              if (message.FreeMul != null && Object.hasOwnProperty.call(message, "FreeMul")) writer.uint32(
              /* id 2, wireType 1 =*/
              17)["double"](message.FreeMul);
              if (message.FreeTotalWin != null && Object.hasOwnProperty.call(message, "FreeTotalWin")) writer.uint32(
              /* id 3, wireType 1 =*/
              25)["double"](message.FreeTotalWin);
              return writer;
            };
            /**
             * Decodes a FreeData message from the specified reader or buffer.
             * @function decode
             * @memberof gem3Proto.FreeData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gem3Proto.FreeData} FreeData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            FreeData.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gem3Proto.FreeData();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    if (!(message.FreeQueue && message.FreeQueue.length)) message.FreeQueue = [];
                    message.FreeQueue.push($root.gem3Proto.SingleFree.decode(reader, reader.uint32()));
                    break;

                  case 2:
                    message.FreeMul = reader["double"]();
                    break;

                  case 3:
                    message.FreeTotalWin = reader["double"]();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };

            return FreeData;
          }();

          gem3Proto.SingleBonus = function () {
            /**
             * Properties of a SingleBonus.
             * @memberof gem3Proto
             * @interface ISingleBonus
             * @property {gem3Proto.IGemData|null} [BonusGem] SingleBonus BonusGem
             * @property {number|null} [BonusSymbol] SingleBonus BonusSymbol
             * @property {number|null} [BonusSymbolCount] SingleBonus BonusSymbolCount
             */

            /**
             * Constructs a new SingleBonus.
             * @memberof gem3Proto
             * @classdesc Represents a SingleBonus.
             * @implements ISingleBonus
             * @constructor
             * @param {gem3Proto.ISingleBonus=} [properties] Properties to set
             */
            function SingleBonus(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * SingleBonus BonusGem.
             * @member {gem3Proto.IGemData|null|undefined} BonusGem
             * @memberof gem3Proto.SingleBonus
             * @instance
             */


            SingleBonus.prototype.BonusGem = null;
            /**
             * SingleBonus BonusSymbol.
             * @member {number} BonusSymbol
             * @memberof gem3Proto.SingleBonus
             * @instance
             */

            SingleBonus.prototype.BonusSymbol = 0;
            /**
             * SingleBonus BonusSymbolCount.
             * @member {number} BonusSymbolCount
             * @memberof gem3Proto.SingleBonus
             * @instance
             */

            SingleBonus.prototype.BonusSymbolCount = 0;
            /**
             * Encodes the specified SingleBonus message. Does not implicitly {@link gem3Proto.SingleBonus.verify|verify} messages.
             * @function encode
             * @memberof gem3Proto.SingleBonus
             * @static
             * @param {gem3Proto.ISingleBonus} message SingleBonus message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */

            SingleBonus.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.BonusGem != null && Object.hasOwnProperty.call(message, "BonusGem")) $root.gem3Proto.GemData.encode(message.BonusGem, writer.uint32(
              /* id 1, wireType 2 =*/
              10).fork()).ldelim();
              if (message.BonusSymbol != null && Object.hasOwnProperty.call(message, "BonusSymbol")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int32(message.BonusSymbol);
              if (message.BonusSymbolCount != null && Object.hasOwnProperty.call(message, "BonusSymbolCount")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.BonusSymbolCount);
              return writer;
            };
            /**
             * Decodes a SingleBonus message from the specified reader or buffer.
             * @function decode
             * @memberof gem3Proto.SingleBonus
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gem3Proto.SingleBonus} SingleBonus
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            SingleBonus.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gem3Proto.SingleBonus();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.BonusGem = $root.gem3Proto.GemData.decode(reader, reader.uint32());
                    break;

                  case 2:
                    message.BonusSymbol = reader.int32();
                    break;

                  case 3:
                    message.BonusSymbolCount = reader.int32();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };

            return SingleBonus;
          }();

          gem3Proto.BonusData = function () {
            /**
             * Properties of a BonusData.
             * @memberof gem3Proto
             * @interface IBonusData
             * @property {Array.<gem3Proto.ISingleBonus>|null} [BonusQueue] BonusData BonusQueue
             * @property {number|null} [BonusCount] BonusData BonusCount
             * @property {number|null} [BonusTotalWin] BonusData BonusTotalWin
             */

            /**
             * Constructs a new BonusData.
             * @memberof gem3Proto
             * @classdesc Represents a BonusData.
             * @implements IBonusData
             * @constructor
             * @param {gem3Proto.IBonusData=} [properties] Properties to set
             */
            function BonusData(properties) {
              this.BonusQueue = [];
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * BonusData BonusQueue.
             * @member {Array.<gem3Proto.ISingleBonus>} BonusQueue
             * @memberof gem3Proto.BonusData
             * @instance
             */


            BonusData.prototype.BonusQueue = $util.emptyArray;
            /**
             * BonusData BonusCount.
             * @member {number} BonusCount
             * @memberof gem3Proto.BonusData
             * @instance
             */

            BonusData.prototype.BonusCount = 0;
            /**
             * BonusData BonusTotalWin.
             * @member {number} BonusTotalWin
             * @memberof gem3Proto.BonusData
             * @instance
             */

            BonusData.prototype.BonusTotalWin = 0;
            /**
             * Encodes the specified BonusData message. Does not implicitly {@link gem3Proto.BonusData.verify|verify} messages.
             * @function encode
             * @memberof gem3Proto.BonusData
             * @static
             * @param {gem3Proto.IBonusData} message BonusData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */

            BonusData.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.BonusQueue != null && message.BonusQueue.length) for (var i = 0; i < message.BonusQueue.length; ++i) {
                $root.gem3Proto.SingleBonus.encode(message.BonusQueue[i], writer.uint32(
                /* id 1, wireType 2 =*/
                10).fork()).ldelim();
              }
              if (message.BonusCount != null && Object.hasOwnProperty.call(message, "BonusCount")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int32(message.BonusCount);
              if (message.BonusTotalWin != null && Object.hasOwnProperty.call(message, "BonusTotalWin")) writer.uint32(
              /* id 3, wireType 1 =*/
              25)["double"](message.BonusTotalWin);
              return writer;
            };
            /**
             * Decodes a BonusData message from the specified reader or buffer.
             * @function decode
             * @memberof gem3Proto.BonusData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gem3Proto.BonusData} BonusData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            BonusData.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gem3Proto.BonusData();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    if (!(message.BonusQueue && message.BonusQueue.length)) message.BonusQueue = [];
                    message.BonusQueue.push($root.gem3Proto.SingleBonus.decode(reader, reader.uint32()));
                    break;

                  case 2:
                    message.BonusCount = reader.int32();
                    break;

                  case 3:
                    message.BonusTotalWin = reader["double"]();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };

            return BonusData;
          }();

          gem3Proto.BetMulData = function () {
            /**
             * Properties of a BetMulData.
             * @memberof gem3Proto
             * @interface IBetMulData
             * @property {number|null} [BetMul] BetMulData BetMul
             * @property {number|null} [BetMulTotalWin] BetMulData BetMulTotalWin
             */

            /**
             * Constructs a new BetMulData.
             * @memberof gem3Proto
             * @classdesc Represents a BetMulData.
             * @implements IBetMulData
             * @constructor
             * @param {gem3Proto.IBetMulData=} [properties] Properties to set
             */
            function BetMulData(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * BetMulData BetMul.
             * @member {number} BetMul
             * @memberof gem3Proto.BetMulData
             * @instance
             */


            BetMulData.prototype.BetMul = 0;
            /**
             * BetMulData BetMulTotalWin.
             * @member {number} BetMulTotalWin
             * @memberof gem3Proto.BetMulData
             * @instance
             */

            BetMulData.prototype.BetMulTotalWin = 0;
            /**
             * Encodes the specified BetMulData message. Does not implicitly {@link gem3Proto.BetMulData.verify|verify} messages.
             * @function encode
             * @memberof gem3Proto.BetMulData
             * @static
             * @param {gem3Proto.IBetMulData} message BetMulData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */

            BetMulData.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.BetMul != null && Object.hasOwnProperty.call(message, "BetMul")) writer.uint32(
              /* id 1, wireType 1 =*/
              9)["double"](message.BetMul);
              if (message.BetMulTotalWin != null && Object.hasOwnProperty.call(message, "BetMulTotalWin")) writer.uint32(
              /* id 2, wireType 1 =*/
              17)["double"](message.BetMulTotalWin);
              return writer;
            };
            /**
             * Decodes a BetMulData message from the specified reader or buffer.
             * @function decode
             * @memberof gem3Proto.BetMulData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gem3Proto.BetMulData} BetMulData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            BetMulData.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gem3Proto.BetMulData();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.BetMul = reader["double"]();
                    break;

                  case 2:
                    message.BetMulTotalWin = reader["double"]();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };

            return BetMulData;
          }();

          gem3Proto.JPData = function () {
            /**
             * Properties of a JPData.
             * @memberof gem3Proto
             * @interface IJPData
             * @property {number|null} [JPType] JPData JPType
             * @property {number|null} [JPTotalWin] JPData JPTotalWin
             */

            /**
             * Constructs a new JPData.
             * @memberof gem3Proto
             * @classdesc Represents a JPData.
             * @implements IJPData
             * @constructor
             * @param {gem3Proto.IJPData=} [properties] Properties to set
             */
            function JPData(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * JPData JPType.
             * @member {number} JPType
             * @memberof gem3Proto.JPData
             * @instance
             */


            JPData.prototype.JPType = 0;
            /**
             * JPData JPTotalWin.
             * @member {number} JPTotalWin
             * @memberof gem3Proto.JPData
             * @instance
             */

            JPData.prototype.JPTotalWin = 0;
            /**
             * Encodes the specified JPData message. Does not implicitly {@link gem3Proto.JPData.verify|verify} messages.
             * @function encode
             * @memberof gem3Proto.JPData
             * @static
             * @param {gem3Proto.IJPData} message JPData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */

            JPData.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.JPType != null && Object.hasOwnProperty.call(message, "JPType")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.JPType);
              if (message.JPTotalWin != null && Object.hasOwnProperty.call(message, "JPTotalWin")) writer.uint32(
              /* id 2, wireType 1 =*/
              17)["double"](message.JPTotalWin);
              return writer;
            };
            /**
             * Decodes a JPData message from the specified reader or buffer.
             * @function decode
             * @memberof gem3Proto.JPData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gem3Proto.JPData} JPData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            JPData.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gem3Proto.JPData();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.JPType = reader.int32();
                    break;

                  case 2:
                    message.JPTotalWin = reader["double"]();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };

            return JPData;
          }();

          gem3Proto.SpinAck = function () {
            /**
             * Properties of a SpinAck.
             * @memberof gem3Proto
             * @interface ISpinAck
             * @property {gem3Proto.IGemData|null} [GemInfo] SpinAck GemInfo
             * @property {boolean|null} [ChangePlate] SpinAck ChangePlate
             * @property {number|null} [ChangePlateSize] SpinAck ChangePlateSize
             * @property {boolean|null} [GetWheel] SpinAck GetWheel
             * @property {number|null} [WheelType] SpinAck WheelType
             * @property {gem3Proto.IFreeData|null} [FreeInfo] SpinAck FreeInfo
             * @property {gem3Proto.IBonusData|null} [BonusInfo] SpinAck BonusInfo
             * @property {gem3Proto.IBetMulData|null} [BetMulInfo] SpinAck BetMulInfo
             * @property {gem3Proto.IJPData|null} [JPInfo] SpinAck JPInfo
             * @property {number|null} [Upcount] SpinAck Upcount
             * @property {number|null} [TotalUpcount] SpinAck TotalUpcount
             * @property {number|null} [Mainwin] SpinAck Mainwin
             * @property {number|null} [Wheelwin] SpinAck Wheelwin
             * @property {number|null} [TotalWin] SpinAck TotalWin
             * @property {number|null} [AwardType] SpinAck AwardType
             * @property {string|null} [ShowIndex] SpinAck ShowIndex
             * @property {number|null} [NowMoney] SpinAck NowMoney
             * @property {number|null} [AckType] SpinAck AckType
             */

            /**
             * Constructs a new SpinAck.
             * @memberof gem3Proto
             * @classdesc Represents a SpinAck.
             * @implements ISpinAck
             * @constructor
             * @param {gem3Proto.ISpinAck=} [properties] Properties to set
             */
            function SpinAck(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * SpinAck GemInfo.
             * @member {gem3Proto.IGemData|null|undefined} GemInfo
             * @memberof gem3Proto.SpinAck
             * @instance
             */


            SpinAck.prototype.GemInfo = null;
            /**
             * SpinAck ChangePlate.
             * @member {boolean} ChangePlate
             * @memberof gem3Proto.SpinAck
             * @instance
             */

            SpinAck.prototype.ChangePlate = false;
            /**
             * SpinAck ChangePlateSize.
             * @member {number} ChangePlateSize
             * @memberof gem3Proto.SpinAck
             * @instance
             */

            SpinAck.prototype.ChangePlateSize = 0;
            /**
             * SpinAck GetWheel.
             * @member {boolean} GetWheel
             * @memberof gem3Proto.SpinAck
             * @instance
             */

            SpinAck.prototype.GetWheel = false;
            /**
             * SpinAck WheelType.
             * @member {number} WheelType
             * @memberof gem3Proto.SpinAck
             * @instance
             */

            SpinAck.prototype.WheelType = 0;
            /**
             * SpinAck FreeInfo.
             * @member {gem3Proto.IFreeData|null|undefined} FreeInfo
             * @memberof gem3Proto.SpinAck
             * @instance
             */

            SpinAck.prototype.FreeInfo = null;
            /**
             * SpinAck BonusInfo.
             * @member {gem3Proto.IBonusData|null|undefined} BonusInfo
             * @memberof gem3Proto.SpinAck
             * @instance
             */

            SpinAck.prototype.BonusInfo = null;
            /**
             * SpinAck BetMulInfo.
             * @member {gem3Proto.IBetMulData|null|undefined} BetMulInfo
             * @memberof gem3Proto.SpinAck
             * @instance
             */

            SpinAck.prototype.BetMulInfo = null;
            /**
             * SpinAck JPInfo.
             * @member {gem3Proto.IJPData|null|undefined} JPInfo
             * @memberof gem3Proto.SpinAck
             * @instance
             */

            SpinAck.prototype.JPInfo = null;
            /**
             * SpinAck Upcount.
             * @member {number} Upcount
             * @memberof gem3Proto.SpinAck
             * @instance
             */

            SpinAck.prototype.Upcount = 0;
            /**
             * SpinAck TotalUpcount.
             * @member {number} TotalUpcount
             * @memberof gem3Proto.SpinAck
             * @instance
             */

            SpinAck.prototype.TotalUpcount = 0;
            /**
             * SpinAck Mainwin.
             * @member {number} Mainwin
             * @memberof gem3Proto.SpinAck
             * @instance
             */

            SpinAck.prototype.Mainwin = 0;
            /**
             * SpinAck Wheelwin.
             * @member {number} Wheelwin
             * @memberof gem3Proto.SpinAck
             * @instance
             */

            SpinAck.prototype.Wheelwin = 0;
            /**
             * SpinAck TotalWin.
             * @member {number} TotalWin
             * @memberof gem3Proto.SpinAck
             * @instance
             */

            SpinAck.prototype.TotalWin = 0;
            /**
             * SpinAck AwardType.
             * @member {number} AwardType
             * @memberof gem3Proto.SpinAck
             * @instance
             */

            SpinAck.prototype.AwardType = 0;
            /**
             * SpinAck ShowIndex.
             * @member {string} ShowIndex
             * @memberof gem3Proto.SpinAck
             * @instance
             */

            SpinAck.prototype.ShowIndex = "";
            /**
             * SpinAck NowMoney.
             * @member {number} NowMoney
             * @memberof gem3Proto.SpinAck
             * @instance
             */

            SpinAck.prototype.NowMoney = 0;
            /**
             * SpinAck AckType.
             * @member {number} AckType
             * @memberof gem3Proto.SpinAck
             * @instance
             */

            SpinAck.prototype.AckType = 0;
            /**
             * Encodes the specified SpinAck message. Does not implicitly {@link gem3Proto.SpinAck.verify|verify} messages.
             * @function encode
             * @memberof gem3Proto.SpinAck
             * @static
             * @param {gem3Proto.ISpinAck} message SpinAck message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */

            SpinAck.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.GemInfo != null && Object.hasOwnProperty.call(message, "GemInfo")) $root.gem3Proto.GemData.encode(message.GemInfo, writer.uint32(
              /* id 1, wireType 2 =*/
              10).fork()).ldelim();
              if (message.ChangePlate != null && Object.hasOwnProperty.call(message, "ChangePlate")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).bool(message.ChangePlate);
              if (message.ChangePlateSize != null && Object.hasOwnProperty.call(message, "ChangePlateSize")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.ChangePlateSize);
              if (message.GetWheel != null && Object.hasOwnProperty.call(message, "GetWheel")) writer.uint32(
              /* id 4, wireType 0 =*/
              32).bool(message.GetWheel);
              if (message.WheelType != null && Object.hasOwnProperty.call(message, "WheelType")) writer.uint32(
              /* id 5, wireType 1 =*/
              41)["double"](message.WheelType);
              if (message.FreeInfo != null && Object.hasOwnProperty.call(message, "FreeInfo")) $root.gem3Proto.FreeData.encode(message.FreeInfo, writer.uint32(
              /* id 6, wireType 2 =*/
              50).fork()).ldelim();
              if (message.BonusInfo != null && Object.hasOwnProperty.call(message, "BonusInfo")) $root.gem3Proto.BonusData.encode(message.BonusInfo, writer.uint32(
              /* id 7, wireType 2 =*/
              58).fork()).ldelim();
              if (message.BetMulInfo != null && Object.hasOwnProperty.call(message, "BetMulInfo")) $root.gem3Proto.BetMulData.encode(message.BetMulInfo, writer.uint32(
              /* id 8, wireType 2 =*/
              66).fork()).ldelim();
              if (message.JPInfo != null && Object.hasOwnProperty.call(message, "JPInfo")) $root.gem3Proto.JPData.encode(message.JPInfo, writer.uint32(
              /* id 9, wireType 2 =*/
              74).fork()).ldelim();
              if (message.Upcount != null && Object.hasOwnProperty.call(message, "Upcount")) writer.uint32(
              /* id 10, wireType 0 =*/
              80).int32(message.Upcount);
              if (message.TotalUpcount != null && Object.hasOwnProperty.call(message, "TotalUpcount")) writer.uint32(
              /* id 11, wireType 0 =*/
              88).int32(message.TotalUpcount);
              if (message.Mainwin != null && Object.hasOwnProperty.call(message, "Mainwin")) writer.uint32(
              /* id 12, wireType 1 =*/
              97)["double"](message.Mainwin);
              if (message.Wheelwin != null && Object.hasOwnProperty.call(message, "Wheelwin")) writer.uint32(
              /* id 13, wireType 1 =*/
              105)["double"](message.Wheelwin);
              if (message.TotalWin != null && Object.hasOwnProperty.call(message, "TotalWin")) writer.uint32(
              /* id 14, wireType 1 =*/
              113)["double"](message.TotalWin);
              if (message.AwardType != null && Object.hasOwnProperty.call(message, "AwardType")) writer.uint32(
              /* id 15, wireType 0 =*/
              120).int32(message.AwardType);
              if (message.ShowIndex != null && Object.hasOwnProperty.call(message, "ShowIndex")) writer.uint32(
              /* id 16, wireType 2 =*/
              130).string(message.ShowIndex);
              if (message.NowMoney != null && Object.hasOwnProperty.call(message, "NowMoney")) writer.uint32(
              /* id 17, wireType 1 =*/
              137)["double"](message.NowMoney);
              if (message.AckType != null && Object.hasOwnProperty.call(message, "AckType")) writer.uint32(
              /* id 18, wireType 0 =*/
              144).int32(message.AckType);
              return writer;
            };
            /**
             * Decodes a SpinAck message from the specified reader or buffer.
             * @function decode
             * @memberof gem3Proto.SpinAck
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gem3Proto.SpinAck} SpinAck
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            SpinAck.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gem3Proto.SpinAck();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.GemInfo = $root.gem3Proto.GemData.decode(reader, reader.uint32());
                    break;

                  case 2:
                    message.ChangePlate = reader.bool();
                    break;

                  case 3:
                    message.ChangePlateSize = reader.int32();
                    break;

                  case 4:
                    message.GetWheel = reader.bool();
                    break;

                  case 5:
                    message.WheelType = reader["double"]();
                    break;

                  case 6:
                    message.FreeInfo = $root.gem3Proto.FreeData.decode(reader, reader.uint32());
                    break;

                  case 7:
                    message.BonusInfo = $root.gem3Proto.BonusData.decode(reader, reader.uint32());
                    break;

                  case 8:
                    message.BetMulInfo = $root.gem3Proto.BetMulData.decode(reader, reader.uint32());
                    break;

                  case 9:
                    message.JPInfo = $root.gem3Proto.JPData.decode(reader, reader.uint32());
                    break;

                  case 10:
                    message.Upcount = reader.int32();
                    break;

                  case 11:
                    message.TotalUpcount = reader.int32();
                    break;

                  case 12:
                    message.Mainwin = reader["double"]();
                    break;

                  case 13:
                    message.Wheelwin = reader["double"]();
                    break;

                  case 14:
                    message.TotalWin = reader["double"]();
                    break;

                  case 15:
                    message.AwardType = reader.int32();
                    break;

                  case 16:
                    message.ShowIndex = reader.string();
                    break;

                  case 17:
                    message.NowMoney = reader["double"]();
                    break;

                  case 18:
                    message.AckType = reader.int32();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };

            return SpinAck;
          }();

          gem3Proto.GameWalletInfo = function () {
            /**
             * Properties of a GameWalletInfo.
             * @memberof gem3Proto
             * @interface IGameWalletInfo
             * @property {gem3Proto.IWalletInfo|null} [Info] GameWalletInfo Info
             * @property {Array.<number>|null} [BetPropList] GameWalletInfo BetPropList
             */

            /**
             * Constructs a new GameWalletInfo.
             * @memberof gem3Proto
             * @classdesc Represents a GameWalletInfo.
             * @implements IGameWalletInfo
             * @constructor
             * @param {gem3Proto.IGameWalletInfo=} [properties] Properties to set
             */
            function GameWalletInfo(properties) {
              this.BetPropList = [];
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * GameWalletInfo Info.
             * @member {gem3Proto.IWalletInfo|null|undefined} Info
             * @memberof gem3Proto.GameWalletInfo
             * @instance
             */


            GameWalletInfo.prototype.Info = null;
            /**
             * GameWalletInfo BetPropList.
             * @member {Array.<number>} BetPropList
             * @memberof gem3Proto.GameWalletInfo
             * @instance
             */

            GameWalletInfo.prototype.BetPropList = $util.emptyArray;
            /**
             * Encodes the specified GameWalletInfo message. Does not implicitly {@link gem3Proto.GameWalletInfo.verify|verify} messages.
             * @function encode
             * @memberof gem3Proto.GameWalletInfo
             * @static
             * @param {gem3Proto.IGameWalletInfo} message GameWalletInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */

            GameWalletInfo.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.Info != null && Object.hasOwnProperty.call(message, "Info")) $root.gem3Proto.WalletInfo.encode(message.Info, writer.uint32(
              /* id 1, wireType 2 =*/
              10).fork()).ldelim();

              if (message.BetPropList != null && message.BetPropList.length) {
                writer.uint32(
                /* id 2, wireType 2 =*/
                18).fork();

                for (var i = 0; i < message.BetPropList.length; ++i) {
                  writer["double"](message.BetPropList[i]);
                }

                writer.ldelim();
              }

              return writer;
            };
            /**
             * Decodes a GameWalletInfo message from the specified reader or buffer.
             * @function decode
             * @memberof gem3Proto.GameWalletInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gem3Proto.GameWalletInfo} GameWalletInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            GameWalletInfo.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gem3Proto.GameWalletInfo();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.Info = $root.gem3Proto.WalletInfo.decode(reader, reader.uint32());
                    break;

                  case 2:
                    if (!(message.BetPropList && message.BetPropList.length)) message.BetPropList = [];

                    if ((tag & 7) === 2) {
                      var end2 = reader.uint32() + reader.pos;

                      while (reader.pos < end2) {
                        message.BetPropList.push(reader["double"]());
                      }
                    } else message.BetPropList.push(reader["double"]());

                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };

            return GameWalletInfo;
          }();

          gem3Proto.GameInfoAck = function () {
            /**
             * Properties of a GameInfoAck.
             * @memberof gem3Proto
             * @interface IGameInfoAck
             * @property {Array.<gem3Proto.IGameWalletInfo>|null} [WalletInfo] GameInfoAck WalletInfo
             * @property {number|null} [ArcadeNo] GameInfoAck ArcadeNo
             * @property {boolean|null} [CanIntoArcade] GameInfoAck CanIntoArcade
             * @property {boolean|null} [Test] GameInfoAck Test
             * @property {gem3Proto.IPreferRoundShow|null} [Prefer] GameInfoAck Prefer
             * @property {number|null} [FreeSpinRemain] GameInfoAck FreeSpinRemain
             * @property {number|null} [LockBet] GameInfoAck LockBet
             * @property {number|null} [Nowsize] GameInfoAck Nowsize
             * @property {number|null} [Upcount] GameInfoAck Upcount
             */

            /**
             * Constructs a new GameInfoAck.
             * @memberof gem3Proto
             * @classdesc Represents a GameInfoAck.
             * @implements IGameInfoAck
             * @constructor
             * @param {gem3Proto.IGameInfoAck=} [properties] Properties to set
             */
            function GameInfoAck(properties) {
              this.WalletInfo = [];
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * GameInfoAck WalletInfo.
             * @member {Array.<gem3Proto.IGameWalletInfo>} WalletInfo
             * @memberof gem3Proto.GameInfoAck
             * @instance
             */


            GameInfoAck.prototype.WalletInfo = $util.emptyArray;
            /**
             * GameInfoAck ArcadeNo.
             * @member {number} ArcadeNo
             * @memberof gem3Proto.GameInfoAck
             * @instance
             */

            GameInfoAck.prototype.ArcadeNo = 0;
            /**
             * GameInfoAck CanIntoArcade.
             * @member {boolean} CanIntoArcade
             * @memberof gem3Proto.GameInfoAck
             * @instance
             */

            GameInfoAck.prototype.CanIntoArcade = false;
            /**
             * GameInfoAck Test.
             * @member {boolean} Test
             * @memberof gem3Proto.GameInfoAck
             * @instance
             */

            GameInfoAck.prototype.Test = false;
            /**
             * GameInfoAck Prefer.
             * @member {gem3Proto.IPreferRoundShow|null|undefined} Prefer
             * @memberof gem3Proto.GameInfoAck
             * @instance
             */

            GameInfoAck.prototype.Prefer = null;
            /**
             * GameInfoAck FreeSpinRemain.
             * @member {number} FreeSpinRemain
             * @memberof gem3Proto.GameInfoAck
             * @instance
             */

            GameInfoAck.prototype.FreeSpinRemain = 0;
            /**
             * GameInfoAck LockBet.
             * @member {number} LockBet
             * @memberof gem3Proto.GameInfoAck
             * @instance
             */

            GameInfoAck.prototype.LockBet = 0;
            /**
             * GameInfoAck Nowsize.
             * @member {number} Nowsize
             * @memberof gem3Proto.GameInfoAck
             * @instance
             */

            GameInfoAck.prototype.Nowsize = 0;
            /**
             * GameInfoAck Upcount.
             * @member {number} Upcount
             * @memberof gem3Proto.GameInfoAck
             * @instance
             */

            GameInfoAck.prototype.Upcount = 0;
            /**
             * Encodes the specified GameInfoAck message. Does not implicitly {@link gem3Proto.GameInfoAck.verify|verify} messages.
             * @function encode
             * @memberof gem3Proto.GameInfoAck
             * @static
             * @param {gem3Proto.IGameInfoAck} message GameInfoAck message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */

            GameInfoAck.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.WalletInfo != null && message.WalletInfo.length) for (var i = 0; i < message.WalletInfo.length; ++i) {
                $root.gem3Proto.GameWalletInfo.encode(message.WalletInfo[i], writer.uint32(
                /* id 1, wireType 2 =*/
                10).fork()).ldelim();
              }
              if (message.ArcadeNo != null && Object.hasOwnProperty.call(message, "ArcadeNo")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int32(message.ArcadeNo);
              if (message.CanIntoArcade != null && Object.hasOwnProperty.call(message, "CanIntoArcade")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).bool(message.CanIntoArcade);
              if (message.Test != null && Object.hasOwnProperty.call(message, "Test")) writer.uint32(
              /* id 4, wireType 0 =*/
              32).bool(message.Test);
              if (message.Prefer != null && Object.hasOwnProperty.call(message, "Prefer")) $root.gem3Proto.PreferRoundShow.encode(message.Prefer, writer.uint32(
              /* id 5, wireType 2 =*/
              42).fork()).ldelim();
              if (message.FreeSpinRemain != null && Object.hasOwnProperty.call(message, "FreeSpinRemain")) writer.uint32(
              /* id 6, wireType 0 =*/
              48).int32(message.FreeSpinRemain);
              if (message.LockBet != null && Object.hasOwnProperty.call(message, "LockBet")) writer.uint32(
              /* id 7, wireType 1 =*/
              57)["double"](message.LockBet);
              if (message.Nowsize != null && Object.hasOwnProperty.call(message, "Nowsize")) writer.uint32(
              /* id 8, wireType 0 =*/
              64).int32(message.Nowsize);
              if (message.Upcount != null && Object.hasOwnProperty.call(message, "Upcount")) writer.uint32(
              /* id 9, wireType 0 =*/
              72).int32(message.Upcount);
              return writer;
            };
            /**
             * Decodes a GameInfoAck message from the specified reader or buffer.
             * @function decode
             * @memberof gem3Proto.GameInfoAck
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gem3Proto.GameInfoAck} GameInfoAck
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            GameInfoAck.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gem3Proto.GameInfoAck();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    if (!(message.WalletInfo && message.WalletInfo.length)) message.WalletInfo = [];
                    message.WalletInfo.push($root.gem3Proto.GameWalletInfo.decode(reader, reader.uint32()));
                    break;

                  case 2:
                    message.ArcadeNo = reader.int32();
                    break;

                  case 3:
                    message.CanIntoArcade = reader.bool();
                    break;

                  case 4:
                    message.Test = reader.bool();
                    break;

                  case 5:
                    message.Prefer = $root.gem3Proto.PreferRoundShow.decode(reader, reader.uint32());
                    break;

                  case 6:
                    message.FreeSpinRemain = reader.int32();
                    break;

                  case 7:
                    message.LockBet = reader["double"]();
                    break;

                  case 8:
                    message.Nowsize = reader.int32();
                    break;

                  case 9:
                    message.Upcount = reader.int32();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };

            return GameInfoAck;
          }();

          gem3Proto.VolInfo = function () {
            /**
             * Properties of a VolInfo.
             * @memberof gem3Proto
             * @interface IVolInfo
             * @property {number|null} [VolPos] VolInfo VolPos
             * @property {Array.<number>|null} [VolList] VolInfo VolList
             */

            /**
             * Constructs a new VolInfo.
             * @memberof gem3Proto
             * @classdesc Represents a VolInfo.
             * @implements IVolInfo
             * @constructor
             * @param {gem3Proto.IVolInfo=} [properties] Properties to set
             */
            function VolInfo(properties) {
              this.VolList = [];
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * VolInfo VolPos.
             * @member {number} VolPos
             * @memberof gem3Proto.VolInfo
             * @instance
             */


            VolInfo.prototype.VolPos = 0;
            /**
             * VolInfo VolList.
             * @member {Array.<number>} VolList
             * @memberof gem3Proto.VolInfo
             * @instance
             */

            VolInfo.prototype.VolList = $util.emptyArray;
            /**
             * Encodes the specified VolInfo message. Does not implicitly {@link gem3Proto.VolInfo.verify|verify} messages.
             * @function encode
             * @memberof gem3Proto.VolInfo
             * @static
             * @param {gem3Proto.IVolInfo} message VolInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */

            VolInfo.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.VolPos != null && Object.hasOwnProperty.call(message, "VolPos")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.VolPos);

              if (message.VolList != null && message.VolList.length) {
                writer.uint32(
                /* id 2, wireType 2 =*/
                18).fork();

                for (var i = 0; i < message.VolList.length; ++i) {
                  writer.int32(message.VolList[i]);
                }

                writer.ldelim();
              }

              return writer;
            };
            /**
             * Decodes a VolInfo message from the specified reader or buffer.
             * @function decode
             * @memberof gem3Proto.VolInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gem3Proto.VolInfo} VolInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            VolInfo.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gem3Proto.VolInfo();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.VolPos = reader.int32();
                    break;

                  case 2:
                    if (!(message.VolList && message.VolList.length)) message.VolList = [];

                    if ((tag & 7) === 2) {
                      var end2 = reader.uint32() + reader.pos;

                      while (reader.pos < end2) {
                        message.VolList.push(reader.int32());
                      }
                    } else message.VolList.push(reader.int32());

                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };

            return VolInfo;
          }();

          gem3Proto.JPInfoReq = function () {
            /**
             * Properties of a JPInfoReq.
             * @memberof gem3Proto
             * @interface IJPInfoReq
             * @property {number|null} [currency] JPInfoReq currency
             */

            /**
             * Constructs a new JPInfoReq.
             * @memberof gem3Proto
             * @classdesc Represents a JPInfoReq.
             * @implements IJPInfoReq
             * @constructor
             * @param {gem3Proto.IJPInfoReq=} [properties] Properties to set
             */
            function JPInfoReq(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * JPInfoReq currency.
             * @member {number} currency
             * @memberof gem3Proto.JPInfoReq
             * @instance
             */


            JPInfoReq.prototype.currency = 0;
            /**
             * Encodes the specified JPInfoReq message. Does not implicitly {@link gem3Proto.JPInfoReq.verify|verify} messages.
             * @function encode
             * @memberof gem3Proto.JPInfoReq
             * @static
             * @param {gem3Proto.IJPInfoReq} message JPInfoReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */

            JPInfoReq.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.currency != null && Object.hasOwnProperty.call(message, "currency")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.currency);
              return writer;
            };
            /**
             * Decodes a JPInfoReq message from the specified reader or buffer.
             * @function decode
             * @memberof gem3Proto.JPInfoReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gem3Proto.JPInfoReq} JPInfoReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            JPInfoReq.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gem3Proto.JPInfoReq();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.currency = reader.int32();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };

            return JPInfoReq;
          }();

          gem3Proto.JPInfoAck = function () {
            /**
             * Properties of a JPInfoAck.
             * @memberof gem3Proto
             * @interface IJPInfoAck
             * @property {number|null} [Self] JPInfoAck Self
             * @property {Array.<number>|null} [Fronts] JPInfoAck Fronts
             */

            /**
             * Constructs a new JPInfoAck.
             * @memberof gem3Proto
             * @classdesc Represents a JPInfoAck.
             * @implements IJPInfoAck
             * @constructor
             * @param {gem3Proto.IJPInfoAck=} [properties] Properties to set
             */
            function JPInfoAck(properties) {
              this.Fronts = [];
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * JPInfoAck Self.
             * @member {number} Self
             * @memberof gem3Proto.JPInfoAck
             * @instance
             */


            JPInfoAck.prototype.Self = 0;
            /**
             * JPInfoAck Fronts.
             * @member {Array.<number>} Fronts
             * @memberof gem3Proto.JPInfoAck
             * @instance
             */

            JPInfoAck.prototype.Fronts = $util.emptyArray;
            /**
             * Encodes the specified JPInfoAck message. Does not implicitly {@link gem3Proto.JPInfoAck.verify|verify} messages.
             * @function encode
             * @memberof gem3Proto.JPInfoAck
             * @static
             * @param {gem3Proto.IJPInfoAck} message JPInfoAck message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */

            JPInfoAck.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.Self != null && Object.hasOwnProperty.call(message, "Self")) writer.uint32(
              /* id 1, wireType 1 =*/
              9)["double"](message.Self);

              if (message.Fronts != null && message.Fronts.length) {
                writer.uint32(
                /* id 2, wireType 2 =*/
                18).fork();

                for (var i = 0; i < message.Fronts.length; ++i) {
                  writer["double"](message.Fronts[i]);
                }

                writer.ldelim();
              }

              return writer;
            };
            /**
             * Decodes a JPInfoAck message from the specified reader or buffer.
             * @function decode
             * @memberof gem3Proto.JPInfoAck
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gem3Proto.JPInfoAck} JPInfoAck
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            JPInfoAck.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gem3Proto.JPInfoAck();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.Self = reader["double"]();
                    break;

                  case 2:
                    if (!(message.Fronts && message.Fronts.length)) message.Fronts = [];

                    if ((tag & 7) === 2) {
                      var end2 = reader.uint32() + reader.pos;

                      while (reader.pos < end2) {
                        message.Fronts.push(reader["double"]());
                      }
                    } else message.Fronts.push(reader["double"]());

                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };

            return JPInfoAck;
          }();

          gem3Proto.ChangeBetReq = function () {
            /**
             * Properties of a ChangeBetReq.
             * @memberof gem3Proto
             * @interface IChangeBetReq
             * @property {number|null} [bet] ChangeBetReq bet
             */

            /**
             * Constructs a new ChangeBetReq.
             * @memberof gem3Proto
             * @classdesc Represents a ChangeBetReq.
             * @implements IChangeBetReq
             * @constructor
             * @param {gem3Proto.IChangeBetReq=} [properties] Properties to set
             */
            function ChangeBetReq(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * ChangeBetReq bet.
             * @member {number} bet
             * @memberof gem3Proto.ChangeBetReq
             * @instance
             */


            ChangeBetReq.prototype.bet = 0;
            /**
             * Encodes the specified ChangeBetReq message. Does not implicitly {@link gem3Proto.ChangeBetReq.verify|verify} messages.
             * @function encode
             * @memberof gem3Proto.ChangeBetReq
             * @static
             * @param {gem3Proto.IChangeBetReq} message ChangeBetReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */

            ChangeBetReq.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.bet != null && Object.hasOwnProperty.call(message, "bet")) writer.uint32(
              /* id 1, wireType 1 =*/
              9)["double"](message.bet);
              return writer;
            };
            /**
             * Decodes a ChangeBetReq message from the specified reader or buffer.
             * @function decode
             * @memberof gem3Proto.ChangeBetReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gem3Proto.ChangeBetReq} ChangeBetReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            ChangeBetReq.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gem3Proto.ChangeBetReq();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.bet = reader["double"]();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };

            return ChangeBetReq;
          }();

          gem3Proto.ChangeBetAck = function () {
            /**
             * Properties of a ChangeBetAck.
             * @memberof gem3Proto
             * @interface IChangeBetAck
             * @property {number|null} [Result] ChangeBetAck Result
             * @property {number|null} [NewBet] ChangeBetAck NewBet
             * @property {number|null} [UpCount] ChangeBetAck UpCount
             */

            /**
             * Constructs a new ChangeBetAck.
             * @memberof gem3Proto
             * @classdesc Represents a ChangeBetAck.
             * @implements IChangeBetAck
             * @constructor
             * @param {gem3Proto.IChangeBetAck=} [properties] Properties to set
             */
            function ChangeBetAck(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * ChangeBetAck Result.
             * @member {number} Result
             * @memberof gem3Proto.ChangeBetAck
             * @instance
             */


            ChangeBetAck.prototype.Result = 0;
            /**
             * ChangeBetAck NewBet.
             * @member {number} NewBet
             * @memberof gem3Proto.ChangeBetAck
             * @instance
             */

            ChangeBetAck.prototype.NewBet = 0;
            /**
             * ChangeBetAck UpCount.
             * @member {number} UpCount
             * @memberof gem3Proto.ChangeBetAck
             * @instance
             */

            ChangeBetAck.prototype.UpCount = 0;
            /**
             * Encodes the specified ChangeBetAck message. Does not implicitly {@link gem3Proto.ChangeBetAck.verify|verify} messages.
             * @function encode
             * @memberof gem3Proto.ChangeBetAck
             * @static
             * @param {gem3Proto.IChangeBetAck} message ChangeBetAck message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */

            ChangeBetAck.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.Result != null && Object.hasOwnProperty.call(message, "Result")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.Result);
              if (message.NewBet != null && Object.hasOwnProperty.call(message, "NewBet")) writer.uint32(
              /* id 2, wireType 1 =*/
              17)["double"](message.NewBet);
              if (message.UpCount != null && Object.hasOwnProperty.call(message, "UpCount")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.UpCount);
              return writer;
            };
            /**
             * Decodes a ChangeBetAck message from the specified reader or buffer.
             * @function decode
             * @memberof gem3Proto.ChangeBetAck
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gem3Proto.ChangeBetAck} ChangeBetAck
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            ChangeBetAck.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gem3Proto.ChangeBetAck();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.Result = reader.int32();
                    break;

                  case 2:
                    message.NewBet = reader["double"]();
                    break;

                  case 3:
                    message.UpCount = reader.int32();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };

            return ChangeBetAck;
          }();

          gem3Proto.ChangeCurrencyReq = function () {
            /**
             * Properties of a ChangeCurrencyReq.
             * @memberof gem3Proto
             * @interface IChangeCurrencyReq
             * @property {number|null} [currency] ChangeCurrencyReq currency
             */

            /**
             * Constructs a new ChangeCurrencyReq.
             * @memberof gem3Proto
             * @classdesc Represents a ChangeCurrencyReq.
             * @implements IChangeCurrencyReq
             * @constructor
             * @param {gem3Proto.IChangeCurrencyReq=} [properties] Properties to set
             */
            function ChangeCurrencyReq(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * ChangeCurrencyReq currency.
             * @member {number} currency
             * @memberof gem3Proto.ChangeCurrencyReq
             * @instance
             */


            ChangeCurrencyReq.prototype.currency = 0;
            /**
             * Encodes the specified ChangeCurrencyReq message. Does not implicitly {@link gem3Proto.ChangeCurrencyReq.verify|verify} messages.
             * @function encode
             * @memberof gem3Proto.ChangeCurrencyReq
             * @static
             * @param {gem3Proto.IChangeCurrencyReq} message ChangeCurrencyReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */

            ChangeCurrencyReq.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.currency != null && Object.hasOwnProperty.call(message, "currency")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.currency);
              return writer;
            };
            /**
             * Decodes a ChangeCurrencyReq message from the specified reader or buffer.
             * @function decode
             * @memberof gem3Proto.ChangeCurrencyReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gem3Proto.ChangeCurrencyReq} ChangeCurrencyReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            ChangeCurrencyReq.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gem3Proto.ChangeCurrencyReq();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.currency = reader.int32();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };

            return ChangeCurrencyReq;
          }();

          gem3Proto.ChangeCurrencyAck = function () {
            /**
             * Properties of a ChangeCurrencyAck.
             * @memberof gem3Proto
             * @interface IChangeCurrencyAck
             * @property {number|null} [Result] ChangeCurrencyAck Result
             * @property {number|null} [LockBet] ChangeCurrencyAck LockBet
             * @property {number|null} [Nowsize] ChangeCurrencyAck Nowsize
             * @property {number|null} [Upcount] ChangeCurrencyAck Upcount
             * @property {number|null} [Currency] ChangeCurrencyAck Currency
             */

            /**
             * Constructs a new ChangeCurrencyAck.
             * @memberof gem3Proto
             * @classdesc Represents a ChangeCurrencyAck.
             * @implements IChangeCurrencyAck
             * @constructor
             * @param {gem3Proto.IChangeCurrencyAck=} [properties] Properties to set
             */
            function ChangeCurrencyAck(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * ChangeCurrencyAck Result.
             * @member {number} Result
             * @memberof gem3Proto.ChangeCurrencyAck
             * @instance
             */


            ChangeCurrencyAck.prototype.Result = 0;
            /**
             * ChangeCurrencyAck LockBet.
             * @member {number} LockBet
             * @memberof gem3Proto.ChangeCurrencyAck
             * @instance
             */

            ChangeCurrencyAck.prototype.LockBet = 0;
            /**
             * ChangeCurrencyAck Nowsize.
             * @member {number} Nowsize
             * @memberof gem3Proto.ChangeCurrencyAck
             * @instance
             */

            ChangeCurrencyAck.prototype.Nowsize = 0;
            /**
             * ChangeCurrencyAck Upcount.
             * @member {number} Upcount
             * @memberof gem3Proto.ChangeCurrencyAck
             * @instance
             */

            ChangeCurrencyAck.prototype.Upcount = 0;
            /**
             * ChangeCurrencyAck Currency.
             * @member {number} Currency
             * @memberof gem3Proto.ChangeCurrencyAck
             * @instance
             */

            ChangeCurrencyAck.prototype.Currency = 0;
            /**
             * Encodes the specified ChangeCurrencyAck message. Does not implicitly {@link gem3Proto.ChangeCurrencyAck.verify|verify} messages.
             * @function encode
             * @memberof gem3Proto.ChangeCurrencyAck
             * @static
             * @param {gem3Proto.IChangeCurrencyAck} message ChangeCurrencyAck message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */

            ChangeCurrencyAck.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.Result != null && Object.hasOwnProperty.call(message, "Result")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.Result);
              if (message.LockBet != null && Object.hasOwnProperty.call(message, "LockBet")) writer.uint32(
              /* id 2, wireType 1 =*/
              17)["double"](message.LockBet);
              if (message.Nowsize != null && Object.hasOwnProperty.call(message, "Nowsize")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.Nowsize);
              if (message.Upcount != null && Object.hasOwnProperty.call(message, "Upcount")) writer.uint32(
              /* id 4, wireType 0 =*/
              32).int32(message.Upcount);
              if (message.Currency != null && Object.hasOwnProperty.call(message, "Currency")) writer.uint32(
              /* id 5, wireType 0 =*/
              40).int32(message.Currency);
              return writer;
            };
            /**
             * Decodes a ChangeCurrencyAck message from the specified reader or buffer.
             * @function decode
             * @memberof gem3Proto.ChangeCurrencyAck
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gem3Proto.ChangeCurrencyAck} ChangeCurrencyAck
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            ChangeCurrencyAck.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gem3Proto.ChangeCurrencyAck();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.Result = reader.int32();
                    break;

                  case 2:
                    message.LockBet = reader["double"]();
                    break;

                  case 3:
                    message.Nowsize = reader.int32();
                    break;

                  case 4:
                    message.Upcount = reader.int32();
                    break;

                  case 5:
                    message.Currency = reader.int32();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };

            return ChangeCurrencyAck;
          }();

          gem3Proto.GameReqData = function () {
            /**
             * Properties of a GameReqData.
             * @memberof gem3Proto
             * @interface IGameReqData
             * @property {number|null} [aid] GameReqData aid
             * @property {number|null} [apiid] GameReqData apiid
             * @property {string|null} [token] GameReqData token
             * @property {Uint8Array|null} [encode] GameReqData encode
             * @property {gem3Proto.ISpinReq|null} [spin] GameReqData spin
             * @property {gem3Proto.ICheckMallReq|null} [checkMall] GameReqData checkMall
             * @property {gem3Proto.IJPInfoReq|null} [jpinfo] GameReqData jpinfo
             * @property {gem3Proto.IChangeBetReq|null} [changebet] GameReqData changebet
             * @property {gem3Proto.IChangeCurrencyReq|null} [changecurrency] GameReqData changecurrency
             */

            /**
             * Constructs a new GameReqData.
             * @memberof gem3Proto
             * @classdesc Represents a GameReqData.
             * @implements IGameReqData
             * @constructor
             * @param {gem3Proto.IGameReqData=} [properties] Properties to set
             */
            function GameReqData(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * GameReqData aid.
             * @member {number} aid
             * @memberof gem3Proto.GameReqData
             * @instance
             */


            GameReqData.prototype.aid = 0;
            /**
             * GameReqData apiid.
             * @member {number} apiid
             * @memberof gem3Proto.GameReqData
             * @instance
             */

            GameReqData.prototype.apiid = 0;
            /**
             * GameReqData token.
             * @member {string} token
             * @memberof gem3Proto.GameReqData
             * @instance
             */

            GameReqData.prototype.token = "";
            /**
             * GameReqData encode.
             * @member {Uint8Array} encode
             * @memberof gem3Proto.GameReqData
             * @instance
             */

            GameReqData.prototype.encode = $util.newBuffer([]);
            /**
             * GameReqData spin.
             * @member {gem3Proto.ISpinReq|null|undefined} spin
             * @memberof gem3Proto.GameReqData
             * @instance
             */

            GameReqData.prototype.spin = null;
            /**
             * GameReqData checkMall.
             * @member {gem3Proto.ICheckMallReq|null|undefined} checkMall
             * @memberof gem3Proto.GameReqData
             * @instance
             */

            GameReqData.prototype.checkMall = null;
            /**
             * GameReqData jpinfo.
             * @member {gem3Proto.IJPInfoReq|null|undefined} jpinfo
             * @memberof gem3Proto.GameReqData
             * @instance
             */

            GameReqData.prototype.jpinfo = null;
            /**
             * GameReqData changebet.
             * @member {gem3Proto.IChangeBetReq|null|undefined} changebet
             * @memberof gem3Proto.GameReqData
             * @instance
             */

            GameReqData.prototype.changebet = null;
            /**
             * GameReqData changecurrency.
             * @member {gem3Proto.IChangeCurrencyReq|null|undefined} changecurrency
             * @memberof gem3Proto.GameReqData
             * @instance
             */

            GameReqData.prototype.changecurrency = null;
            /**
             * Encodes the specified GameReqData message. Does not implicitly {@link gem3Proto.GameReqData.verify|verify} messages.
             * @function encode
             * @memberof gem3Proto.GameReqData
             * @static
             * @param {gem3Proto.IGameReqData} message GameReqData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */

            GameReqData.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.aid != null && Object.hasOwnProperty.call(message, "aid")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.aid);
              if (message.apiid != null && Object.hasOwnProperty.call(message, "apiid")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int32(message.apiid);
              if (message.token != null && Object.hasOwnProperty.call(message, "token")) writer.uint32(
              /* id 3, wireType 2 =*/
              26).string(message.token);
              if (message.encode != null && Object.hasOwnProperty.call(message, "encode")) writer.uint32(
              /* id 4, wireType 2 =*/
              34).bytes(message.encode);
              if (message.spin != null && Object.hasOwnProperty.call(message, "spin")) $root.gem3Proto.SpinReq.encode(message.spin, writer.uint32(
              /* id 5, wireType 2 =*/
              42).fork()).ldelim();
              if (message.checkMall != null && Object.hasOwnProperty.call(message, "checkMall")) $root.gem3Proto.CheckMallReq.encode(message.checkMall, writer.uint32(
              /* id 6, wireType 2 =*/
              50).fork()).ldelim();
              if (message.jpinfo != null && Object.hasOwnProperty.call(message, "jpinfo")) $root.gem3Proto.JPInfoReq.encode(message.jpinfo, writer.uint32(
              /* id 7, wireType 2 =*/
              58).fork()).ldelim();
              if (message.changebet != null && Object.hasOwnProperty.call(message, "changebet")) $root.gem3Proto.ChangeBetReq.encode(message.changebet, writer.uint32(
              /* id 8, wireType 2 =*/
              66).fork()).ldelim();
              if (message.changecurrency != null && Object.hasOwnProperty.call(message, "changecurrency")) $root.gem3Proto.ChangeCurrencyReq.encode(message.changecurrency, writer.uint32(
              /* id 9, wireType 2 =*/
              74).fork()).ldelim();
              return writer;
            };
            /**
             * Decodes a GameReqData message from the specified reader or buffer.
             * @function decode
             * @memberof gem3Proto.GameReqData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gem3Proto.GameReqData} GameReqData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            GameReqData.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gem3Proto.GameReqData();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.aid = reader.int32();
                    break;

                  case 2:
                    message.apiid = reader.int32();
                    break;

                  case 3:
                    message.token = reader.string();
                    break;

                  case 4:
                    message.encode = reader.bytes();
                    break;

                  case 5:
                    message.spin = $root.gem3Proto.SpinReq.decode(reader, reader.uint32());
                    break;

                  case 6:
                    message.checkMall = $root.gem3Proto.CheckMallReq.decode(reader, reader.uint32());
                    break;

                  case 7:
                    message.jpinfo = $root.gem3Proto.JPInfoReq.decode(reader, reader.uint32());
                    break;

                  case 8:
                    message.changebet = $root.gem3Proto.ChangeBetReq.decode(reader, reader.uint32());
                    break;

                  case 9:
                    message.changecurrency = $root.gem3Proto.ChangeCurrencyReq.decode(reader, reader.uint32());
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };

            return GameReqData;
          }();

          gem3Proto.SpinReq = function () {
            /**
             * Properties of a SpinReq.
             * @memberof gem3Proto
             * @interface ISpinReq
             * @property {number|null} [Bet] SpinReq Bet
             * @property {number|null} [Currency] SpinReq Currency
             * @property {number|null} [TestMode] SpinReq TestMode
             * @property {number|null} [MallID] SpinReq MallID
             * @property {number|null} [MallBet] SpinReq MallBet
             * @property {number|null} [VipLv] SpinReq VipLv
             * @property {number|null} [Free] SpinReq Free
             * @property {number|null} [Trial] SpinReq Trial
             * @property {number|null} [VolType] SpinReq VolType
             * @property {number|null} [Level] SpinReq Level
             */

            /**
             * Constructs a new SpinReq.
             * @memberof gem3Proto
             * @classdesc Represents a SpinReq.
             * @implements ISpinReq
             * @constructor
             * @param {gem3Proto.ISpinReq=} [properties] Properties to set
             */
            function SpinReq(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * SpinReq Bet.
             * @member {number} Bet
             * @memberof gem3Proto.SpinReq
             * @instance
             */


            SpinReq.prototype.Bet = 0;
            /**
             * SpinReq Currency.
             * @member {number} Currency
             * @memberof gem3Proto.SpinReq
             * @instance
             */

            SpinReq.prototype.Currency = 0;
            /**
             * SpinReq TestMode.
             * @member {number} TestMode
             * @memberof gem3Proto.SpinReq
             * @instance
             */

            SpinReq.prototype.TestMode = 0;
            /**
             * SpinReq MallID.
             * @member {number} MallID
             * @memberof gem3Proto.SpinReq
             * @instance
             */

            SpinReq.prototype.MallID = 0;
            /**
             * SpinReq MallBet.
             * @member {number} MallBet
             * @memberof gem3Proto.SpinReq
             * @instance
             */

            SpinReq.prototype.MallBet = 0;
            /**
             * SpinReq VipLv.
             * @member {number} VipLv
             * @memberof gem3Proto.SpinReq
             * @instance
             */

            SpinReq.prototype.VipLv = 0;
            /**
             * SpinReq Free.
             * @member {number} Free
             * @memberof gem3Proto.SpinReq
             * @instance
             */

            SpinReq.prototype.Free = 0;
            /**
             * SpinReq Trial.
             * @member {number} Trial
             * @memberof gem3Proto.SpinReq
             * @instance
             */

            SpinReq.prototype.Trial = 0;
            /**
             * SpinReq VolType.
             * @member {number} VolType
             * @memberof gem3Proto.SpinReq
             * @instance
             */

            SpinReq.prototype.VolType = 0;
            /**
             * SpinReq Level.
             * @member {number} Level
             * @memberof gem3Proto.SpinReq
             * @instance
             */

            SpinReq.prototype.Level = 0;
            /**
             * Encodes the specified SpinReq message. Does not implicitly {@link gem3Proto.SpinReq.verify|verify} messages.
             * @function encode
             * @memberof gem3Proto.SpinReq
             * @static
             * @param {gem3Proto.ISpinReq} message SpinReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */

            SpinReq.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.Bet != null && Object.hasOwnProperty.call(message, "Bet")) writer.uint32(
              /* id 1, wireType 1 =*/
              9)["double"](message.Bet);
              if (message.Currency != null && Object.hasOwnProperty.call(message, "Currency")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.Currency);
              if (message.TestMode != null && Object.hasOwnProperty.call(message, "TestMode")) writer.uint32(
              /* id 4, wireType 0 =*/
              32).int32(message.TestMode);
              if (message.MallID != null && Object.hasOwnProperty.call(message, "MallID")) writer.uint32(
              /* id 5, wireType 0 =*/
              40).int32(message.MallID);
              if (message.MallBet != null && Object.hasOwnProperty.call(message, "MallBet")) writer.uint32(
              /* id 6, wireType 1 =*/
              49)["double"](message.MallBet);
              if (message.VipLv != null && Object.hasOwnProperty.call(message, "VipLv")) writer.uint32(
              /* id 7, wireType 0 =*/
              56).int32(message.VipLv);
              if (message.Free != null && Object.hasOwnProperty.call(message, "Free")) writer.uint32(
              /* id 8, wireType 0 =*/
              64).int32(message.Free);
              if (message.Trial != null && Object.hasOwnProperty.call(message, "Trial")) writer.uint32(
              /* id 9, wireType 0 =*/
              72).int32(message.Trial);
              if (message.VolType != null && Object.hasOwnProperty.call(message, "VolType")) writer.uint32(
              /* id 10, wireType 0 =*/
              80).int32(message.VolType);
              if (message.Level != null && Object.hasOwnProperty.call(message, "Level")) writer.uint32(
              /* id 11, wireType 0 =*/
              88).int32(message.Level);
              return writer;
            };
            /**
             * Decodes a SpinReq message from the specified reader or buffer.
             * @function decode
             * @memberof gem3Proto.SpinReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gem3Proto.SpinReq} SpinReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            SpinReq.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gem3Proto.SpinReq();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.Bet = reader["double"]();
                    break;

                  case 3:
                    message.Currency = reader.int32();
                    break;

                  case 4:
                    message.TestMode = reader.int32();
                    break;

                  case 5:
                    message.MallID = reader.int32();
                    break;

                  case 6:
                    message.MallBet = reader["double"]();
                    break;

                  case 7:
                    message.VipLv = reader.int32();
                    break;

                  case 8:
                    message.Free = reader.int32();
                    break;

                  case 9:
                    message.Trial = reader.int32();
                    break;

                  case 10:
                    message.VolType = reader.int32();
                    break;

                  case 11:
                    message.Level = reader.int32();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };

            return SpinReq;
          }();

          gem3Proto.InfoData = function () {
            /**
             * Properties of an InfoData.
             * @memberof gem3Proto
             * @interface IInfoData
             * @property {Uint8Array|null} [encode] InfoData encode
             * @property {gem3Proto.ISpinAllData|null} [spinAll] InfoData spinAll
             * @property {gem3Proto.IGameInfoAck|null} [gameInfo] InfoData gameInfo
             * @property {gem3Proto.ICheckMallAck|null} [checkMall] InfoData checkMall
             * @property {gem3Proto.ILoginDataAck|null} [loginData] InfoData loginData
             * @property {gem3Proto.IHeartAck|null} [heart] InfoData heart
             * @property {gem3Proto.IExchangeAck|null} [exchange] InfoData exchange
             * @property {gem3Proto.ILastSpinAck|null} [lastSpin] InfoData lastSpin
             * @property {gem3Proto.IJPInfoAck|null} [jpinfo] InfoData jpinfo
             * @property {gem3Proto.IChangeBetAck|null} [changebet] InfoData changebet
             * @property {gem3Proto.IChangeCurrencyAck|null} [changecurrency] InfoData changecurrency
             */

            /**
             * Constructs a new InfoData.
             * @memberof gem3Proto
             * @classdesc Represents an InfoData.
             * @implements IInfoData
             * @constructor
             * @param {gem3Proto.IInfoData=} [properties] Properties to set
             */
            function InfoData(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * InfoData encode.
             * @member {Uint8Array} encode
             * @memberof gem3Proto.InfoData
             * @instance
             */


            InfoData.prototype.encode = $util.newBuffer([]);
            /**
             * InfoData spinAll.
             * @member {gem3Proto.ISpinAllData|null|undefined} spinAll
             * @memberof gem3Proto.InfoData
             * @instance
             */

            InfoData.prototype.spinAll = null;
            /**
             * InfoData gameInfo.
             * @member {gem3Proto.IGameInfoAck|null|undefined} gameInfo
             * @memberof gem3Proto.InfoData
             * @instance
             */

            InfoData.prototype.gameInfo = null;
            /**
             * InfoData checkMall.
             * @member {gem3Proto.ICheckMallAck|null|undefined} checkMall
             * @memberof gem3Proto.InfoData
             * @instance
             */

            InfoData.prototype.checkMall = null;
            /**
             * InfoData loginData.
             * @member {gem3Proto.ILoginDataAck|null|undefined} loginData
             * @memberof gem3Proto.InfoData
             * @instance
             */

            InfoData.prototype.loginData = null;
            /**
             * InfoData heart.
             * @member {gem3Proto.IHeartAck|null|undefined} heart
             * @memberof gem3Proto.InfoData
             * @instance
             */

            InfoData.prototype.heart = null;
            /**
             * InfoData exchange.
             * @member {gem3Proto.IExchangeAck|null|undefined} exchange
             * @memberof gem3Proto.InfoData
             * @instance
             */

            InfoData.prototype.exchange = null;
            /**
             * InfoData lastSpin.
             * @member {gem3Proto.ILastSpinAck|null|undefined} lastSpin
             * @memberof gem3Proto.InfoData
             * @instance
             */

            InfoData.prototype.lastSpin = null;
            /**
             * InfoData jpinfo.
             * @member {gem3Proto.IJPInfoAck|null|undefined} jpinfo
             * @memberof gem3Proto.InfoData
             * @instance
             */

            InfoData.prototype.jpinfo = null;
            /**
             * InfoData changebet.
             * @member {gem3Proto.IChangeBetAck|null|undefined} changebet
             * @memberof gem3Proto.InfoData
             * @instance
             */

            InfoData.prototype.changebet = null;
            /**
             * InfoData changecurrency.
             * @member {gem3Proto.IChangeCurrencyAck|null|undefined} changecurrency
             * @memberof gem3Proto.InfoData
             * @instance
             */

            InfoData.prototype.changecurrency = null;
            /**
             * Encodes the specified InfoData message. Does not implicitly {@link gem3Proto.InfoData.verify|verify} messages.
             * @function encode
             * @memberof gem3Proto.InfoData
             * @static
             * @param {gem3Proto.IInfoData} message InfoData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */

            InfoData.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.encode != null && Object.hasOwnProperty.call(message, "encode")) writer.uint32(
              /* id 1, wireType 2 =*/
              10).bytes(message.encode);
              if (message.spinAll != null && Object.hasOwnProperty.call(message, "spinAll")) $root.gem3Proto.SpinAllData.encode(message.spinAll, writer.uint32(
              /* id 2, wireType 2 =*/
              18).fork()).ldelim();
              if (message.gameInfo != null && Object.hasOwnProperty.call(message, "gameInfo")) $root.gem3Proto.GameInfoAck.encode(message.gameInfo, writer.uint32(
              /* id 3, wireType 2 =*/
              26).fork()).ldelim();
              if (message.checkMall != null && Object.hasOwnProperty.call(message, "checkMall")) $root.gem3Proto.CheckMallAck.encode(message.checkMall, writer.uint32(
              /* id 4, wireType 2 =*/
              34).fork()).ldelim();
              if (message.loginData != null && Object.hasOwnProperty.call(message, "loginData")) $root.gem3Proto.LoginDataAck.encode(message.loginData, writer.uint32(
              /* id 5, wireType 2 =*/
              42).fork()).ldelim();
              if (message.heart != null && Object.hasOwnProperty.call(message, "heart")) $root.gem3Proto.HeartAck.encode(message.heart, writer.uint32(
              /* id 6, wireType 2 =*/
              50).fork()).ldelim();
              if (message.exchange != null && Object.hasOwnProperty.call(message, "exchange")) $root.gem3Proto.ExchangeAck.encode(message.exchange, writer.uint32(
              /* id 7, wireType 2 =*/
              58).fork()).ldelim();
              if (message.lastSpin != null && Object.hasOwnProperty.call(message, "lastSpin")) $root.gem3Proto.LastSpinAck.encode(message.lastSpin, writer.uint32(
              /* id 8, wireType 2 =*/
              66).fork()).ldelim();
              if (message.jpinfo != null && Object.hasOwnProperty.call(message, "jpinfo")) $root.gem3Proto.JPInfoAck.encode(message.jpinfo, writer.uint32(
              /* id 9, wireType 2 =*/
              74).fork()).ldelim();
              if (message.changebet != null && Object.hasOwnProperty.call(message, "changebet")) $root.gem3Proto.ChangeBetAck.encode(message.changebet, writer.uint32(
              /* id 10, wireType 2 =*/
              82).fork()).ldelim();
              if (message.changecurrency != null && Object.hasOwnProperty.call(message, "changecurrency")) $root.gem3Proto.ChangeCurrencyAck.encode(message.changecurrency, writer.uint32(
              /* id 11, wireType 2 =*/
              90).fork()).ldelim();
              return writer;
            };
            /**
             * Decodes an InfoData message from the specified reader or buffer.
             * @function decode
             * @memberof gem3Proto.InfoData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gem3Proto.InfoData} InfoData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            InfoData.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gem3Proto.InfoData();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.encode = reader.bytes();
                    break;

                  case 2:
                    message.spinAll = $root.gem3Proto.SpinAllData.decode(reader, reader.uint32());
                    break;

                  case 3:
                    message.gameInfo = $root.gem3Proto.GameInfoAck.decode(reader, reader.uint32());
                    break;

                  case 4:
                    message.checkMall = $root.gem3Proto.CheckMallAck.decode(reader, reader.uint32());
                    break;

                  case 5:
                    message.loginData = $root.gem3Proto.LoginDataAck.decode(reader, reader.uint32());
                    break;

                  case 6:
                    message.heart = $root.gem3Proto.HeartAck.decode(reader, reader.uint32());
                    break;

                  case 7:
                    message.exchange = $root.gem3Proto.ExchangeAck.decode(reader, reader.uint32());
                    break;

                  case 8:
                    message.lastSpin = $root.gem3Proto.LastSpinAck.decode(reader, reader.uint32());
                    break;

                  case 9:
                    message.jpinfo = $root.gem3Proto.JPInfoAck.decode(reader, reader.uint32());
                    break;

                  case 10:
                    message.changebet = $root.gem3Proto.ChangeBetAck.decode(reader, reader.uint32());
                    break;

                  case 11:
                    message.changecurrency = $root.gem3Proto.ChangeCurrencyAck.decode(reader, reader.uint32());
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };

            return InfoData;
          }();

          gem3Proto.ResData = function () {
            /**
             * Properties of a ResData.
             * @memberof gem3Proto
             * @interface IResData
             * @property {number|null} [ret] ResData ret
             * @property {number|null} [type] ResData type
             * @property {string|null} [token] ResData token
             * @property {string|null} [msg] ResData msg
             * @property {gem3Proto.IInfoData|null} [data] ResData data
             */

            /**
             * Constructs a new ResData.
             * @memberof gem3Proto
             * @classdesc Represents a ResData.
             * @implements IResData
             * @constructor
             * @param {gem3Proto.IResData=} [properties] Properties to set
             */
            function ResData(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * ResData ret.
             * @member {number} ret
             * @memberof gem3Proto.ResData
             * @instance
             */


            ResData.prototype.ret = 0;
            /**
             * ResData type.
             * @member {number} type
             * @memberof gem3Proto.ResData
             * @instance
             */

            ResData.prototype.type = 0;
            /**
             * ResData token.
             * @member {string} token
             * @memberof gem3Proto.ResData
             * @instance
             */

            ResData.prototype.token = "";
            /**
             * ResData msg.
             * @member {string} msg
             * @memberof gem3Proto.ResData
             * @instance
             */

            ResData.prototype.msg = "";
            /**
             * ResData data.
             * @member {gem3Proto.IInfoData|null|undefined} data
             * @memberof gem3Proto.ResData
             * @instance
             */

            ResData.prototype.data = null;
            /**
             * Encodes the specified ResData message. Does not implicitly {@link gem3Proto.ResData.verify|verify} messages.
             * @function encode
             * @memberof gem3Proto.ResData
             * @static
             * @param {gem3Proto.IResData} message ResData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */

            ResData.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.ret != null && Object.hasOwnProperty.call(message, "ret")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.ret);
              if (message.type != null && Object.hasOwnProperty.call(message, "type")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int32(message.type);
              if (message.token != null && Object.hasOwnProperty.call(message, "token")) writer.uint32(
              /* id 3, wireType 2 =*/
              26).string(message.token);
              if (message.msg != null && Object.hasOwnProperty.call(message, "msg")) writer.uint32(
              /* id 4, wireType 2 =*/
              34).string(message.msg);
              if (message.data != null && Object.hasOwnProperty.call(message, "data")) $root.gem3Proto.InfoData.encode(message.data, writer.uint32(
              /* id 5, wireType 2 =*/
              42).fork()).ldelim();
              return writer;
            };
            /**
             * Decodes a ResData message from the specified reader or buffer.
             * @function decode
             * @memberof gem3Proto.ResData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gem3Proto.ResData} ResData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            ResData.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gem3Proto.ResData();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.ret = reader.int32();
                    break;

                  case 2:
                    message.type = reader.int32();
                    break;

                  case 3:
                    message.token = reader.string();
                    break;

                  case 4:
                    message.msg = reader.string();
                    break;

                  case 5:
                    message.data = $root.gem3Proto.InfoData.decode(reader, reader.uint32());
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };

            return ResData;
          }();

          gem3Proto.SpinAllData = function () {
            /**
             * Properties of a SpinAllData.
             * @memberof gem3Proto
             * @interface ISpinAllData
             * @property {gem3Proto.ISpinAck|null} [info] SpinAllData info
             * @property {gem3Proto.IServiceData|null} [serviceInfo] SpinAllData serviceInfo
             * @property {gem3Proto.IJPInfoAck|null} [jpinfo] SpinAllData jpinfo
             * @property {Uint8Array|null} [serviceProto] SpinAllData serviceProto
             */

            /**
             * Constructs a new SpinAllData.
             * @memberof gem3Proto
             * @classdesc Represents a SpinAllData.
             * @implements ISpinAllData
             * @constructor
             * @param {gem3Proto.ISpinAllData=} [properties] Properties to set
             */
            function SpinAllData(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * SpinAllData info.
             * @member {gem3Proto.ISpinAck|null|undefined} info
             * @memberof gem3Proto.SpinAllData
             * @instance
             */


            SpinAllData.prototype.info = null;
            /**
             * SpinAllData serviceInfo.
             * @member {gem3Proto.IServiceData|null|undefined} serviceInfo
             * @memberof gem3Proto.SpinAllData
             * @instance
             */

            SpinAllData.prototype.serviceInfo = null;
            /**
             * SpinAllData jpinfo.
             * @member {gem3Proto.IJPInfoAck|null|undefined} jpinfo
             * @memberof gem3Proto.SpinAllData
             * @instance
             */

            SpinAllData.prototype.jpinfo = null;
            /**
             * SpinAllData serviceProto.
             * @member {Uint8Array} serviceProto
             * @memberof gem3Proto.SpinAllData
             * @instance
             */

            SpinAllData.prototype.serviceProto = $util.newBuffer([]);
            /**
             * Encodes the specified SpinAllData message. Does not implicitly {@link gem3Proto.SpinAllData.verify|verify} messages.
             * @function encode
             * @memberof gem3Proto.SpinAllData
             * @static
             * @param {gem3Proto.ISpinAllData} message SpinAllData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */

            SpinAllData.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.info != null && Object.hasOwnProperty.call(message, "info")) $root.gem3Proto.SpinAck.encode(message.info, writer.uint32(
              /* id 1, wireType 2 =*/
              10).fork()).ldelim();
              if (message.serviceInfo != null && Object.hasOwnProperty.call(message, "serviceInfo")) $root.gem3Proto.ServiceData.encode(message.serviceInfo, writer.uint32(
              /* id 2, wireType 2 =*/
              18).fork()).ldelim();
              if (message.jpinfo != null && Object.hasOwnProperty.call(message, "jpinfo")) $root.gem3Proto.JPInfoAck.encode(message.jpinfo, writer.uint32(
              /* id 3, wireType 2 =*/
              26).fork()).ldelim();
              if (message.serviceProto != null && Object.hasOwnProperty.call(message, "serviceProto")) writer.uint32(
              /* id 4, wireType 2 =*/
              34).bytes(message.serviceProto);
              return writer;
            };
            /**
             * Decodes a SpinAllData message from the specified reader or buffer.
             * @function decode
             * @memberof gem3Proto.SpinAllData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gem3Proto.SpinAllData} SpinAllData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            SpinAllData.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gem3Proto.SpinAllData();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.info = $root.gem3Proto.SpinAck.decode(reader, reader.uint32());
                    break;

                  case 2:
                    message.serviceInfo = $root.gem3Proto.ServiceData.decode(reader, reader.uint32());
                    break;

                  case 3:
                    message.jpinfo = $root.gem3Proto.JPInfoAck.decode(reader, reader.uint32());
                    break;

                  case 4:
                    message.serviceProto = reader.bytes();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };

            return SpinAllData;
          }();

          gem3Proto.ServiceData = function () {
            /**
             * Properties of a ServiceData.
             * @memberof gem3Proto
             * @interface IServiceData
             * @property {number|null} [missionReward] ServiceData missionReward
             * @property {number|null} [jpType] ServiceData jpType
             * @property {number|null} [jpWin] ServiceData jpWin
             * @property {number|null} [fullJpWin] ServiceData fullJpWin
             * @property {number|null} [trialfinish] ServiceData trialfinish
             * @property {number|null} [trialaward] ServiceData trialaward
             * @property {number|null} [freeremain] ServiceData freeremain
             */

            /**
             * Constructs a new ServiceData.
             * @memberof gem3Proto
             * @classdesc Represents a ServiceData.
             * @implements IServiceData
             * @constructor
             * @param {gem3Proto.IServiceData=} [properties] Properties to set
             */
            function ServiceData(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * ServiceData missionReward.
             * @member {number} missionReward
             * @memberof gem3Proto.ServiceData
             * @instance
             */


            ServiceData.prototype.missionReward = 0;
            /**
             * ServiceData jpType.
             * @member {number} jpType
             * @memberof gem3Proto.ServiceData
             * @instance
             */

            ServiceData.prototype.jpType = 0;
            /**
             * ServiceData jpWin.
             * @member {number} jpWin
             * @memberof gem3Proto.ServiceData
             * @instance
             */

            ServiceData.prototype.jpWin = 0;
            /**
             * ServiceData fullJpWin.
             * @member {number} fullJpWin
             * @memberof gem3Proto.ServiceData
             * @instance
             */

            ServiceData.prototype.fullJpWin = 0;
            /**
             * ServiceData trialfinish.
             * @member {number} trialfinish
             * @memberof gem3Proto.ServiceData
             * @instance
             */

            ServiceData.prototype.trialfinish = 0;
            /**
             * ServiceData trialaward.
             * @member {number} trialaward
             * @memberof gem3Proto.ServiceData
             * @instance
             */

            ServiceData.prototype.trialaward = 0;
            /**
             * ServiceData freeremain.
             * @member {number} freeremain
             * @memberof gem3Proto.ServiceData
             * @instance
             */

            ServiceData.prototype.freeremain = 0;
            /**
             * Encodes the specified ServiceData message. Does not implicitly {@link gem3Proto.ServiceData.verify|verify} messages.
             * @function encode
             * @memberof gem3Proto.ServiceData
             * @static
             * @param {gem3Proto.IServiceData} message ServiceData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */

            ServiceData.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.missionReward != null && Object.hasOwnProperty.call(message, "missionReward")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).uint32(message.missionReward);
              if (message.jpType != null && Object.hasOwnProperty.call(message, "jpType")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int32(message.jpType);
              if (message.jpWin != null && Object.hasOwnProperty.call(message, "jpWin")) writer.uint32(
              /* id 3, wireType 1 =*/
              25)["double"](message.jpWin);
              if (message.fullJpWin != null && Object.hasOwnProperty.call(message, "fullJpWin")) writer.uint32(
              /* id 4, wireType 1 =*/
              33)["double"](message.fullJpWin);
              if (message.trialfinish != null && Object.hasOwnProperty.call(message, "trialfinish")) writer.uint32(
              /* id 5, wireType 0 =*/
              40).int32(message.trialfinish);
              if (message.trialaward != null && Object.hasOwnProperty.call(message, "trialaward")) writer.uint32(
              /* id 6, wireType 0 =*/
              48).int32(message.trialaward);
              if (message.freeremain != null && Object.hasOwnProperty.call(message, "freeremain")) writer.uint32(
              /* id 7, wireType 0 =*/
              56).int32(message.freeremain);
              return writer;
            };
            /**
             * Decodes a ServiceData message from the specified reader or buffer.
             * @function decode
             * @memberof gem3Proto.ServiceData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gem3Proto.ServiceData} ServiceData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            ServiceData.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gem3Proto.ServiceData();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.missionReward = reader.uint32();
                    break;

                  case 2:
                    message.jpType = reader.int32();
                    break;

                  case 3:
                    message.jpWin = reader["double"]();
                    break;

                  case 4:
                    message.fullJpWin = reader["double"]();
                    break;

                  case 5:
                    message.trialfinish = reader.int32();
                    break;

                  case 6:
                    message.trialaward = reader.int32();
                    break;

                  case 7:
                    message.freeremain = reader.int32();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };

            return ServiceData;
          }();

          gem3Proto.WalletInfo = function () {
            /**
             * Properties of a WalletInfo.
             * @memberof gem3Proto
             * @interface IWalletInfo
             * @property {number|null} [currencyNumber] WalletInfo currencyNumber
             * @property {string|null} [currencyName] WalletInfo currencyName
             * @property {string|null} [currencySymbol] WalletInfo currencySymbol
             * @property {number|null} [coin] WalletInfo coin
             * @property {Array.<number>|null} [bet] WalletInfo bet
             * @property {number|null} [unit] WalletInfo unit
             * @property {number|null} [ratio] WalletInfo ratio
             * @property {number|null} [rate] WalletInfo rate
             * @property {number|null} [upper] WalletInfo upper
             * @property {number|null} [lower] WalletInfo lower
             * @property {number|null} [cycle] WalletInfo cycle
             * @property {number|null} [decimal] WalletInfo decimal
             */

            /**
             * Constructs a new WalletInfo.
             * @memberof gem3Proto
             * @classdesc Represents a WalletInfo.
             * @implements IWalletInfo
             * @constructor
             * @param {gem3Proto.IWalletInfo=} [properties] Properties to set
             */
            function WalletInfo(properties) {
              this.bet = [];
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * WalletInfo currencyNumber.
             * @member {number} currencyNumber
             * @memberof gem3Proto.WalletInfo
             * @instance
             */


            WalletInfo.prototype.currencyNumber = 0;
            /**
             * WalletInfo currencyName.
             * @member {string} currencyName
             * @memberof gem3Proto.WalletInfo
             * @instance
             */

            WalletInfo.prototype.currencyName = "";
            /**
             * WalletInfo currencySymbol.
             * @member {string} currencySymbol
             * @memberof gem3Proto.WalletInfo
             * @instance
             */

            WalletInfo.prototype.currencySymbol = "";
            /**
             * WalletInfo coin.
             * @member {number} coin
             * @memberof gem3Proto.WalletInfo
             * @instance
             */

            WalletInfo.prototype.coin = 0;
            /**
             * WalletInfo bet.
             * @member {Array.<number>} bet
             * @memberof gem3Proto.WalletInfo
             * @instance
             */

            WalletInfo.prototype.bet = $util.emptyArray;
            /**
             * WalletInfo unit.
             * @member {number} unit
             * @memberof gem3Proto.WalletInfo
             * @instance
             */

            WalletInfo.prototype.unit = 0;
            /**
             * WalletInfo ratio.
             * @member {number} ratio
             * @memberof gem3Proto.WalletInfo
             * @instance
             */

            WalletInfo.prototype.ratio = 0;
            /**
             * WalletInfo rate.
             * @member {number} rate
             * @memberof gem3Proto.WalletInfo
             * @instance
             */

            WalletInfo.prototype.rate = 0;
            /**
             * WalletInfo upper.
             * @member {number} upper
             * @memberof gem3Proto.WalletInfo
             * @instance
             */

            WalletInfo.prototype.upper = 0;
            /**
             * WalletInfo lower.
             * @member {number} lower
             * @memberof gem3Proto.WalletInfo
             * @instance
             */

            WalletInfo.prototype.lower = 0;
            /**
             * WalletInfo cycle.
             * @member {number} cycle
             * @memberof gem3Proto.WalletInfo
             * @instance
             */

            WalletInfo.prototype.cycle = 0;
            /**
             * WalletInfo decimal.
             * @member {number} decimal
             * @memberof gem3Proto.WalletInfo
             * @instance
             */

            WalletInfo.prototype.decimal = 0;
            /**
             * Encodes the specified WalletInfo message. Does not implicitly {@link gem3Proto.WalletInfo.verify|verify} messages.
             * @function encode
             * @memberof gem3Proto.WalletInfo
             * @static
             * @param {gem3Proto.IWalletInfo} message WalletInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */

            WalletInfo.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.currencyNumber != null && Object.hasOwnProperty.call(message, "currencyNumber")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.currencyNumber);
              if (message.currencyName != null && Object.hasOwnProperty.call(message, "currencyName")) writer.uint32(
              /* id 2, wireType 2 =*/
              18).string(message.currencyName);
              if (message.currencySymbol != null && Object.hasOwnProperty.call(message, "currencySymbol")) writer.uint32(
              /* id 3, wireType 2 =*/
              26).string(message.currencySymbol);
              if (message.coin != null && Object.hasOwnProperty.call(message, "coin")) writer.uint32(
              /* id 4, wireType 1 =*/
              33)["double"](message.coin);

              if (message.bet != null && message.bet.length) {
                writer.uint32(
                /* id 5, wireType 2 =*/
                42).fork();

                for (var i = 0; i < message.bet.length; ++i) {
                  writer["double"](message.bet[i]);
                }

                writer.ldelim();
              }

              if (message.unit != null && Object.hasOwnProperty.call(message, "unit")) writer.uint32(
              /* id 6, wireType 1 =*/
              49)["double"](message.unit);
              if (message.ratio != null && Object.hasOwnProperty.call(message, "ratio")) writer.uint32(
              /* id 7, wireType 1 =*/
              57)["double"](message.ratio);
              if (message.rate != null && Object.hasOwnProperty.call(message, "rate")) writer.uint32(
              /* id 8, wireType 1 =*/
              65)["double"](message.rate);
              if (message.upper != null && Object.hasOwnProperty.call(message, "upper")) writer.uint32(
              /* id 9, wireType 1 =*/
              73)["double"](message.upper);
              if (message.lower != null && Object.hasOwnProperty.call(message, "lower")) writer.uint32(
              /* id 10, wireType 1 =*/
              81)["double"](message.lower);
              if (message.cycle != null && Object.hasOwnProperty.call(message, "cycle")) writer.uint32(
              /* id 11, wireType 0 =*/
              88).int32(message.cycle);
              if (message.decimal != null && Object.hasOwnProperty.call(message, "decimal")) writer.uint32(
              /* id 12, wireType 0 =*/
              96).int32(message.decimal);
              return writer;
            };
            /**
             * Decodes a WalletInfo message from the specified reader or buffer.
             * @function decode
             * @memberof gem3Proto.WalletInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gem3Proto.WalletInfo} WalletInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            WalletInfo.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gem3Proto.WalletInfo();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.currencyNumber = reader.int32();
                    break;

                  case 2:
                    message.currencyName = reader.string();
                    break;

                  case 3:
                    message.currencySymbol = reader.string();
                    break;

                  case 4:
                    message.coin = reader["double"]();
                    break;

                  case 5:
                    if (!(message.bet && message.bet.length)) message.bet = [];

                    if ((tag & 7) === 2) {
                      var end2 = reader.uint32() + reader.pos;

                      while (reader.pos < end2) {
                        message.bet.push(reader["double"]());
                      }
                    } else message.bet.push(reader["double"]());

                    break;

                  case 6:
                    message.unit = reader["double"]();
                    break;

                  case 7:
                    message.ratio = reader["double"]();
                    break;

                  case 8:
                    message.rate = reader["double"]();
                    break;

                  case 9:
                    message.upper = reader["double"]();
                    break;

                  case 10:
                    message.lower = reader["double"]();
                    break;

                  case 11:
                    message.cycle = reader.int32();
                    break;

                  case 12:
                    message.decimal = reader.int32();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };

            return WalletInfo;
          }();

          gem3Proto.PreferRoundShow = function () {
            /**
             * Properties of a PreferRoundShow.
             * @memberof gem3Proto
             * @interface IPreferRoundShow
             * @property {number|null} [BaseRound] PreferRoundShow BaseRound
             * @property {number|null} [SigmaRound] PreferRoundShow SigmaRound
             * @property {number|null} [CV] PreferRoundShow CV
             * @property {number|null} [HR] PreferRoundShow HR
             * @property {number|null} [MGR] PreferRoundShow MGR
             * @property {number|null} [Range] PreferRoundShow Range
             * @property {number|null} [Show] PreferRoundShow Show
             */

            /**
             * Constructs a new PreferRoundShow.
             * @memberof gem3Proto
             * @classdesc Represents a PreferRoundShow.
             * @implements IPreferRoundShow
             * @constructor
             * @param {gem3Proto.IPreferRoundShow=} [properties] Properties to set
             */
            function PreferRoundShow(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * PreferRoundShow BaseRound.
             * @member {number} BaseRound
             * @memberof gem3Proto.PreferRoundShow
             * @instance
             */


            PreferRoundShow.prototype.BaseRound = 0;
            /**
             * PreferRoundShow SigmaRound.
             * @member {number} SigmaRound
             * @memberof gem3Proto.PreferRoundShow
             * @instance
             */

            PreferRoundShow.prototype.SigmaRound = 0;
            /**
             * PreferRoundShow CV.
             * @member {number} CV
             * @memberof gem3Proto.PreferRoundShow
             * @instance
             */

            PreferRoundShow.prototype.CV = 0;
            /**
             * PreferRoundShow HR.
             * @member {number} HR
             * @memberof gem3Proto.PreferRoundShow
             * @instance
             */

            PreferRoundShow.prototype.HR = 0;
            /**
             * PreferRoundShow MGR.
             * @member {number} MGR
             * @memberof gem3Proto.PreferRoundShow
             * @instance
             */

            PreferRoundShow.prototype.MGR = 0;
            /**
             * PreferRoundShow Range.
             * @member {number} Range
             * @memberof gem3Proto.PreferRoundShow
             * @instance
             */

            PreferRoundShow.prototype.Range = 0;
            /**
             * PreferRoundShow Show.
             * @member {number} Show
             * @memberof gem3Proto.PreferRoundShow
             * @instance
             */

            PreferRoundShow.prototype.Show = 0;
            /**
             * Encodes the specified PreferRoundShow message. Does not implicitly {@link gem3Proto.PreferRoundShow.verify|verify} messages.
             * @function encode
             * @memberof gem3Proto.PreferRoundShow
             * @static
             * @param {gem3Proto.IPreferRoundShow} message PreferRoundShow message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */

            PreferRoundShow.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.BaseRound != null && Object.hasOwnProperty.call(message, "BaseRound")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.BaseRound);
              if (message.SigmaRound != null && Object.hasOwnProperty.call(message, "SigmaRound")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int32(message.SigmaRound);
              if (message.CV != null && Object.hasOwnProperty.call(message, "CV")) writer.uint32(
              /* id 3, wireType 1 =*/
              25)["double"](message.CV);
              if (message.HR != null && Object.hasOwnProperty.call(message, "HR")) writer.uint32(
              /* id 4, wireType 1 =*/
              33)["double"](message.HR);
              if (message.MGR != null && Object.hasOwnProperty.call(message, "MGR")) writer.uint32(
              /* id 5, wireType 1 =*/
              41)["double"](message.MGR);
              if (message.Range != null && Object.hasOwnProperty.call(message, "Range")) writer.uint32(
              /* id 6, wireType 0 =*/
              48).int32(message.Range);
              if (message.Show != null && Object.hasOwnProperty.call(message, "Show")) writer.uint32(
              /* id 7, wireType 0 =*/
              56).int32(message.Show);
              return writer;
            };
            /**
             * Decodes a PreferRoundShow message from the specified reader or buffer.
             * @function decode
             * @memberof gem3Proto.PreferRoundShow
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gem3Proto.PreferRoundShow} PreferRoundShow
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            PreferRoundShow.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gem3Proto.PreferRoundShow();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.BaseRound = reader.int32();
                    break;

                  case 2:
                    message.SigmaRound = reader.int32();
                    break;

                  case 3:
                    message.CV = reader["double"]();
                    break;

                  case 4:
                    message.HR = reader["double"]();
                    break;

                  case 5:
                    message.MGR = reader["double"]();
                    break;

                  case 6:
                    message.Range = reader.int32();
                    break;

                  case 7:
                    message.Show = reader.int32();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };

            return PreferRoundShow;
          }();

          gem3Proto.CheckMallReq = function () {
            /**
             * Properties of a CheckMallReq.
             * @memberof gem3Proto
             * @interface ICheckMallReq
             * @property {number|null} [Currency] CheckMallReq Currency
             */

            /**
             * Constructs a new CheckMallReq.
             * @memberof gem3Proto
             * @classdesc Represents a CheckMallReq.
             * @implements ICheckMallReq
             * @constructor
             * @param {gem3Proto.ICheckMallReq=} [properties] Properties to set
             */
            function CheckMallReq(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * CheckMallReq Currency.
             * @member {number} Currency
             * @memberof gem3Proto.CheckMallReq
             * @instance
             */


            CheckMallReq.prototype.Currency = 0;
            /**
             * Encodes the specified CheckMallReq message. Does not implicitly {@link gem3Proto.CheckMallReq.verify|verify} messages.
             * @function encode
             * @memberof gem3Proto.CheckMallReq
             * @static
             * @param {gem3Proto.ICheckMallReq} message CheckMallReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */

            CheckMallReq.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.Currency != null && Object.hasOwnProperty.call(message, "Currency")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.Currency);
              return writer;
            };
            /**
             * Decodes a CheckMallReq message from the specified reader or buffer.
             * @function decode
             * @memberof gem3Proto.CheckMallReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gem3Proto.CheckMallReq} CheckMallReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            CheckMallReq.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gem3Proto.CheckMallReq();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.Currency = reader.int32();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };

            return CheckMallReq;
          }();

          gem3Proto.CheckMallAck = function () {
            /**
             * Properties of a CheckMallAck.
             * @memberof gem3Proto
             * @interface ICheckMallAck
             * @property {Array.<gem3Proto.IGameMallSetting>|null} [Settings] CheckMallAck Settings
             * @property {number|null} [Show] CheckMallAck Show
             */

            /**
             * Constructs a new CheckMallAck.
             * @memberof gem3Proto
             * @classdesc Represents a CheckMallAck.
             * @implements ICheckMallAck
             * @constructor
             * @param {gem3Proto.ICheckMallAck=} [properties] Properties to set
             */
            function CheckMallAck(properties) {
              this.Settings = [];
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * CheckMallAck Settings.
             * @member {Array.<gem3Proto.IGameMallSetting>} Settings
             * @memberof gem3Proto.CheckMallAck
             * @instance
             */


            CheckMallAck.prototype.Settings = $util.emptyArray;
            /**
             * CheckMallAck Show.
             * @member {number} Show
             * @memberof gem3Proto.CheckMallAck
             * @instance
             */

            CheckMallAck.prototype.Show = 0;
            /**
             * Encodes the specified CheckMallAck message. Does not implicitly {@link gem3Proto.CheckMallAck.verify|verify} messages.
             * @function encode
             * @memberof gem3Proto.CheckMallAck
             * @static
             * @param {gem3Proto.ICheckMallAck} message CheckMallAck message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */

            CheckMallAck.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.Settings != null && message.Settings.length) for (var i = 0; i < message.Settings.length; ++i) {
                $root.gem3Proto.GameMallSetting.encode(message.Settings[i], writer.uint32(
                /* id 1, wireType 2 =*/
                10).fork()).ldelim();
              }
              if (message.Show != null && Object.hasOwnProperty.call(message, "Show")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int32(message.Show);
              return writer;
            };
            /**
             * Decodes a CheckMallAck message from the specified reader or buffer.
             * @function decode
             * @memberof gem3Proto.CheckMallAck
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gem3Proto.CheckMallAck} CheckMallAck
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            CheckMallAck.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gem3Proto.CheckMallAck();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    if (!(message.Settings && message.Settings.length)) message.Settings = [];
                    message.Settings.push($root.gem3Proto.GameMallSetting.decode(reader, reader.uint32()));
                    break;

                  case 2:
                    message.Show = reader.int32();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };

            return CheckMallAck;
          }();

          gem3Proto.GameMallSetting = function () {
            /**
             * Properties of a GameMallSetting.
             * @memberof gem3Proto
             * @interface IGameMallSetting
             * @property {number|null} [GameID] GameMallSetting GameID
             * @property {number|null} [APIID] GameMallSetting APIID
             * @property {number|null} [AlterID] GameMallSetting AlterID
             * @property {number|null} [DescType] GameMallSetting DescType
             * @property {number|null} [DescRounds] GameMallSetting DescRounds
             * @property {number|null} [MaxBet] GameMallSetting MaxBet
             * @property {number|null} [PriceOdd] GameMallSetting PriceOdd
             * @property {boolean|null} [ForSale] GameMallSetting ForSale
             * @property {Array.<number>|null} [BetVec] GameMallSetting BetVec
             * @property {number|null} [ReelNo] GameMallSetting ReelNo
             * @property {number|null} [BetNo] GameMallSetting BetNo
             * @property {boolean|null} [Event] GameMallSetting Event
             */

            /**
             * Constructs a new GameMallSetting.
             * @memberof gem3Proto
             * @classdesc Represents a GameMallSetting.
             * @implements IGameMallSetting
             * @constructor
             * @param {gem3Proto.IGameMallSetting=} [properties] Properties to set
             */
            function GameMallSetting(properties) {
              this.BetVec = [];
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * GameMallSetting GameID.
             * @member {number} GameID
             * @memberof gem3Proto.GameMallSetting
             * @instance
             */


            GameMallSetting.prototype.GameID = 0;
            /**
             * GameMallSetting APIID.
             * @member {number} APIID
             * @memberof gem3Proto.GameMallSetting
             * @instance
             */

            GameMallSetting.prototype.APIID = 0;
            /**
             * GameMallSetting AlterID.
             * @member {number} AlterID
             * @memberof gem3Proto.GameMallSetting
             * @instance
             */

            GameMallSetting.prototype.AlterID = 0;
            /**
             * GameMallSetting DescType.
             * @member {number} DescType
             * @memberof gem3Proto.GameMallSetting
             * @instance
             */

            GameMallSetting.prototype.DescType = 0;
            /**
             * GameMallSetting DescRounds.
             * @member {number} DescRounds
             * @memberof gem3Proto.GameMallSetting
             * @instance
             */

            GameMallSetting.prototype.DescRounds = 0;
            /**
             * GameMallSetting MaxBet.
             * @member {number} MaxBet
             * @memberof gem3Proto.GameMallSetting
             * @instance
             */

            GameMallSetting.prototype.MaxBet = 0;
            /**
             * GameMallSetting PriceOdd.
             * @member {number} PriceOdd
             * @memberof gem3Proto.GameMallSetting
             * @instance
             */

            GameMallSetting.prototype.PriceOdd = 0;
            /**
             * GameMallSetting ForSale.
             * @member {boolean} ForSale
             * @memberof gem3Proto.GameMallSetting
             * @instance
             */

            GameMallSetting.prototype.ForSale = false;
            /**
             * GameMallSetting BetVec.
             * @member {Array.<number>} BetVec
             * @memberof gem3Proto.GameMallSetting
             * @instance
             */

            GameMallSetting.prototype.BetVec = $util.emptyArray;
            /**
             * GameMallSetting ReelNo.
             * @member {number} ReelNo
             * @memberof gem3Proto.GameMallSetting
             * @instance
             */

            GameMallSetting.prototype.ReelNo = 0;
            /**
             * GameMallSetting BetNo.
             * @member {number} BetNo
             * @memberof gem3Proto.GameMallSetting
             * @instance
             */

            GameMallSetting.prototype.BetNo = 0;
            /**
             * GameMallSetting Event.
             * @member {boolean} Event
             * @memberof gem3Proto.GameMallSetting
             * @instance
             */

            GameMallSetting.prototype.Event = false;
            /**
             * Encodes the specified GameMallSetting message. Does not implicitly {@link gem3Proto.GameMallSetting.verify|verify} messages.
             * @function encode
             * @memberof gem3Proto.GameMallSetting
             * @static
             * @param {gem3Proto.IGameMallSetting} message GameMallSetting message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */

            GameMallSetting.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.GameID != null && Object.hasOwnProperty.call(message, "GameID")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.GameID);
              if (message.APIID != null && Object.hasOwnProperty.call(message, "APIID")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int32(message.APIID);
              if (message.AlterID != null && Object.hasOwnProperty.call(message, "AlterID")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.AlterID);
              if (message.DescType != null && Object.hasOwnProperty.call(message, "DescType")) writer.uint32(
              /* id 4, wireType 0 =*/
              32).int32(message.DescType);
              if (message.DescRounds != null && Object.hasOwnProperty.call(message, "DescRounds")) writer.uint32(
              /* id 5, wireType 0 =*/
              40).int32(message.DescRounds);
              if (message.MaxBet != null && Object.hasOwnProperty.call(message, "MaxBet")) writer.uint32(
              /* id 6, wireType 1 =*/
              49)["double"](message.MaxBet);
              if (message.PriceOdd != null && Object.hasOwnProperty.call(message, "PriceOdd")) writer.uint32(
              /* id 7, wireType 1 =*/
              57)["double"](message.PriceOdd);
              if (message.ForSale != null && Object.hasOwnProperty.call(message, "ForSale")) writer.uint32(
              /* id 8, wireType 0 =*/
              64).bool(message.ForSale);

              if (message.BetVec != null && message.BetVec.length) {
                writer.uint32(
                /* id 9, wireType 2 =*/
                74).fork();

                for (var i = 0; i < message.BetVec.length; ++i) {
                  writer["double"](message.BetVec[i]);
                }

                writer.ldelim();
              }

              if (message.ReelNo != null && Object.hasOwnProperty.call(message, "ReelNo")) writer.uint32(
              /* id 10, wireType 0 =*/
              80).int32(message.ReelNo);
              if (message.BetNo != null && Object.hasOwnProperty.call(message, "BetNo")) writer.uint32(
              /* id 11, wireType 0 =*/
              88).int32(message.BetNo);
              if (message.Event != null && Object.hasOwnProperty.call(message, "Event")) writer.uint32(
              /* id 12, wireType 0 =*/
              96).bool(message.Event);
              return writer;
            };
            /**
             * Decodes a GameMallSetting message from the specified reader or buffer.
             * @function decode
             * @memberof gem3Proto.GameMallSetting
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gem3Proto.GameMallSetting} GameMallSetting
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            GameMallSetting.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gem3Proto.GameMallSetting();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.GameID = reader.int32();
                    break;

                  case 2:
                    message.APIID = reader.int32();
                    break;

                  case 3:
                    message.AlterID = reader.int32();
                    break;

                  case 4:
                    message.DescType = reader.int32();
                    break;

                  case 5:
                    message.DescRounds = reader.int32();
                    break;

                  case 6:
                    message.MaxBet = reader["double"]();
                    break;

                  case 7:
                    message.PriceOdd = reader["double"]();
                    break;

                  case 8:
                    message.ForSale = reader.bool();
                    break;

                  case 9:
                    if (!(message.BetVec && message.BetVec.length)) message.BetVec = [];

                    if ((tag & 7) === 2) {
                      var end2 = reader.uint32() + reader.pos;

                      while (reader.pos < end2) {
                        message.BetVec.push(reader["double"]());
                      }
                    } else message.BetVec.push(reader["double"]());

                    break;

                  case 10:
                    message.ReelNo = reader.int32();
                    break;

                  case 11:
                    message.BetNo = reader.int32();
                    break;

                  case 12:
                    message.Event = reader.bool();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };

            return GameMallSetting;
          }();

          gem3Proto.LoginDataAck = function () {
            /**
             * Properties of a LoginDataAck.
             * @memberof gem3Proto
             * @interface ILoginDataAck
             * @property {number|null} [result] LoginDataAck result
             * @property {number|null} [aid] LoginDataAck aid
             */

            /**
             * Constructs a new LoginDataAck.
             * @memberof gem3Proto
             * @classdesc Represents a LoginDataAck.
             * @implements ILoginDataAck
             * @constructor
             * @param {gem3Proto.ILoginDataAck=} [properties] Properties to set
             */
            function LoginDataAck(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * LoginDataAck result.
             * @member {number} result
             * @memberof gem3Proto.LoginDataAck
             * @instance
             */


            LoginDataAck.prototype.result = 0;
            /**
             * LoginDataAck aid.
             * @member {number} aid
             * @memberof gem3Proto.LoginDataAck
             * @instance
             */

            LoginDataAck.prototype.aid = 0;
            /**
             * Encodes the specified LoginDataAck message. Does not implicitly {@link gem3Proto.LoginDataAck.verify|verify} messages.
             * @function encode
             * @memberof gem3Proto.LoginDataAck
             * @static
             * @param {gem3Proto.ILoginDataAck} message LoginDataAck message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */

            LoginDataAck.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.result != null && Object.hasOwnProperty.call(message, "result")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.result);
              if (message.aid != null && Object.hasOwnProperty.call(message, "aid")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int32(message.aid);
              return writer;
            };
            /**
             * Decodes a LoginDataAck message from the specified reader or buffer.
             * @function decode
             * @memberof gem3Proto.LoginDataAck
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gem3Proto.LoginDataAck} LoginDataAck
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            LoginDataAck.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gem3Proto.LoginDataAck();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.result = reader.int32();
                    break;

                  case 2:
                    message.aid = reader.int32();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };

            return LoginDataAck;
          }();

          gem3Proto.LoginDataReq = function () {
            /**
             * Properties of a LoginDataReq.
             * @memberof gem3Proto
             * @interface ILoginDataReq
             * @property {string|null} [Token] LoginDataReq Token
             * @property {number|null} [Source] LoginDataReq Source
             * @property {string|null} [OSType] LoginDataReq OSType
             * @property {string|null} [OSVersion] LoginDataReq OSVersion
             * @property {string|null} [Browser] LoginDataReq Browser
             * @property {string|null} [BrowserVersion] LoginDataReq BrowserVersion
             * @property {number|null} [BrowserTag] LoginDataReq BrowserTag
             * @property {string|null} [Machine] LoginDataReq Machine
             * @property {number|null} [Width] LoginDataReq Width
             * @property {number|null} [Height] LoginDataReq Height
             * @property {number|null} [Ratio] LoginDataReq Ratio
             * @property {string|null} [Language] LoginDataReq Language
             * @property {number|null} [Cheat] LoginDataReq Cheat
             */

            /**
             * Constructs a new LoginDataReq.
             * @memberof gem3Proto
             * @classdesc Represents a LoginDataReq.
             * @implements ILoginDataReq
             * @constructor
             * @param {gem3Proto.ILoginDataReq=} [properties] Properties to set
             */
            function LoginDataReq(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * LoginDataReq Token.
             * @member {string} Token
             * @memberof gem3Proto.LoginDataReq
             * @instance
             */


            LoginDataReq.prototype.Token = "";
            /**
             * LoginDataReq Source.
             * @member {number} Source
             * @memberof gem3Proto.LoginDataReq
             * @instance
             */

            LoginDataReq.prototype.Source = 0;
            /**
             * LoginDataReq OSType.
             * @member {string} OSType
             * @memberof gem3Proto.LoginDataReq
             * @instance
             */

            LoginDataReq.prototype.OSType = "";
            /**
             * LoginDataReq OSVersion.
             * @member {string} OSVersion
             * @memberof gem3Proto.LoginDataReq
             * @instance
             */

            LoginDataReq.prototype.OSVersion = "";
            /**
             * LoginDataReq Browser.
             * @member {string} Browser
             * @memberof gem3Proto.LoginDataReq
             * @instance
             */

            LoginDataReq.prototype.Browser = "";
            /**
             * LoginDataReq BrowserVersion.
             * @member {string} BrowserVersion
             * @memberof gem3Proto.LoginDataReq
             * @instance
             */

            LoginDataReq.prototype.BrowserVersion = "";
            /**
             * LoginDataReq BrowserTag.
             * @member {number} BrowserTag
             * @memberof gem3Proto.LoginDataReq
             * @instance
             */

            LoginDataReq.prototype.BrowserTag = 0;
            /**
             * LoginDataReq Machine.
             * @member {string} Machine
             * @memberof gem3Proto.LoginDataReq
             * @instance
             */

            LoginDataReq.prototype.Machine = "";
            /**
             * LoginDataReq Width.
             * @member {number} Width
             * @memberof gem3Proto.LoginDataReq
             * @instance
             */

            LoginDataReq.prototype.Width = 0;
            /**
             * LoginDataReq Height.
             * @member {number} Height
             * @memberof gem3Proto.LoginDataReq
             * @instance
             */

            LoginDataReq.prototype.Height = 0;
            /**
             * LoginDataReq Ratio.
             * @member {number} Ratio
             * @memberof gem3Proto.LoginDataReq
             * @instance
             */

            LoginDataReq.prototype.Ratio = 0;
            /**
             * LoginDataReq Language.
             * @member {string} Language
             * @memberof gem3Proto.LoginDataReq
             * @instance
             */

            LoginDataReq.prototype.Language = "";
            /**
             * LoginDataReq Cheat.
             * @member {number} Cheat
             * @memberof gem3Proto.LoginDataReq
             * @instance
             */

            LoginDataReq.prototype.Cheat = 0;
            /**
             * Encodes the specified LoginDataReq message. Does not implicitly {@link gem3Proto.LoginDataReq.verify|verify} messages.
             * @function encode
             * @memberof gem3Proto.LoginDataReq
             * @static
             * @param {gem3Proto.ILoginDataReq} message LoginDataReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */

            LoginDataReq.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.Token != null && Object.hasOwnProperty.call(message, "Token")) writer.uint32(
              /* id 1, wireType 2 =*/
              10).string(message.Token);
              if (message.Source != null && Object.hasOwnProperty.call(message, "Source")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int32(message.Source);
              if (message.OSType != null && Object.hasOwnProperty.call(message, "OSType")) writer.uint32(
              /* id 3, wireType 2 =*/
              26).string(message.OSType);
              if (message.OSVersion != null && Object.hasOwnProperty.call(message, "OSVersion")) writer.uint32(
              /* id 4, wireType 2 =*/
              34).string(message.OSVersion);
              if (message.Browser != null && Object.hasOwnProperty.call(message, "Browser")) writer.uint32(
              /* id 5, wireType 2 =*/
              42).string(message.Browser);
              if (message.BrowserVersion != null && Object.hasOwnProperty.call(message, "BrowserVersion")) writer.uint32(
              /* id 6, wireType 2 =*/
              50).string(message.BrowserVersion);
              if (message.BrowserTag != null && Object.hasOwnProperty.call(message, "BrowserTag")) writer.uint32(
              /* id 7, wireType 0 =*/
              56).int32(message.BrowserTag);
              if (message.Machine != null && Object.hasOwnProperty.call(message, "Machine")) writer.uint32(
              /* id 8, wireType 2 =*/
              66).string(message.Machine);
              if (message.Width != null && Object.hasOwnProperty.call(message, "Width")) writer.uint32(
              /* id 9, wireType 0 =*/
              72).int32(message.Width);
              if (message.Height != null && Object.hasOwnProperty.call(message, "Height")) writer.uint32(
              /* id 10, wireType 0 =*/
              80).int32(message.Height);
              if (message.Ratio != null && Object.hasOwnProperty.call(message, "Ratio")) writer.uint32(
              /* id 11, wireType 1 =*/
              89)["double"](message.Ratio);
              if (message.Language != null && Object.hasOwnProperty.call(message, "Language")) writer.uint32(
              /* id 12, wireType 2 =*/
              98).string(message.Language);
              if (message.Cheat != null && Object.hasOwnProperty.call(message, "Cheat")) writer.uint32(
              /* id 13, wireType 0 =*/
              104).int32(message.Cheat);
              return writer;
            };
            /**
             * Decodes a LoginDataReq message from the specified reader or buffer.
             * @function decode
             * @memberof gem3Proto.LoginDataReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gem3Proto.LoginDataReq} LoginDataReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            LoginDataReq.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gem3Proto.LoginDataReq();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.Token = reader.string();
                    break;

                  case 2:
                    message.Source = reader.int32();
                    break;

                  case 3:
                    message.OSType = reader.string();
                    break;

                  case 4:
                    message.OSVersion = reader.string();
                    break;

                  case 5:
                    message.Browser = reader.string();
                    break;

                  case 6:
                    message.BrowserVersion = reader.string();
                    break;

                  case 7:
                    message.BrowserTag = reader.int32();
                    break;

                  case 8:
                    message.Machine = reader.string();
                    break;

                  case 9:
                    message.Width = reader.int32();
                    break;

                  case 10:
                    message.Height = reader.int32();
                    break;

                  case 11:
                    message.Ratio = reader["double"]();
                    break;

                  case 12:
                    message.Language = reader.string();
                    break;

                  case 13:
                    message.Cheat = reader.int32();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };

            return LoginDataReq;
          }();

          gem3Proto.LogoutReq = function () {
            /**
             * Properties of a LogoutReq.
             * @memberof gem3Proto
             * @interface ILogoutReq
             * @property {number|null} [aid] LogoutReq aid
             */

            /**
             * Constructs a new LogoutReq.
             * @memberof gem3Proto
             * @classdesc Represents a LogoutReq.
             * @implements ILogoutReq
             * @constructor
             * @param {gem3Proto.ILogoutReq=} [properties] Properties to set
             */
            function LogoutReq(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * LogoutReq aid.
             * @member {number} aid
             * @memberof gem3Proto.LogoutReq
             * @instance
             */


            LogoutReq.prototype.aid = 0;
            /**
             * Encodes the specified LogoutReq message. Does not implicitly {@link gem3Proto.LogoutReq.verify|verify} messages.
             * @function encode
             * @memberof gem3Proto.LogoutReq
             * @static
             * @param {gem3Proto.ILogoutReq} message LogoutReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */

            LogoutReq.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.aid != null && Object.hasOwnProperty.call(message, "aid")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.aid);
              return writer;
            };
            /**
             * Decodes a LogoutReq message from the specified reader or buffer.
             * @function decode
             * @memberof gem3Proto.LogoutReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gem3Proto.LogoutReq} LogoutReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            LogoutReq.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gem3Proto.LogoutReq();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.aid = reader.int32();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };

            return LogoutReq;
          }();

          gem3Proto.HeartAck = function () {
            /**
             * Properties of a HeartAck.
             * @memberof gem3Proto
             * @interface IHeartAck
             * @property {number|null} [state] HeartAck state
             * @property {string|null} [message] HeartAck message
             */

            /**
             * Constructs a new HeartAck.
             * @memberof gem3Proto
             * @classdesc Represents a HeartAck.
             * @implements IHeartAck
             * @constructor
             * @param {gem3Proto.IHeartAck=} [properties] Properties to set
             */
            function HeartAck(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * HeartAck state.
             * @member {number} state
             * @memberof gem3Proto.HeartAck
             * @instance
             */


            HeartAck.prototype.state = 0;
            /**
             * HeartAck message.
             * @member {string} message
             * @memberof gem3Proto.HeartAck
             * @instance
             */

            HeartAck.prototype.message = "";
            /**
             * Encodes the specified HeartAck message. Does not implicitly {@link gem3Proto.HeartAck.verify|verify} messages.
             * @function encode
             * @memberof gem3Proto.HeartAck
             * @static
             * @param {gem3Proto.IHeartAck} message HeartAck message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */

            HeartAck.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.state != null && Object.hasOwnProperty.call(message, "state")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.state);
              if (message.message != null && Object.hasOwnProperty.call(message, "message")) writer.uint32(
              /* id 2, wireType 2 =*/
              18).string(message.message);
              return writer;
            };
            /**
             * Decodes a HeartAck message from the specified reader or buffer.
             * @function decode
             * @memberof gem3Proto.HeartAck
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gem3Proto.HeartAck} HeartAck
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            HeartAck.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gem3Proto.HeartAck();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.state = reader.int32();
                    break;

                  case 2:
                    message.message = reader.string();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };

            return HeartAck;
          }();

          gem3Proto.ExchangeReq = function () {
            /**
             * Properties of an ExchangeReq.
             * @memberof gem3Proto
             * @interface IExchangeReq
             * @property {number|null} [aid] ExchangeReq aid
             * @property {string|null} [token] ExchangeReq token
             * @property {string|null} [stamp] ExchangeReq stamp
             */

            /**
             * Constructs a new ExchangeReq.
             * @memberof gem3Proto
             * @classdesc Represents an ExchangeReq.
             * @implements IExchangeReq
             * @constructor
             * @param {gem3Proto.IExchangeReq=} [properties] Properties to set
             */
            function ExchangeReq(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * ExchangeReq aid.
             * @member {number} aid
             * @memberof gem3Proto.ExchangeReq
             * @instance
             */


            ExchangeReq.prototype.aid = 0;
            /**
             * ExchangeReq token.
             * @member {string} token
             * @memberof gem3Proto.ExchangeReq
             * @instance
             */

            ExchangeReq.prototype.token = "";
            /**
             * ExchangeReq stamp.
             * @member {string} stamp
             * @memberof gem3Proto.ExchangeReq
             * @instance
             */

            ExchangeReq.prototype.stamp = "";
            /**
             * Encodes the specified ExchangeReq message. Does not implicitly {@link gem3Proto.ExchangeReq.verify|verify} messages.
             * @function encode
             * @memberof gem3Proto.ExchangeReq
             * @static
             * @param {gem3Proto.IExchangeReq} message ExchangeReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */

            ExchangeReq.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.aid != null && Object.hasOwnProperty.call(message, "aid")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.aid);
              if (message.token != null && Object.hasOwnProperty.call(message, "token")) writer.uint32(
              /* id 2, wireType 2 =*/
              18).string(message.token);
              if (message.stamp != null && Object.hasOwnProperty.call(message, "stamp")) writer.uint32(
              /* id 3, wireType 2 =*/
              26).string(message.stamp);
              return writer;
            };
            /**
             * Decodes an ExchangeReq message from the specified reader or buffer.
             * @function decode
             * @memberof gem3Proto.ExchangeReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gem3Proto.ExchangeReq} ExchangeReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            ExchangeReq.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gem3Proto.ExchangeReq();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.aid = reader.int32();
                    break;

                  case 2:
                    message.token = reader.string();
                    break;

                  case 3:
                    message.stamp = reader.string();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };

            return ExchangeReq;
          }();

          gem3Proto.ExchangeAck = function () {
            /**
             * Properties of an ExchangeAck.
             * @memberof gem3Proto
             * @interface IExchangeAck
             * @property {Array.<gem3Proto.IWallet>|null} [wallet] ExchangeAck wallet
             * @property {string|null} [stamp] ExchangeAck stamp
             */

            /**
             * Constructs a new ExchangeAck.
             * @memberof gem3Proto
             * @classdesc Represents an ExchangeAck.
             * @implements IExchangeAck
             * @constructor
             * @param {gem3Proto.IExchangeAck=} [properties] Properties to set
             */
            function ExchangeAck(properties) {
              this.wallet = [];
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * ExchangeAck wallet.
             * @member {Array.<gem3Proto.IWallet>} wallet
             * @memberof gem3Proto.ExchangeAck
             * @instance
             */


            ExchangeAck.prototype.wallet = $util.emptyArray;
            /**
             * ExchangeAck stamp.
             * @member {string} stamp
             * @memberof gem3Proto.ExchangeAck
             * @instance
             */

            ExchangeAck.prototype.stamp = "";
            /**
             * Encodes the specified ExchangeAck message. Does not implicitly {@link gem3Proto.ExchangeAck.verify|verify} messages.
             * @function encode
             * @memberof gem3Proto.ExchangeAck
             * @static
             * @param {gem3Proto.IExchangeAck} message ExchangeAck message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */

            ExchangeAck.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.wallet != null && message.wallet.length) for (var i = 0; i < message.wallet.length; ++i) {
                $root.gem3Proto.Wallet.encode(message.wallet[i], writer.uint32(
                /* id 1, wireType 2 =*/
                10).fork()).ldelim();
              }
              if (message.stamp != null && Object.hasOwnProperty.call(message, "stamp")) writer.uint32(
              /* id 2, wireType 2 =*/
              18).string(message.stamp);
              return writer;
            };
            /**
             * Decodes an ExchangeAck message from the specified reader or buffer.
             * @function decode
             * @memberof gem3Proto.ExchangeAck
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gem3Proto.ExchangeAck} ExchangeAck
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            ExchangeAck.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gem3Proto.ExchangeAck();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    if (!(message.wallet && message.wallet.length)) message.wallet = [];
                    message.wallet.push($root.gem3Proto.Wallet.decode(reader, reader.uint32()));
                    break;

                  case 2:
                    message.stamp = reader.string();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };

            return ExchangeAck;
          }();

          gem3Proto.Wallet = function () {
            /**
             * Properties of a Wallet.
             * @memberof gem3Proto
             * @interface IWallet
             * @property {number|null} [coin] Wallet coin
             * @property {number|null} [currencyNumber] Wallet currencyNumber
             * @property {number|null} [ratio] Wallet ratio
             * @property {number|null} [rate] Wallet rate
             * @property {number|null} [unit] Wallet unit
             */

            /**
             * Constructs a new Wallet.
             * @memberof gem3Proto
             * @classdesc Represents a Wallet.
             * @implements IWallet
             * @constructor
             * @param {gem3Proto.IWallet=} [properties] Properties to set
             */
            function Wallet(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * Wallet coin.
             * @member {number} coin
             * @memberof gem3Proto.Wallet
             * @instance
             */


            Wallet.prototype.coin = 0;
            /**
             * Wallet currencyNumber.
             * @member {number} currencyNumber
             * @memberof gem3Proto.Wallet
             * @instance
             */

            Wallet.prototype.currencyNumber = 0;
            /**
             * Wallet ratio.
             * @member {number} ratio
             * @memberof gem3Proto.Wallet
             * @instance
             */

            Wallet.prototype.ratio = 0;
            /**
             * Wallet rate.
             * @member {number} rate
             * @memberof gem3Proto.Wallet
             * @instance
             */

            Wallet.prototype.rate = 0;
            /**
             * Wallet unit.
             * @member {number} unit
             * @memberof gem3Proto.Wallet
             * @instance
             */

            Wallet.prototype.unit = 0;
            /**
             * Encodes the specified Wallet message. Does not implicitly {@link gem3Proto.Wallet.verify|verify} messages.
             * @function encode
             * @memberof gem3Proto.Wallet
             * @static
             * @param {gem3Proto.IWallet} message Wallet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */

            Wallet.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.coin != null && Object.hasOwnProperty.call(message, "coin")) writer.uint32(
              /* id 1, wireType 1 =*/
              9)["double"](message.coin);
              if (message.currencyNumber != null && Object.hasOwnProperty.call(message, "currencyNumber")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int32(message.currencyNumber);
              if (message.ratio != null && Object.hasOwnProperty.call(message, "ratio")) writer.uint32(
              /* id 3, wireType 1 =*/
              25)["double"](message.ratio);
              if (message.rate != null && Object.hasOwnProperty.call(message, "rate")) writer.uint32(
              /* id 4, wireType 1 =*/
              33)["double"](message.rate);
              if (message.unit != null && Object.hasOwnProperty.call(message, "unit")) writer.uint32(
              /* id 5, wireType 1 =*/
              41)["double"](message.unit);
              return writer;
            };
            /**
             * Decodes a Wallet message from the specified reader or buffer.
             * @function decode
             * @memberof gem3Proto.Wallet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gem3Proto.Wallet} Wallet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            Wallet.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gem3Proto.Wallet();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.coin = reader["double"]();
                    break;

                  case 2:
                    message.currencyNumber = reader.int32();
                    break;

                  case 3:
                    message.ratio = reader["double"]();
                    break;

                  case 4:
                    message.rate = reader["double"]();
                    break;

                  case 5:
                    message.unit = reader["double"]();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };

            return Wallet;
          }();

          gem3Proto.LastReq = function () {
            /**
             * Properties of a LastReq.
             * @memberof gem3Proto
             * @interface ILastReq
             * @property {number|null} [aid] LastReq aid
             * @property {string|null} [token] LastReq token
             */

            /**
             * Constructs a new LastReq.
             * @memberof gem3Proto
             * @classdesc Represents a LastReq.
             * @implements ILastReq
             * @constructor
             * @param {gem3Proto.ILastReq=} [properties] Properties to set
             */
            function LastReq(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * LastReq aid.
             * @member {number} aid
             * @memberof gem3Proto.LastReq
             * @instance
             */


            LastReq.prototype.aid = 0;
            /**
             * LastReq token.
             * @member {string} token
             * @memberof gem3Proto.LastReq
             * @instance
             */

            LastReq.prototype.token = "";
            /**
             * Encodes the specified LastReq message. Does not implicitly {@link gem3Proto.LastReq.verify|verify} messages.
             * @function encode
             * @memberof gem3Proto.LastReq
             * @static
             * @param {gem3Proto.ILastReq} message LastReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */

            LastReq.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.aid != null && Object.hasOwnProperty.call(message, "aid")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.aid);
              if (message.token != null && Object.hasOwnProperty.call(message, "token")) writer.uint32(
              /* id 2, wireType 2 =*/
              18).string(message.token);
              return writer;
            };
            /**
             * Decodes a LastReq message from the specified reader or buffer.
             * @function decode
             * @memberof gem3Proto.LastReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gem3Proto.LastReq} LastReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            LastReq.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gem3Proto.LastReq();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.aid = reader.int32();
                    break;

                  case 2:
                    message.token = reader.string();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };

            return LastReq;
          }();

          gem3Proto.LastSpinAck = function () {
            /**
             * Properties of a LastSpinAck.
             * @memberof gem3Proto
             * @interface ILastSpinAck
             * @property {number|null} [result] LastSpinAck result
             * @property {gem3Proto.ISpinAck|null} [lastSpin] LastSpinAck lastSpin
             */

            /**
             * Constructs a new LastSpinAck.
             * @memberof gem3Proto
             * @classdesc Represents a LastSpinAck.
             * @implements ILastSpinAck
             * @constructor
             * @param {gem3Proto.ILastSpinAck=} [properties] Properties to set
             */
            function LastSpinAck(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * LastSpinAck result.
             * @member {number} result
             * @memberof gem3Proto.LastSpinAck
             * @instance
             */


            LastSpinAck.prototype.result = 0;
            /**
             * LastSpinAck lastSpin.
             * @member {gem3Proto.ISpinAck|null|undefined} lastSpin
             * @memberof gem3Proto.LastSpinAck
             * @instance
             */

            LastSpinAck.prototype.lastSpin = null;
            /**
             * Encodes the specified LastSpinAck message. Does not implicitly {@link gem3Proto.LastSpinAck.verify|verify} messages.
             * @function encode
             * @memberof gem3Proto.LastSpinAck
             * @static
             * @param {gem3Proto.ILastSpinAck} message LastSpinAck message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */

            LastSpinAck.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.result != null && Object.hasOwnProperty.call(message, "result")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.result);
              if (message.lastSpin != null && Object.hasOwnProperty.call(message, "lastSpin")) $root.gem3Proto.SpinAck.encode(message.lastSpin, writer.uint32(
              /* id 2, wireType 2 =*/
              18).fork()).ldelim();
              return writer;
            };
            /**
             * Decodes a LastSpinAck message from the specified reader or buffer.
             * @function decode
             * @memberof gem3Proto.LastSpinAck
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gem3Proto.LastSpinAck} LastSpinAck
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            LastSpinAck.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.gem3Proto.LastSpinAck();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.result = reader.int32();
                    break;

                  case 2:
                    message.lastSpin = $root.gem3Proto.SpinAck.decode(reader, reader.uint32());
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };

            return LastSpinAck;
          }();

          return gem3Proto;
        }();

        module.exports = $root; // #endregion ORIGINAL CODE

        _cjsExports = exports('default', module.exports);
      }, function () {
        return {
          'protobufjs/minimal': __cjsMetaURL$1
        };
      });
    }
  };
});

System.register("chunks:///_virtual/gem3Proto.mjs_cjs=&original=.js", ['./gem3Proto.js', './cjs-loader.mjs'], function (exports, module) {
  'use strict';

  var __cjsMetaURL, loader;

  return {
    setters: [function (module) {
      __cjsMetaURL = module.__cjsMetaURL;
      var _setter = {};
      _setter.__cjsMetaURL = module.__cjsMetaURL;
      _setter.default = module.default;
      exports(_setter);
    }, function (module) {
      loader = module.default;
    }],
    execute: function () {
      // I am the facade module who provides access to the CommonJS module './gem3Proto.js'~
      if (!__cjsMetaURL) {
        loader.throwInvalidWrapper('./gem3Proto.js', module.meta.url);
      }

      loader.require(__cjsMetaURL);
    }
  };
});

System.register("chunks:///_virtual/index-light.js", ['./cjs-loader.mjs', './index-minimal.js', './encoder.js', './decoder.js', './verifier.js', './converter.js', './object.js', './namespace.js', './root.js', './enum.js', './type.js', './field.js', './oneof.js', './mapfield.js', './service.js', './method.js', './message.js', './wrappers.js', './types.js', './util.js'], function (exports, module) {
  'use strict';

  var loader, __cjsMetaURL$1, __cjsMetaURL$2, __cjsMetaURL$3, __cjsMetaURL$4, __cjsMetaURL$5, __cjsMetaURL$6, __cjsMetaURL$7, __cjsMetaURL$8, __cjsMetaURL$9, __cjsMetaURL$a, __cjsMetaURL$b, __cjsMetaURL$c, __cjsMetaURL$d, __cjsMetaURL$e, __cjsMetaURL$f, __cjsMetaURL$g, __cjsMetaURL$h, __cjsMetaURL$i, __cjsMetaURL$j;

  return {
    setters: [function (module) {
      loader = module.default;
    }, function (module) {
      __cjsMetaURL$1 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$2 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$3 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$4 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$5 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$6 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$7 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$8 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$9 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$a = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$b = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$c = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$d = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$e = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$f = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$g = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$h = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$i = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$j = module.__cjsMetaURL;
    }],
    execute: function () {
      var __cjsMetaURL = exports('__cjsMetaURL', module.meta.url);

      loader.define(__cjsMetaURL, function (exports, require, module, __filename, __dirname) {
        var protobuf = module.exports = require("./index-minimal");

        protobuf.build = "light";
        /**
         * A node-style callback as used by {@link load} and {@link Root#load}.
         * @typedef LoadCallback
         * @type {function}
         * @param {Error|null} error Error, if any, otherwise `null`
         * @param {Root} [root] Root, if there hasn't been an error
         * @returns {undefined}
         */

        /**
         * Loads one or multiple .proto or preprocessed .json files into a common root namespace and calls the callback.
         * @param {string|string[]} filename One or multiple files to load
         * @param {Root} root Root namespace, defaults to create a new one if omitted.
         * @param {LoadCallback} callback Callback function
         * @returns {undefined}
         * @see {@link Root#load}
         */

        function load(filename, root, callback) {
          if (typeof root === "function") {
            callback = root;
            root = new protobuf.Root();
          } else if (!root) root = new protobuf.Root();

          return root.load(filename, callback);
        }
        /**
         * Loads one or multiple .proto or preprocessed .json files into a common root namespace and calls the callback.
         * @name load
         * @function
         * @param {string|string[]} filename One or multiple files to load
         * @param {LoadCallback} callback Callback function
         * @returns {undefined}
         * @see {@link Root#load}
         * @variation 2
         */
        // function load(filename:string, callback:LoadCallback):undefined

        /**
         * Loads one or multiple .proto or preprocessed .json files into a common root namespace and returns a promise.
         * @name load
         * @function
         * @param {string|string[]} filename One or multiple files to load
         * @param {Root} [root] Root namespace, defaults to create a new one if omitted.
         * @returns {Promise<Root>} Promise
         * @see {@link Root#load}
         * @variation 3
         */
        // function load(filename:string, [root:Root]):Promise<Root>


        protobuf.load = load;
        /**
         * Synchronously loads one or multiple .proto or preprocessed .json files into a common root namespace (node only).
         * @param {string|string[]} filename One or multiple files to load
         * @param {Root} [root] Root namespace, defaults to create a new one if omitted.
         * @returns {Root} Root namespace
         * @throws {Error} If synchronous fetching is not supported (i.e. in browsers) or if a file's syntax is invalid
         * @see {@link Root#loadSync}
         */

        function loadSync(filename, root) {
          if (!root) root = new protobuf.Root();
          return root.loadSync(filename);
        }

        protobuf.loadSync = loadSync; // Serialization

        protobuf.encoder = require("./encoder");
        protobuf.decoder = require("./decoder");
        protobuf.verifier = require("./verifier");
        protobuf.converter = require("./converter"); // Reflection

        protobuf.ReflectionObject = require("./object");
        protobuf.Namespace = require("./namespace");
        protobuf.Root = require("./root");
        protobuf.Enum = require("./enum");
        protobuf.Type = require("./type");
        protobuf.Field = require("./field");
        protobuf.OneOf = require("./oneof");
        protobuf.MapField = require("./mapfield");
        protobuf.Service = require("./service");
        protobuf.Method = require("./method"); // Runtime

        protobuf.Message = require("./message");
        protobuf.wrappers = require("./wrappers"); // Utility

        protobuf.types = require("./types");
        protobuf.util = require("./util"); // Set up possibly cyclic reflection dependencies

        protobuf.ReflectionObject._configure(protobuf.Root);

        protobuf.Namespace._configure(protobuf.Type, protobuf.Service, protobuf.Enum);

        protobuf.Root._configure(protobuf.Type);

        protobuf.Field._configure(protobuf.Type); // #endregion ORIGINAL CODE


        module.exports;
      }, function () {
        return {
          './index-minimal': __cjsMetaURL$1,
          './encoder': __cjsMetaURL$2,
          './decoder': __cjsMetaURL$3,
          './verifier': __cjsMetaURL$4,
          './converter': __cjsMetaURL$5,
          './object': __cjsMetaURL$6,
          './namespace': __cjsMetaURL$7,
          './root': __cjsMetaURL$8,
          './enum': __cjsMetaURL$9,
          './type': __cjsMetaURL$a,
          './field': __cjsMetaURL$b,
          './oneof': __cjsMetaURL$c,
          './mapfield': __cjsMetaURL$d,
          './service': __cjsMetaURL$e,
          './method': __cjsMetaURL$f,
          './message': __cjsMetaURL$g,
          './wrappers': __cjsMetaURL$h,
          './types': __cjsMetaURL$i,
          './util': __cjsMetaURL$j
        };
      });
    }
  };
});

System.register("chunks:///_virtual/index-minimal.js", ['./cjs-loader.mjs', './writer.js', './writer_buffer.js', './reader.js', './reader_buffer.js', './minimal2.js', './rpc.js', './roots.js'], function (exports, module) {
  'use strict';

  var loader, __cjsMetaURL$1, __cjsMetaURL$2, __cjsMetaURL$3, __cjsMetaURL$4, __cjsMetaURL$5, __cjsMetaURL$6, __cjsMetaURL$7;

  return {
    setters: [function (module) {
      loader = module.default;
    }, function (module) {
      __cjsMetaURL$1 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$2 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$3 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$4 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$5 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$6 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$7 = module.__cjsMetaURL;
    }],
    execute: function () {
      var __cjsMetaURL = exports('__cjsMetaURL', module.meta.url);

      loader.define(__cjsMetaURL, function (exports, require, module, __filename, __dirname) {
        var protobuf = exports;
        /**
         * Build type, one of `"full"`, `"light"` or `"minimal"`.
         * @name build
         * @type {string}
         * @const
         */

        protobuf.build = "minimal"; // Serialization

        protobuf.Writer = require("./writer");
        protobuf.BufferWriter = require("./writer_buffer");
        protobuf.Reader = require("./reader");
        protobuf.BufferReader = require("./reader_buffer"); // Utility

        protobuf.util = require("./util/minimal");
        protobuf.rpc = require("./rpc");
        protobuf.roots = require("./roots");
        protobuf.configure = configure;
        /* istanbul ignore next */

        /**
         * Reconfigures the library according to the environment.
         * @returns {undefined}
         */

        function configure() {
          protobuf.util._configure();

          protobuf.Writer._configure(protobuf.BufferWriter);

          protobuf.Reader._configure(protobuf.BufferReader);
        } // Set up buffer utility according to the environment


        configure(); // #endregion ORIGINAL CODE

        module.exports;
      }, function () {
        return {
          './writer': __cjsMetaURL$1,
          './writer_buffer': __cjsMetaURL$2,
          './reader': __cjsMetaURL$3,
          './reader_buffer': __cjsMetaURL$4,
          './util/minimal': __cjsMetaURL$5,
          './rpc': __cjsMetaURL$6,
          './roots': __cjsMetaURL$7
        };
      });
    }
  };
});

System.register("chunks:///_virtual/index.js", ['./cjs-loader.mjs', './index2.js'], function (exports, module) {
  'use strict';

  var loader, __cjsMetaURL$1;

  return {
    setters: [function (module) {
      loader = module.default;
    }, function (module) {
      __cjsMetaURL$1 = module.__cjsMetaURL;
    }],
    execute: function () {
      exports('default', void 0);

      var _cjsExports;

      var __cjsMetaURL = exports('__cjsMetaURL', module.meta.url);

      loader.define(__cjsMetaURL, function (exports$1, require, module, __filename, __dirname) {
        module.exports = require("./src/index"); // #endregion ORIGINAL CODE

        _cjsExports = exports('default', module.exports);
      }, function () {
        return {
          './src/index': __cjsMetaURL$1
        };
      });
    }
  };
});

System.register("chunks:///_virtual/index.mjs_cjs=&original=.js", ['./index.js', './cjs-loader.mjs'], function (exports, module) {
  'use strict';

  var __cjsMetaURL, loader;

  return {
    setters: [function (module) {
      __cjsMetaURL = module.__cjsMetaURL;
      var _setter = {};
      _setter.__cjsMetaURL = module.__cjsMetaURL;
      _setter.default = module.default;
      exports(_setter);
    }, function (module) {
      loader = module.default;
    }],
    execute: function () {
      // I am the facade module who provides access to the CommonJS module './index.js'~
      if (!__cjsMetaURL) {
        loader.throwInvalidWrapper('./index.js', module.meta.url);
      }

      loader.require(__cjsMetaURL);
    }
  };
});

System.register("chunks:///_virtual/index10.js", ['./cjs-loader.mjs', './index4.js', './index7.js'], function (exports, module) {
  'use strict';

  var loader, __cjsMetaURL$1, __cjsMetaURL$2;

  return {
    setters: [function (module) {
      loader = module.default;
    }, function (module) {
      __cjsMetaURL$1 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$2 = module.__cjsMetaURL;
    }],
    execute: function () {
      var __cjsMetaURL = exports('__cjsMetaURL', module.meta.url);

      loader.define(__cjsMetaURL, function (exports, require, module, __filename, __dirname) {
        module.exports = fetch;

        var asPromise = require("@protobufjs/aspromise"),
            inquire = require("@protobufjs/inquire");

        var fs = inquire("fs");
        /**
         * Node-style callback as used by {@link util.fetch}.
         * @typedef FetchCallback
         * @type {function}
         * @param {?Error} error Error, if any, otherwise `null`
         * @param {string} [contents] File contents, if there hasn't been an error
         * @returns {undefined}
         */

        /**
         * Options as used by {@link util.fetch}.
         * @typedef FetchOptions
         * @type {Object}
         * @property {boolean} [binary=false] Whether expecting a binary response
         * @property {boolean} [xhr=false] If `true`, forces the use of XMLHttpRequest
         */

        /**
         * Fetches the contents of a file.
         * @memberof util
         * @param {string} filename File path or url
         * @param {FetchOptions} options Fetch options
         * @param {FetchCallback} callback Callback function
         * @returns {undefined}
         */

        function fetch(filename, options, callback) {
          if (typeof options === "function") {
            callback = options;
            options = {};
          } else if (!options) options = {};

          if (!callback) return asPromise(fetch, this, filename, options); // eslint-disable-line no-invalid-this
          // if a node-like filesystem is present, try it first but fall back to XHR if nothing is found.

          if (!options.xhr && fs && fs.readFile) return fs.readFile(filename, function fetchReadFileCallback(err, contents) {
            return err && typeof XMLHttpRequest !== "undefined" ? fetch.xhr(filename, options, callback) : err ? callback(err) : callback(null, options.binary ? contents : contents.toString("utf8"));
          }); // use the XHR version otherwise.

          return fetch.xhr(filename, options, callback);
        }
        /**
         * Fetches the contents of a file.
         * @name util.fetch
         * @function
         * @param {string} path File path or url
         * @param {FetchCallback} callback Callback function
         * @returns {undefined}
         * @variation 2
         */

        /**
         * Fetches the contents of a file.
         * @name util.fetch
         * @function
         * @param {string} path File path or url
         * @param {FetchOptions} [options] Fetch options
         * @returns {Promise<string|Uint8Array>} Promise
         * @variation 3
         */

        /**/


        fetch.xhr = function fetch_xhr(filename, options, callback) {
          var xhr = new XMLHttpRequest();

          xhr.onreadystatechange
          /* works everywhere */
          = function fetchOnReadyStateChange() {
            if (xhr.readyState !== 4) return undefined; // local cors security errors return status 0 / empty string, too. afaik this cannot be
            // reliably distinguished from an actually empty file for security reasons. feel free
            // to send a pull request if you are aware of a solution.

            if (xhr.status !== 0 && xhr.status !== 200) return callback(Error("status " + xhr.status)); // if binary data is expected, make sure that some sort of array is returned, even if
            // ArrayBuffers are not supported. the binary string fallback, however, is unsafe.

            if (options.binary) {
              var buffer = xhr.response;

              if (!buffer) {
                buffer = [];

                for (var i = 0; i < xhr.responseText.length; ++i) {
                  buffer.push(xhr.responseText.charCodeAt(i) & 255);
                }
              }

              return callback(null, typeof Uint8Array !== "undefined" ? new Uint8Array(buffer) : buffer);
            }

            return callback(null, xhr.responseText);
          };

          if (options.binary) {
            // ref: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Sending_and_Receiving_Binary_Data#Receiving_binary_data_in_older_browsers
            if ("overrideMimeType" in xhr) xhr.overrideMimeType("text/plain; charset=x-user-defined");
            xhr.responseType = "arraybuffer";
          }

          xhr.open("GET", filename);
          xhr.send();
        }; // #endregion ORIGINAL CODE


        module.exports;
      }, function () {
        return {
          '@protobufjs/aspromise': __cjsMetaURL$1,
          '@protobufjs/inquire': __cjsMetaURL$2
        };
      });
    }
  };
});

System.register("chunks:///_virtual/index11.js", ['./cjs-loader.mjs'], function (exports, module) {
  'use strict';

  var loader;
  return {
    setters: [function (module) {
      loader = module.default;
    }],
    execute: function () {
      var __cjsMetaURL = exports('__cjsMetaURL', module.meta.url);

      loader.define(__cjsMetaURL, function (exports, require, module, __filename, __dirname) {
        /**
         * A minimal path module to resolve Unix, Windows and URL paths alike.
         * @memberof util
         * @namespace
         */
        var path = exports;

        var isAbsolute =
        /**
         * Tests if the specified path is absolute.
         * @param {string} path Path to test
         * @returns {boolean} `true` if path is absolute
         */
        path.isAbsolute = function isAbsolute(path) {
          return /^(?:\/|\w+:)/.test(path);
        };

        var normalize =
        /**
         * Normalizes the specified path.
         * @param {string} path Path to normalize
         * @returns {string} Normalized path
         */
        path.normalize = function normalize(path) {
          path = path.replace(/\\/g, "/").replace(/\/{2,}/g, "/");
          var parts = path.split("/"),
              absolute = isAbsolute(path),
              prefix = "";
          if (absolute) prefix = parts.shift() + "/";

          for (var i = 0; i < parts.length;) {
            if (parts[i] === "..") {
              if (i > 0 && parts[i - 1] !== "..") parts.splice(--i, 2);else if (absolute) parts.splice(i, 1);else ++i;
            } else if (parts[i] === ".") parts.splice(i, 1);else ++i;
          }

          return prefix + parts.join("/");
        };
        /**
         * Resolves the specified include path against the specified origin path.
         * @param {string} originPath Path to the origin file
         * @param {string} includePath Include path relative to origin path
         * @param {boolean} [alreadyNormalized=false] `true` if both paths are already known to be normalized
         * @returns {string} Path to the include file
         */


        path.resolve = function resolve(originPath, includePath, alreadyNormalized) {
          if (!alreadyNormalized) includePath = normalize(includePath);
          if (isAbsolute(includePath)) return includePath;
          if (!alreadyNormalized) originPath = normalize(originPath);
          return (originPath = originPath.replace(/(?:\/|^)[^/]+$/, "")).length ? normalize(originPath + "/" + includePath) : includePath;
        }; // #endregion ORIGINAL CODE


        module.exports;
      }, {});
    }
  };
});

System.register("chunks:///_virtual/index12.js", ['./cjs-loader.mjs'], function (exports, module) {
  'use strict';

  var loader;
  return {
    setters: [function (module) {
      loader = module.default;
    }],
    execute: function () {
      var __cjsMetaURL = exports('__cjsMetaURL', module.meta.url);

      loader.define(__cjsMetaURL, function (exports, require, module, __filename, __dirname) {
        module.exports = codegen;
        /**
         * Begins generating a function.
         * @memberof util
         * @param {string[]} functionParams Function parameter names
         * @param {string} [functionName] Function name if not anonymous
         * @returns {Codegen} Appender that appends code to the function's body
         */

        function codegen(functionParams, functionName) {
          /* istanbul ignore if */
          if (typeof functionParams === "string") {
            functionName = functionParams;
            functionParams = undefined;
          }

          var body = [];
          /**
           * Appends code to the function's body or finishes generation.
           * @typedef Codegen
           * @type {function}
           * @param {string|Object.<string,*>} [formatStringOrScope] Format string or, to finish the function, an object of additional scope variables, if any
           * @param {...*} [formatParams] Format parameters
           * @returns {Codegen|Function} Itself or the generated function if finished
           * @throws {Error} If format parameter counts do not match
           */

          function Codegen(formatStringOrScope) {
            // note that explicit array handling below makes this ~50% faster
            // finish the function
            if (typeof formatStringOrScope !== "string") {
              var source = toString();
              if (codegen.verbose) console.log("codegen: " + source); // eslint-disable-line no-console

              source = "return " + source;

              if (formatStringOrScope) {
                var scopeKeys = Object.keys(formatStringOrScope),
                    scopeParams = new Array(scopeKeys.length + 1),
                    scopeValues = new Array(scopeKeys.length),
                    scopeOffset = 0;

                while (scopeOffset < scopeKeys.length) {
                  scopeParams[scopeOffset] = scopeKeys[scopeOffset];
                  scopeValues[scopeOffset] = formatStringOrScope[scopeKeys[scopeOffset++]];
                }

                scopeParams[scopeOffset] = source;
                return Function.apply(null, scopeParams).apply(null, scopeValues); // eslint-disable-line no-new-func
              }

              return Function(source)(); // eslint-disable-line no-new-func
            } // otherwise append to body


            var formatParams = new Array(arguments.length - 1),
                formatOffset = 0;

            while (formatOffset < formatParams.length) {
              formatParams[formatOffset] = arguments[++formatOffset];
            }

            formatOffset = 0;
            formatStringOrScope = formatStringOrScope.replace(/%([%dfijs])/g, function replace($0, $1) {
              var value = formatParams[formatOffset++];

              switch ($1) {
                case "d":
                case "f":
                  return String(Number(value));

                case "i":
                  return String(Math.floor(value));

                case "j":
                  return JSON.stringify(value);

                case "s":
                  return String(value);
              }

              return "%";
            });
            if (formatOffset !== formatParams.length) throw Error("parameter count mismatch");
            body.push(formatStringOrScope);
            return Codegen;
          }

          function toString(functionNameOverride) {
            return "function " + (functionNameOverride || functionName || "") + "(" + (functionParams && functionParams.join(",") || "") + "){\n  " + body.join("\n  ") + "\n}";
          }

          Codegen.toString = toString;
          return Codegen;
        }
        /**
         * Begins generating a function.
         * @memberof util
         * @function codegen
         * @param {string} [functionName] Function name if not anonymous
         * @returns {Codegen} Appender that appends code to the function's body
         * @variation 2
         */

        /**
         * When set to `true`, codegen will log generated code to console. Useful for debugging.
         * @name util.codegen.verbose
         * @type {boolean}
         */


        codegen.verbose = false; // #endregion ORIGINAL CODE

        module.exports;
      }, {});
    }
  };
});

System.register("chunks:///_virtual/index2.js", ['./cjs-loader.mjs', './index-light.js', './tokenize.js', './parse.js', './common.js'], function (exports, module) {
  'use strict';

  var loader, __cjsMetaURL$1, __cjsMetaURL$2, __cjsMetaURL$3, __cjsMetaURL$4;

  return {
    setters: [function (module) {
      loader = module.default;
    }, function (module) {
      __cjsMetaURL$1 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$2 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$3 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$4 = module.__cjsMetaURL;
    }],
    execute: function () {
      var __cjsMetaURL = exports('__cjsMetaURL', module.meta.url);

      loader.define(__cjsMetaURL, function (exports, require, module, __filename, __dirname) {
        var protobuf = module.exports = require("./index-light");

        protobuf.build = "full"; // Parser

        protobuf.tokenize = require("./tokenize");
        protobuf.parse = require("./parse");
        protobuf.common = require("./common"); // Configure parser

        protobuf.Root._configure(protobuf.Type, protobuf.parse, protobuf.common); // #endregion ORIGINAL CODE


        module.exports;
      }, function () {
        return {
          './index-light': __cjsMetaURL$1,
          './tokenize': __cjsMetaURL$2,
          './parse': __cjsMetaURL$3,
          './common': __cjsMetaURL$4
        };
      });
    }
  };
});

System.register("chunks:///_virtual/index3.js", ['./cjs-loader.mjs'], function (exports, module) {
  'use strict';

  var loader;
  return {
    setters: [function (module) {
      loader = module.default;
    }],
    execute: function () {
      var __cjsMetaURL = exports('__cjsMetaURL', module.meta.url);

      loader.define(__cjsMetaURL, function (exports, require, module, __filename, __dirname) {
        module.exports = factory(factory);
        /**
         * Reads / writes floats / doubles from / to buffers.
         * @name util.float
         * @namespace
         */

        /**
         * Writes a 32 bit float to a buffer using little endian byte order.
         * @name util.float.writeFloatLE
         * @function
         * @param {number} val Value to write
         * @param {Uint8Array} buf Target buffer
         * @param {number} pos Target buffer offset
         * @returns {undefined}
         */

        /**
         * Writes a 32 bit float to a buffer using big endian byte order.
         * @name util.float.writeFloatBE
         * @function
         * @param {number} val Value to write
         * @param {Uint8Array} buf Target buffer
         * @param {number} pos Target buffer offset
         * @returns {undefined}
         */

        /**
         * Reads a 32 bit float from a buffer using little endian byte order.
         * @name util.float.readFloatLE
         * @function
         * @param {Uint8Array} buf Source buffer
         * @param {number} pos Source buffer offset
         * @returns {number} Value read
         */

        /**
         * Reads a 32 bit float from a buffer using big endian byte order.
         * @name util.float.readFloatBE
         * @function
         * @param {Uint8Array} buf Source buffer
         * @param {number} pos Source buffer offset
         * @returns {number} Value read
         */

        /**
         * Writes a 64 bit double to a buffer using little endian byte order.
         * @name util.float.writeDoubleLE
         * @function
         * @param {number} val Value to write
         * @param {Uint8Array} buf Target buffer
         * @param {number} pos Target buffer offset
         * @returns {undefined}
         */

        /**
         * Writes a 64 bit double to a buffer using big endian byte order.
         * @name util.float.writeDoubleBE
         * @function
         * @param {number} val Value to write
         * @param {Uint8Array} buf Target buffer
         * @param {number} pos Target buffer offset
         * @returns {undefined}
         */

        /**
         * Reads a 64 bit double from a buffer using little endian byte order.
         * @name util.float.readDoubleLE
         * @function
         * @param {Uint8Array} buf Source buffer
         * @param {number} pos Source buffer offset
         * @returns {number} Value read
         */

        /**
         * Reads a 64 bit double from a buffer using big endian byte order.
         * @name util.float.readDoubleBE
         * @function
         * @param {Uint8Array} buf Source buffer
         * @param {number} pos Source buffer offset
         * @returns {number} Value read
         */
        // Factory function for the purpose of node-based testing in modified global environments

        function factory(exports) {
          // float: typed array
          if (typeof Float32Array !== "undefined") (function () {
            var f32 = new Float32Array([-0]),
                f8b = new Uint8Array(f32.buffer),
                le = f8b[3] === 128;

            function writeFloat_f32_cpy(val, buf, pos) {
              f32[0] = val;
              buf[pos] = f8b[0];
              buf[pos + 1] = f8b[1];
              buf[pos + 2] = f8b[2];
              buf[pos + 3] = f8b[3];
            }

            function writeFloat_f32_rev(val, buf, pos) {
              f32[0] = val;
              buf[pos] = f8b[3];
              buf[pos + 1] = f8b[2];
              buf[pos + 2] = f8b[1];
              buf[pos + 3] = f8b[0];
            }
            /* istanbul ignore next */


            exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
            /* istanbul ignore next */

            exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;

            function readFloat_f32_cpy(buf, pos) {
              f8b[0] = buf[pos];
              f8b[1] = buf[pos + 1];
              f8b[2] = buf[pos + 2];
              f8b[3] = buf[pos + 3];
              return f32[0];
            }

            function readFloat_f32_rev(buf, pos) {
              f8b[3] = buf[pos];
              f8b[2] = buf[pos + 1];
              f8b[1] = buf[pos + 2];
              f8b[0] = buf[pos + 3];
              return f32[0];
            }
            /* istanbul ignore next */


            exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
            /* istanbul ignore next */

            exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy; // float: ieee754
          })();else (function () {
            function writeFloat_ieee754(writeUint, val, buf, pos) {
              var sign = val < 0 ? 1 : 0;
              if (sign) val = -val;
              if (val === 0) writeUint(1 / val > 0 ?
              /* positive */
              0 :
              /* negative 0 */
              2147483648, buf, pos);else if (isNaN(val)) writeUint(2143289344, buf, pos);else if (val > 3.4028234663852886e+38) // +-Infinity
                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);else if (val < 1.1754943508222875e-38) // denormal
                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);else {
                var exponent = Math.floor(Math.log(val) / Math.LN2),
                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
              }
            }

            exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
            exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);

            function readFloat_ieee754(readUint, buf, pos) {
              var uint = readUint(buf, pos),
                  sign = (uint >> 31) * 2 + 1,
                  exponent = uint >>> 23 & 255,
                  mantissa = uint & 8388607;
              return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 // denormal
              ? sign * 1.401298464324817e-45 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
            }

            exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
            exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
          })(); // double: typed array

          if (typeof Float64Array !== "undefined") (function () {
            var f64 = new Float64Array([-0]),
                f8b = new Uint8Array(f64.buffer),
                le = f8b[7] === 128;

            function writeDouble_f64_cpy(val, buf, pos) {
              f64[0] = val;
              buf[pos] = f8b[0];
              buf[pos + 1] = f8b[1];
              buf[pos + 2] = f8b[2];
              buf[pos + 3] = f8b[3];
              buf[pos + 4] = f8b[4];
              buf[pos + 5] = f8b[5];
              buf[pos + 6] = f8b[6];
              buf[pos + 7] = f8b[7];
            }

            function writeDouble_f64_rev(val, buf, pos) {
              f64[0] = val;
              buf[pos] = f8b[7];
              buf[pos + 1] = f8b[6];
              buf[pos + 2] = f8b[5];
              buf[pos + 3] = f8b[4];
              buf[pos + 4] = f8b[3];
              buf[pos + 5] = f8b[2];
              buf[pos + 6] = f8b[1];
              buf[pos + 7] = f8b[0];
            }
            /* istanbul ignore next */


            exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
            /* istanbul ignore next */

            exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;

            function readDouble_f64_cpy(buf, pos) {
              f8b[0] = buf[pos];
              f8b[1] = buf[pos + 1];
              f8b[2] = buf[pos + 2];
              f8b[3] = buf[pos + 3];
              f8b[4] = buf[pos + 4];
              f8b[5] = buf[pos + 5];
              f8b[6] = buf[pos + 6];
              f8b[7] = buf[pos + 7];
              return f64[0];
            }

            function readDouble_f64_rev(buf, pos) {
              f8b[7] = buf[pos];
              f8b[6] = buf[pos + 1];
              f8b[5] = buf[pos + 2];
              f8b[4] = buf[pos + 3];
              f8b[3] = buf[pos + 4];
              f8b[2] = buf[pos + 5];
              f8b[1] = buf[pos + 6];
              f8b[0] = buf[pos + 7];
              return f64[0];
            }
            /* istanbul ignore next */


            exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
            /* istanbul ignore next */

            exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy; // double: ieee754
          })();else (function () {
            function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
              var sign = val < 0 ? 1 : 0;
              if (sign) val = -val;

              if (val === 0) {
                writeUint(0, buf, pos + off0);
                writeUint(1 / val > 0 ?
                /* positive */
                0 :
                /* negative 0 */
                2147483648, buf, pos + off1);
              } else if (isNaN(val)) {
                writeUint(0, buf, pos + off0);
                writeUint(2146959360, buf, pos + off1);
              } else if (val > 1.7976931348623157e+308) {
                // +-Infinity
                writeUint(0, buf, pos + off0);
                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
              } else {
                var mantissa;

                if (val < 2.2250738585072014e-308) {
                  // denormal
                  mantissa = val / 5e-324;
                  writeUint(mantissa >>> 0, buf, pos + off0);
                  writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
                } else {
                  var exponent = Math.floor(Math.log(val) / Math.LN2);
                  if (exponent === 1024) exponent = 1023;
                  mantissa = val * Math.pow(2, -exponent);
                  writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                  writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
                }
              }
            }

            exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
            exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);

            function readDouble_ieee754(readUint, off0, off1, buf, pos) {
              var lo = readUint(buf, pos + off0),
                  hi = readUint(buf, pos + off1);
              var sign = (hi >> 31) * 2 + 1,
                  exponent = hi >>> 20 & 2047,
                  mantissa = 4294967296 * (hi & 1048575) + lo;
              return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 // denormal
              ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
            }

            exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
            exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
          })();
          return exports;
        } // uint helpers


        function writeUintLE(val, buf, pos) {
          buf[pos] = val & 255;
          buf[pos + 1] = val >>> 8 & 255;
          buf[pos + 2] = val >>> 16 & 255;
          buf[pos + 3] = val >>> 24;
        }

        function writeUintBE(val, buf, pos) {
          buf[pos] = val >>> 24;
          buf[pos + 1] = val >>> 16 & 255;
          buf[pos + 2] = val >>> 8 & 255;
          buf[pos + 3] = val & 255;
        }

        function readUintLE(buf, pos) {
          return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;
        }

        function readUintBE(buf, pos) {
          return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;
        } // #endregion ORIGINAL CODE


        module.exports;
        module.exports.writeFloatLE;
        module.exports.writeFloatBE;
        module.exports.readFloatLE;
        module.exports.readFloatBE;
        module.exports.writeDoubleLE;
        module.exports.writeDoubleBE;
        module.exports.readDoubleLE;
        module.exports.readDoubleBE;
      }, {});
    }
  };
});

System.register("chunks:///_virtual/index4.js", ['./cjs-loader.mjs'], function (exports, module) {
  'use strict';

  var loader;
  return {
    setters: [function (module) {
      loader = module.default;
    }],
    execute: function () {
      var __cjsMetaURL = exports('__cjsMetaURL', module.meta.url);

      loader.define(__cjsMetaURL, function (exports, require, module, __filename, __dirname) {
        module.exports = asPromise;
        /**
         * Callback as used by {@link util.asPromise}.
         * @typedef asPromiseCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {...*} params Additional arguments
         * @returns {undefined}
         */

        /**
         * Returns a promise from a node-style callback function.
         * @memberof util
         * @param {asPromiseCallback} fn Function to call
         * @param {*} ctx Function context
         * @param {...*} params Function arguments
         * @returns {Promise<*>} Promisified function
         */

        function asPromise(fn, ctx
        /*, varargs */
        ) {
          var params = new Array(arguments.length - 1),
              offset = 0,
              index = 2,
              pending = true;

          while (index < arguments.length) {
            params[offset++] = arguments[index++];
          }

          return new Promise(function executor(resolve, reject) {
            params[offset] = function callback(err
            /*, varargs */
            ) {
              if (pending) {
                pending = false;
                if (err) reject(err);else {
                  var params = new Array(arguments.length - 1),
                      offset = 0;

                  while (offset < params.length) {
                    params[offset++] = arguments[offset];
                  }

                  resolve.apply(null, params);
                }
              }
            };

            try {
              fn.apply(ctx || null, params);
            } catch (err) {
              if (pending) {
                pending = false;
                reject(err);
              }
            }
          });
        } // #endregion ORIGINAL CODE


        module.exports;
      }, {});
    }
  };
});

System.register("chunks:///_virtual/index5.js", ['./cjs-loader.mjs'], function (exports, module) {
  'use strict';

  var loader;
  return {
    setters: [function (module) {
      loader = module.default;
    }],
    execute: function () {
      var __cjsMetaURL = exports('__cjsMetaURL', module.meta.url);

      loader.define(__cjsMetaURL, function (exports, require, module, __filename, __dirname) {
        /**
         * A minimal base64 implementation for number arrays.
         * @memberof util
         * @namespace
         */
        var base64 = exports;
        /**
         * Calculates the byte length of a base64 encoded string.
         * @param {string} string Base64 encoded string
         * @returns {number} Byte length
         */

        base64.length = function length(string) {
          var p = string.length;
          if (!p) return 0;
          var n = 0;

          while (--p % 4 > 1 && string.charAt(p) === "=") {
            ++n;
          }

          return Math.ceil(string.length * 3) / 4 - n;
        }; // Base64 encoding table


        var b64 = new Array(64); // Base64 decoding table

        var s64 = new Array(123); // 65..90, 97..122, 48..57, 43, 47

        for (var i = 0; i < 64;) {
          s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
        }
        /**
         * Encodes a buffer to a base64 encoded string.
         * @param {Uint8Array} buffer Source buffer
         * @param {number} start Source start
         * @param {number} end Source end
         * @returns {string} Base64 encoded string
         */


        base64.encode = function encode(buffer, start, end) {
          var parts = null,
              chunk = [];
          var i = 0,
              // output index
          j = 0,
              // goto index
          t; // temporary

          while (start < end) {
            var b = buffer[start++];

            switch (j) {
              case 0:
                chunk[i++] = b64[b >> 2];
                t = (b & 3) << 4;
                j = 1;
                break;

              case 1:
                chunk[i++] = b64[t | b >> 4];
                t = (b & 15) << 2;
                j = 2;
                break;

              case 2:
                chunk[i++] = b64[t | b >> 6];
                chunk[i++] = b64[b & 63];
                j = 0;
                break;
            }

            if (i > 8191) {
              (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
              i = 0;
            }
          }

          if (j) {
            chunk[i++] = b64[t];
            chunk[i++] = 61;
            if (j === 1) chunk[i++] = 61;
          }

          if (parts) {
            if (i) parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
            return parts.join("");
          }

          return String.fromCharCode.apply(String, chunk.slice(0, i));
        };

        var invalidEncoding = "invalid encoding";
        /**
         * Decodes a base64 encoded string to a buffer.
         * @param {string} string Source string
         * @param {Uint8Array} buffer Destination buffer
         * @param {number} offset Destination offset
         * @returns {number} Number of bytes written
         * @throws {Error} If encoding is invalid
         */

        base64.decode = function decode(string, buffer, offset) {
          var start = offset;
          var j = 0,
              // goto index
          t; // temporary

          for (var i = 0; i < string.length;) {
            var c = string.charCodeAt(i++);
            if (c === 61 && j > 1) break;
            if ((c = s64[c]) === undefined) throw Error(invalidEncoding);

            switch (j) {
              case 0:
                t = c;
                j = 1;
                break;

              case 1:
                buffer[offset++] = t << 2 | (c & 48) >> 4;
                t = c;
                j = 2;
                break;

              case 2:
                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
                t = c;
                j = 3;
                break;

              case 3:
                buffer[offset++] = (t & 3) << 6 | c;
                j = 0;
                break;
            }
          }

          if (j === 1) throw Error(invalidEncoding);
          return offset - start;
        };
        /**
         * Tests if the specified string appears to be base64 encoded.
         * @param {string} string String to test
         * @returns {boolean} `true` if probably base64 encoded, otherwise false
         */


        base64.test = function test(string) {
          return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
        }; // #endregion ORIGINAL CODE


        module.exports;
      }, {});
    }
  };
});

System.register("chunks:///_virtual/index6.js", ['./cjs-loader.mjs'], function (exports, module) {
  'use strict';

  var loader;
  return {
    setters: [function (module) {
      loader = module.default;
    }],
    execute: function () {
      var __cjsMetaURL = exports('__cjsMetaURL', module.meta.url);

      loader.define(__cjsMetaURL, function (exports, require, module, __filename, __dirname) {
        module.exports = EventEmitter;
        /**
         * Constructs a new event emitter instance.
         * @classdesc A minimal event emitter.
         * @memberof util
         * @constructor
         */

        function EventEmitter() {
          /**
           * Registered listeners.
           * @type {Object.<string,*>}
           * @private
           */
          this._listeners = {};
        }
        /**
         * Registers an event listener.
         * @param {string} evt Event name
         * @param {function} fn Listener
         * @param {*} [ctx] Listener context
         * @returns {util.EventEmitter} `this`
         */


        EventEmitter.prototype.on = function on(evt, fn, ctx) {
          (this._listeners[evt] || (this._listeners[evt] = [])).push({
            fn: fn,
            ctx: ctx || this
          });
          return this;
        };
        /**
         * Removes an event listener or any matching listeners if arguments are omitted.
         * @param {string} [evt] Event name. Removes all listeners if omitted.
         * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.
         * @returns {util.EventEmitter} `this`
         */


        EventEmitter.prototype.off = function off(evt, fn) {
          if (evt === undefined) this._listeners = {};else {
            if (fn === undefined) this._listeners[evt] = [];else {
              var listeners = this._listeners[evt];

              for (var i = 0; i < listeners.length;) {
                if (listeners[i].fn === fn) listeners.splice(i, 1);else ++i;
              }
            }
          }
          return this;
        };
        /**
         * Emits an event by calling its listeners with the specified arguments.
         * @param {string} evt Event name
         * @param {...*} args Arguments
         * @returns {util.EventEmitter} `this`
         */


        EventEmitter.prototype.emit = function emit(evt) {
          var listeners = this._listeners[evt];

          if (listeners) {
            var args = [],
                i = 1;

            for (; i < arguments.length;) {
              args.push(arguments[i++]);
            }

            for (i = 0; i < listeners.length;) {
              listeners[i].fn.apply(listeners[i++].ctx, args);
            }
          }

          return this;
        }; // #endregion ORIGINAL CODE


        module.exports;
      }, {});
    }
  };
});

System.register("chunks:///_virtual/index7.js", ['./cjs-loader.mjs'], function (exports, module) {
  'use strict';

  var loader;
  return {
    setters: [function (module) {
      loader = module.default;
    }],
    execute: function () {
      var __cjsMetaURL = exports('__cjsMetaURL', module.meta.url);

      loader.define(__cjsMetaURL, function (exports, require, module, __filename, __dirname) {
        module.exports = inquire;
        /**
         * Requires a module only if available.
         * @memberof util
         * @param {string} moduleName Module to require
         * @returns {?Object} Required module if available and not empty, otherwise `null`
         */

        function inquire(moduleName) {
          try {
            var mod = eval("quire".replace(/^/, "re"))(moduleName); // eslint-disable-line no-eval

            if (mod && (mod.length || Object.keys(mod).length)) return mod;
          } catch (e) {} // eslint-disable-line no-empty


          return null;
        } // #endregion ORIGINAL CODE


        module.exports;
      }, {});
    }
  };
});

System.register("chunks:///_virtual/index8.js", ['./cjs-loader.mjs'], function (exports, module) {
  'use strict';

  var loader;
  return {
    setters: [function (module) {
      loader = module.default;
    }],
    execute: function () {
      var __cjsMetaURL = exports('__cjsMetaURL', module.meta.url);

      loader.define(__cjsMetaURL, function (exports, require, module, __filename, __dirname) {
        /**
         * A minimal UTF8 implementation for number arrays.
         * @memberof util
         * @namespace
         */
        var utf8 = exports;
        /**
         * Calculates the UTF8 byte length of a string.
         * @param {string} string String
         * @returns {number} Byte length
         */

        utf8.length = function utf8_length(string) {
          var len = 0,
              c = 0;

          for (var i = 0; i < string.length; ++i) {
            c = string.charCodeAt(i);
            if (c < 128) len += 1;else if (c < 2048) len += 2;else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {
              ++i;
              len += 4;
            } else len += 3;
          }

          return len;
        };
        /**
         * Reads UTF8 bytes as a string.
         * @param {Uint8Array} buffer Source buffer
         * @param {number} start Source start
         * @param {number} end Source end
         * @returns {string} String read
         */


        utf8.read = function utf8_read(buffer, start, end) {
          var len = end - start;
          if (len < 1) return "";
          var parts = null,
              chunk = [],
              i = 0,
              // char offset
          t; // temporary

          while (start < end) {
            t = buffer[start++];
            if (t < 128) chunk[i++] = t;else if (t > 191 && t < 224) chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;else if (t > 239 && t < 365) {
              t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;
              chunk[i++] = 0xD800 + (t >> 10);
              chunk[i++] = 0xDC00 + (t & 1023);
            } else chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;

            if (i > 8191) {
              (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
              i = 0;
            }
          }

          if (parts) {
            if (i) parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
            return parts.join("");
          }

          return String.fromCharCode.apply(String, chunk.slice(0, i));
        };
        /**
         * Writes a string as UTF8 bytes.
         * @param {string} string Source string
         * @param {Uint8Array} buffer Destination buffer
         * @param {number} offset Destination offset
         * @returns {number} Bytes written
         */


        utf8.write = function utf8_write(string, buffer, offset) {
          var start = offset,
              c1,
              // character 1
          c2; // character 2

          for (var i = 0; i < string.length; ++i) {
            c1 = string.charCodeAt(i);

            if (c1 < 128) {
              buffer[offset++] = c1;
            } else if (c1 < 2048) {
              buffer[offset++] = c1 >> 6 | 192;
              buffer[offset++] = c1 & 63 | 128;
            } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {
              c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);
              ++i;
              buffer[offset++] = c1 >> 18 | 240;
              buffer[offset++] = c1 >> 12 & 63 | 128;
              buffer[offset++] = c1 >> 6 & 63 | 128;
              buffer[offset++] = c1 & 63 | 128;
            } else {
              buffer[offset++] = c1 >> 12 | 224;
              buffer[offset++] = c1 >> 6 & 63 | 128;
              buffer[offset++] = c1 & 63 | 128;
            }
          }

          return offset - start;
        }; // #endregion ORIGINAL CODE


        module.exports;
      }, {});
    }
  };
});

System.register("chunks:///_virtual/index9.js", ['./cjs-loader.mjs'], function (exports, module) {
  'use strict';

  var loader;
  return {
    setters: [function (module) {
      loader = module.default;
    }],
    execute: function () {
      var __cjsMetaURL = exports('__cjsMetaURL', module.meta.url);

      loader.define(__cjsMetaURL, function (exports, require, module, __filename, __dirname) {
        module.exports = pool;
        /**
         * An allocator as used by {@link util.pool}.
         * @typedef PoolAllocator
         * @type {function}
         * @param {number} size Buffer size
         * @returns {Uint8Array} Buffer
         */

        /**
         * A slicer as used by {@link util.pool}.
         * @typedef PoolSlicer
         * @type {function}
         * @param {number} start Start offset
         * @param {number} end End offset
         * @returns {Uint8Array} Buffer slice
         * @this {Uint8Array}
         */

        /**
         * A general purpose buffer pool.
         * @memberof util
         * @function
         * @param {PoolAllocator} alloc Allocator
         * @param {PoolSlicer} slice Slicer
         * @param {number} [size=8192] Slab size
         * @returns {PoolAllocator} Pooled allocator
         */

        function pool(alloc, slice, size) {
          var SIZE = size || 8192;
          var MAX = SIZE >>> 1;
          var slab = null;
          var offset = SIZE;
          return function pool_alloc(size) {
            if (size < 1 || size > MAX) return alloc(size);

            if (offset + size > SIZE) {
              slab = alloc(SIZE);
              offset = 0;
            }

            var buf = slice.call(slab, offset, offset += size);
            if (offset & 7) // align to 32 bit
              offset = (offset | 7) + 1;
            return buf;
          };
        } // #endregion ORIGINAL CODE


        module.exports;
      }, {});
    }
  };
});

System.register("chunks:///_virtual/itemproto.js", ['./cjs-loader.mjs', './minimal.js'], function (exports, module) {
  'use strict';

  var loader, __cjsMetaURL$1;

  return {
    setters: [function (module) {
      loader = module.default;
    }, function (module) {
      __cjsMetaURL$1 = module.__cjsMetaURL;
    }],
    execute: function () {
      exports('default', void 0);

      var _cjsExports;

      var __cjsMetaURL = exports('__cjsMetaURL', module.meta.url);

      loader.define(__cjsMetaURL, function (exports$1, require, module, __filename, __dirname) {
        var $protobuf = require("protobufjs/minimal"); // Common aliases


        var $Reader = $protobuf.Reader,
            $Writer = $protobuf.Writer,
            $util = $protobuf.util; // Exported root namespace

        var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

        $root.itemprotocol = function () {
          /**
           * Namespace itemprotocol.
           * @exports itemprotocol
           * @namespace
           */
          var itemprotocol = {};

          itemprotocol.ListData = function () {
            /**
             * Properties of a ListData.
             * @memberof itemprotocol
             * @interface IListData
             * @property {number|null} [itemindex] ListData itemindex
             * @property {number|null} [itemid] ListData itemid
             * @property {number|null} [amount] ListData amount
             * @property {number|null} [gameid] ListData gameid
             * @property {number|null} [lvmin] ListData lvmin
             * @property {number|null} [lvmax] ListData lvmax
             * @property {number|null} [coinlimit] ListData coinlimit
             * @property {number|null} [dailyremaintimes] ListData dailyremaintimes
             * @property {string|null} [startTime] ListData startTime
             * @property {string|null} [expiredtime] ListData expiredtime
             * @property {number|null} [bet] ListData bet
             * @property {number|null} [spinpaytype] ListData spinpaytype
             * @property {number|null} [givetype] ListData givetype
             * @property {number|null} [wintype] ListData wintype
             * @property {number|null} [winmultiplier] ListData winmultiplier
             * @property {number|null} [winmaxmag] ListData winmaxmag
             * @property {number|null} [winmagset] ListData winmagset
             * @property {number|null} [itemvalue] ListData itemvalue
             * @property {string|null} [itemname] ListData itemname
             * @property {number|null} [icon] ListData icon
             * @property {number|null} [banreason] ListData banreason
             * @property {string|null} [itemdesc] ListData itemdesc
             * @property {number|null} [star] ListData star
             * @property {string|null} [gamename] ListData gamename
             * @property {number|null} [currencynumber] ListData currencynumber
             * @property {number|null} [source] ListData source
             * @property {number|null} [playvalue] ListData playvalue
             * @property {number|Long|null} [start] ListData start
             * @property {number|Long|null} [expired] ListData expired
             */

            /**
             * Constructs a new ListData.
             * @memberof itemprotocol
             * @classdesc Represents a ListData.
             * @implements IListData
             * @constructor
             * @param {itemprotocol.IListData=} [properties] Properties to set
             */
            function ListData(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * ListData itemindex.
             * @member {number} itemindex
             * @memberof itemprotocol.ListData
             * @instance
             */


            ListData.prototype.itemindex = 0;
            /**
             * ListData itemid.
             * @member {number} itemid
             * @memberof itemprotocol.ListData
             * @instance
             */

            ListData.prototype.itemid = 0;
            /**
             * ListData amount.
             * @member {number} amount
             * @memberof itemprotocol.ListData
             * @instance
             */

            ListData.prototype.amount = 0;
            /**
             * ListData gameid.
             * @member {number} gameid
             * @memberof itemprotocol.ListData
             * @instance
             */

            ListData.prototype.gameid = 0;
            /**
             * ListData lvmin.
             * @member {number} lvmin
             * @memberof itemprotocol.ListData
             * @instance
             */

            ListData.prototype.lvmin = 0;
            /**
             * ListData lvmax.
             * @member {number} lvmax
             * @memberof itemprotocol.ListData
             * @instance
             */

            ListData.prototype.lvmax = 0;
            /**
             * ListData coinlimit.
             * @member {number} coinlimit
             * @memberof itemprotocol.ListData
             * @instance
             */

            ListData.prototype.coinlimit = 0;
            /**
             * ListData dailyremaintimes.
             * @member {number} dailyremaintimes
             * @memberof itemprotocol.ListData
             * @instance
             */

            ListData.prototype.dailyremaintimes = 0;
            /**
             * ListData startTime.
             * @member {string} startTime
             * @memberof itemprotocol.ListData
             * @instance
             */

            ListData.prototype.startTime = "";
            /**
             * ListData expiredtime.
             * @member {string} expiredtime
             * @memberof itemprotocol.ListData
             * @instance
             */

            ListData.prototype.expiredtime = "";
            /**
             * ListData bet.
             * @member {number} bet
             * @memberof itemprotocol.ListData
             * @instance
             */

            ListData.prototype.bet = 0;
            /**
             * ListData spinpaytype.
             * @member {number} spinpaytype
             * @memberof itemprotocol.ListData
             * @instance
             */

            ListData.prototype.spinpaytype = 0;
            /**
             * ListData givetype.
             * @member {number} givetype
             * @memberof itemprotocol.ListData
             * @instance
             */

            ListData.prototype.givetype = 0;
            /**
             * ListData wintype.
             * @member {number} wintype
             * @memberof itemprotocol.ListData
             * @instance
             */

            ListData.prototype.wintype = 0;
            /**
             * ListData winmultiplier.
             * @member {number} winmultiplier
             * @memberof itemprotocol.ListData
             * @instance
             */

            ListData.prototype.winmultiplier = 0;
            /**
             * ListData winmaxmag.
             * @member {number} winmaxmag
             * @memberof itemprotocol.ListData
             * @instance
             */

            ListData.prototype.winmaxmag = 0;
            /**
             * ListData winmagset.
             * @member {number} winmagset
             * @memberof itemprotocol.ListData
             * @instance
             */

            ListData.prototype.winmagset = 0;
            /**
             * ListData itemvalue.
             * @member {number} itemvalue
             * @memberof itemprotocol.ListData
             * @instance
             */

            ListData.prototype.itemvalue = 0;
            /**
             * ListData itemname.
             * @member {string} itemname
             * @memberof itemprotocol.ListData
             * @instance
             */

            ListData.prototype.itemname = "";
            /**
             * ListData icon.
             * @member {number} icon
             * @memberof itemprotocol.ListData
             * @instance
             */

            ListData.prototype.icon = 0;
            /**
             * ListData banreason.
             * @member {number} banreason
             * @memberof itemprotocol.ListData
             * @instance
             */

            ListData.prototype.banreason = 0;
            /**
             * ListData itemdesc.
             * @member {string} itemdesc
             * @memberof itemprotocol.ListData
             * @instance
             */

            ListData.prototype.itemdesc = "";
            /**
             * ListData star.
             * @member {number} star
             * @memberof itemprotocol.ListData
             * @instance
             */

            ListData.prototype.star = 0;
            /**
             * ListData gamename.
             * @member {string} gamename
             * @memberof itemprotocol.ListData
             * @instance
             */

            ListData.prototype.gamename = "";
            /**
             * ListData currencynumber.
             * @member {number} currencynumber
             * @memberof itemprotocol.ListData
             * @instance
             */

            ListData.prototype.currencynumber = 0;
            /**
             * ListData source.
             * @member {number} source
             * @memberof itemprotocol.ListData
             * @instance
             */

            ListData.prototype.source = 0;
            /**
             * ListData playvalue.
             * @member {number} playvalue
             * @memberof itemprotocol.ListData
             * @instance
             */

            ListData.prototype.playvalue = 0;
            /**
             * ListData start.
             * @member {number|Long} start
             * @memberof itemprotocol.ListData
             * @instance
             */

            ListData.prototype.start = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
             * ListData expired.
             * @member {number|Long} expired
             * @memberof itemprotocol.ListData
             * @instance
             */

            ListData.prototype.expired = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
             * Creates a new ListData instance using the specified properties.
             * @function create
             * @memberof itemprotocol.ListData
             * @static
             * @param {itemprotocol.IListData=} [properties] Properties to set
             * @returns {itemprotocol.ListData} ListData instance
             */

            ListData.create = function create(properties) {
              return new ListData(properties);
            };
            /**
             * Encodes the specified ListData message. Does not implicitly {@link itemprotocol.ListData.verify|verify} messages.
             * @function encode
             * @memberof itemprotocol.ListData
             * @static
             * @param {itemprotocol.IListData} message ListData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            ListData.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.itemindex != null && Object.hasOwnProperty.call(message, "itemindex")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.itemindex);
              if (message.itemid != null && Object.hasOwnProperty.call(message, "itemid")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int32(message.itemid);
              if (message.amount != null && Object.hasOwnProperty.call(message, "amount")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.amount);
              if (message.gameid != null && Object.hasOwnProperty.call(message, "gameid")) writer.uint32(
              /* id 4, wireType 0 =*/
              32).int32(message.gameid);
              if (message.lvmin != null && Object.hasOwnProperty.call(message, "lvmin")) writer.uint32(
              /* id 5, wireType 0 =*/
              40).int32(message.lvmin);
              if (message.lvmax != null && Object.hasOwnProperty.call(message, "lvmax")) writer.uint32(
              /* id 6, wireType 0 =*/
              48).int32(message.lvmax);
              if (message.coinlimit != null && Object.hasOwnProperty.call(message, "coinlimit")) writer.uint32(
              /* id 7, wireType 1 =*/
              57)["double"](message.coinlimit);
              if (message.dailyremaintimes != null && Object.hasOwnProperty.call(message, "dailyremaintimes")) writer.uint32(
              /* id 8, wireType 0 =*/
              64).int32(message.dailyremaintimes);
              if (message.startTime != null && Object.hasOwnProperty.call(message, "startTime")) writer.uint32(
              /* id 9, wireType 2 =*/
              74).string(message.startTime);
              if (message.expiredtime != null && Object.hasOwnProperty.call(message, "expiredtime")) writer.uint32(
              /* id 10, wireType 2 =*/
              82).string(message.expiredtime);
              if (message.bet != null && Object.hasOwnProperty.call(message, "bet")) writer.uint32(
              /* id 11, wireType 1 =*/
              89)["double"](message.bet);
              if (message.spinpaytype != null && Object.hasOwnProperty.call(message, "spinpaytype")) writer.uint32(
              /* id 12, wireType 0 =*/
              96).int32(message.spinpaytype);
              if (message.givetype != null && Object.hasOwnProperty.call(message, "givetype")) writer.uint32(
              /* id 13, wireType 1 =*/
              105)["double"](message.givetype);
              if (message.wintype != null && Object.hasOwnProperty.call(message, "wintype")) writer.uint32(
              /* id 14, wireType 0 =*/
              112).int32(message.wintype);
              if (message.winmultiplier != null && Object.hasOwnProperty.call(message, "winmultiplier")) writer.uint32(
              /* id 15, wireType 1 =*/
              121)["double"](message.winmultiplier);
              if (message.winmaxmag != null && Object.hasOwnProperty.call(message, "winmaxmag")) writer.uint32(
              /* id 16, wireType 1 =*/
              129)["double"](message.winmaxmag);
              if (message.winmagset != null && Object.hasOwnProperty.call(message, "winmagset")) writer.uint32(
              /* id 17, wireType 0 =*/
              136).int32(message.winmagset);
              if (message.itemvalue != null && Object.hasOwnProperty.call(message, "itemvalue")) writer.uint32(
              /* id 18, wireType 1 =*/
              145)["double"](message.itemvalue);
              if (message.itemname != null && Object.hasOwnProperty.call(message, "itemname")) writer.uint32(
              /* id 19, wireType 2 =*/
              154).string(message.itemname);
              if (message.icon != null && Object.hasOwnProperty.call(message, "icon")) writer.uint32(
              /* id 20, wireType 0 =*/
              160).int32(message.icon);
              if (message.banreason != null && Object.hasOwnProperty.call(message, "banreason")) writer.uint32(
              /* id 21, wireType 0 =*/
              168).int32(message.banreason);
              if (message.itemdesc != null && Object.hasOwnProperty.call(message, "itemdesc")) writer.uint32(
              /* id 22, wireType 2 =*/
              178).string(message.itemdesc);
              if (message.star != null && Object.hasOwnProperty.call(message, "star")) writer.uint32(
              /* id 23, wireType 0 =*/
              184).int32(message.star);
              if (message.gamename != null && Object.hasOwnProperty.call(message, "gamename")) writer.uint32(
              /* id 24, wireType 2 =*/
              194).string(message.gamename);
              if (message.currencynumber != null && Object.hasOwnProperty.call(message, "currencynumber")) writer.uint32(
              /* id 25, wireType 0 =*/
              200).int32(message.currencynumber);
              if (message.source != null && Object.hasOwnProperty.call(message, "source")) writer.uint32(
              /* id 26, wireType 0 =*/
              208).int32(message.source);
              if (message.playvalue != null && Object.hasOwnProperty.call(message, "playvalue")) writer.uint32(
              /* id 27, wireType 1 =*/
              217)["double"](message.playvalue);
              if (message.start != null && Object.hasOwnProperty.call(message, "start")) writer.uint32(
              /* id 28, wireType 0 =*/
              224).int64(message.start);
              if (message.expired != null && Object.hasOwnProperty.call(message, "expired")) writer.uint32(
              /* id 29, wireType 0 =*/
              232).int64(message.expired);
              return writer;
            };
            /**
             * Encodes the specified ListData message, length delimited. Does not implicitly {@link itemprotocol.ListData.verify|verify} messages.
             * @function encodeDelimited
             * @memberof itemprotocol.ListData
             * @static
             * @param {itemprotocol.IListData} message ListData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            ListData.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a ListData message from the specified reader or buffer.
             * @function decode
             * @memberof itemprotocol.ListData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {itemprotocol.ListData} ListData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            ListData.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.itemprotocol.ListData();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.itemindex = reader.int32();
                    break;

                  case 2:
                    message.itemid = reader.int32();
                    break;

                  case 3:
                    message.amount = reader.int32();
                    break;

                  case 4:
                    message.gameid = reader.int32();
                    break;

                  case 5:
                    message.lvmin = reader.int32();
                    break;

                  case 6:
                    message.lvmax = reader.int32();
                    break;

                  case 7:
                    message.coinlimit = reader["double"]();
                    break;

                  case 8:
                    message.dailyremaintimes = reader.int32();
                    break;

                  case 9:
                    message.startTime = reader.string();
                    break;

                  case 10:
                    message.expiredtime = reader.string();
                    break;

                  case 11:
                    message.bet = reader["double"]();
                    break;

                  case 12:
                    message.spinpaytype = reader.int32();
                    break;

                  case 13:
                    message.givetype = reader["double"]();
                    break;

                  case 14:
                    message.wintype = reader.int32();
                    break;

                  case 15:
                    message.winmultiplier = reader["double"]();
                    break;

                  case 16:
                    message.winmaxmag = reader["double"]();
                    break;

                  case 17:
                    message.winmagset = reader.int32();
                    break;

                  case 18:
                    message.itemvalue = reader["double"]();
                    break;

                  case 19:
                    message.itemname = reader.string();
                    break;

                  case 20:
                    message.icon = reader.int32();
                    break;

                  case 21:
                    message.banreason = reader.int32();
                    break;

                  case 22:
                    message.itemdesc = reader.string();
                    break;

                  case 23:
                    message.star = reader.int32();
                    break;

                  case 24:
                    message.gamename = reader.string();
                    break;

                  case 25:
                    message.currencynumber = reader.int32();
                    break;

                  case 26:
                    message.source = reader.int32();
                    break;

                  case 27:
                    message.playvalue = reader["double"]();
                    break;

                  case 28:
                    message.start = reader.int64();
                    break;

                  case 29:
                    message.expired = reader.int64();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
             * Decodes a ListData message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof itemprotocol.ListData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {itemprotocol.ListData} ListData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            ListData.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a ListData message.
             * @function verify
             * @memberof itemprotocol.ListData
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */


            ListData.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.itemindex != null && message.hasOwnProperty("itemindex")) if (!$util.isInteger(message.itemindex)) return "itemindex: integer expected";
              if (message.itemid != null && message.hasOwnProperty("itemid")) if (!$util.isInteger(message.itemid)) return "itemid: integer expected";
              if (message.amount != null && message.hasOwnProperty("amount")) if (!$util.isInteger(message.amount)) return "amount: integer expected";
              if (message.gameid != null && message.hasOwnProperty("gameid")) if (!$util.isInteger(message.gameid)) return "gameid: integer expected";
              if (message.lvmin != null && message.hasOwnProperty("lvmin")) if (!$util.isInteger(message.lvmin)) return "lvmin: integer expected";
              if (message.lvmax != null && message.hasOwnProperty("lvmax")) if (!$util.isInteger(message.lvmax)) return "lvmax: integer expected";
              if (message.coinlimit != null && message.hasOwnProperty("coinlimit")) if (typeof message.coinlimit !== "number") return "coinlimit: number expected";
              if (message.dailyremaintimes != null && message.hasOwnProperty("dailyremaintimes")) if (!$util.isInteger(message.dailyremaintimes)) return "dailyremaintimes: integer expected";
              if (message.startTime != null && message.hasOwnProperty("startTime")) if (!$util.isString(message.startTime)) return "startTime: string expected";
              if (message.expiredtime != null && message.hasOwnProperty("expiredtime")) if (!$util.isString(message.expiredtime)) return "expiredtime: string expected";
              if (message.bet != null && message.hasOwnProperty("bet")) if (typeof message.bet !== "number") return "bet: number expected";
              if (message.spinpaytype != null && message.hasOwnProperty("spinpaytype")) if (!$util.isInteger(message.spinpaytype)) return "spinpaytype: integer expected";
              if (message.givetype != null && message.hasOwnProperty("givetype")) if (typeof message.givetype !== "number") return "givetype: number expected";
              if (message.wintype != null && message.hasOwnProperty("wintype")) if (!$util.isInteger(message.wintype)) return "wintype: integer expected";
              if (message.winmultiplier != null && message.hasOwnProperty("winmultiplier")) if (typeof message.winmultiplier !== "number") return "winmultiplier: number expected";
              if (message.winmaxmag != null && message.hasOwnProperty("winmaxmag")) if (typeof message.winmaxmag !== "number") return "winmaxmag: number expected";
              if (message.winmagset != null && message.hasOwnProperty("winmagset")) if (!$util.isInteger(message.winmagset)) return "winmagset: integer expected";
              if (message.itemvalue != null && message.hasOwnProperty("itemvalue")) if (typeof message.itemvalue !== "number") return "itemvalue: number expected";
              if (message.itemname != null && message.hasOwnProperty("itemname")) if (!$util.isString(message.itemname)) return "itemname: string expected";
              if (message.icon != null && message.hasOwnProperty("icon")) if (!$util.isInteger(message.icon)) return "icon: integer expected";
              if (message.banreason != null && message.hasOwnProperty("banreason")) if (!$util.isInteger(message.banreason)) return "banreason: integer expected";
              if (message.itemdesc != null && message.hasOwnProperty("itemdesc")) if (!$util.isString(message.itemdesc)) return "itemdesc: string expected";
              if (message.star != null && message.hasOwnProperty("star")) if (!$util.isInteger(message.star)) return "star: integer expected";
              if (message.gamename != null && message.hasOwnProperty("gamename")) if (!$util.isString(message.gamename)) return "gamename: string expected";
              if (message.currencynumber != null && message.hasOwnProperty("currencynumber")) if (!$util.isInteger(message.currencynumber)) return "currencynumber: integer expected";
              if (message.source != null && message.hasOwnProperty("source")) if (!$util.isInteger(message.source)) return "source: integer expected";
              if (message.playvalue != null && message.hasOwnProperty("playvalue")) if (typeof message.playvalue !== "number") return "playvalue: number expected";
              if (message.start != null && message.hasOwnProperty("start")) if (!$util.isInteger(message.start) && !(message.start && $util.isInteger(message.start.low) && $util.isInteger(message.start.high))) return "start: integer|Long expected";
              if (message.expired != null && message.hasOwnProperty("expired")) if (!$util.isInteger(message.expired) && !(message.expired && $util.isInteger(message.expired.low) && $util.isInteger(message.expired.high))) return "expired: integer|Long expected";
              return null;
            };
            /**
             * Creates a ListData message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof itemprotocol.ListData
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {itemprotocol.ListData} ListData
             */


            ListData.fromObject = function fromObject(object) {
              if (object instanceof $root.itemprotocol.ListData) return object;
              var message = new $root.itemprotocol.ListData();
              if (object.itemindex != null) message.itemindex = object.itemindex | 0;
              if (object.itemid != null) message.itemid = object.itemid | 0;
              if (object.amount != null) message.amount = object.amount | 0;
              if (object.gameid != null) message.gameid = object.gameid | 0;
              if (object.lvmin != null) message.lvmin = object.lvmin | 0;
              if (object.lvmax != null) message.lvmax = object.lvmax | 0;
              if (object.coinlimit != null) message.coinlimit = Number(object.coinlimit);
              if (object.dailyremaintimes != null) message.dailyremaintimes = object.dailyremaintimes | 0;
              if (object.startTime != null) message.startTime = String(object.startTime);
              if (object.expiredtime != null) message.expiredtime = String(object.expiredtime);
              if (object.bet != null) message.bet = Number(object.bet);
              if (object.spinpaytype != null) message.spinpaytype = object.spinpaytype | 0;
              if (object.givetype != null) message.givetype = Number(object.givetype);
              if (object.wintype != null) message.wintype = object.wintype | 0;
              if (object.winmultiplier != null) message.winmultiplier = Number(object.winmultiplier);
              if (object.winmaxmag != null) message.winmaxmag = Number(object.winmaxmag);
              if (object.winmagset != null) message.winmagset = object.winmagset | 0;
              if (object.itemvalue != null) message.itemvalue = Number(object.itemvalue);
              if (object.itemname != null) message.itemname = String(object.itemname);
              if (object.icon != null) message.icon = object.icon | 0;
              if (object.banreason != null) message.banreason = object.banreason | 0;
              if (object.itemdesc != null) message.itemdesc = String(object.itemdesc);
              if (object.star != null) message.star = object.star | 0;
              if (object.gamename != null) message.gamename = String(object.gamename);
              if (object.currencynumber != null) message.currencynumber = object.currencynumber | 0;
              if (object.source != null) message.source = object.source | 0;
              if (object.playvalue != null) message.playvalue = Number(object.playvalue);
              if (object.start != null) if ($util.Long) (message.start = $util.Long.fromValue(object.start)).unsigned = false;else if (typeof object.start === "string") message.start = parseInt(object.start, 10);else if (typeof object.start === "number") message.start = object.start;else if (typeof object.start === "object") message.start = new $util.LongBits(object.start.low >>> 0, object.start.high >>> 0).toNumber();
              if (object.expired != null) if ($util.Long) (message.expired = $util.Long.fromValue(object.expired)).unsigned = false;else if (typeof object.expired === "string") message.expired = parseInt(object.expired, 10);else if (typeof object.expired === "number") message.expired = object.expired;else if (typeof object.expired === "object") message.expired = new $util.LongBits(object.expired.low >>> 0, object.expired.high >>> 0).toNumber();
              return message;
            };
            /**
             * Creates a plain object from a ListData message. Also converts values to other types if specified.
             * @function toObject
             * @memberof itemprotocol.ListData
             * @static
             * @param {itemprotocol.ListData} message ListData
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */


            ListData.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.itemindex = 0;
                object.itemid = 0;
                object.amount = 0;
                object.gameid = 0;
                object.lvmin = 0;
                object.lvmax = 0;
                object.coinlimit = 0;
                object.dailyremaintimes = 0;
                object.startTime = "";
                object.expiredtime = "";
                object.bet = 0;
                object.spinpaytype = 0;
                object.givetype = 0;
                object.wintype = 0;
                object.winmultiplier = 0;
                object.winmaxmag = 0;
                object.winmagset = 0;
                object.itemvalue = 0;
                object.itemname = "";
                object.icon = 0;
                object.banreason = 0;
                object.itemdesc = "";
                object.star = 0;
                object.gamename = "";
                object.currencynumber = 0;
                object.source = 0;
                object.playvalue = 0;

                if ($util.Long) {
                  var _long = new $util.Long(0, 0, false);

                  object.start = options.longs === String ? _long.toString() : options.longs === Number ? _long.toNumber() : _long;
                } else object.start = options.longs === String ? "0" : 0;

                if ($util.Long) {
                  var _long = new $util.Long(0, 0, false);

                  object.expired = options.longs === String ? _long.toString() : options.longs === Number ? _long.toNumber() : _long;
                } else object.expired = options.longs === String ? "0" : 0;
              }

              if (message.itemindex != null && message.hasOwnProperty("itemindex")) object.itemindex = message.itemindex;
              if (message.itemid != null && message.hasOwnProperty("itemid")) object.itemid = message.itemid;
              if (message.amount != null && message.hasOwnProperty("amount")) object.amount = message.amount;
              if (message.gameid != null && message.hasOwnProperty("gameid")) object.gameid = message.gameid;
              if (message.lvmin != null && message.hasOwnProperty("lvmin")) object.lvmin = message.lvmin;
              if (message.lvmax != null && message.hasOwnProperty("lvmax")) object.lvmax = message.lvmax;
              if (message.coinlimit != null && message.hasOwnProperty("coinlimit")) object.coinlimit = options.json && !isFinite(message.coinlimit) ? String(message.coinlimit) : message.coinlimit;
              if (message.dailyremaintimes != null && message.hasOwnProperty("dailyremaintimes")) object.dailyremaintimes = message.dailyremaintimes;
              if (message.startTime != null && message.hasOwnProperty("startTime")) object.startTime = message.startTime;
              if (message.expiredtime != null && message.hasOwnProperty("expiredtime")) object.expiredtime = message.expiredtime;
              if (message.bet != null && message.hasOwnProperty("bet")) object.bet = options.json && !isFinite(message.bet) ? String(message.bet) : message.bet;
              if (message.spinpaytype != null && message.hasOwnProperty("spinpaytype")) object.spinpaytype = message.spinpaytype;
              if (message.givetype != null && message.hasOwnProperty("givetype")) object.givetype = options.json && !isFinite(message.givetype) ? String(message.givetype) : message.givetype;
              if (message.wintype != null && message.hasOwnProperty("wintype")) object.wintype = message.wintype;
              if (message.winmultiplier != null && message.hasOwnProperty("winmultiplier")) object.winmultiplier = options.json && !isFinite(message.winmultiplier) ? String(message.winmultiplier) : message.winmultiplier;
              if (message.winmaxmag != null && message.hasOwnProperty("winmaxmag")) object.winmaxmag = options.json && !isFinite(message.winmaxmag) ? String(message.winmaxmag) : message.winmaxmag;
              if (message.winmagset != null && message.hasOwnProperty("winmagset")) object.winmagset = message.winmagset;
              if (message.itemvalue != null && message.hasOwnProperty("itemvalue")) object.itemvalue = options.json && !isFinite(message.itemvalue) ? String(message.itemvalue) : message.itemvalue;
              if (message.itemname != null && message.hasOwnProperty("itemname")) object.itemname = message.itemname;
              if (message.icon != null && message.hasOwnProperty("icon")) object.icon = message.icon;
              if (message.banreason != null && message.hasOwnProperty("banreason")) object.banreason = message.banreason;
              if (message.itemdesc != null && message.hasOwnProperty("itemdesc")) object.itemdesc = message.itemdesc;
              if (message.star != null && message.hasOwnProperty("star")) object.star = message.star;
              if (message.gamename != null && message.hasOwnProperty("gamename")) object.gamename = message.gamename;
              if (message.currencynumber != null && message.hasOwnProperty("currencynumber")) object.currencynumber = message.currencynumber;
              if (message.source != null && message.hasOwnProperty("source")) object.source = message.source;
              if (message.playvalue != null && message.hasOwnProperty("playvalue")) object.playvalue = options.json && !isFinite(message.playvalue) ? String(message.playvalue) : message.playvalue;
              if (message.start != null && message.hasOwnProperty("start")) if (typeof message.start === "number") object.start = options.longs === String ? String(message.start) : message.start;else object.start = options.longs === String ? $util.Long.prototype.toString.call(message.start) : options.longs === Number ? new $util.LongBits(message.start.low >>> 0, message.start.high >>> 0).toNumber() : message.start;
              if (message.expired != null && message.hasOwnProperty("expired")) if (typeof message.expired === "number") object.expired = options.longs === String ? String(message.expired) : message.expired;else object.expired = options.longs === String ? $util.Long.prototype.toString.call(message.expired) : options.longs === Number ? new $util.LongBits(message.expired.low >>> 0, message.expired.high >>> 0).toNumber() : message.expired;
              return object;
            };
            /**
             * Converts this ListData to JSON.
             * @function toJSON
             * @memberof itemprotocol.ListData
             * @instance
             * @returns {Object.<string,*>} JSON object
             */


            ListData.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ListData;
          }();

          itemprotocol.ListInfo = function () {
            /**
             * Properties of a ListInfo.
             * @memberof itemprotocol
             * @interface IListInfo
             * @property {number|null} [result] ListInfo result
             * @property {Array.<itemprotocol.IListData>|null} [playeritemdata] ListInfo playeritemdata
             */

            /**
             * Constructs a new ListInfo.
             * @memberof itemprotocol
             * @classdesc Represents a ListInfo.
             * @implements IListInfo
             * @constructor
             * @param {itemprotocol.IListInfo=} [properties] Properties to set
             */
            function ListInfo(properties) {
              this.playeritemdata = [];
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * ListInfo result.
             * @member {number} result
             * @memberof itemprotocol.ListInfo
             * @instance
             */


            ListInfo.prototype.result = 0;
            /**
             * ListInfo playeritemdata.
             * @member {Array.<itemprotocol.IListData>} playeritemdata
             * @memberof itemprotocol.ListInfo
             * @instance
             */

            ListInfo.prototype.playeritemdata = $util.emptyArray;
            /**
             * Creates a new ListInfo instance using the specified properties.
             * @function create
             * @memberof itemprotocol.ListInfo
             * @static
             * @param {itemprotocol.IListInfo=} [properties] Properties to set
             * @returns {itemprotocol.ListInfo} ListInfo instance
             */

            ListInfo.create = function create(properties) {
              return new ListInfo(properties);
            };
            /**
             * Encodes the specified ListInfo message. Does not implicitly {@link itemprotocol.ListInfo.verify|verify} messages.
             * @function encode
             * @memberof itemprotocol.ListInfo
             * @static
             * @param {itemprotocol.IListInfo} message ListInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            ListInfo.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.result != null && Object.hasOwnProperty.call(message, "result")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.result);
              if (message.playeritemdata != null && message.playeritemdata.length) for (var i = 0; i < message.playeritemdata.length; ++i) {
                $root.itemprotocol.ListData.encode(message.playeritemdata[i], writer.uint32(
                /* id 2, wireType 2 =*/
                18).fork()).ldelim();
              }
              return writer;
            };
            /**
             * Encodes the specified ListInfo message, length delimited. Does not implicitly {@link itemprotocol.ListInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof itemprotocol.ListInfo
             * @static
             * @param {itemprotocol.IListInfo} message ListInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            ListInfo.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a ListInfo message from the specified reader or buffer.
             * @function decode
             * @memberof itemprotocol.ListInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {itemprotocol.ListInfo} ListInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            ListInfo.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.itemprotocol.ListInfo();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.result = reader.int32();
                    break;

                  case 2:
                    if (!(message.playeritemdata && message.playeritemdata.length)) message.playeritemdata = [];
                    message.playeritemdata.push($root.itemprotocol.ListData.decode(reader, reader.uint32()));
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
             * Decodes a ListInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof itemprotocol.ListInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {itemprotocol.ListInfo} ListInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            ListInfo.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a ListInfo message.
             * @function verify
             * @memberof itemprotocol.ListInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */


            ListInfo.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.result != null && message.hasOwnProperty("result")) if (!$util.isInteger(message.result)) return "result: integer expected";

              if (message.playeritemdata != null && message.hasOwnProperty("playeritemdata")) {
                if (!Array.isArray(message.playeritemdata)) return "playeritemdata: array expected";

                for (var i = 0; i < message.playeritemdata.length; ++i) {
                  var error = $root.itemprotocol.ListData.verify(message.playeritemdata[i]);
                  if (error) return "playeritemdata." + error;
                }
              }

              return null;
            };
            /**
             * Creates a ListInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof itemprotocol.ListInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {itemprotocol.ListInfo} ListInfo
             */


            ListInfo.fromObject = function fromObject(object) {
              if (object instanceof $root.itemprotocol.ListInfo) return object;
              var message = new $root.itemprotocol.ListInfo();
              if (object.result != null) message.result = object.result | 0;

              if (object.playeritemdata) {
                if (!Array.isArray(object.playeritemdata)) throw TypeError(".itemprotocol.ListInfo.playeritemdata: array expected");
                message.playeritemdata = [];

                for (var i = 0; i < object.playeritemdata.length; ++i) {
                  if (typeof object.playeritemdata[i] !== "object") throw TypeError(".itemprotocol.ListInfo.playeritemdata: object expected");
                  message.playeritemdata[i] = $root.itemprotocol.ListData.fromObject(object.playeritemdata[i]);
                }
              }

              return message;
            };
            /**
             * Creates a plain object from a ListInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof itemprotocol.ListInfo
             * @static
             * @param {itemprotocol.ListInfo} message ListInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */


            ListInfo.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};
              if (options.arrays || options.defaults) object.playeritemdata = [];
              if (options.defaults) object.result = 0;
              if (message.result != null && message.hasOwnProperty("result")) object.result = message.result;

              if (message.playeritemdata && message.playeritemdata.length) {
                object.playeritemdata = [];

                for (var j = 0; j < message.playeritemdata.length; ++j) {
                  object.playeritemdata[j] = $root.itemprotocol.ListData.toObject(message.playeritemdata[j], options);
                }
              }

              return object;
            };
            /**
             * Converts this ListInfo to JSON.
             * @function toJSON
             * @memberof itemprotocol.ListInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */


            ListInfo.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ListInfo;
          }();

          itemprotocol.CleintCanUseItemData = function () {
            /**
             * Properties of a CleintCanUseItemData.
             * @memberof itemprotocol
             * @interface ICleintCanUseItemData
             * @property {number|null} [gameid] CleintCanUseItemData gameid
             * @property {number|null} [ownamount] CleintCanUseItemData ownamount
             * @property {number|null} [canamount] CleintCanUseItemData canamount
             * @property {number|null} [minitemindex] CleintCanUseItemData minitemindex
             */

            /**
             * Constructs a new CleintCanUseItemData.
             * @memberof itemprotocol
             * @classdesc Represents a CleintCanUseItemData.
             * @implements ICleintCanUseItemData
             * @constructor
             * @param {itemprotocol.ICleintCanUseItemData=} [properties] Properties to set
             */
            function CleintCanUseItemData(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * CleintCanUseItemData gameid.
             * @member {number} gameid
             * @memberof itemprotocol.CleintCanUseItemData
             * @instance
             */


            CleintCanUseItemData.prototype.gameid = 0;
            /**
             * CleintCanUseItemData ownamount.
             * @member {number} ownamount
             * @memberof itemprotocol.CleintCanUseItemData
             * @instance
             */

            CleintCanUseItemData.prototype.ownamount = 0;
            /**
             * CleintCanUseItemData canamount.
             * @member {number} canamount
             * @memberof itemprotocol.CleintCanUseItemData
             * @instance
             */

            CleintCanUseItemData.prototype.canamount = 0;
            /**
             * CleintCanUseItemData minitemindex.
             * @member {number} minitemindex
             * @memberof itemprotocol.CleintCanUseItemData
             * @instance
             */

            CleintCanUseItemData.prototype.minitemindex = 0;
            /**
             * Creates a new CleintCanUseItemData instance using the specified properties.
             * @function create
             * @memberof itemprotocol.CleintCanUseItemData
             * @static
             * @param {itemprotocol.ICleintCanUseItemData=} [properties] Properties to set
             * @returns {itemprotocol.CleintCanUseItemData} CleintCanUseItemData instance
             */

            CleintCanUseItemData.create = function create(properties) {
              return new CleintCanUseItemData(properties);
            };
            /**
             * Encodes the specified CleintCanUseItemData message. Does not implicitly {@link itemprotocol.CleintCanUseItemData.verify|verify} messages.
             * @function encode
             * @memberof itemprotocol.CleintCanUseItemData
             * @static
             * @param {itemprotocol.ICleintCanUseItemData} message CleintCanUseItemData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            CleintCanUseItemData.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.gameid != null && Object.hasOwnProperty.call(message, "gameid")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.gameid);
              if (message.ownamount != null && Object.hasOwnProperty.call(message, "ownamount")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int32(message.ownamount);
              if (message.canamount != null && Object.hasOwnProperty.call(message, "canamount")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.canamount);
              if (message.minitemindex != null && Object.hasOwnProperty.call(message, "minitemindex")) writer.uint32(
              /* id 4, wireType 0 =*/
              32).int32(message.minitemindex);
              return writer;
            };
            /**
             * Encodes the specified CleintCanUseItemData message, length delimited. Does not implicitly {@link itemprotocol.CleintCanUseItemData.verify|verify} messages.
             * @function encodeDelimited
             * @memberof itemprotocol.CleintCanUseItemData
             * @static
             * @param {itemprotocol.ICleintCanUseItemData} message CleintCanUseItemData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            CleintCanUseItemData.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a CleintCanUseItemData message from the specified reader or buffer.
             * @function decode
             * @memberof itemprotocol.CleintCanUseItemData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {itemprotocol.CleintCanUseItemData} CleintCanUseItemData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            CleintCanUseItemData.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.itemprotocol.CleintCanUseItemData();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.gameid = reader.int32();
                    break;

                  case 2:
                    message.ownamount = reader.int32();
                    break;

                  case 3:
                    message.canamount = reader.int32();
                    break;

                  case 4:
                    message.minitemindex = reader.int32();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
             * Decodes a CleintCanUseItemData message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof itemprotocol.CleintCanUseItemData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {itemprotocol.CleintCanUseItemData} CleintCanUseItemData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            CleintCanUseItemData.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a CleintCanUseItemData message.
             * @function verify
             * @memberof itemprotocol.CleintCanUseItemData
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */


            CleintCanUseItemData.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.gameid != null && message.hasOwnProperty("gameid")) if (!$util.isInteger(message.gameid)) return "gameid: integer expected";
              if (message.ownamount != null && message.hasOwnProperty("ownamount")) if (!$util.isInteger(message.ownamount)) return "ownamount: integer expected";
              if (message.canamount != null && message.hasOwnProperty("canamount")) if (!$util.isInteger(message.canamount)) return "canamount: integer expected";
              if (message.minitemindex != null && message.hasOwnProperty("minitemindex")) if (!$util.isInteger(message.minitemindex)) return "minitemindex: integer expected";
              return null;
            };
            /**
             * Creates a CleintCanUseItemData message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof itemprotocol.CleintCanUseItemData
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {itemprotocol.CleintCanUseItemData} CleintCanUseItemData
             */


            CleintCanUseItemData.fromObject = function fromObject(object) {
              if (object instanceof $root.itemprotocol.CleintCanUseItemData) return object;
              var message = new $root.itemprotocol.CleintCanUseItemData();
              if (object.gameid != null) message.gameid = object.gameid | 0;
              if (object.ownamount != null) message.ownamount = object.ownamount | 0;
              if (object.canamount != null) message.canamount = object.canamount | 0;
              if (object.minitemindex != null) message.minitemindex = object.minitemindex | 0;
              return message;
            };
            /**
             * Creates a plain object from a CleintCanUseItemData message. Also converts values to other types if specified.
             * @function toObject
             * @memberof itemprotocol.CleintCanUseItemData
             * @static
             * @param {itemprotocol.CleintCanUseItemData} message CleintCanUseItemData
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */


            CleintCanUseItemData.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.gameid = 0;
                object.ownamount = 0;
                object.canamount = 0;
                object.minitemindex = 0;
              }

              if (message.gameid != null && message.hasOwnProperty("gameid")) object.gameid = message.gameid;
              if (message.ownamount != null && message.hasOwnProperty("ownamount")) object.ownamount = message.ownamount;
              if (message.canamount != null && message.hasOwnProperty("canamount")) object.canamount = message.canamount;
              if (message.minitemindex != null && message.hasOwnProperty("minitemindex")) object.minitemindex = message.minitemindex;
              return object;
            };
            /**
             * Converts this CleintCanUseItemData to JSON.
             * @function toJSON
             * @memberof itemprotocol.CleintCanUseItemData
             * @instance
             * @returns {Object.<string,*>} JSON object
             */


            CleintCanUseItemData.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CleintCanUseItemData;
          }();

          itemprotocol.ListAllGameInfo = function () {
            /**
             * Properties of a ListAllGameInfo.
             * @memberof itemprotocol
             * @interface IListAllGameInfo
             * @property {number|null} [result] ListAllGameInfo result
             * @property {Array.<itemprotocol.ICleintCanUseItemData>|null} [canuseitem] ListAllGameInfo canuseitem
             */

            /**
             * Constructs a new ListAllGameInfo.
             * @memberof itemprotocol
             * @classdesc Represents a ListAllGameInfo.
             * @implements IListAllGameInfo
             * @constructor
             * @param {itemprotocol.IListAllGameInfo=} [properties] Properties to set
             */
            function ListAllGameInfo(properties) {
              this.canuseitem = [];
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * ListAllGameInfo result.
             * @member {number} result
             * @memberof itemprotocol.ListAllGameInfo
             * @instance
             */


            ListAllGameInfo.prototype.result = 0;
            /**
             * ListAllGameInfo canuseitem.
             * @member {Array.<itemprotocol.ICleintCanUseItemData>} canuseitem
             * @memberof itemprotocol.ListAllGameInfo
             * @instance
             */

            ListAllGameInfo.prototype.canuseitem = $util.emptyArray;
            /**
             * Creates a new ListAllGameInfo instance using the specified properties.
             * @function create
             * @memberof itemprotocol.ListAllGameInfo
             * @static
             * @param {itemprotocol.IListAllGameInfo=} [properties] Properties to set
             * @returns {itemprotocol.ListAllGameInfo} ListAllGameInfo instance
             */

            ListAllGameInfo.create = function create(properties) {
              return new ListAllGameInfo(properties);
            };
            /**
             * Encodes the specified ListAllGameInfo message. Does not implicitly {@link itemprotocol.ListAllGameInfo.verify|verify} messages.
             * @function encode
             * @memberof itemprotocol.ListAllGameInfo
             * @static
             * @param {itemprotocol.IListAllGameInfo} message ListAllGameInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            ListAllGameInfo.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.result != null && Object.hasOwnProperty.call(message, "result")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.result);
              if (message.canuseitem != null && message.canuseitem.length) for (var i = 0; i < message.canuseitem.length; ++i) {
                $root.itemprotocol.CleintCanUseItemData.encode(message.canuseitem[i], writer.uint32(
                /* id 2, wireType 2 =*/
                18).fork()).ldelim();
              }
              return writer;
            };
            /**
             * Encodes the specified ListAllGameInfo message, length delimited. Does not implicitly {@link itemprotocol.ListAllGameInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof itemprotocol.ListAllGameInfo
             * @static
             * @param {itemprotocol.IListAllGameInfo} message ListAllGameInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            ListAllGameInfo.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a ListAllGameInfo message from the specified reader or buffer.
             * @function decode
             * @memberof itemprotocol.ListAllGameInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {itemprotocol.ListAllGameInfo} ListAllGameInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            ListAllGameInfo.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.itemprotocol.ListAllGameInfo();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.result = reader.int32();
                    break;

                  case 2:
                    if (!(message.canuseitem && message.canuseitem.length)) message.canuseitem = [];
                    message.canuseitem.push($root.itemprotocol.CleintCanUseItemData.decode(reader, reader.uint32()));
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
             * Decodes a ListAllGameInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof itemprotocol.ListAllGameInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {itemprotocol.ListAllGameInfo} ListAllGameInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            ListAllGameInfo.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a ListAllGameInfo message.
             * @function verify
             * @memberof itemprotocol.ListAllGameInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */


            ListAllGameInfo.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.result != null && message.hasOwnProperty("result")) if (!$util.isInteger(message.result)) return "result: integer expected";

              if (message.canuseitem != null && message.hasOwnProperty("canuseitem")) {
                if (!Array.isArray(message.canuseitem)) return "canuseitem: array expected";

                for (var i = 0; i < message.canuseitem.length; ++i) {
                  var error = $root.itemprotocol.CleintCanUseItemData.verify(message.canuseitem[i]);
                  if (error) return "canuseitem." + error;
                }
              }

              return null;
            };
            /**
             * Creates a ListAllGameInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof itemprotocol.ListAllGameInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {itemprotocol.ListAllGameInfo} ListAllGameInfo
             */


            ListAllGameInfo.fromObject = function fromObject(object) {
              if (object instanceof $root.itemprotocol.ListAllGameInfo) return object;
              var message = new $root.itemprotocol.ListAllGameInfo();
              if (object.result != null) message.result = object.result | 0;

              if (object.canuseitem) {
                if (!Array.isArray(object.canuseitem)) throw TypeError(".itemprotocol.ListAllGameInfo.canuseitem: array expected");
                message.canuseitem = [];

                for (var i = 0; i < object.canuseitem.length; ++i) {
                  if (typeof object.canuseitem[i] !== "object") throw TypeError(".itemprotocol.ListAllGameInfo.canuseitem: object expected");
                  message.canuseitem[i] = $root.itemprotocol.CleintCanUseItemData.fromObject(object.canuseitem[i]);
                }
              }

              return message;
            };
            /**
             * Creates a plain object from a ListAllGameInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof itemprotocol.ListAllGameInfo
             * @static
             * @param {itemprotocol.ListAllGameInfo} message ListAllGameInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */


            ListAllGameInfo.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};
              if (options.arrays || options.defaults) object.canuseitem = [];
              if (options.defaults) object.result = 0;
              if (message.result != null && message.hasOwnProperty("result")) object.result = message.result;

              if (message.canuseitem && message.canuseitem.length) {
                object.canuseitem = [];

                for (var j = 0; j < message.canuseitem.length; ++j) {
                  object.canuseitem[j] = $root.itemprotocol.CleintCanUseItemData.toObject(message.canuseitem[j], options);
                }
              }

              return object;
            };
            /**
             * Converts this ListAllGameInfo to JSON.
             * @function toJSON
             * @memberof itemprotocol.ListAllGameInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */


            ListAllGameInfo.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ListAllGameInfo;
          }();

          itemprotocol.UseCardAck = function () {
            /**
             * Properties of a UseCardAck.
             * @memberof itemprotocol
             * @interface IUseCardAck
             * @property {number|null} [result] UseCardAck result
             * @property {number|null} [itemid] UseCardAck itemid
             * @property {number|null} [amount] UseCardAck amount
             * @property {number|null} [bet] UseCardAck bet
             * @property {number|null} [spinpaytype] UseCardAck spinpaytype
             * @property {number|null} [givetype] UseCardAck givetype
             * @property {number|null} [wintype] UseCardAck wintype
             * @property {number|null} [winmultiplier] UseCardAck winmultiplier
             * @property {number|null} [star] UseCardAck star
             * @property {number|null} [icon] UseCardAck icon
             */

            /**
             * Constructs a new UseCardAck.
             * @memberof itemprotocol
             * @classdesc Represents a UseCardAck.
             * @implements IUseCardAck
             * @constructor
             * @param {itemprotocol.IUseCardAck=} [properties] Properties to set
             */
            function UseCardAck(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * UseCardAck result.
             * @member {number} result
             * @memberof itemprotocol.UseCardAck
             * @instance
             */


            UseCardAck.prototype.result = 0;
            /**
             * UseCardAck itemid.
             * @member {number} itemid
             * @memberof itemprotocol.UseCardAck
             * @instance
             */

            UseCardAck.prototype.itemid = 0;
            /**
             * UseCardAck amount.
             * @member {number} amount
             * @memberof itemprotocol.UseCardAck
             * @instance
             */

            UseCardAck.prototype.amount = 0;
            /**
             * UseCardAck bet.
             * @member {number} bet
             * @memberof itemprotocol.UseCardAck
             * @instance
             */

            UseCardAck.prototype.bet = 0;
            /**
             * UseCardAck spinpaytype.
             * @member {number} spinpaytype
             * @memberof itemprotocol.UseCardAck
             * @instance
             */

            UseCardAck.prototype.spinpaytype = 0;
            /**
             * UseCardAck givetype.
             * @member {number} givetype
             * @memberof itemprotocol.UseCardAck
             * @instance
             */

            UseCardAck.prototype.givetype = 0;
            /**
             * UseCardAck wintype.
             * @member {number} wintype
             * @memberof itemprotocol.UseCardAck
             * @instance
             */

            UseCardAck.prototype.wintype = 0;
            /**
             * UseCardAck winmultiplier.
             * @member {number} winmultiplier
             * @memberof itemprotocol.UseCardAck
             * @instance
             */

            UseCardAck.prototype.winmultiplier = 0;
            /**
             * UseCardAck star.
             * @member {number} star
             * @memberof itemprotocol.UseCardAck
             * @instance
             */

            UseCardAck.prototype.star = 0;
            /**
             * UseCardAck icon.
             * @member {number} icon
             * @memberof itemprotocol.UseCardAck
             * @instance
             */

            UseCardAck.prototype.icon = 0;
            /**
             * Creates a new UseCardAck instance using the specified properties.
             * @function create
             * @memberof itemprotocol.UseCardAck
             * @static
             * @param {itemprotocol.IUseCardAck=} [properties] Properties to set
             * @returns {itemprotocol.UseCardAck} UseCardAck instance
             */

            UseCardAck.create = function create(properties) {
              return new UseCardAck(properties);
            };
            /**
             * Encodes the specified UseCardAck message. Does not implicitly {@link itemprotocol.UseCardAck.verify|verify} messages.
             * @function encode
             * @memberof itemprotocol.UseCardAck
             * @static
             * @param {itemprotocol.IUseCardAck} message UseCardAck message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            UseCardAck.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.result != null && Object.hasOwnProperty.call(message, "result")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.result);
              if (message.itemid != null && Object.hasOwnProperty.call(message, "itemid")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int32(message.itemid);
              if (message.amount != null && Object.hasOwnProperty.call(message, "amount")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.amount);
              if (message.bet != null && Object.hasOwnProperty.call(message, "bet")) writer.uint32(
              /* id 4, wireType 1 =*/
              33)["double"](message.bet);
              if (message.spinpaytype != null && Object.hasOwnProperty.call(message, "spinpaytype")) writer.uint32(
              /* id 5, wireType 0 =*/
              40).int32(message.spinpaytype);
              if (message.givetype != null && Object.hasOwnProperty.call(message, "givetype")) writer.uint32(
              /* id 6, wireType 0 =*/
              48).int32(message.givetype);
              if (message.wintype != null && Object.hasOwnProperty.call(message, "wintype")) writer.uint32(
              /* id 7, wireType 0 =*/
              56).int32(message.wintype);
              if (message.winmultiplier != null && Object.hasOwnProperty.call(message, "winmultiplier")) writer.uint32(
              /* id 8, wireType 1 =*/
              65)["double"](message.winmultiplier);
              if (message.star != null && Object.hasOwnProperty.call(message, "star")) writer.uint32(
              /* id 9, wireType 0 =*/
              72).int32(message.star);
              if (message.icon != null && Object.hasOwnProperty.call(message, "icon")) writer.uint32(
              /* id 10, wireType 0 =*/
              80).int32(message.icon);
              return writer;
            };
            /**
             * Encodes the specified UseCardAck message, length delimited. Does not implicitly {@link itemprotocol.UseCardAck.verify|verify} messages.
             * @function encodeDelimited
             * @memberof itemprotocol.UseCardAck
             * @static
             * @param {itemprotocol.IUseCardAck} message UseCardAck message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            UseCardAck.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a UseCardAck message from the specified reader or buffer.
             * @function decode
             * @memberof itemprotocol.UseCardAck
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {itemprotocol.UseCardAck} UseCardAck
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            UseCardAck.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.itemprotocol.UseCardAck();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.result = reader.int32();
                    break;

                  case 2:
                    message.itemid = reader.int32();
                    break;

                  case 3:
                    message.amount = reader.int32();
                    break;

                  case 4:
                    message.bet = reader["double"]();
                    break;

                  case 5:
                    message.spinpaytype = reader.int32();
                    break;

                  case 6:
                    message.givetype = reader.int32();
                    break;

                  case 7:
                    message.wintype = reader.int32();
                    break;

                  case 8:
                    message.winmultiplier = reader["double"]();
                    break;

                  case 9:
                    message.star = reader.int32();
                    break;

                  case 10:
                    message.icon = reader.int32();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
             * Decodes a UseCardAck message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof itemprotocol.UseCardAck
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {itemprotocol.UseCardAck} UseCardAck
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            UseCardAck.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a UseCardAck message.
             * @function verify
             * @memberof itemprotocol.UseCardAck
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */


            UseCardAck.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.result != null && message.hasOwnProperty("result")) if (!$util.isInteger(message.result)) return "result: integer expected";
              if (message.itemid != null && message.hasOwnProperty("itemid")) if (!$util.isInteger(message.itemid)) return "itemid: integer expected";
              if (message.amount != null && message.hasOwnProperty("amount")) if (!$util.isInteger(message.amount)) return "amount: integer expected";
              if (message.bet != null && message.hasOwnProperty("bet")) if (typeof message.bet !== "number") return "bet: number expected";
              if (message.spinpaytype != null && message.hasOwnProperty("spinpaytype")) if (!$util.isInteger(message.spinpaytype)) return "spinpaytype: integer expected";
              if (message.givetype != null && message.hasOwnProperty("givetype")) if (!$util.isInteger(message.givetype)) return "givetype: integer expected";
              if (message.wintype != null && message.hasOwnProperty("wintype")) if (!$util.isInteger(message.wintype)) return "wintype: integer expected";
              if (message.winmultiplier != null && message.hasOwnProperty("winmultiplier")) if (typeof message.winmultiplier !== "number") return "winmultiplier: number expected";
              if (message.star != null && message.hasOwnProperty("star")) if (!$util.isInteger(message.star)) return "star: integer expected";
              if (message.icon != null && message.hasOwnProperty("icon")) if (!$util.isInteger(message.icon)) return "icon: integer expected";
              return null;
            };
            /**
             * Creates a UseCardAck message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof itemprotocol.UseCardAck
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {itemprotocol.UseCardAck} UseCardAck
             */


            UseCardAck.fromObject = function fromObject(object) {
              if (object instanceof $root.itemprotocol.UseCardAck) return object;
              var message = new $root.itemprotocol.UseCardAck();
              if (object.result != null) message.result = object.result | 0;
              if (object.itemid != null) message.itemid = object.itemid | 0;
              if (object.amount != null) message.amount = object.amount | 0;
              if (object.bet != null) message.bet = Number(object.bet);
              if (object.spinpaytype != null) message.spinpaytype = object.spinpaytype | 0;
              if (object.givetype != null) message.givetype = object.givetype | 0;
              if (object.wintype != null) message.wintype = object.wintype | 0;
              if (object.winmultiplier != null) message.winmultiplier = Number(object.winmultiplier);
              if (object.star != null) message.star = object.star | 0;
              if (object.icon != null) message.icon = object.icon | 0;
              return message;
            };
            /**
             * Creates a plain object from a UseCardAck message. Also converts values to other types if specified.
             * @function toObject
             * @memberof itemprotocol.UseCardAck
             * @static
             * @param {itemprotocol.UseCardAck} message UseCardAck
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */


            UseCardAck.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.result = 0;
                object.itemid = 0;
                object.amount = 0;
                object.bet = 0;
                object.spinpaytype = 0;
                object.givetype = 0;
                object.wintype = 0;
                object.winmultiplier = 0;
                object.star = 0;
                object.icon = 0;
              }

              if (message.result != null && message.hasOwnProperty("result")) object.result = message.result;
              if (message.itemid != null && message.hasOwnProperty("itemid")) object.itemid = message.itemid;
              if (message.amount != null && message.hasOwnProperty("amount")) object.amount = message.amount;
              if (message.bet != null && message.hasOwnProperty("bet")) object.bet = options.json && !isFinite(message.bet) ? String(message.bet) : message.bet;
              if (message.spinpaytype != null && message.hasOwnProperty("spinpaytype")) object.spinpaytype = message.spinpaytype;
              if (message.givetype != null && message.hasOwnProperty("givetype")) object.givetype = message.givetype;
              if (message.wintype != null && message.hasOwnProperty("wintype")) object.wintype = message.wintype;
              if (message.winmultiplier != null && message.hasOwnProperty("winmultiplier")) object.winmultiplier = options.json && !isFinite(message.winmultiplier) ? String(message.winmultiplier) : message.winmultiplier;
              if (message.star != null && message.hasOwnProperty("star")) object.star = message.star;
              if (message.icon != null && message.hasOwnProperty("icon")) object.icon = message.icon;
              return object;
            };
            /**
             * Converts this UseCardAck to JSON.
             * @function toJSON
             * @memberof itemprotocol.UseCardAck
             * @instance
             * @returns {Object.<string,*>} JSON object
             */


            UseCardAck.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return UseCardAck;
          }();

          itemprotocol.CheckAck = function () {
            /**
             * Properties of a CheckAck.
             * @memberof itemprotocol
             * @interface ICheckAck
             * @property {number|null} [result] CheckAck result
             * @property {boolean|null} [isnew] CheckAck isnew
             */

            /**
             * Constructs a new CheckAck.
             * @memberof itemprotocol
             * @classdesc Represents a CheckAck.
             * @implements ICheckAck
             * @constructor
             * @param {itemprotocol.ICheckAck=} [properties] Properties to set
             */
            function CheckAck(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * CheckAck result.
             * @member {number} result
             * @memberof itemprotocol.CheckAck
             * @instance
             */


            CheckAck.prototype.result = 0;
            /**
             * CheckAck isnew.
             * @member {boolean} isnew
             * @memberof itemprotocol.CheckAck
             * @instance
             */

            CheckAck.prototype.isnew = false;
            /**
             * Creates a new CheckAck instance using the specified properties.
             * @function create
             * @memberof itemprotocol.CheckAck
             * @static
             * @param {itemprotocol.ICheckAck=} [properties] Properties to set
             * @returns {itemprotocol.CheckAck} CheckAck instance
             */

            CheckAck.create = function create(properties) {
              return new CheckAck(properties);
            };
            /**
             * Encodes the specified CheckAck message. Does not implicitly {@link itemprotocol.CheckAck.verify|verify} messages.
             * @function encode
             * @memberof itemprotocol.CheckAck
             * @static
             * @param {itemprotocol.ICheckAck} message CheckAck message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            CheckAck.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.result != null && Object.hasOwnProperty.call(message, "result")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.result);
              if (message.isnew != null && Object.hasOwnProperty.call(message, "isnew")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).bool(message.isnew);
              return writer;
            };
            /**
             * Encodes the specified CheckAck message, length delimited. Does not implicitly {@link itemprotocol.CheckAck.verify|verify} messages.
             * @function encodeDelimited
             * @memberof itemprotocol.CheckAck
             * @static
             * @param {itemprotocol.ICheckAck} message CheckAck message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            CheckAck.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a CheckAck message from the specified reader or buffer.
             * @function decode
             * @memberof itemprotocol.CheckAck
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {itemprotocol.CheckAck} CheckAck
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            CheckAck.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.itemprotocol.CheckAck();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.result = reader.int32();
                    break;

                  case 2:
                    message.isnew = reader.bool();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
             * Decodes a CheckAck message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof itemprotocol.CheckAck
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {itemprotocol.CheckAck} CheckAck
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            CheckAck.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a CheckAck message.
             * @function verify
             * @memberof itemprotocol.CheckAck
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */


            CheckAck.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.result != null && message.hasOwnProperty("result")) if (!$util.isInteger(message.result)) return "result: integer expected";
              if (message.isnew != null && message.hasOwnProperty("isnew")) if (typeof message.isnew !== "boolean") return "isnew: boolean expected";
              return null;
            };
            /**
             * Creates a CheckAck message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof itemprotocol.CheckAck
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {itemprotocol.CheckAck} CheckAck
             */


            CheckAck.fromObject = function fromObject(object) {
              if (object instanceof $root.itemprotocol.CheckAck) return object;
              var message = new $root.itemprotocol.CheckAck();
              if (object.result != null) message.result = object.result | 0;
              if (object.isnew != null) message.isnew = Boolean(object.isnew);
              return message;
            };
            /**
             * Creates a plain object from a CheckAck message. Also converts values to other types if specified.
             * @function toObject
             * @memberof itemprotocol.CheckAck
             * @static
             * @param {itemprotocol.CheckAck} message CheckAck
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */


            CheckAck.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.result = 0;
                object.isnew = false;
              }

              if (message.result != null && message.hasOwnProperty("result")) object.result = message.result;
              if (message.isnew != null && message.hasOwnProperty("isnew")) object.isnew = message.isnew;
              return object;
            };
            /**
             * Converts this CheckAck to JSON.
             * @function toJSON
             * @memberof itemprotocol.CheckAck
             * @instance
             * @returns {Object.<string,*>} JSON object
             */


            CheckAck.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CheckAck;
          }();

          itemprotocol.UserMailContent = function () {
            /**
             * Properties of a UserMailContent.
             * @memberof itemprotocol
             * @interface IUserMailContent
             * @property {number|null} [action] UserMailContent action
             * @property {number|null} [gameid] UserMailContent gameid
             * @property {number|null} [itemid] UserMailContent itemid
             * @property {number|null} [amount] UserMailContent amount
             * @property {number|null} [star] UserMailContent star
             * @property {number|null} [wintype] UserMailContent wintype
             * @property {string|null} [createtime] UserMailContent createtime
             * @property {string|null} [msg] UserMailContent msg
             */

            /**
             * Constructs a new UserMailContent.
             * @memberof itemprotocol
             * @classdesc Represents a UserMailContent.
             * @implements IUserMailContent
             * @constructor
             * @param {itemprotocol.IUserMailContent=} [properties] Properties to set
             */
            function UserMailContent(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * UserMailContent action.
             * @member {number} action
             * @memberof itemprotocol.UserMailContent
             * @instance
             */


            UserMailContent.prototype.action = 0;
            /**
             * UserMailContent gameid.
             * @member {number} gameid
             * @memberof itemprotocol.UserMailContent
             * @instance
             */

            UserMailContent.prototype.gameid = 0;
            /**
             * UserMailContent itemid.
             * @member {number} itemid
             * @memberof itemprotocol.UserMailContent
             * @instance
             */

            UserMailContent.prototype.itemid = 0;
            /**
             * UserMailContent amount.
             * @member {number} amount
             * @memberof itemprotocol.UserMailContent
             * @instance
             */

            UserMailContent.prototype.amount = 0;
            /**
             * UserMailContent star.
             * @member {number} star
             * @memberof itemprotocol.UserMailContent
             * @instance
             */

            UserMailContent.prototype.star = 0;
            /**
             * UserMailContent wintype.
             * @member {number} wintype
             * @memberof itemprotocol.UserMailContent
             * @instance
             */

            UserMailContent.prototype.wintype = 0;
            /**
             * UserMailContent createtime.
             * @member {string} createtime
             * @memberof itemprotocol.UserMailContent
             * @instance
             */

            UserMailContent.prototype.createtime = "";
            /**
             * UserMailContent msg.
             * @member {string} msg
             * @memberof itemprotocol.UserMailContent
             * @instance
             */

            UserMailContent.prototype.msg = "";
            /**
             * Creates a new UserMailContent instance using the specified properties.
             * @function create
             * @memberof itemprotocol.UserMailContent
             * @static
             * @param {itemprotocol.IUserMailContent=} [properties] Properties to set
             * @returns {itemprotocol.UserMailContent} UserMailContent instance
             */

            UserMailContent.create = function create(properties) {
              return new UserMailContent(properties);
            };
            /**
             * Encodes the specified UserMailContent message. Does not implicitly {@link itemprotocol.UserMailContent.verify|verify} messages.
             * @function encode
             * @memberof itemprotocol.UserMailContent
             * @static
             * @param {itemprotocol.IUserMailContent} message UserMailContent message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            UserMailContent.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.action != null && Object.hasOwnProperty.call(message, "action")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.action);
              if (message.gameid != null && Object.hasOwnProperty.call(message, "gameid")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int32(message.gameid);
              if (message.itemid != null && Object.hasOwnProperty.call(message, "itemid")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.itemid);
              if (message.amount != null && Object.hasOwnProperty.call(message, "amount")) writer.uint32(
              /* id 4, wireType 1 =*/
              33)["double"](message.amount);
              if (message.star != null && Object.hasOwnProperty.call(message, "star")) writer.uint32(
              /* id 5, wireType 0 =*/
              40).int32(message.star);
              if (message.wintype != null && Object.hasOwnProperty.call(message, "wintype")) writer.uint32(
              /* id 6, wireType 0 =*/
              48).int32(message.wintype);
              if (message.createtime != null && Object.hasOwnProperty.call(message, "createtime")) writer.uint32(
              /* id 7, wireType 2 =*/
              58).string(message.createtime);
              if (message.msg != null && Object.hasOwnProperty.call(message, "msg")) writer.uint32(
              /* id 8, wireType 2 =*/
              66).string(message.msg);
              return writer;
            };
            /**
             * Encodes the specified UserMailContent message, length delimited. Does not implicitly {@link itemprotocol.UserMailContent.verify|verify} messages.
             * @function encodeDelimited
             * @memberof itemprotocol.UserMailContent
             * @static
             * @param {itemprotocol.IUserMailContent} message UserMailContent message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            UserMailContent.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a UserMailContent message from the specified reader or buffer.
             * @function decode
             * @memberof itemprotocol.UserMailContent
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {itemprotocol.UserMailContent} UserMailContent
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            UserMailContent.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.itemprotocol.UserMailContent();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.action = reader.int32();
                    break;

                  case 2:
                    message.gameid = reader.int32();
                    break;

                  case 3:
                    message.itemid = reader.int32();
                    break;

                  case 4:
                    message.amount = reader["double"]();
                    break;

                  case 5:
                    message.star = reader.int32();
                    break;

                  case 6:
                    message.wintype = reader.int32();
                    break;

                  case 7:
                    message.createtime = reader.string();
                    break;

                  case 8:
                    message.msg = reader.string();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
             * Decodes a UserMailContent message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof itemprotocol.UserMailContent
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {itemprotocol.UserMailContent} UserMailContent
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            UserMailContent.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a UserMailContent message.
             * @function verify
             * @memberof itemprotocol.UserMailContent
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */


            UserMailContent.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.action != null && message.hasOwnProperty("action")) if (!$util.isInteger(message.action)) return "action: integer expected";
              if (message.gameid != null && message.hasOwnProperty("gameid")) if (!$util.isInteger(message.gameid)) return "gameid: integer expected";
              if (message.itemid != null && message.hasOwnProperty("itemid")) if (!$util.isInteger(message.itemid)) return "itemid: integer expected";
              if (message.amount != null && message.hasOwnProperty("amount")) if (typeof message.amount !== "number") return "amount: number expected";
              if (message.star != null && message.hasOwnProperty("star")) if (!$util.isInteger(message.star)) return "star: integer expected";
              if (message.wintype != null && message.hasOwnProperty("wintype")) if (!$util.isInteger(message.wintype)) return "wintype: integer expected";
              if (message.createtime != null && message.hasOwnProperty("createtime")) if (!$util.isString(message.createtime)) return "createtime: string expected";
              if (message.msg != null && message.hasOwnProperty("msg")) if (!$util.isString(message.msg)) return "msg: string expected";
              return null;
            };
            /**
             * Creates a UserMailContent message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof itemprotocol.UserMailContent
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {itemprotocol.UserMailContent} UserMailContent
             */


            UserMailContent.fromObject = function fromObject(object) {
              if (object instanceof $root.itemprotocol.UserMailContent) return object;
              var message = new $root.itemprotocol.UserMailContent();
              if (object.action != null) message.action = object.action | 0;
              if (object.gameid != null) message.gameid = object.gameid | 0;
              if (object.itemid != null) message.itemid = object.itemid | 0;
              if (object.amount != null) message.amount = Number(object.amount);
              if (object.star != null) message.star = object.star | 0;
              if (object.wintype != null) message.wintype = object.wintype | 0;
              if (object.createtime != null) message.createtime = String(object.createtime);
              if (object.msg != null) message.msg = String(object.msg);
              return message;
            };
            /**
             * Creates a plain object from a UserMailContent message. Also converts values to other types if specified.
             * @function toObject
             * @memberof itemprotocol.UserMailContent
             * @static
             * @param {itemprotocol.UserMailContent} message UserMailContent
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */


            UserMailContent.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.action = 0;
                object.gameid = 0;
                object.itemid = 0;
                object.amount = 0;
                object.star = 0;
                object.wintype = 0;
                object.createtime = "";
                object.msg = "";
              }

              if (message.action != null && message.hasOwnProperty("action")) object.action = message.action;
              if (message.gameid != null && message.hasOwnProperty("gameid")) object.gameid = message.gameid;
              if (message.itemid != null && message.hasOwnProperty("itemid")) object.itemid = message.itemid;
              if (message.amount != null && message.hasOwnProperty("amount")) object.amount = options.json && !isFinite(message.amount) ? String(message.amount) : message.amount;
              if (message.star != null && message.hasOwnProperty("star")) object.star = message.star;
              if (message.wintype != null && message.hasOwnProperty("wintype")) object.wintype = message.wintype;
              if (message.createtime != null && message.hasOwnProperty("createtime")) object.createtime = message.createtime;
              if (message.msg != null && message.hasOwnProperty("msg")) object.msg = message.msg;
              return object;
            };
            /**
             * Converts this UserMailContent to JSON.
             * @function toJSON
             * @memberof itemprotocol.UserMailContent
             * @instance
             * @returns {Object.<string,*>} JSON object
             */


            UserMailContent.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return UserMailContent;
          }();

          itemprotocol.UserMailData = function () {
            /**
             * Properties of a UserMailData.
             * @memberof itemprotocol
             * @interface IUserMailData
             * @property {number|null} [idx] UserMailData idx
             * @property {number|null} [accountid] UserMailData accountid
             * @property {number|null} [source] UserMailData source
             * @property {itemprotocol.IUserMailContent|null} [content] UserMailData content
             * @property {number|null} [isread] UserMailData isread
             * @property {string|null} [createtime] UserMailData createtime
             * @property {number|Long|null} [created] UserMailData created
             */

            /**
             * Constructs a new UserMailData.
             * @memberof itemprotocol
             * @classdesc Represents a UserMailData.
             * @implements IUserMailData
             * @constructor
             * @param {itemprotocol.IUserMailData=} [properties] Properties to set
             */
            function UserMailData(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * UserMailData idx.
             * @member {number} idx
             * @memberof itemprotocol.UserMailData
             * @instance
             */


            UserMailData.prototype.idx = 0;
            /**
             * UserMailData accountid.
             * @member {number} accountid
             * @memberof itemprotocol.UserMailData
             * @instance
             */

            UserMailData.prototype.accountid = 0;
            /**
             * UserMailData source.
             * @member {number} source
             * @memberof itemprotocol.UserMailData
             * @instance
             */

            UserMailData.prototype.source = 0;
            /**
             * UserMailData content.
             * @member {itemprotocol.IUserMailContent|null|undefined} content
             * @memberof itemprotocol.UserMailData
             * @instance
             */

            UserMailData.prototype.content = null;
            /**
             * UserMailData isread.
             * @member {number} isread
             * @memberof itemprotocol.UserMailData
             * @instance
             */

            UserMailData.prototype.isread = 0;
            /**
             * UserMailData createtime.
             * @member {string} createtime
             * @memberof itemprotocol.UserMailData
             * @instance
             */

            UserMailData.prototype.createtime = "";
            /**
             * UserMailData created.
             * @member {number|Long} created
             * @memberof itemprotocol.UserMailData
             * @instance
             */

            UserMailData.prototype.created = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
             * Creates a new UserMailData instance using the specified properties.
             * @function create
             * @memberof itemprotocol.UserMailData
             * @static
             * @param {itemprotocol.IUserMailData=} [properties] Properties to set
             * @returns {itemprotocol.UserMailData} UserMailData instance
             */

            UserMailData.create = function create(properties) {
              return new UserMailData(properties);
            };
            /**
             * Encodes the specified UserMailData message. Does not implicitly {@link itemprotocol.UserMailData.verify|verify} messages.
             * @function encode
             * @memberof itemprotocol.UserMailData
             * @static
             * @param {itemprotocol.IUserMailData} message UserMailData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            UserMailData.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.idx != null && Object.hasOwnProperty.call(message, "idx")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.idx);
              if (message.accountid != null && Object.hasOwnProperty.call(message, "accountid")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int32(message.accountid);
              if (message.source != null && Object.hasOwnProperty.call(message, "source")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.source);
              if (message.content != null && Object.hasOwnProperty.call(message, "content")) $root.itemprotocol.UserMailContent.encode(message.content, writer.uint32(
              /* id 4, wireType 2 =*/
              34).fork()).ldelim();
              if (message.isread != null && Object.hasOwnProperty.call(message, "isread")) writer.uint32(
              /* id 5, wireType 0 =*/
              40).int32(message.isread);
              if (message.createtime != null && Object.hasOwnProperty.call(message, "createtime")) writer.uint32(
              /* id 6, wireType 2 =*/
              50).string(message.createtime);
              if (message.created != null && Object.hasOwnProperty.call(message, "created")) writer.uint32(
              /* id 7, wireType 0 =*/
              56).int64(message.created);
              return writer;
            };
            /**
             * Encodes the specified UserMailData message, length delimited. Does not implicitly {@link itemprotocol.UserMailData.verify|verify} messages.
             * @function encodeDelimited
             * @memberof itemprotocol.UserMailData
             * @static
             * @param {itemprotocol.IUserMailData} message UserMailData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            UserMailData.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a UserMailData message from the specified reader or buffer.
             * @function decode
             * @memberof itemprotocol.UserMailData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {itemprotocol.UserMailData} UserMailData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            UserMailData.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.itemprotocol.UserMailData();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.idx = reader.int32();
                    break;

                  case 2:
                    message.accountid = reader.int32();
                    break;

                  case 3:
                    message.source = reader.int32();
                    break;

                  case 4:
                    message.content = $root.itemprotocol.UserMailContent.decode(reader, reader.uint32());
                    break;

                  case 5:
                    message.isread = reader.int32();
                    break;

                  case 6:
                    message.createtime = reader.string();
                    break;

                  case 7:
                    message.created = reader.int64();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
             * Decodes a UserMailData message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof itemprotocol.UserMailData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {itemprotocol.UserMailData} UserMailData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            UserMailData.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a UserMailData message.
             * @function verify
             * @memberof itemprotocol.UserMailData
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */


            UserMailData.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.idx != null && message.hasOwnProperty("idx")) if (!$util.isInteger(message.idx)) return "idx: integer expected";
              if (message.accountid != null && message.hasOwnProperty("accountid")) if (!$util.isInteger(message.accountid)) return "accountid: integer expected";
              if (message.source != null && message.hasOwnProperty("source")) if (!$util.isInteger(message.source)) return "source: integer expected";

              if (message.content != null && message.hasOwnProperty("content")) {
                var error = $root.itemprotocol.UserMailContent.verify(message.content);
                if (error) return "content." + error;
              }

              if (message.isread != null && message.hasOwnProperty("isread")) if (!$util.isInteger(message.isread)) return "isread: integer expected";
              if (message.createtime != null && message.hasOwnProperty("createtime")) if (!$util.isString(message.createtime)) return "createtime: string expected";
              if (message.created != null && message.hasOwnProperty("created")) if (!$util.isInteger(message.created) && !(message.created && $util.isInteger(message.created.low) && $util.isInteger(message.created.high))) return "created: integer|Long expected";
              return null;
            };
            /**
             * Creates a UserMailData message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof itemprotocol.UserMailData
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {itemprotocol.UserMailData} UserMailData
             */


            UserMailData.fromObject = function fromObject(object) {
              if (object instanceof $root.itemprotocol.UserMailData) return object;
              var message = new $root.itemprotocol.UserMailData();
              if (object.idx != null) message.idx = object.idx | 0;
              if (object.accountid != null) message.accountid = object.accountid | 0;
              if (object.source != null) message.source = object.source | 0;

              if (object.content != null) {
                if (typeof object.content !== "object") throw TypeError(".itemprotocol.UserMailData.content: object expected");
                message.content = $root.itemprotocol.UserMailContent.fromObject(object.content);
              }

              if (object.isread != null) message.isread = object.isread | 0;
              if (object.createtime != null) message.createtime = String(object.createtime);
              if (object.created != null) if ($util.Long) (message.created = $util.Long.fromValue(object.created)).unsigned = false;else if (typeof object.created === "string") message.created = parseInt(object.created, 10);else if (typeof object.created === "number") message.created = object.created;else if (typeof object.created === "object") message.created = new $util.LongBits(object.created.low >>> 0, object.created.high >>> 0).toNumber();
              return message;
            };
            /**
             * Creates a plain object from a UserMailData message. Also converts values to other types if specified.
             * @function toObject
             * @memberof itemprotocol.UserMailData
             * @static
             * @param {itemprotocol.UserMailData} message UserMailData
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */


            UserMailData.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.idx = 0;
                object.accountid = 0;
                object.source = 0;
                object.content = null;
                object.isread = 0;
                object.createtime = "";

                if ($util.Long) {
                  var _long2 = new $util.Long(0, 0, false);

                  object.created = options.longs === String ? _long2.toString() : options.longs === Number ? _long2.toNumber() : _long2;
                } else object.created = options.longs === String ? "0" : 0;
              }

              if (message.idx != null && message.hasOwnProperty("idx")) object.idx = message.idx;
              if (message.accountid != null && message.hasOwnProperty("accountid")) object.accountid = message.accountid;
              if (message.source != null && message.hasOwnProperty("source")) object.source = message.source;
              if (message.content != null && message.hasOwnProperty("content")) object.content = $root.itemprotocol.UserMailContent.toObject(message.content, options);
              if (message.isread != null && message.hasOwnProperty("isread")) object.isread = message.isread;
              if (message.createtime != null && message.hasOwnProperty("createtime")) object.createtime = message.createtime;
              if (message.created != null && message.hasOwnProperty("created")) if (typeof message.created === "number") object.created = options.longs === String ? String(message.created) : message.created;else object.created = options.longs === String ? $util.Long.prototype.toString.call(message.created) : options.longs === Number ? new $util.LongBits(message.created.low >>> 0, message.created.high >>> 0).toNumber() : message.created;
              return object;
            };
            /**
             * Converts this UserMailData to JSON.
             * @function toJSON
             * @memberof itemprotocol.UserMailData
             * @instance
             * @returns {Object.<string,*>} JSON object
             */


            UserMailData.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return UserMailData;
          }();

          itemprotocol.GetMailAck = function () {
            /**
             * Properties of a GetMailAck.
             * @memberof itemprotocol
             * @interface IGetMailAck
             * @property {number|null} [result] GetMailAck result
             * @property {Array.<itemprotocol.IUserMailData>|null} [usermailackdata] GetMailAck usermailackdata
             * @property {number|null} [isread] GetMailAck isread
             */

            /**
             * Constructs a new GetMailAck.
             * @memberof itemprotocol
             * @classdesc Represents a GetMailAck.
             * @implements IGetMailAck
             * @constructor
             * @param {itemprotocol.IGetMailAck=} [properties] Properties to set
             */
            function GetMailAck(properties) {
              this.usermailackdata = [];
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * GetMailAck result.
             * @member {number} result
             * @memberof itemprotocol.GetMailAck
             * @instance
             */


            GetMailAck.prototype.result = 0;
            /**
             * GetMailAck usermailackdata.
             * @member {Array.<itemprotocol.IUserMailData>} usermailackdata
             * @memberof itemprotocol.GetMailAck
             * @instance
             */

            GetMailAck.prototype.usermailackdata = $util.emptyArray;
            /**
             * GetMailAck isread.
             * @member {number} isread
             * @memberof itemprotocol.GetMailAck
             * @instance
             */

            GetMailAck.prototype.isread = 0;
            /**
             * Creates a new GetMailAck instance using the specified properties.
             * @function create
             * @memberof itemprotocol.GetMailAck
             * @static
             * @param {itemprotocol.IGetMailAck=} [properties] Properties to set
             * @returns {itemprotocol.GetMailAck} GetMailAck instance
             */

            GetMailAck.create = function create(properties) {
              return new GetMailAck(properties);
            };
            /**
             * Encodes the specified GetMailAck message. Does not implicitly {@link itemprotocol.GetMailAck.verify|verify} messages.
             * @function encode
             * @memberof itemprotocol.GetMailAck
             * @static
             * @param {itemprotocol.IGetMailAck} message GetMailAck message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            GetMailAck.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.result != null && Object.hasOwnProperty.call(message, "result")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.result);
              if (message.usermailackdata != null && message.usermailackdata.length) for (var i = 0; i < message.usermailackdata.length; ++i) {
                $root.itemprotocol.UserMailData.encode(message.usermailackdata[i], writer.uint32(
                /* id 2, wireType 2 =*/
                18).fork()).ldelim();
              }
              if (message.isread != null && Object.hasOwnProperty.call(message, "isread")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.isread);
              return writer;
            };
            /**
             * Encodes the specified GetMailAck message, length delimited. Does not implicitly {@link itemprotocol.GetMailAck.verify|verify} messages.
             * @function encodeDelimited
             * @memberof itemprotocol.GetMailAck
             * @static
             * @param {itemprotocol.IGetMailAck} message GetMailAck message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            GetMailAck.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a GetMailAck message from the specified reader or buffer.
             * @function decode
             * @memberof itemprotocol.GetMailAck
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {itemprotocol.GetMailAck} GetMailAck
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            GetMailAck.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.itemprotocol.GetMailAck();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.result = reader.int32();
                    break;

                  case 2:
                    if (!(message.usermailackdata && message.usermailackdata.length)) message.usermailackdata = [];
                    message.usermailackdata.push($root.itemprotocol.UserMailData.decode(reader, reader.uint32()));
                    break;

                  case 3:
                    message.isread = reader.int32();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
             * Decodes a GetMailAck message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof itemprotocol.GetMailAck
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {itemprotocol.GetMailAck} GetMailAck
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            GetMailAck.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a GetMailAck message.
             * @function verify
             * @memberof itemprotocol.GetMailAck
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */


            GetMailAck.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.result != null && message.hasOwnProperty("result")) if (!$util.isInteger(message.result)) return "result: integer expected";

              if (message.usermailackdata != null && message.hasOwnProperty("usermailackdata")) {
                if (!Array.isArray(message.usermailackdata)) return "usermailackdata: array expected";

                for (var i = 0; i < message.usermailackdata.length; ++i) {
                  var error = $root.itemprotocol.UserMailData.verify(message.usermailackdata[i]);
                  if (error) return "usermailackdata." + error;
                }
              }

              if (message.isread != null && message.hasOwnProperty("isread")) if (!$util.isInteger(message.isread)) return "isread: integer expected";
              return null;
            };
            /**
             * Creates a GetMailAck message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof itemprotocol.GetMailAck
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {itemprotocol.GetMailAck} GetMailAck
             */


            GetMailAck.fromObject = function fromObject(object) {
              if (object instanceof $root.itemprotocol.GetMailAck) return object;
              var message = new $root.itemprotocol.GetMailAck();
              if (object.result != null) message.result = object.result | 0;

              if (object.usermailackdata) {
                if (!Array.isArray(object.usermailackdata)) throw TypeError(".itemprotocol.GetMailAck.usermailackdata: array expected");
                message.usermailackdata = [];

                for (var i = 0; i < object.usermailackdata.length; ++i) {
                  if (typeof object.usermailackdata[i] !== "object") throw TypeError(".itemprotocol.GetMailAck.usermailackdata: object expected");
                  message.usermailackdata[i] = $root.itemprotocol.UserMailData.fromObject(object.usermailackdata[i]);
                }
              }

              if (object.isread != null) message.isread = object.isread | 0;
              return message;
            };
            /**
             * Creates a plain object from a GetMailAck message. Also converts values to other types if specified.
             * @function toObject
             * @memberof itemprotocol.GetMailAck
             * @static
             * @param {itemprotocol.GetMailAck} message GetMailAck
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */


            GetMailAck.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};
              if (options.arrays || options.defaults) object.usermailackdata = [];

              if (options.defaults) {
                object.result = 0;
                object.isread = 0;
              }

              if (message.result != null && message.hasOwnProperty("result")) object.result = message.result;

              if (message.usermailackdata && message.usermailackdata.length) {
                object.usermailackdata = [];

                for (var j = 0; j < message.usermailackdata.length; ++j) {
                  object.usermailackdata[j] = $root.itemprotocol.UserMailData.toObject(message.usermailackdata[j], options);
                }
              }

              if (message.isread != null && message.hasOwnProperty("isread")) object.isread = message.isread;
              return object;
            };
            /**
             * Converts this GetMailAck to JSON.
             * @function toJSON
             * @memberof itemprotocol.GetMailAck
             * @instance
             * @returns {Object.<string,*>} JSON object
             */


            GetMailAck.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GetMailAck;
          }();

          itemprotocol.ChangeMailAck = function () {
            /**
             * Properties of a ChangeMailAck.
             * @memberof itemprotocol
             * @interface IChangeMailAck
             * @property {number|null} [result] ChangeMailAck result
             */

            /**
             * Constructs a new ChangeMailAck.
             * @memberof itemprotocol
             * @classdesc Represents a ChangeMailAck.
             * @implements IChangeMailAck
             * @constructor
             * @param {itemprotocol.IChangeMailAck=} [properties] Properties to set
             */
            function ChangeMailAck(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * ChangeMailAck result.
             * @member {number} result
             * @memberof itemprotocol.ChangeMailAck
             * @instance
             */


            ChangeMailAck.prototype.result = 0;
            /**
             * Creates a new ChangeMailAck instance using the specified properties.
             * @function create
             * @memberof itemprotocol.ChangeMailAck
             * @static
             * @param {itemprotocol.IChangeMailAck=} [properties] Properties to set
             * @returns {itemprotocol.ChangeMailAck} ChangeMailAck instance
             */

            ChangeMailAck.create = function create(properties) {
              return new ChangeMailAck(properties);
            };
            /**
             * Encodes the specified ChangeMailAck message. Does not implicitly {@link itemprotocol.ChangeMailAck.verify|verify} messages.
             * @function encode
             * @memberof itemprotocol.ChangeMailAck
             * @static
             * @param {itemprotocol.IChangeMailAck} message ChangeMailAck message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            ChangeMailAck.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.result != null && Object.hasOwnProperty.call(message, "result")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.result);
              return writer;
            };
            /**
             * Encodes the specified ChangeMailAck message, length delimited. Does not implicitly {@link itemprotocol.ChangeMailAck.verify|verify} messages.
             * @function encodeDelimited
             * @memberof itemprotocol.ChangeMailAck
             * @static
             * @param {itemprotocol.IChangeMailAck} message ChangeMailAck message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            ChangeMailAck.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a ChangeMailAck message from the specified reader or buffer.
             * @function decode
             * @memberof itemprotocol.ChangeMailAck
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {itemprotocol.ChangeMailAck} ChangeMailAck
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            ChangeMailAck.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.itemprotocol.ChangeMailAck();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.result = reader.int32();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
             * Decodes a ChangeMailAck message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof itemprotocol.ChangeMailAck
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {itemprotocol.ChangeMailAck} ChangeMailAck
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            ChangeMailAck.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a ChangeMailAck message.
             * @function verify
             * @memberof itemprotocol.ChangeMailAck
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */


            ChangeMailAck.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.result != null && message.hasOwnProperty("result")) if (!$util.isInteger(message.result)) return "result: integer expected";
              return null;
            };
            /**
             * Creates a ChangeMailAck message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof itemprotocol.ChangeMailAck
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {itemprotocol.ChangeMailAck} ChangeMailAck
             */


            ChangeMailAck.fromObject = function fromObject(object) {
              if (object instanceof $root.itemprotocol.ChangeMailAck) return object;
              var message = new $root.itemprotocol.ChangeMailAck();
              if (object.result != null) message.result = object.result | 0;
              return message;
            };
            /**
             * Creates a plain object from a ChangeMailAck message. Also converts values to other types if specified.
             * @function toObject
             * @memberof itemprotocol.ChangeMailAck
             * @static
             * @param {itemprotocol.ChangeMailAck} message ChangeMailAck
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */


            ChangeMailAck.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};
              if (options.defaults) object.result = 0;
              if (message.result != null && message.hasOwnProperty("result")) object.result = message.result;
              return object;
            };
            /**
             * Converts this ChangeMailAck to JSON.
             * @function toJSON
             * @memberof itemprotocol.ChangeMailAck
             * @instance
             * @returns {Object.<string,*>} JSON object
             */


            ChangeMailAck.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ChangeMailAck;
          }();

          return itemprotocol;
        }();

        module.exports = $root; // #endregion ORIGINAL CODE

        _cjsExports = exports('default', module.exports);
      }, function () {
        return {
          'protobufjs/minimal': __cjsMetaURL$1
        };
      });
    }
  };
});

System.register("chunks:///_virtual/itemproto.mjs_cjs=&original=.js", ['./itemproto.js', './cjs-loader.mjs'], function (exports, module) {
  'use strict';

  var __cjsMetaURL, loader;

  return {
    setters: [function (module) {
      __cjsMetaURL = module.__cjsMetaURL;
      var _setter = {};
      _setter.__cjsMetaURL = module.__cjsMetaURL;
      _setter.default = module.default;
      exports(_setter);
    }, function (module) {
      loader = module.default;
    }],
    execute: function () {
      // I am the facade module who provides access to the CommonJS module './itemproto.js'~
      if (!__cjsMetaURL) {
        loader.throwInvalidWrapper('./itemproto.js', module.meta.url);
      }

      loader.require(__cjsMetaURL);
    }
  };
});

System.register("chunks:///_virtual/levelservice.js", ['./cjs-loader.mjs', './minimal.js'], function (exports, module) {
  'use strict';

  var loader, __cjsMetaURL$1;

  return {
    setters: [function (module) {
      loader = module.default;
    }, function (module) {
      __cjsMetaURL$1 = module.__cjsMetaURL;
    }],
    execute: function () {
      exports('default', void 0);

      var _cjsExports;

      var __cjsMetaURL = exports('__cjsMetaURL', module.meta.url);

      loader.define(__cjsMetaURL, function (exports$1, require, module, __filename, __dirname) {
        var $protobuf = require("protobufjs/minimal"); // Common aliases


        var $Reader = $protobuf.Reader,
            $Writer = $protobuf.Writer,
            $util = $protobuf.util; // Exported root namespace

        var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

        $root.levelProto = function () {
          /**
           * Namespace levelProto.
           * @exports levelProto
           * @namespace
           */
          var levelProto = {};
          /**
           * Error enum.
           * @name levelProto.Error
           * @enum {number}
           * @property {number} success=0 success value
           * @property {number} failed=1 failed value
           * @property {number} unknow=999 unknow value
           */

          levelProto.Error = function () {
            var valuesById = {},
                values = Object.create(valuesById);
            values[valuesById[0] = "success"] = 0;
            values[valuesById[1] = "failed"] = 1;
            values[valuesById[999] = "unknow"] = 999;
            return values;
          }();

          levelProto.LevelServiceReq = function () {
            /**
             * Properties of a LevelServiceReq.
             * @memberof levelProto
             * @interface ILevelServiceReq
             * @property {number|null} [accountID] LevelServiceReq accountID
             */

            /**
             * Constructs a new LevelServiceReq.
             * @memberof levelProto
             * @classdesc Represents a LevelServiceReq.
             * @implements ILevelServiceReq
             * @constructor
             * @param {levelProto.ILevelServiceReq=} [properties] Properties to set
             */
            function LevelServiceReq(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * LevelServiceReq accountID.
             * @member {number} accountID
             * @memberof levelProto.LevelServiceReq
             * @instance
             */


            LevelServiceReq.prototype.accountID = 0;
            /**
             * Creates a new LevelServiceReq instance using the specified properties.
             * @function create
             * @memberof levelProto.LevelServiceReq
             * @static
             * @param {levelProto.ILevelServiceReq=} [properties] Properties to set
             * @returns {levelProto.LevelServiceReq} LevelServiceReq instance
             */

            LevelServiceReq.create = function create(properties) {
              return new LevelServiceReq(properties);
            };
            /**
             * Encodes the specified LevelServiceReq message. Does not implicitly {@link levelProto.LevelServiceReq.verify|verify} messages.
             * @function encode
             * @memberof levelProto.LevelServiceReq
             * @static
             * @param {levelProto.ILevelServiceReq} message LevelServiceReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            LevelServiceReq.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.accountID != null && Object.hasOwnProperty.call(message, "accountID")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.accountID);
              return writer;
            };
            /**
             * Encodes the specified LevelServiceReq message, length delimited. Does not implicitly {@link levelProto.LevelServiceReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof levelProto.LevelServiceReq
             * @static
             * @param {levelProto.ILevelServiceReq} message LevelServiceReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            LevelServiceReq.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a LevelServiceReq message from the specified reader or buffer.
             * @function decode
             * @memberof levelProto.LevelServiceReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {levelProto.LevelServiceReq} LevelServiceReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            LevelServiceReq.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.levelProto.LevelServiceReq();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.accountID = reader.int32();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
             * Decodes a LevelServiceReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof levelProto.LevelServiceReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {levelProto.LevelServiceReq} LevelServiceReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            LevelServiceReq.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a LevelServiceReq message.
             * @function verify
             * @memberof levelProto.LevelServiceReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */


            LevelServiceReq.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.accountID != null && message.hasOwnProperty("accountID")) if (!$util.isInteger(message.accountID)) return "accountID: integer expected";
              return null;
            };
            /**
             * Creates a LevelServiceReq message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof levelProto.LevelServiceReq
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {levelProto.LevelServiceReq} LevelServiceReq
             */


            LevelServiceReq.fromObject = function fromObject(object) {
              if (object instanceof $root.levelProto.LevelServiceReq) return object;
              var message = new $root.levelProto.LevelServiceReq();
              if (object.accountID != null) message.accountID = object.accountID | 0;
              return message;
            };
            /**
             * Creates a plain object from a LevelServiceReq message. Also converts values to other types if specified.
             * @function toObject
             * @memberof levelProto.LevelServiceReq
             * @static
             * @param {levelProto.LevelServiceReq} message LevelServiceReq
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */


            LevelServiceReq.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};
              if (options.defaults) object.accountID = 0;
              if (message.accountID != null && message.hasOwnProperty("accountID")) object.accountID = message.accountID;
              return object;
            };
            /**
             * Converts this LevelServiceReq to JSON.
             * @function toJSON
             * @memberof levelProto.LevelServiceReq
             * @instance
             * @returns {Object.<string,*>} JSON object
             */


            LevelServiceReq.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return LevelServiceReq;
          }();

          levelProto.LevelServiceResp = function () {
            /**
             * Properties of a LevelServiceResp.
             * @memberof levelProto
             * @interface ILevelServiceResp
             * @property {number|null} [level] LevelServiceResp level
             * @property {number|null} [exp] LevelServiceResp exp
             * @property {number|null} [nextExp] LevelServiceResp nextExp
             * @property {Array.<levelProto.IRewardData>|null} [nextReward] LevelServiceResp nextReward
             * @property {Array.<levelProto.IRewardData>|null} [reward] LevelServiceResp reward
             * @property {levelProto.Error|null} [error] LevelServiceResp error
             * @property {number|null} [betOpen] LevelServiceResp betOpen
             */

            /**
             * Constructs a new LevelServiceResp.
             * @memberof levelProto
             * @classdesc Represents a LevelServiceResp.
             * @implements ILevelServiceResp
             * @constructor
             * @param {levelProto.ILevelServiceResp=} [properties] Properties to set
             */
            function LevelServiceResp(properties) {
              this.nextReward = [];
              this.reward = [];
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * LevelServiceResp level.
             * @member {number} level
             * @memberof levelProto.LevelServiceResp
             * @instance
             */


            LevelServiceResp.prototype.level = 0;
            /**
             * LevelServiceResp exp.
             * @member {number} exp
             * @memberof levelProto.LevelServiceResp
             * @instance
             */

            LevelServiceResp.prototype.exp = 0;
            /**
             * LevelServiceResp nextExp.
             * @member {number} nextExp
             * @memberof levelProto.LevelServiceResp
             * @instance
             */

            LevelServiceResp.prototype.nextExp = 0;
            /**
             * LevelServiceResp nextReward.
             * @member {Array.<levelProto.IRewardData>} nextReward
             * @memberof levelProto.LevelServiceResp
             * @instance
             */

            LevelServiceResp.prototype.nextReward = $util.emptyArray;
            /**
             * LevelServiceResp reward.
             * @member {Array.<levelProto.IRewardData>} reward
             * @memberof levelProto.LevelServiceResp
             * @instance
             */

            LevelServiceResp.prototype.reward = $util.emptyArray;
            /**
             * LevelServiceResp error.
             * @member {levelProto.Error} error
             * @memberof levelProto.LevelServiceResp
             * @instance
             */

            LevelServiceResp.prototype.error = 0;
            /**
             * LevelServiceResp betOpen.
             * @member {number} betOpen
             * @memberof levelProto.LevelServiceResp
             * @instance
             */

            LevelServiceResp.prototype.betOpen = 0;
            /**
             * Creates a new LevelServiceResp instance using the specified properties.
             * @function create
             * @memberof levelProto.LevelServiceResp
             * @static
             * @param {levelProto.ILevelServiceResp=} [properties] Properties to set
             * @returns {levelProto.LevelServiceResp} LevelServiceResp instance
             */

            LevelServiceResp.create = function create(properties) {
              return new LevelServiceResp(properties);
            };
            /**
             * Encodes the specified LevelServiceResp message. Does not implicitly {@link levelProto.LevelServiceResp.verify|verify} messages.
             * @function encode
             * @memberof levelProto.LevelServiceResp
             * @static
             * @param {levelProto.ILevelServiceResp} message LevelServiceResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            LevelServiceResp.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.level != null && Object.hasOwnProperty.call(message, "level")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.level);
              if (message.exp != null && Object.hasOwnProperty.call(message, "exp")) writer.uint32(
              /* id 2, wireType 1 =*/
              17)["double"](message.exp);
              if (message.nextExp != null && Object.hasOwnProperty.call(message, "nextExp")) writer.uint32(
              /* id 3, wireType 1 =*/
              25)["double"](message.nextExp);
              if (message.nextReward != null && message.nextReward.length) for (var i = 0; i < message.nextReward.length; ++i) {
                $root.levelProto.RewardData.encode(message.nextReward[i], writer.uint32(
                /* id 4, wireType 2 =*/
                34).fork()).ldelim();
              }
              if (message.reward != null && message.reward.length) for (var i = 0; i < message.reward.length; ++i) {
                $root.levelProto.RewardData.encode(message.reward[i], writer.uint32(
                /* id 5, wireType 2 =*/
                42).fork()).ldelim();
              }
              if (message.error != null && Object.hasOwnProperty.call(message, "error")) writer.uint32(
              /* id 6, wireType 0 =*/
              48).int32(message.error);
              if (message.betOpen != null && Object.hasOwnProperty.call(message, "betOpen")) writer.uint32(
              /* id 7, wireType 0 =*/
              56).int32(message.betOpen);
              return writer;
            };
            /**
             * Encodes the specified LevelServiceResp message, length delimited. Does not implicitly {@link levelProto.LevelServiceResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof levelProto.LevelServiceResp
             * @static
             * @param {levelProto.ILevelServiceResp} message LevelServiceResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            LevelServiceResp.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a LevelServiceResp message from the specified reader or buffer.
             * @function decode
             * @memberof levelProto.LevelServiceResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {levelProto.LevelServiceResp} LevelServiceResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            LevelServiceResp.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.levelProto.LevelServiceResp();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.level = reader.int32();
                    break;

                  case 2:
                    message.exp = reader["double"]();
                    break;

                  case 3:
                    message.nextExp = reader["double"]();
                    break;

                  case 4:
                    if (!(message.nextReward && message.nextReward.length)) message.nextReward = [];
                    message.nextReward.push($root.levelProto.RewardData.decode(reader, reader.uint32()));
                    break;

                  case 5:
                    if (!(message.reward && message.reward.length)) message.reward = [];
                    message.reward.push($root.levelProto.RewardData.decode(reader, reader.uint32()));
                    break;

                  case 6:
                    message.error = reader.int32();
                    break;

                  case 7:
                    message.betOpen = reader.int32();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
             * Decodes a LevelServiceResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof levelProto.LevelServiceResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {levelProto.LevelServiceResp} LevelServiceResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            LevelServiceResp.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a LevelServiceResp message.
             * @function verify
             * @memberof levelProto.LevelServiceResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */


            LevelServiceResp.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.level != null && message.hasOwnProperty("level")) if (!$util.isInteger(message.level)) return "level: integer expected";
              if (message.exp != null && message.hasOwnProperty("exp")) if (typeof message.exp !== "number") return "exp: number expected";
              if (message.nextExp != null && message.hasOwnProperty("nextExp")) if (typeof message.nextExp !== "number") return "nextExp: number expected";

              if (message.nextReward != null && message.hasOwnProperty("nextReward")) {
                if (!Array.isArray(message.nextReward)) return "nextReward: array expected";

                for (var i = 0; i < message.nextReward.length; ++i) {
                  var error = $root.levelProto.RewardData.verify(message.nextReward[i]);
                  if (error) return "nextReward." + error;
                }
              }

              if (message.reward != null && message.hasOwnProperty("reward")) {
                if (!Array.isArray(message.reward)) return "reward: array expected";

                for (var i = 0; i < message.reward.length; ++i) {
                  var error = $root.levelProto.RewardData.verify(message.reward[i]);
                  if (error) return "reward." + error;
                }
              }

              if (message.error != null && message.hasOwnProperty("error")) switch (message.error) {
                default:
                  return "error: enum value expected";

                case 0:
                case 1:
                case 999:
                  break;
              }
              if (message.betOpen != null && message.hasOwnProperty("betOpen")) if (!$util.isInteger(message.betOpen)) return "betOpen: integer expected";
              return null;
            };
            /**
             * Creates a LevelServiceResp message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof levelProto.LevelServiceResp
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {levelProto.LevelServiceResp} LevelServiceResp
             */


            LevelServiceResp.fromObject = function fromObject(object) {
              if (object instanceof $root.levelProto.LevelServiceResp) return object;
              var message = new $root.levelProto.LevelServiceResp();
              if (object.level != null) message.level = object.level | 0;
              if (object.exp != null) message.exp = Number(object.exp);
              if (object.nextExp != null) message.nextExp = Number(object.nextExp);

              if (object.nextReward) {
                if (!Array.isArray(object.nextReward)) throw TypeError(".levelProto.LevelServiceResp.nextReward: array expected");
                message.nextReward = [];

                for (var i = 0; i < object.nextReward.length; ++i) {
                  if (typeof object.nextReward[i] !== "object") throw TypeError(".levelProto.LevelServiceResp.nextReward: object expected");
                  message.nextReward[i] = $root.levelProto.RewardData.fromObject(object.nextReward[i]);
                }
              }

              if (object.reward) {
                if (!Array.isArray(object.reward)) throw TypeError(".levelProto.LevelServiceResp.reward: array expected");
                message.reward = [];

                for (var i = 0; i < object.reward.length; ++i) {
                  if (typeof object.reward[i] !== "object") throw TypeError(".levelProto.LevelServiceResp.reward: object expected");
                  message.reward[i] = $root.levelProto.RewardData.fromObject(object.reward[i]);
                }
              }

              switch (object.error) {
                case "success":
                case 0:
                  message.error = 0;
                  break;

                case "failed":
                case 1:
                  message.error = 1;
                  break;

                case "unknow":
                case 999:
                  message.error = 999;
                  break;
              }

              if (object.betOpen != null) message.betOpen = object.betOpen | 0;
              return message;
            };
            /**
             * Creates a plain object from a LevelServiceResp message. Also converts values to other types if specified.
             * @function toObject
             * @memberof levelProto.LevelServiceResp
             * @static
             * @param {levelProto.LevelServiceResp} message LevelServiceResp
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */


            LevelServiceResp.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.arrays || options.defaults) {
                object.nextReward = [];
                object.reward = [];
              }

              if (options.defaults) {
                object.level = 0;
                object.exp = 0;
                object.nextExp = 0;
                object.error = options.enums === String ? "success" : 0;
                object.betOpen = 0;
              }

              if (message.level != null && message.hasOwnProperty("level")) object.level = message.level;
              if (message.exp != null && message.hasOwnProperty("exp")) object.exp = options.json && !isFinite(message.exp) ? String(message.exp) : message.exp;
              if (message.nextExp != null && message.hasOwnProperty("nextExp")) object.nextExp = options.json && !isFinite(message.nextExp) ? String(message.nextExp) : message.nextExp;

              if (message.nextReward && message.nextReward.length) {
                object.nextReward = [];

                for (var j = 0; j < message.nextReward.length; ++j) {
                  object.nextReward[j] = $root.levelProto.RewardData.toObject(message.nextReward[j], options);
                }
              }

              if (message.reward && message.reward.length) {
                object.reward = [];

                for (var j = 0; j < message.reward.length; ++j) {
                  object.reward[j] = $root.levelProto.RewardData.toObject(message.reward[j], options);
                }
              }

              if (message.error != null && message.hasOwnProperty("error")) object.error = options.enums === String ? $root.levelProto.Error[message.error] : message.error;
              if (message.betOpen != null && message.hasOwnProperty("betOpen")) object.betOpen = message.betOpen;
              return object;
            };
            /**
             * Converts this LevelServiceResp to JSON.
             * @function toJSON
             * @memberof levelProto.LevelServiceResp
             * @instance
             * @returns {Object.<string,*>} JSON object
             */


            LevelServiceResp.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return LevelServiceResp;
          }();

          levelProto.RewardData = function () {
            /**
             * Properties of a RewardData.
             * @memberof levelProto
             * @interface IRewardData
             * @property {number|null} [amount] RewardData amount
             * @property {number|null} [betOpen] RewardData betOpen
             * @property {number|null} [newGame] RewardData newGame
             * @property {number|null} [origin] RewardData origin
             * @property {Array.<number>|null} [newGames] RewardData newGames
             * @property {Array.<number>|null} [unlock] RewardData unlock
             * @property {number|null} [vipExp] RewardData vipExp
             * @property {number|null} [ruby] RewardData ruby
             * @property {number|null} [itemID] RewardData itemID
             * @property {number|null} [ItemCount] RewardData ItemCount
             * @property {number|Long|null} [buffID] RewardData buffID
             * @property {number|null} [buffCount] RewardData buffCount
             * @property {number|null} [cardBookID] RewardData cardBookID
             * @property {number|null} [cardBookCount] RewardData cardBookCount
             * @property {number|null} [show] RewardData show
             */

            /**
             * Constructs a new RewardData.
             * @memberof levelProto
             * @classdesc Represents a RewardData.
             * @implements IRewardData
             * @constructor
             * @param {levelProto.IRewardData=} [properties] Properties to set
             */
            function RewardData(properties) {
              this.newGames = [];
              this.unlock = [];
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * RewardData amount.
             * @member {number} amount
             * @memberof levelProto.RewardData
             * @instance
             */


            RewardData.prototype.amount = 0;
            /**
             * RewardData betOpen.
             * @member {number} betOpen
             * @memberof levelProto.RewardData
             * @instance
             */

            RewardData.prototype.betOpen = 0;
            /**
             * RewardData newGame.
             * @member {number} newGame
             * @memberof levelProto.RewardData
             * @instance
             */

            RewardData.prototype.newGame = 0;
            /**
             * RewardData origin.
             * @member {number} origin
             * @memberof levelProto.RewardData
             * @instance
             */

            RewardData.prototype.origin = 0;
            /**
             * RewardData newGames.
             * @member {Array.<number>} newGames
             * @memberof levelProto.RewardData
             * @instance
             */

            RewardData.prototype.newGames = $util.emptyArray;
            /**
             * RewardData unlock.
             * @member {Array.<number>} unlock
             * @memberof levelProto.RewardData
             * @instance
             */

            RewardData.prototype.unlock = $util.emptyArray;
            /**
             * RewardData vipExp.
             * @member {number} vipExp
             * @memberof levelProto.RewardData
             * @instance
             */

            RewardData.prototype.vipExp = 0;
            /**
             * RewardData ruby.
             * @member {number} ruby
             * @memberof levelProto.RewardData
             * @instance
             */

            RewardData.prototype.ruby = 0;
            /**
             * RewardData itemID.
             * @member {number} itemID
             * @memberof levelProto.RewardData
             * @instance
             */

            RewardData.prototype.itemID = 0;
            /**
             * RewardData ItemCount.
             * @member {number} ItemCount
             * @memberof levelProto.RewardData
             * @instance
             */

            RewardData.prototype.ItemCount = 0;
            /**
             * RewardData buffID.
             * @member {number|Long} buffID
             * @memberof levelProto.RewardData
             * @instance
             */

            RewardData.prototype.buffID = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
             * RewardData buffCount.
             * @member {number} buffCount
             * @memberof levelProto.RewardData
             * @instance
             */

            RewardData.prototype.buffCount = 0;
            /**
             * RewardData cardBookID.
             * @member {number} cardBookID
             * @memberof levelProto.RewardData
             * @instance
             */

            RewardData.prototype.cardBookID = 0;
            /**
             * RewardData cardBookCount.
             * @member {number} cardBookCount
             * @memberof levelProto.RewardData
             * @instance
             */

            RewardData.prototype.cardBookCount = 0;
            /**
             * RewardData show.
             * @member {number} show
             * @memberof levelProto.RewardData
             * @instance
             */

            RewardData.prototype.show = 0;
            /**
             * Creates a new RewardData instance using the specified properties.
             * @function create
             * @memberof levelProto.RewardData
             * @static
             * @param {levelProto.IRewardData=} [properties] Properties to set
             * @returns {levelProto.RewardData} RewardData instance
             */

            RewardData.create = function create(properties) {
              return new RewardData(properties);
            };
            /**
             * Encodes the specified RewardData message. Does not implicitly {@link levelProto.RewardData.verify|verify} messages.
             * @function encode
             * @memberof levelProto.RewardData
             * @static
             * @param {levelProto.IRewardData} message RewardData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            RewardData.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.amount != null && Object.hasOwnProperty.call(message, "amount")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.amount);
              if (message.betOpen != null && Object.hasOwnProperty.call(message, "betOpen")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int32(message.betOpen);
              if (message.newGame != null && Object.hasOwnProperty.call(message, "newGame")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.newGame);
              if (message.origin != null && Object.hasOwnProperty.call(message, "origin")) writer.uint32(
              /* id 4, wireType 0 =*/
              32).int32(message.origin);

              if (message.newGames != null && message.newGames.length) {
                writer.uint32(
                /* id 5, wireType 2 =*/
                42).fork();

                for (var i = 0; i < message.newGames.length; ++i) {
                  writer.int32(message.newGames[i]);
                }

                writer.ldelim();
              }

              if (message.unlock != null && message.unlock.length) {
                writer.uint32(
                /* id 6, wireType 2 =*/
                50).fork();

                for (var i = 0; i < message.unlock.length; ++i) {
                  writer.int32(message.unlock[i]);
                }

                writer.ldelim();
              }

              if (message.vipExp != null && Object.hasOwnProperty.call(message, "vipExp")) writer.uint32(
              /* id 7, wireType 0 =*/
              56).int32(message.vipExp);
              if (message.ruby != null && Object.hasOwnProperty.call(message, "ruby")) writer.uint32(
              /* id 8, wireType 0 =*/
              64).int32(message.ruby);
              if (message.itemID != null && Object.hasOwnProperty.call(message, "itemID")) writer.uint32(
              /* id 9, wireType 0 =*/
              72).int32(message.itemID);
              if (message.ItemCount != null && Object.hasOwnProperty.call(message, "ItemCount")) writer.uint32(
              /* id 10, wireType 0 =*/
              80).int32(message.ItemCount);
              if (message.buffID != null && Object.hasOwnProperty.call(message, "buffID")) writer.uint32(
              /* id 11, wireType 0 =*/
              88).int64(message.buffID);
              if (message.buffCount != null && Object.hasOwnProperty.call(message, "buffCount")) writer.uint32(
              /* id 12, wireType 0 =*/
              96).int32(message.buffCount);
              if (message.cardBookID != null && Object.hasOwnProperty.call(message, "cardBookID")) writer.uint32(
              /* id 13, wireType 0 =*/
              104).int32(message.cardBookID);
              if (message.cardBookCount != null && Object.hasOwnProperty.call(message, "cardBookCount")) writer.uint32(
              /* id 14, wireType 0 =*/
              112).int32(message.cardBookCount);
              if (message.show != null && Object.hasOwnProperty.call(message, "show")) writer.uint32(
              /* id 15, wireType 0 =*/
              120).int32(message.show);
              return writer;
            };
            /**
             * Encodes the specified RewardData message, length delimited. Does not implicitly {@link levelProto.RewardData.verify|verify} messages.
             * @function encodeDelimited
             * @memberof levelProto.RewardData
             * @static
             * @param {levelProto.IRewardData} message RewardData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            RewardData.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a RewardData message from the specified reader or buffer.
             * @function decode
             * @memberof levelProto.RewardData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {levelProto.RewardData} RewardData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            RewardData.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.levelProto.RewardData();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.amount = reader.int32();
                    break;

                  case 2:
                    message.betOpen = reader.int32();
                    break;

                  case 3:
                    message.newGame = reader.int32();
                    break;

                  case 4:
                    message.origin = reader.int32();
                    break;

                  case 5:
                    if (!(message.newGames && message.newGames.length)) message.newGames = [];

                    if ((tag & 7) === 2) {
                      var end2 = reader.uint32() + reader.pos;

                      while (reader.pos < end2) {
                        message.newGames.push(reader.int32());
                      }
                    } else message.newGames.push(reader.int32());

                    break;

                  case 6:
                    if (!(message.unlock && message.unlock.length)) message.unlock = [];

                    if ((tag & 7) === 2) {
                      var end2 = reader.uint32() + reader.pos;

                      while (reader.pos < end2) {
                        message.unlock.push(reader.int32());
                      }
                    } else message.unlock.push(reader.int32());

                    break;

                  case 7:
                    message.vipExp = reader.int32();
                    break;

                  case 8:
                    message.ruby = reader.int32();
                    break;

                  case 9:
                    message.itemID = reader.int32();
                    break;

                  case 10:
                    message.ItemCount = reader.int32();
                    break;

                  case 11:
                    message.buffID = reader.int64();
                    break;

                  case 12:
                    message.buffCount = reader.int32();
                    break;

                  case 13:
                    message.cardBookID = reader.int32();
                    break;

                  case 14:
                    message.cardBookCount = reader.int32();
                    break;

                  case 15:
                    message.show = reader.int32();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
             * Decodes a RewardData message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof levelProto.RewardData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {levelProto.RewardData} RewardData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            RewardData.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a RewardData message.
             * @function verify
             * @memberof levelProto.RewardData
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */


            RewardData.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.amount != null && message.hasOwnProperty("amount")) if (!$util.isInteger(message.amount)) return "amount: integer expected";
              if (message.betOpen != null && message.hasOwnProperty("betOpen")) if (!$util.isInteger(message.betOpen)) return "betOpen: integer expected";
              if (message.newGame != null && message.hasOwnProperty("newGame")) if (!$util.isInteger(message.newGame)) return "newGame: integer expected";
              if (message.origin != null && message.hasOwnProperty("origin")) if (!$util.isInteger(message.origin)) return "origin: integer expected";

              if (message.newGames != null && message.hasOwnProperty("newGames")) {
                if (!Array.isArray(message.newGames)) return "newGames: array expected";

                for (var i = 0; i < message.newGames.length; ++i) {
                  if (!$util.isInteger(message.newGames[i])) return "newGames: integer[] expected";
                }
              }

              if (message.unlock != null && message.hasOwnProperty("unlock")) {
                if (!Array.isArray(message.unlock)) return "unlock: array expected";

                for (var i = 0; i < message.unlock.length; ++i) {
                  if (!$util.isInteger(message.unlock[i])) return "unlock: integer[] expected";
                }
              }

              if (message.vipExp != null && message.hasOwnProperty("vipExp")) if (!$util.isInteger(message.vipExp)) return "vipExp: integer expected";
              if (message.ruby != null && message.hasOwnProperty("ruby")) if (!$util.isInteger(message.ruby)) return "ruby: integer expected";
              if (message.itemID != null && message.hasOwnProperty("itemID")) if (!$util.isInteger(message.itemID)) return "itemID: integer expected";
              if (message.ItemCount != null && message.hasOwnProperty("ItemCount")) if (!$util.isInteger(message.ItemCount)) return "ItemCount: integer expected";
              if (message.buffID != null && message.hasOwnProperty("buffID")) if (!$util.isInteger(message.buffID) && !(message.buffID && $util.isInteger(message.buffID.low) && $util.isInteger(message.buffID.high))) return "buffID: integer|Long expected";
              if (message.buffCount != null && message.hasOwnProperty("buffCount")) if (!$util.isInteger(message.buffCount)) return "buffCount: integer expected";
              if (message.cardBookID != null && message.hasOwnProperty("cardBookID")) if (!$util.isInteger(message.cardBookID)) return "cardBookID: integer expected";
              if (message.cardBookCount != null && message.hasOwnProperty("cardBookCount")) if (!$util.isInteger(message.cardBookCount)) return "cardBookCount: integer expected";
              if (message.show != null && message.hasOwnProperty("show")) if (!$util.isInteger(message.show)) return "show: integer expected";
              return null;
            };
            /**
             * Creates a RewardData message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof levelProto.RewardData
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {levelProto.RewardData} RewardData
             */


            RewardData.fromObject = function fromObject(object) {
              if (object instanceof $root.levelProto.RewardData) return object;
              var message = new $root.levelProto.RewardData();
              if (object.amount != null) message.amount = object.amount | 0;
              if (object.betOpen != null) message.betOpen = object.betOpen | 0;
              if (object.newGame != null) message.newGame = object.newGame | 0;
              if (object.origin != null) message.origin = object.origin | 0;

              if (object.newGames) {
                if (!Array.isArray(object.newGames)) throw TypeError(".levelProto.RewardData.newGames: array expected");
                message.newGames = [];

                for (var i = 0; i < object.newGames.length; ++i) {
                  message.newGames[i] = object.newGames[i] | 0;
                }
              }

              if (object.unlock) {
                if (!Array.isArray(object.unlock)) throw TypeError(".levelProto.RewardData.unlock: array expected");
                message.unlock = [];

                for (var i = 0; i < object.unlock.length; ++i) {
                  message.unlock[i] = object.unlock[i] | 0;
                }
              }

              if (object.vipExp != null) message.vipExp = object.vipExp | 0;
              if (object.ruby != null) message.ruby = object.ruby | 0;
              if (object.itemID != null) message.itemID = object.itemID | 0;
              if (object.ItemCount != null) message.ItemCount = object.ItemCount | 0;
              if (object.buffID != null) if ($util.Long) (message.buffID = $util.Long.fromValue(object.buffID)).unsigned = false;else if (typeof object.buffID === "string") message.buffID = parseInt(object.buffID, 10);else if (typeof object.buffID === "number") message.buffID = object.buffID;else if (typeof object.buffID === "object") message.buffID = new $util.LongBits(object.buffID.low >>> 0, object.buffID.high >>> 0).toNumber();
              if (object.buffCount != null) message.buffCount = object.buffCount | 0;
              if (object.cardBookID != null) message.cardBookID = object.cardBookID | 0;
              if (object.cardBookCount != null) message.cardBookCount = object.cardBookCount | 0;
              if (object.show != null) message.show = object.show | 0;
              return message;
            };
            /**
             * Creates a plain object from a RewardData message. Also converts values to other types if specified.
             * @function toObject
             * @memberof levelProto.RewardData
             * @static
             * @param {levelProto.RewardData} message RewardData
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */


            RewardData.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.arrays || options.defaults) {
                object.newGames = [];
                object.unlock = [];
              }

              if (options.defaults) {
                object.amount = 0;
                object.betOpen = 0;
                object.newGame = 0;
                object.origin = 0;
                object.vipExp = 0;
                object.ruby = 0;
                object.itemID = 0;
                object.ItemCount = 0;

                if ($util.Long) {
                  var _long = new $util.Long(0, 0, false);

                  object.buffID = options.longs === String ? _long.toString() : options.longs === Number ? _long.toNumber() : _long;
                } else object.buffID = options.longs === String ? "0" : 0;

                object.buffCount = 0;
                object.cardBookID = 0;
                object.cardBookCount = 0;
                object.show = 0;
              }

              if (message.amount != null && message.hasOwnProperty("amount")) object.amount = message.amount;
              if (message.betOpen != null && message.hasOwnProperty("betOpen")) object.betOpen = message.betOpen;
              if (message.newGame != null && message.hasOwnProperty("newGame")) object.newGame = message.newGame;
              if (message.origin != null && message.hasOwnProperty("origin")) object.origin = message.origin;

              if (message.newGames && message.newGames.length) {
                object.newGames = [];

                for (var j = 0; j < message.newGames.length; ++j) {
                  object.newGames[j] = message.newGames[j];
                }
              }

              if (message.unlock && message.unlock.length) {
                object.unlock = [];

                for (var j = 0; j < message.unlock.length; ++j) {
                  object.unlock[j] = message.unlock[j];
                }
              }

              if (message.vipExp != null && message.hasOwnProperty("vipExp")) object.vipExp = message.vipExp;
              if (message.ruby != null && message.hasOwnProperty("ruby")) object.ruby = message.ruby;
              if (message.itemID != null && message.hasOwnProperty("itemID")) object.itemID = message.itemID;
              if (message.ItemCount != null && message.hasOwnProperty("ItemCount")) object.ItemCount = message.ItemCount;
              if (message.buffID != null && message.hasOwnProperty("buffID")) if (typeof message.buffID === "number") object.buffID = options.longs === String ? String(message.buffID) : message.buffID;else object.buffID = options.longs === String ? $util.Long.prototype.toString.call(message.buffID) : options.longs === Number ? new $util.LongBits(message.buffID.low >>> 0, message.buffID.high >>> 0).toNumber() : message.buffID;
              if (message.buffCount != null && message.hasOwnProperty("buffCount")) object.buffCount = message.buffCount;
              if (message.cardBookID != null && message.hasOwnProperty("cardBookID")) object.cardBookID = message.cardBookID;
              if (message.cardBookCount != null && message.hasOwnProperty("cardBookCount")) object.cardBookCount = message.cardBookCount;
              if (message.show != null && message.hasOwnProperty("show")) object.show = message.show;
              return object;
            };
            /**
             * Converts this RewardData to JSON.
             * @function toJSON
             * @memberof levelProto.RewardData
             * @instance
             * @returns {Object.<string,*>} JSON object
             */


            RewardData.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RewardData;
          }();

          return levelProto;
        }();

        module.exports = $root; // #endregion ORIGINAL CODE

        _cjsExports = exports('default', module.exports);
      }, function () {
        return {
          'protobufjs/minimal': __cjsMetaURL$1
        };
      });
    }
  };
});

System.register("chunks:///_virtual/levelservice.mjs_cjs=&original=.js", ['./levelservice.js', './cjs-loader.mjs'], function (exports, module) {
  'use strict';

  var __cjsMetaURL, loader;

  return {
    setters: [function (module) {
      __cjsMetaURL = module.__cjsMetaURL;
      var _setter = {};
      _setter.__cjsMetaURL = module.__cjsMetaURL;
      _setter.default = module.default;
      exports(_setter);
    }, function (module) {
      loader = module.default;
    }],
    execute: function () {
      // I am the facade module who provides access to the CommonJS module './levelservice.js'~
      if (!__cjsMetaURL) {
        loader.throwInvalidWrapper('./levelservice.js', module.meta.url);
      }

      loader.require(__cjsMetaURL);
    }
  };
});

System.register("chunks:///_virtual/lifeService.js", ['./cjs-loader.mjs', './minimal.js'], function (exports, module) {
  'use strict';

  var loader, __cjsMetaURL$1;

  return {
    setters: [function (module) {
      loader = module.default;
    }, function (module) {
      __cjsMetaURL$1 = module.__cjsMetaURL;
    }],
    execute: function () {
      exports('default', void 0);

      var _cjsExports;

      var __cjsMetaURL = exports('__cjsMetaURL', module.meta.url);

      loader.define(__cjsMetaURL, function (exports$1, require, module, __filename, __dirname) {
        var $protobuf = require("protobufjs/minimal"); // Common aliases


        var $Reader = $protobuf.Reader,
            $Writer = $protobuf.Writer,
            $util = $protobuf.util; // Exported root namespace

        var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

        $root.lifeServiceProto = function () {
          /**
           * Namespace lifeServiceProto.
           * @exports lifeServiceProto
           * @namespace
           */
          var lifeServiceProto = {};

          lifeServiceProto.LifeServiceInitInfo = function () {
            /**
             * Properties of a LifeServiceInitInfo.
             * @memberof lifeServiceProto
             * @interface ILifeServiceInitInfo
             * @property {string|null} [userID] LifeServiceInitInfo userID
             * @property {number|Long|null} [accountID] LifeServiceInitInfo accountID
             * @property {number|null} [gameID] LifeServiceInitInfo gameID
             * @property {string|null} [token] LifeServiceInitInfo token
             * @property {number|null} [route] LifeServiceInitInfo route
             * @property {number|null} [apiID] LifeServiceInitInfo apiID
             */

            /**
             * Constructs a new LifeServiceInitInfo.
             * @memberof lifeServiceProto
             * @classdesc Represents a LifeServiceInitInfo.
             * @implements ILifeServiceInitInfo
             * @constructor
             * @param {lifeServiceProto.ILifeServiceInitInfo=} [properties] Properties to set
             */
            function LifeServiceInitInfo(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * LifeServiceInitInfo userID.
             * @member {string} userID
             * @memberof lifeServiceProto.LifeServiceInitInfo
             * @instance
             */


            LifeServiceInitInfo.prototype.userID = "";
            /**
             * LifeServiceInitInfo accountID.
             * @member {number|Long} accountID
             * @memberof lifeServiceProto.LifeServiceInitInfo
             * @instance
             */

            LifeServiceInitInfo.prototype.accountID = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
             * LifeServiceInitInfo gameID.
             * @member {number} gameID
             * @memberof lifeServiceProto.LifeServiceInitInfo
             * @instance
             */

            LifeServiceInitInfo.prototype.gameID = 0;
            /**
             * LifeServiceInitInfo token.
             * @member {string} token
             * @memberof lifeServiceProto.LifeServiceInitInfo
             * @instance
             */

            LifeServiceInitInfo.prototype.token = "";
            /**
             * LifeServiceInitInfo route.
             * @member {number} route
             * @memberof lifeServiceProto.LifeServiceInitInfo
             * @instance
             */

            LifeServiceInitInfo.prototype.route = 0;
            /**
             * LifeServiceInitInfo apiID.
             * @member {number} apiID
             * @memberof lifeServiceProto.LifeServiceInitInfo
             * @instance
             */

            LifeServiceInitInfo.prototype.apiID = 0;
            /**
             * Creates a new LifeServiceInitInfo instance using the specified properties.
             * @function create
             * @memberof lifeServiceProto.LifeServiceInitInfo
             * @static
             * @param {lifeServiceProto.ILifeServiceInitInfo=} [properties] Properties to set
             * @returns {lifeServiceProto.LifeServiceInitInfo} LifeServiceInitInfo instance
             */

            LifeServiceInitInfo.create = function create(properties) {
              return new LifeServiceInitInfo(properties);
            };
            /**
             * Encodes the specified LifeServiceInitInfo message. Does not implicitly {@link lifeServiceProto.LifeServiceInitInfo.verify|verify} messages.
             * @function encode
             * @memberof lifeServiceProto.LifeServiceInitInfo
             * @static
             * @param {lifeServiceProto.ILifeServiceInitInfo} message LifeServiceInitInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            LifeServiceInitInfo.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.userID != null && Object.hasOwnProperty.call(message, "userID")) writer.uint32(
              /* id 1, wireType 2 =*/
              10).string(message.userID);
              if (message.accountID != null && Object.hasOwnProperty.call(message, "accountID")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int64(message.accountID);
              if (message.gameID != null && Object.hasOwnProperty.call(message, "gameID")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.gameID);
              if (message.token != null && Object.hasOwnProperty.call(message, "token")) writer.uint32(
              /* id 4, wireType 2 =*/
              34).string(message.token);
              if (message.route != null && Object.hasOwnProperty.call(message, "route")) writer.uint32(
              /* id 5, wireType 0 =*/
              40).int32(message.route);
              if (message.apiID != null && Object.hasOwnProperty.call(message, "apiID")) writer.uint32(
              /* id 6, wireType 0 =*/
              48).int32(message.apiID);
              return writer;
            };
            /**
             * Encodes the specified LifeServiceInitInfo message, length delimited. Does not implicitly {@link lifeServiceProto.LifeServiceInitInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lifeServiceProto.LifeServiceInitInfo
             * @static
             * @param {lifeServiceProto.ILifeServiceInitInfo} message LifeServiceInitInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            LifeServiceInitInfo.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a LifeServiceInitInfo message from the specified reader or buffer.
             * @function decode
             * @memberof lifeServiceProto.LifeServiceInitInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lifeServiceProto.LifeServiceInitInfo} LifeServiceInitInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            LifeServiceInitInfo.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.lifeServiceProto.LifeServiceInitInfo();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.userID = reader.string();
                    break;

                  case 2:
                    message.accountID = reader.int64();
                    break;

                  case 3:
                    message.gameID = reader.int32();
                    break;

                  case 4:
                    message.token = reader.string();
                    break;

                  case 5:
                    message.route = reader.int32();
                    break;

                  case 6:
                    message.apiID = reader.int32();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
             * Decodes a LifeServiceInitInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lifeServiceProto.LifeServiceInitInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lifeServiceProto.LifeServiceInitInfo} LifeServiceInitInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            LifeServiceInitInfo.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a LifeServiceInitInfo message.
             * @function verify
             * @memberof lifeServiceProto.LifeServiceInitInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */


            LifeServiceInitInfo.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.userID != null && message.hasOwnProperty("userID")) if (!$util.isString(message.userID)) return "userID: string expected";
              if (message.accountID != null && message.hasOwnProperty("accountID")) if (!$util.isInteger(message.accountID) && !(message.accountID && $util.isInteger(message.accountID.low) && $util.isInteger(message.accountID.high))) return "accountID: integer|Long expected";
              if (message.gameID != null && message.hasOwnProperty("gameID")) if (!$util.isInteger(message.gameID)) return "gameID: integer expected";
              if (message.token != null && message.hasOwnProperty("token")) if (!$util.isString(message.token)) return "token: string expected";
              if (message.route != null && message.hasOwnProperty("route")) if (!$util.isInteger(message.route)) return "route: integer expected";
              if (message.apiID != null && message.hasOwnProperty("apiID")) if (!$util.isInteger(message.apiID)) return "apiID: integer expected";
              return null;
            };
            /**
             * Creates a LifeServiceInitInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lifeServiceProto.LifeServiceInitInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lifeServiceProto.LifeServiceInitInfo} LifeServiceInitInfo
             */


            LifeServiceInitInfo.fromObject = function fromObject(object) {
              if (object instanceof $root.lifeServiceProto.LifeServiceInitInfo) return object;
              var message = new $root.lifeServiceProto.LifeServiceInitInfo();
              if (object.userID != null) message.userID = String(object.userID);
              if (object.accountID != null) if ($util.Long) (message.accountID = $util.Long.fromValue(object.accountID)).unsigned = false;else if (typeof object.accountID === "string") message.accountID = parseInt(object.accountID, 10);else if (typeof object.accountID === "number") message.accountID = object.accountID;else if (typeof object.accountID === "object") message.accountID = new $util.LongBits(object.accountID.low >>> 0, object.accountID.high >>> 0).toNumber();
              if (object.gameID != null) message.gameID = object.gameID | 0;
              if (object.token != null) message.token = String(object.token);
              if (object.route != null) message.route = object.route | 0;
              if (object.apiID != null) message.apiID = object.apiID | 0;
              return message;
            };
            /**
             * Creates a plain object from a LifeServiceInitInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lifeServiceProto.LifeServiceInitInfo
             * @static
             * @param {lifeServiceProto.LifeServiceInitInfo} message LifeServiceInitInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */


            LifeServiceInitInfo.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.userID = "";

                if ($util.Long) {
                  var _long = new $util.Long(0, 0, false);

                  object.accountID = options.longs === String ? _long.toString() : options.longs === Number ? _long.toNumber() : _long;
                } else object.accountID = options.longs === String ? "0" : 0;

                object.gameID = 0;
                object.token = "";
                object.route = 0;
                object.apiID = 0;
              }

              if (message.userID != null && message.hasOwnProperty("userID")) object.userID = message.userID;
              if (message.accountID != null && message.hasOwnProperty("accountID")) if (typeof message.accountID === "number") object.accountID = options.longs === String ? String(message.accountID) : message.accountID;else object.accountID = options.longs === String ? $util.Long.prototype.toString.call(message.accountID) : options.longs === Number ? new $util.LongBits(message.accountID.low >>> 0, message.accountID.high >>> 0).toNumber() : message.accountID;
              if (message.gameID != null && message.hasOwnProperty("gameID")) object.gameID = message.gameID;
              if (message.token != null && message.hasOwnProperty("token")) object.token = message.token;
              if (message.route != null && message.hasOwnProperty("route")) object.route = message.route;
              if (message.apiID != null && message.hasOwnProperty("apiID")) object.apiID = message.apiID;
              return object;
            };
            /**
             * Converts this LifeServiceInitInfo to JSON.
             * @function toJSON
             * @memberof lifeServiceProto.LifeServiceInitInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */


            LifeServiceInitInfo.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return LifeServiceInitInfo;
          }();

          return lifeServiceProto;
        }();

        module.exports = $root; // #endregion ORIGINAL CODE

        _cjsExports = exports('default', module.exports);
      }, function () {
        return {
          'protobufjs/minimal': __cjsMetaURL$1
        };
      });
    }
  };
});

System.register("chunks:///_virtual/lifeService.mjs_cjs=&original=.js", ['./lifeService.js', './cjs-loader.mjs'], function (exports, module) {
  'use strict';

  var __cjsMetaURL, loader;

  return {
    setters: [function (module) {
      __cjsMetaURL = module.__cjsMetaURL;
      var _setter = {};
      _setter.__cjsMetaURL = module.__cjsMetaURL;
      _setter.default = module.default;
      exports(_setter);
    }, function (module) {
      loader = module.default;
    }],
    execute: function () {
      // I am the facade module who provides access to the CommonJS module './lifeService.js'~
      if (!__cjsMetaURL) {
        loader.throwInvalidWrapper('./lifeService.js', module.meta.url);
      }

      loader.require(__cjsMetaURL);
    }
  };
});

System.register("chunks:///_virtual/long.js", ['./cjs-loader.mjs'], function (exports, module) {
  'use strict';

  var loader;
  return {
    setters: [function (module) {
      loader = module.default;
    }],
    execute: function () {
      exports('default', void 0);

      var _cjsExports;

      var __cjsMetaURL = exports('__cjsMetaURL', module.meta.url);

      loader.define(__cjsMetaURL, function (exports$1, require, module, __filename, __dirname) {
        // #region ORIGINAL CODE
        module.exports = Long;
        /**
         * wasm optimizations, to do native i64 multiplication and divide
         */

        var wasm = null;

        try {
          wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
        } catch (e) {// no wasm support :(
        }
        /**
         * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
         *  See the from* functions below for more convenient ways of constructing Longs.
         * @exports Long
         * @class A Long class for representing a 64 bit two's-complement integer value.
         * @param {number} low The low (signed) 32 bits of the long
         * @param {number} high The high (signed) 32 bits of the long
         * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
         * @constructor
         */


        function Long(low, high, unsigned) {
          /**
           * The low 32 bits as a signed value.
           * @type {number}
           */
          this.low = low | 0;
          /**
           * The high 32 bits as a signed value.
           * @type {number}
           */

          this.high = high | 0;
          /**
           * Whether unsigned or not.
           * @type {boolean}
           */

          this.unsigned = !!unsigned;
        } // The internal representation of a long is the two given signed, 32-bit values.
        // We use 32-bit pieces because these are the size of integers on which
        // Javascript performs bit-operations.  For operations like addition and
        // multiplication, we split each number into 16 bit pieces, which can easily be
        // multiplied within Javascript's floating-point representation without overflow
        // or change in sign.
        //
        // In the algorithms below, we frequently reduce the negative case to the
        // positive case by negating the input(s) and then post-processing the result.
        // Note that we must ALWAYS check specially whether those values are MIN_VALUE
        // (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
        // a positive number, it overflows back into a negative).  Not handling this
        // case would often result in infinite recursion.
        //
        // Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
        // methods on which they depend.

        /**
         * An indicator used to reliably determine if an object is a Long or not.
         * @type {boolean}
         * @const
         * @private
         */


        Long.prototype.__isLong__;
        Object.defineProperty(Long.prototype, "__isLong__", {
          value: true
        });
        /**
         * @function
         * @param {*} obj Object
         * @returns {boolean}
         * @inner
         */

        function isLong(obj) {
          return (obj && obj["__isLong__"]) === true;
        }
        /**
         * Tests if the specified object is a Long.
         * @function
         * @param {*} obj Object
         * @returns {boolean}
         */


        Long.isLong = isLong;
        /**
         * A cache of the Long representations of small integer values.
         * @type {!Object}
         * @inner
         */

        var INT_CACHE = {};
        /**
         * A cache of the Long representations of small unsigned integer values.
         * @type {!Object}
         * @inner
         */

        var UINT_CACHE = {};
        /**
         * @param {number} value
         * @param {boolean=} unsigned
         * @returns {!Long}
         * @inner
         */

        function fromInt(value, unsigned) {
          var obj, cachedObj, cache;

          if (unsigned) {
            value >>>= 0;

            if (cache = 0 <= value && value < 256) {
              cachedObj = UINT_CACHE[value];
              if (cachedObj) return cachedObj;
            }

            obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
            if (cache) UINT_CACHE[value] = obj;
            return obj;
          } else {
            value |= 0;

            if (cache = -128 <= value && value < 128) {
              cachedObj = INT_CACHE[value];
              if (cachedObj) return cachedObj;
            }

            obj = fromBits(value, value < 0 ? -1 : 0, false);
            if (cache) INT_CACHE[value] = obj;
            return obj;
          }
        }
        /**
         * Returns a Long representing the given 32 bit integer value.
         * @function
         * @param {number} value The 32 bit integer in question
         * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
         * @returns {!Long} The corresponding Long value
         */


        Long.fromInt = fromInt;
        /**
         * @param {number} value
         * @param {boolean=} unsigned
         * @returns {!Long}
         * @inner
         */

        function fromNumber(value, unsigned) {
          if (isNaN(value)) return unsigned ? UZERO : ZERO;

          if (unsigned) {
            if (value < 0) return UZERO;
            if (value >= TWO_PWR_64_DBL) return MAX_UNSIGNED_VALUE;
          } else {
            if (value <= -TWO_PWR_63_DBL) return MIN_VALUE;
            if (value + 1 >= TWO_PWR_63_DBL) return MAX_VALUE;
          }

          if (value < 0) return fromNumber(-value, unsigned).neg();
          return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
        }
        /**
         * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
         * @function
         * @param {number} value The number in question
         * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
         * @returns {!Long} The corresponding Long value
         */


        Long.fromNumber = fromNumber;
        /**
         * @param {number} lowBits
         * @param {number} highBits
         * @param {boolean=} unsigned
         * @returns {!Long}
         * @inner
         */

        function fromBits(lowBits, highBits, unsigned) {
          return new Long(lowBits, highBits, unsigned);
        }
        /**
         * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
         *  assumed to use 32 bits.
         * @function
         * @param {number} lowBits The low 32 bits
         * @param {number} highBits The high 32 bits
         * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
         * @returns {!Long} The corresponding Long value
         */


        Long.fromBits = fromBits;
        /**
         * @function
         * @param {number} base
         * @param {number} exponent
         * @returns {number}
         * @inner
         */

        var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)

        /**
         * @param {string} str
         * @param {(boolean|number)=} unsigned
         * @param {number=} radix
         * @returns {!Long}
         * @inner
         */

        function fromString(str, unsigned, radix) {
          if (str.length === 0) throw Error('empty string');
          if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity") return ZERO;

          if (typeof unsigned === 'number') {
            // For goog.math.long compatibility
            radix = unsigned, unsigned = false;
          } else {
            unsigned = !!unsigned;
          }

          radix = radix || 10;
          if (radix < 2 || 36 < radix) throw RangeError('radix');
          var p;
          if ((p = str.indexOf('-')) > 0) throw Error('interior hyphen');else if (p === 0) {
            return fromString(str.substring(1), unsigned, radix).neg();
          } // Do several (8) digits each time through the loop, so as to
          // minimize the calls to the very expensive emulated div.

          var radixToPower = fromNumber(pow_dbl(radix, 8));
          var result = ZERO;

          for (var i = 0; i < str.length; i += 8) {
            var size = Math.min(8, str.length - i),
                value = parseInt(str.substring(i, i + size), radix);

            if (size < 8) {
              var power = fromNumber(pow_dbl(radix, size));
              result = result.mul(power).add(fromNumber(value));
            } else {
              result = result.mul(radixToPower);
              result = result.add(fromNumber(value));
            }
          }

          result.unsigned = unsigned;
          return result;
        }
        /**
         * Returns a Long representation of the given string, written using the specified radix.
         * @function
         * @param {string} str The textual representation of the Long
         * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed
         * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
         * @returns {!Long} The corresponding Long value
         */


        Long.fromString = fromString;
        /**
         * @function
         * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
         * @param {boolean=} unsigned
         * @returns {!Long}
         * @inner
         */

        function fromValue(val, unsigned) {
          if (typeof val === 'number') return fromNumber(val, unsigned);
          if (typeof val === 'string') return fromString(val, unsigned); // Throws for non-objects, converts non-instanceof Long:

          return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);
        }
        /**
         * Converts the specified value to a Long using the appropriate from* function for its type.
         * @function
         * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value
         * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
         * @returns {!Long}
         */


        Long.fromValue = fromValue; // NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
        // no runtime penalty for these.

        /**
         * @type {number}
         * @const
         * @inner
         */

        var TWO_PWR_16_DBL = 1 << 16;
        /**
         * @type {number}
         * @const
         * @inner
         */

        var TWO_PWR_24_DBL = 1 << 24;
        /**
         * @type {number}
         * @const
         * @inner
         */

        var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
        /**
         * @type {number}
         * @const
         * @inner
         */

        var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
        /**
         * @type {number}
         * @const
         * @inner
         */

        var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
        /**
         * @type {!Long}
         * @const
         * @inner
         */

        var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
        /**
         * @type {!Long}
         * @inner
         */

        var ZERO = fromInt(0);
        /**
         * Signed zero.
         * @type {!Long}
         */

        Long.ZERO = ZERO;
        /**
         * @type {!Long}
         * @inner
         */

        var UZERO = fromInt(0, true);
        /**
         * Unsigned zero.
         * @type {!Long}
         */

        Long.UZERO = UZERO;
        /**
         * @type {!Long}
         * @inner
         */

        var ONE = fromInt(1);
        /**
         * Signed one.
         * @type {!Long}
         */

        Long.ONE = ONE;
        /**
         * @type {!Long}
         * @inner
         */

        var UONE = fromInt(1, true);
        /**
         * Unsigned one.
         * @type {!Long}
         */

        Long.UONE = UONE;
        /**
         * @type {!Long}
         * @inner
         */

        var NEG_ONE = fromInt(-1);
        /**
         * Signed negative one.
         * @type {!Long}
         */

        Long.NEG_ONE = NEG_ONE;
        /**
         * @type {!Long}
         * @inner
         */

        var MAX_VALUE = fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0, false);
        /**
         * Maximum signed value.
         * @type {!Long}
         */

        Long.MAX_VALUE = MAX_VALUE;
        /**
         * @type {!Long}
         * @inner
         */

        var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF | 0, 0xFFFFFFFF | 0, true);
        /**
         * Maximum unsigned value.
         * @type {!Long}
         */

        Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
        /**
         * @type {!Long}
         * @inner
         */

        var MIN_VALUE = fromBits(0, 0x80000000 | 0, false);
        /**
         * Minimum signed value.
         * @type {!Long}
         */

        Long.MIN_VALUE = MIN_VALUE;
        /**
         * @alias Long.prototype
         * @inner
         */

        var LongPrototype = Long.prototype;
        /**
         * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
         * @returns {number}
         */

        LongPrototype.toInt = function toInt() {
          return this.unsigned ? this.low >>> 0 : this.low;
        };
        /**
         * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
         * @returns {number}
         */


        LongPrototype.toNumber = function toNumber() {
          if (this.unsigned) return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
          return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
        };
        /**
         * Converts the Long to a string written in the specified radix.
         * @param {number=} radix Radix (2-36), defaults to 10
         * @returns {string}
         * @override
         * @throws {RangeError} If `radix` is out of range
         */


        LongPrototype.toString = function toString(radix) {
          radix = radix || 10;
          if (radix < 2 || 36 < radix) throw RangeError('radix');
          if (this.isZero()) return '0';

          if (this.isNegative()) {
            // Unsigned Longs are never negative
            if (this.eq(MIN_VALUE)) {
              // We need to change the Long value before it can be negated, so we remove
              // the bottom-most digit in this base and then recurse to do the rest.
              var radixLong = fromNumber(radix),
                  div = this.div(radixLong),
                  rem1 = div.mul(radixLong).sub(this);
              return div.toString(radix) + rem1.toInt().toString(radix);
            } else return '-' + this.neg().toString(radix);
          } // Do several (6) digits each time through the loop, so as to
          // minimize the calls to the very expensive emulated div.


          var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
              rem = this;
          var result = '';

          while (true) {
            var remDiv = rem.div(radixToPower),
                intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,
                digits = intval.toString(radix);
            rem = remDiv;
            if (rem.isZero()) return digits + result;else {
              while (digits.length < 6) {
                digits = '0' + digits;
              }

              result = '' + digits + result;
            }
          }
        };
        /**
         * Gets the high 32 bits as a signed integer.
         * @returns {number} Signed high bits
         */


        LongPrototype.getHighBits = function getHighBits() {
          return this.high;
        };
        /**
         * Gets the high 32 bits as an unsigned integer.
         * @returns {number} Unsigned high bits
         */


        LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
          return this.high >>> 0;
        };
        /**
         * Gets the low 32 bits as a signed integer.
         * @returns {number} Signed low bits
         */


        LongPrototype.getLowBits = function getLowBits() {
          return this.low;
        };
        /**
         * Gets the low 32 bits as an unsigned integer.
         * @returns {number} Unsigned low bits
         */


        LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
          return this.low >>> 0;
        };
        /**
         * Gets the number of bits needed to represent the absolute value of this Long.
         * @returns {number}
         */


        LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
          if (this.isNegative()) // Unsigned Longs are never negative
            return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
          var val = this.high != 0 ? this.high : this.low;

          for (var bit = 31; bit > 0; bit--) {
            if ((val & 1 << bit) != 0) break;
          }

          return this.high != 0 ? bit + 33 : bit + 1;
        };
        /**
         * Tests if this Long's value equals zero.
         * @returns {boolean}
         */


        LongPrototype.isZero = function isZero() {
          return this.high === 0 && this.low === 0;
        };
        /**
         * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.
         * @returns {boolean}
         */


        LongPrototype.eqz = LongPrototype.isZero;
        /**
         * Tests if this Long's value is negative.
         * @returns {boolean}
         */

        LongPrototype.isNegative = function isNegative() {
          return !this.unsigned && this.high < 0;
        };
        /**
         * Tests if this Long's value is positive.
         * @returns {boolean}
         */


        LongPrototype.isPositive = function isPositive() {
          return this.unsigned || this.high >= 0;
        };
        /**
         * Tests if this Long's value is odd.
         * @returns {boolean}
         */


        LongPrototype.isOdd = function isOdd() {
          return (this.low & 1) === 1;
        };
        /**
         * Tests if this Long's value is even.
         * @returns {boolean}
         */


        LongPrototype.isEven = function isEven() {
          return (this.low & 1) === 0;
        };
        /**
         * Tests if this Long's value equals the specified's.
         * @param {!Long|number|string} other Other value
         * @returns {boolean}
         */


        LongPrototype.equals = function equals(other) {
          if (!isLong(other)) other = fromValue(other);
          if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1) return false;
          return this.high === other.high && this.low === other.low;
        };
        /**
         * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
         * @function
         * @param {!Long|number|string} other Other value
         * @returns {boolean}
         */


        LongPrototype.eq = LongPrototype.equals;
        /**
         * Tests if this Long's value differs from the specified's.
         * @param {!Long|number|string} other Other value
         * @returns {boolean}
         */

        LongPrototype.notEquals = function notEquals(other) {
          return !this.eq(
          /* validates */
          other);
        };
        /**
         * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
         * @function
         * @param {!Long|number|string} other Other value
         * @returns {boolean}
         */


        LongPrototype.neq = LongPrototype.notEquals;
        /**
         * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
         * @function
         * @param {!Long|number|string} other Other value
         * @returns {boolean}
         */

        LongPrototype.ne = LongPrototype.notEquals;
        /**
         * Tests if this Long's value is less than the specified's.
         * @param {!Long|number|string} other Other value
         * @returns {boolean}
         */

        LongPrototype.lessThan = function lessThan(other) {
          return this.comp(
          /* validates */
          other) < 0;
        };
        /**
         * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
         * @function
         * @param {!Long|number|string} other Other value
         * @returns {boolean}
         */


        LongPrototype.lt = LongPrototype.lessThan;
        /**
         * Tests if this Long's value is less than or equal the specified's.
         * @param {!Long|number|string} other Other value
         * @returns {boolean}
         */

        LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
          return this.comp(
          /* validates */
          other) <= 0;
        };
        /**
         * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
         * @function
         * @param {!Long|number|string} other Other value
         * @returns {boolean}
         */


        LongPrototype.lte = LongPrototype.lessThanOrEqual;
        /**
         * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
         * @function
         * @param {!Long|number|string} other Other value
         * @returns {boolean}
         */

        LongPrototype.le = LongPrototype.lessThanOrEqual;
        /**
         * Tests if this Long's value is greater than the specified's.
         * @param {!Long|number|string} other Other value
         * @returns {boolean}
         */

        LongPrototype.greaterThan = function greaterThan(other) {
          return this.comp(
          /* validates */
          other) > 0;
        };
        /**
         * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
         * @function
         * @param {!Long|number|string} other Other value
         * @returns {boolean}
         */


        LongPrototype.gt = LongPrototype.greaterThan;
        /**
         * Tests if this Long's value is greater than or equal the specified's.
         * @param {!Long|number|string} other Other value
         * @returns {boolean}
         */

        LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
          return this.comp(
          /* validates */
          other) >= 0;
        };
        /**
         * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
         * @function
         * @param {!Long|number|string} other Other value
         * @returns {boolean}
         */


        LongPrototype.gte = LongPrototype.greaterThanOrEqual;
        /**
         * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
         * @function
         * @param {!Long|number|string} other Other value
         * @returns {boolean}
         */

        LongPrototype.ge = LongPrototype.greaterThanOrEqual;
        /**
         * Compares this Long's value with the specified's.
         * @param {!Long|number|string} other Other value
         * @returns {number} 0 if they are the same, 1 if the this is greater and -1
         *  if the given one is greater
         */

        LongPrototype.compare = function compare(other) {
          if (!isLong(other)) other = fromValue(other);
          if (this.eq(other)) return 0;
          var thisNeg = this.isNegative(),
              otherNeg = other.isNegative();
          if (thisNeg && !otherNeg) return -1;
          if (!thisNeg && otherNeg) return 1; // At this point the sign bits are the same

          if (!this.unsigned) return this.sub(other).isNegative() ? -1 : 1; // Both are positive if at least one is unsigned

          return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
        };
        /**
         * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
         * @function
         * @param {!Long|number|string} other Other value
         * @returns {number} 0 if they are the same, 1 if the this is greater and -1
         *  if the given one is greater
         */


        LongPrototype.comp = LongPrototype.compare;
        /**
         * Negates this Long's value.
         * @returns {!Long} Negated Long
         */

        LongPrototype.negate = function negate() {
          if (!this.unsigned && this.eq(MIN_VALUE)) return MIN_VALUE;
          return this.not().add(ONE);
        };
        /**
         * Negates this Long's value. This is an alias of {@link Long#negate}.
         * @function
         * @returns {!Long} Negated Long
         */


        LongPrototype.neg = LongPrototype.negate;
        /**
         * Returns the sum of this and the specified Long.
         * @param {!Long|number|string} addend Addend
         * @returns {!Long} Sum
         */

        LongPrototype.add = function add(addend) {
          if (!isLong(addend)) addend = fromValue(addend); // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

          var a48 = this.high >>> 16;
          var a32 = this.high & 0xFFFF;
          var a16 = this.low >>> 16;
          var a00 = this.low & 0xFFFF;
          var b48 = addend.high >>> 16;
          var b32 = addend.high & 0xFFFF;
          var b16 = addend.low >>> 16;
          var b00 = addend.low & 0xFFFF;
          var c48 = 0,
              c32 = 0,
              c16 = 0,
              c00 = 0;
          c00 += a00 + b00;
          c16 += c00 >>> 16;
          c00 &= 0xFFFF;
          c16 += a16 + b16;
          c32 += c16 >>> 16;
          c16 &= 0xFFFF;
          c32 += a32 + b32;
          c48 += c32 >>> 16;
          c32 &= 0xFFFF;
          c48 += a48 + b48;
          c48 &= 0xFFFF;
          return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
        };
        /**
         * Returns the difference of this and the specified Long.
         * @param {!Long|number|string} subtrahend Subtrahend
         * @returns {!Long} Difference
         */


        LongPrototype.subtract = function subtract(subtrahend) {
          if (!isLong(subtrahend)) subtrahend = fromValue(subtrahend);
          return this.add(subtrahend.neg());
        };
        /**
         * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
         * @function
         * @param {!Long|number|string} subtrahend Subtrahend
         * @returns {!Long} Difference
         */


        LongPrototype.sub = LongPrototype.subtract;
        /**
         * Returns the product of this and the specified Long.
         * @param {!Long|number|string} multiplier Multiplier
         * @returns {!Long} Product
         */

        LongPrototype.multiply = function multiply(multiplier) {
          if (this.isZero()) return ZERO;
          if (!isLong(multiplier)) multiplier = fromValue(multiplier); // use wasm support if present

          if (wasm) {
            var low = wasm.mul(this.low, this.high, multiplier.low, multiplier.high);
            return fromBits(low, wasm.get_high(), this.unsigned);
          }

          if (multiplier.isZero()) return ZERO;
          if (this.eq(MIN_VALUE)) return multiplier.isOdd() ? MIN_VALUE : ZERO;
          if (multiplier.eq(MIN_VALUE)) return this.isOdd() ? MIN_VALUE : ZERO;

          if (this.isNegative()) {
            if (multiplier.isNegative()) return this.neg().mul(multiplier.neg());else return this.neg().mul(multiplier).neg();
          } else if (multiplier.isNegative()) return this.mul(multiplier.neg()).neg(); // If both longs are small, use float multiplication


          if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24)) return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned); // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
          // We can skip products that would overflow.

          var a48 = this.high >>> 16;
          var a32 = this.high & 0xFFFF;
          var a16 = this.low >>> 16;
          var a00 = this.low & 0xFFFF;
          var b48 = multiplier.high >>> 16;
          var b32 = multiplier.high & 0xFFFF;
          var b16 = multiplier.low >>> 16;
          var b00 = multiplier.low & 0xFFFF;
          var c48 = 0,
              c32 = 0,
              c16 = 0,
              c00 = 0;
          c00 += a00 * b00;
          c16 += c00 >>> 16;
          c00 &= 0xFFFF;
          c16 += a16 * b00;
          c32 += c16 >>> 16;
          c16 &= 0xFFFF;
          c16 += a00 * b16;
          c32 += c16 >>> 16;
          c16 &= 0xFFFF;
          c32 += a32 * b00;
          c48 += c32 >>> 16;
          c32 &= 0xFFFF;
          c32 += a16 * b16;
          c48 += c32 >>> 16;
          c32 &= 0xFFFF;
          c32 += a00 * b32;
          c48 += c32 >>> 16;
          c32 &= 0xFFFF;
          c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
          c48 &= 0xFFFF;
          return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
        };
        /**
         * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
         * @function
         * @param {!Long|number|string} multiplier Multiplier
         * @returns {!Long} Product
         */


        LongPrototype.mul = LongPrototype.multiply;
        /**
         * Returns this Long divided by the specified. The result is signed if this Long is signed or
         *  unsigned if this Long is unsigned.
         * @param {!Long|number|string} divisor Divisor
         * @returns {!Long} Quotient
         */

        LongPrototype.divide = function divide(divisor) {
          if (!isLong(divisor)) divisor = fromValue(divisor);
          if (divisor.isZero()) throw Error('division by zero'); // use wasm support if present

          if (wasm) {
            // guard against signed division overflow: the largest
            // negative number / -1 would be 1 larger than the largest
            // positive number, due to two's complement.
            if (!this.unsigned && this.high === -0x80000000 && divisor.low === -1 && divisor.high === -1) {
              // be consistent with non-wasm code path
              return this;
            }

            var low = (this.unsigned ? wasm.div_u : wasm.div_s)(this.low, this.high, divisor.low, divisor.high);
            return fromBits(low, wasm.get_high(), this.unsigned);
          }

          if (this.isZero()) return this.unsigned ? UZERO : ZERO;
          var approx, rem, res;

          if (!this.unsigned) {
            // This section is only relevant for signed longs and is derived from the
            // closure library as a whole.
            if (this.eq(MIN_VALUE)) {
              if (divisor.eq(ONE) || divisor.eq(NEG_ONE)) return MIN_VALUE; // recall that -MIN_VALUE == MIN_VALUE
              else if (divisor.eq(MIN_VALUE)) return ONE;else {
                  // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
                  var halfThis = this.shr(1);
                  approx = halfThis.div(divisor).shl(1);

                  if (approx.eq(ZERO)) {
                    return divisor.isNegative() ? ONE : NEG_ONE;
                  } else {
                    rem = this.sub(divisor.mul(approx));
                    res = approx.add(rem.div(divisor));
                    return res;
                  }
                }
            } else if (divisor.eq(MIN_VALUE)) return this.unsigned ? UZERO : ZERO;

            if (this.isNegative()) {
              if (divisor.isNegative()) return this.neg().div(divisor.neg());
              return this.neg().div(divisor).neg();
            } else if (divisor.isNegative()) return this.div(divisor.neg()).neg();

            res = ZERO;
          } else {
            // The algorithm below has not been made for unsigned longs. It's therefore
            // required to take special care of the MSB prior to running it.
            if (!divisor.unsigned) divisor = divisor.toUnsigned();
            if (divisor.gt(this)) return UZERO;
            if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true
              return UONE;
            res = UZERO;
          } // Repeat the following until the remainder is less than other:  find a
          // floating-point that approximates remainder / other *from below*, add this
          // into the result, and subtract it from the remainder.  It is critical that
          // the approximate value is less than or equal to the real value so that the
          // remainder never becomes negative.


          rem = this;

          while (rem.gte(divisor)) {
            // Approximate the result of division. This may be a little greater or
            // smaller than the actual value.
            approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber())); // We will tweak the approximate result by changing it in the 48-th digit or
            // the smallest non-fractional digit, whichever is larger.

            var log2 = Math.ceil(Math.log(approx) / Math.LN2),
                delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48),
                // Decrease the approximation until it is smaller than the remainder.  Note
            // that if it is too large, the product overflows and is negative.
            approxRes = fromNumber(approx),
                approxRem = approxRes.mul(divisor);

            while (approxRem.isNegative() || approxRem.gt(rem)) {
              approx -= delta;
              approxRes = fromNumber(approx, this.unsigned);
              approxRem = approxRes.mul(divisor);
            } // We know the answer can't be zero... and actually, zero would cause
            // infinite recursion since we would make no progress.


            if (approxRes.isZero()) approxRes = ONE;
            res = res.add(approxRes);
            rem = rem.sub(approxRem);
          }

          return res;
        };
        /**
         * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
         * @function
         * @param {!Long|number|string} divisor Divisor
         * @returns {!Long} Quotient
         */


        LongPrototype.div = LongPrototype.divide;
        /**
         * Returns this Long modulo the specified.
         * @param {!Long|number|string} divisor Divisor
         * @returns {!Long} Remainder
         */

        LongPrototype.modulo = function modulo(divisor) {
          if (!isLong(divisor)) divisor = fromValue(divisor); // use wasm support if present

          if (wasm) {
            var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(this.low, this.high, divisor.low, divisor.high);
            return fromBits(low, wasm.get_high(), this.unsigned);
          }

          return this.sub(this.div(divisor).mul(divisor));
        };
        /**
         * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
         * @function
         * @param {!Long|number|string} divisor Divisor
         * @returns {!Long} Remainder
         */


        LongPrototype.mod = LongPrototype.modulo;
        /**
         * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
         * @function
         * @param {!Long|number|string} divisor Divisor
         * @returns {!Long} Remainder
         */

        LongPrototype.rem = LongPrototype.modulo;
        /**
         * Returns the bitwise NOT of this Long.
         * @returns {!Long}
         */

        LongPrototype.not = function not() {
          return fromBits(~this.low, ~this.high, this.unsigned);
        };
        /**
         * Returns the bitwise AND of this Long and the specified.
         * @param {!Long|number|string} other Other Long
         * @returns {!Long}
         */


        LongPrototype.and = function and(other) {
          if (!isLong(other)) other = fromValue(other);
          return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
        };
        /**
         * Returns the bitwise OR of this Long and the specified.
         * @param {!Long|number|string} other Other Long
         * @returns {!Long}
         */


        LongPrototype.or = function or(other) {
          if (!isLong(other)) other = fromValue(other);
          return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
        };
        /**
         * Returns the bitwise XOR of this Long and the given one.
         * @param {!Long|number|string} other Other Long
         * @returns {!Long}
         */


        LongPrototype.xor = function xor(other) {
          if (!isLong(other)) other = fromValue(other);
          return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
        };
        /**
         * Returns this Long with bits shifted to the left by the given amount.
         * @param {number|!Long} numBits Number of bits
         * @returns {!Long} Shifted Long
         */


        LongPrototype.shiftLeft = function shiftLeft(numBits) {
          if (isLong(numBits)) numBits = numBits.toInt();
          if ((numBits &= 63) === 0) return this;else if (numBits < 32) return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);else return fromBits(0, this.low << numBits - 32, this.unsigned);
        };
        /**
         * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
         * @function
         * @param {number|!Long} numBits Number of bits
         * @returns {!Long} Shifted Long
         */


        LongPrototype.shl = LongPrototype.shiftLeft;
        /**
         * Returns this Long with bits arithmetically shifted to the right by the given amount.
         * @param {number|!Long} numBits Number of bits
         * @returns {!Long} Shifted Long
         */

        LongPrototype.shiftRight = function shiftRight(numBits) {
          if (isLong(numBits)) numBits = numBits.toInt();
          if ((numBits &= 63) === 0) return this;else if (numBits < 32) return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);else return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
        };
        /**
         * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
         * @function
         * @param {number|!Long} numBits Number of bits
         * @returns {!Long} Shifted Long
         */


        LongPrototype.shr = LongPrototype.shiftRight;
        /**
         * Returns this Long with bits logically shifted to the right by the given amount.
         * @param {number|!Long} numBits Number of bits
         * @returns {!Long} Shifted Long
         */

        LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
          if (isLong(numBits)) numBits = numBits.toInt();
          numBits &= 63;
          if (numBits === 0) return this;else {
            var high = this.high;

            if (numBits < 32) {
              var low = this.low;
              return fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);
            } else if (numBits === 32) return fromBits(high, 0, this.unsigned);else return fromBits(high >>> numBits - 32, 0, this.unsigned);
          }
        };
        /**
         * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
         * @function
         * @param {number|!Long} numBits Number of bits
         * @returns {!Long} Shifted Long
         */


        LongPrototype.shru = LongPrototype.shiftRightUnsigned;
        /**
         * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
         * @function
         * @param {number|!Long} numBits Number of bits
         * @returns {!Long} Shifted Long
         */

        LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
        /**
         * Converts this Long to signed.
         * @returns {!Long} Signed long
         */

        LongPrototype.toSigned = function toSigned() {
          if (!this.unsigned) return this;
          return fromBits(this.low, this.high, false);
        };
        /**
         * Converts this Long to unsigned.
         * @returns {!Long} Unsigned long
         */


        LongPrototype.toUnsigned = function toUnsigned() {
          if (this.unsigned) return this;
          return fromBits(this.low, this.high, true);
        };
        /**
         * Converts this Long to its byte representation.
         * @param {boolean=} le Whether little or big endian, defaults to big endian
         * @returns {!Array.<number>} Byte representation
         */


        LongPrototype.toBytes = function toBytes(le) {
          return le ? this.toBytesLE() : this.toBytesBE();
        };
        /**
         * Converts this Long to its little endian byte representation.
         * @returns {!Array.<number>} Little endian byte representation
         */


        LongPrototype.toBytesLE = function toBytesLE() {
          var hi = this.high,
              lo = this.low;
          return [lo & 0xff, lo >>> 8 & 0xff, lo >>> 16 & 0xff, lo >>> 24, hi & 0xff, hi >>> 8 & 0xff, hi >>> 16 & 0xff, hi >>> 24];
        };
        /**
         * Converts this Long to its big endian byte representation.
         * @returns {!Array.<number>} Big endian byte representation
         */


        LongPrototype.toBytesBE = function toBytesBE() {
          var hi = this.high,
              lo = this.low;
          return [hi >>> 24, hi >>> 16 & 0xff, hi >>> 8 & 0xff, hi & 0xff, lo >>> 24, lo >>> 16 & 0xff, lo >>> 8 & 0xff, lo & 0xff];
        };
        /**
         * Creates a Long from its byte representation.
         * @param {!Array.<number>} bytes Byte representation
         * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
         * @param {boolean=} le Whether little or big endian, defaults to big endian
         * @returns {Long} The corresponding Long value
         */


        Long.fromBytes = function fromBytes(bytes, unsigned, le) {
          return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
        };
        /**
         * Creates a Long from its little endian byte representation.
         * @param {!Array.<number>} bytes Little endian byte representation
         * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
         * @returns {Long} The corresponding Long value
         */


        Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
          return new Long(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);
        };
        /**
         * Creates a Long from its big endian byte representation.
         * @param {!Array.<number>} bytes Big endian byte representation
         * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
         * @returns {Long} The corresponding Long value
         */


        Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
          return new Long(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned);
        }; // #endregion ORIGINAL CODE


        _cjsExports = exports('default', module.exports);
      }, {});
    }
  };
});

System.register("chunks:///_virtual/long.mjs_cjs=&original=.js", ['./long.js', './cjs-loader.mjs'], function (exports, module) {
  'use strict';

  var __cjsMetaURL, loader;

  return {
    setters: [function (module) {
      __cjsMetaURL = module.__cjsMetaURL;
      var _setter = {};
      _setter.__cjsMetaURL = module.__cjsMetaURL;
      _setter.default = module.default;
      exports(_setter);
    }, function (module) {
      loader = module.default;
    }],
    execute: function () {
      // I am the facade module who provides access to the CommonJS module './long.js'~
      if (!__cjsMetaURL) {
        loader.throwInvalidWrapper('./long.js', module.meta.url);
      }

      loader.require(__cjsMetaURL);
    }
  };
});

System.register("chunks:///_virtual/longbits.js", ['./cjs-loader.mjs', './minimal2.js'], function (exports, module) {
  'use strict';

  var loader, __cjsMetaURL$1;

  return {
    setters: [function (module) {
      loader = module.default;
    }, function (module) {
      __cjsMetaURL$1 = module.__cjsMetaURL;
    }],
    execute: function () {
      var __cjsMetaURL = exports('__cjsMetaURL', module.meta.url);

      loader.define(__cjsMetaURL, function (exports, require, module, __filename, __dirname) {
        module.exports = LongBits;

        var util = require("../util/minimal");
        /**
         * Constructs new long bits.
         * @classdesc Helper class for working with the low and high bits of a 64 bit value.
         * @memberof util
         * @constructor
         * @param {number} lo Low 32 bits, unsigned
         * @param {number} hi High 32 bits, unsigned
         */


        function LongBits(lo, hi) {
          // note that the casts below are theoretically unnecessary as of today, but older statically
          // generated converter code might still call the ctor with signed 32bits. kept for compat.

          /**
           * Low bits.
           * @type {number}
           */
          this.lo = lo >>> 0;
          /**
           * High bits.
           * @type {number}
           */

          this.hi = hi >>> 0;
        }
        /**
         * Zero bits.
         * @memberof util.LongBits
         * @type {util.LongBits}
         */


        var zero = LongBits.zero = new LongBits(0, 0);

        zero.toNumber = function () {
          return 0;
        };

        zero.zzEncode = zero.zzDecode = function () {
          return this;
        };

        zero.length = function () {
          return 1;
        };
        /**
         * Zero hash.
         * @memberof util.LongBits
         * @type {string}
         */


        var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
        /**
         * Constructs new long bits from the specified number.
         * @param {number} value Value
         * @returns {util.LongBits} Instance
         */

        LongBits.fromNumber = function fromNumber(value) {
          if (value === 0) return zero;
          var sign = value < 0;
          if (sign) value = -value;
          var lo = value >>> 0,
              hi = (value - lo) / 4294967296 >>> 0;

          if (sign) {
            hi = ~hi >>> 0;
            lo = ~lo >>> 0;

            if (++lo > 4294967295) {
              lo = 0;
              if (++hi > 4294967295) hi = 0;
            }
          }

          return new LongBits(lo, hi);
        };
        /**
         * Constructs new long bits from a number, long or string.
         * @param {Long|number|string} value Value
         * @returns {util.LongBits} Instance
         */


        LongBits.from = function from(value) {
          if (typeof value === "number") return LongBits.fromNumber(value);

          if (util.isString(value)) {
            /* istanbul ignore else */
            if (util.Long) value = util.Long.fromString(value);else return LongBits.fromNumber(parseInt(value, 10));
          }

          return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
        };
        /**
         * Converts this long bits to a possibly unsafe JavaScript number.
         * @param {boolean} [unsigned=false] Whether unsigned or not
         * @returns {number} Possibly unsafe number
         */


        LongBits.prototype.toNumber = function toNumber(unsigned) {
          if (!unsigned && this.hi >>> 31) {
            var lo = ~this.lo + 1 >>> 0,
                hi = ~this.hi >>> 0;
            if (!lo) hi = hi + 1 >>> 0;
            return -(lo + hi * 4294967296);
          }

          return this.lo + this.hi * 4294967296;
        };
        /**
         * Converts this long bits to a long.
         * @param {boolean} [unsigned=false] Whether unsigned or not
         * @returns {Long} Long
         */


        LongBits.prototype.toLong = function toLong(unsigned) {
          return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))
          /* istanbul ignore next */
          : {
            low: this.lo | 0,
            high: this.hi | 0,
            unsigned: Boolean(unsigned)
          };
        };

        var charCodeAt = String.prototype.charCodeAt;
        /**
         * Constructs new long bits from the specified 8 characters long hash.
         * @param {string} hash Hash
         * @returns {util.LongBits} Bits
         */

        LongBits.fromHash = function fromHash(hash) {
          if (hash === zeroHash) return zero;
          return new LongBits((charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0, (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0);
        };
        /**
         * Converts this long bits to a 8 characters long hash.
         * @returns {string} Hash
         */


        LongBits.prototype.toHash = function toHash() {
          return String.fromCharCode(this.lo & 255, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, this.hi & 255, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);
        };
        /**
         * Zig-zag encodes this long bits.
         * @returns {util.LongBits} `this`
         */


        LongBits.prototype.zzEncode = function zzEncode() {
          var mask = this.hi >> 31;
          this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
          this.lo = (this.lo << 1 ^ mask) >>> 0;
          return this;
        };
        /**
         * Zig-zag decodes this long bits.
         * @returns {util.LongBits} `this`
         */


        LongBits.prototype.zzDecode = function zzDecode() {
          var mask = -(this.lo & 1);
          this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
          this.hi = (this.hi >>> 1 ^ mask) >>> 0;
          return this;
        };
        /**
         * Calculates the length of this longbits when encoded as a varint.
         * @returns {number} Length
         */


        LongBits.prototype.length = function length() {
          var part0 = this.lo,
              part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,
              part2 = this.hi >>> 24;
          return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
        }; // #endregion ORIGINAL CODE


        module.exports;
      }, function () {
        return {
          '../util/minimal': __cjsMetaURL$1
        };
      });
    }
  };
});

System.register("chunks:///_virtual/longhu.js", ['./cjs-loader.mjs', './minimal.js'], function (exports, module) {
  'use strict';

  var loader, __cjsMetaURL$1;

  return {
    setters: [function (module) {
      loader = module.default;
    }, function (module) {
      __cjsMetaURL$1 = module.__cjsMetaURL;
    }],
    execute: function () {
      exports('default', void 0);

      var _cjsExports;

      var __cjsMetaURL = exports('__cjsMetaURL', module.meta.url);

      loader.define(__cjsMetaURL, function (exports$1, require, module, __filename, __dirname) {
        var $protobuf = require("protobufjs/minimal"); // Common aliases


        var $Reader = $protobuf.Reader,
            $Writer = $protobuf.Writer,
            $util = $protobuf.util; // Exported root namespace

        var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

        $root.longhuProto = function () {
          /**
           * Namespace longhuProto.
           * @exports longhuProto
           * @namespace
           */
          var longhuProto = {};

          longhuProto.GetLonghuListRequest = function () {
            /**
             * Properties of a GetLonghuListRequest.
             * @memberof longhuProto
             * @interface IGetLonghuListRequest
             * @property {number|null} [apiID] GetLonghuListRequest apiID
             * @property {number|null} [accountID] GetLonghuListRequest accountID
             * @property {number|null} [subAgentCode] GetLonghuListRequest subAgentCode
             * @property {number|null} [GameID] GetLonghuListRequest GameID
             */

            /**
             * Constructs a new GetLonghuListRequest.
             * @memberof longhuProto
             * @classdesc Represents a GetLonghuListRequest.
             * @implements IGetLonghuListRequest
             * @constructor
             * @param {longhuProto.IGetLonghuListRequest=} [properties] Properties to set
             */
            function GetLonghuListRequest(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * GetLonghuListRequest apiID.
             * @member {number} apiID
             * @memberof longhuProto.GetLonghuListRequest
             * @instance
             */


            GetLonghuListRequest.prototype.apiID = 0;
            /**
             * GetLonghuListRequest accountID.
             * @member {number} accountID
             * @memberof longhuProto.GetLonghuListRequest
             * @instance
             */

            GetLonghuListRequest.prototype.accountID = 0;
            /**
             * GetLonghuListRequest subAgentCode.
             * @member {number} subAgentCode
             * @memberof longhuProto.GetLonghuListRequest
             * @instance
             */

            GetLonghuListRequest.prototype.subAgentCode = 0;
            /**
             * GetLonghuListRequest GameID.
             * @member {number} GameID
             * @memberof longhuProto.GetLonghuListRequest
             * @instance
             */

            GetLonghuListRequest.prototype.GameID = 0;
            /**
             * Encodes the specified GetLonghuListRequest message. Does not implicitly {@link longhuProto.GetLonghuListRequest.verify|verify} messages.
             * @function encode
             * @memberof longhuProto.GetLonghuListRequest
             * @static
             * @param {longhuProto.IGetLonghuListRequest} message GetLonghuListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */

            GetLonghuListRequest.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.apiID != null && Object.hasOwnProperty.call(message, "apiID")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.apiID);
              if (message.accountID != null && Object.hasOwnProperty.call(message, "accountID")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int32(message.accountID);
              if (message.subAgentCode != null && Object.hasOwnProperty.call(message, "subAgentCode")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.subAgentCode);
              if (message.GameID != null && Object.hasOwnProperty.call(message, "GameID")) writer.uint32(
              /* id 4, wireType 0 =*/
              32).int32(message.GameID);
              return writer;
            };
            /**
             * Decodes a GetLonghuListRequest message from the specified reader or buffer.
             * @function decode
             * @memberof longhuProto.GetLonghuListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {longhuProto.GetLonghuListRequest} GetLonghuListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            GetLonghuListRequest.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.longhuProto.GetLonghuListRequest();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      message.apiID = reader.int32();
                      break;
                    }

                  case 2:
                    {
                      message.accountID = reader.int32();
                      break;
                    }

                  case 3:
                    {
                      message.subAgentCode = reader.int32();
                      break;
                    }

                  case 4:
                    {
                      message.GameID = reader.int32();
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
             * Gets the default type url for GetLonghuListRequest
             * @function getTypeUrl
             * @memberof longhuProto.GetLonghuListRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */


            GetLonghuListRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/longhuProto.GetLonghuListRequest";
            };

            return GetLonghuListRequest;
          }();

          longhuProto.LonghuListMixPlayer = function () {
            /**
             * Properties of a LonghuListMixPlayer.
             * @memberof longhuProto
             * @interface ILonghuListMixPlayer
             * @property {number|null} [no] LonghuListMixPlayer no
             * @property {string|null} [account] LonghuListMixPlayer account
             * @property {string|null} [nickname] LonghuListMixPlayer nickname
             * @property {number|null} [gameID] LonghuListMixPlayer gameID
             * @property {number|null} [win] LonghuListMixPlayer win
             * @property {number|null} [odd] LonghuListMixPlayer odd
             * @property {Long|null} [createTime] LonghuListMixPlayer createTime
             */

            /**
             * Constructs a new LonghuListMixPlayer.
             * @memberof longhuProto
             * @classdesc Represents a LonghuListMixPlayer.
             * @implements ILonghuListMixPlayer
             * @constructor
             * @param {longhuProto.ILonghuListMixPlayer=} [properties] Properties to set
             */
            function LonghuListMixPlayer(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * LonghuListMixPlayer no.
             * @member {number} no
             * @memberof longhuProto.LonghuListMixPlayer
             * @instance
             */


            LonghuListMixPlayer.prototype.no = 0;
            /**
             * LonghuListMixPlayer account.
             * @member {string} account
             * @memberof longhuProto.LonghuListMixPlayer
             * @instance
             */

            LonghuListMixPlayer.prototype.account = "";
            /**
             * LonghuListMixPlayer nickname.
             * @member {string} nickname
             * @memberof longhuProto.LonghuListMixPlayer
             * @instance
             */

            LonghuListMixPlayer.prototype.nickname = "";
            /**
             * LonghuListMixPlayer gameID.
             * @member {number} gameID
             * @memberof longhuProto.LonghuListMixPlayer
             * @instance
             */

            LonghuListMixPlayer.prototype.gameID = 0;
            /**
             * LonghuListMixPlayer win.
             * @member {number} win
             * @memberof longhuProto.LonghuListMixPlayer
             * @instance
             */

            LonghuListMixPlayer.prototype.win = 0;
            /**
             * LonghuListMixPlayer odd.
             * @member {number} odd
             * @memberof longhuProto.LonghuListMixPlayer
             * @instance
             */

            LonghuListMixPlayer.prototype.odd = 0;
            /**
             * LonghuListMixPlayer createTime.
             * @member {Long} createTime
             * @memberof longhuProto.LonghuListMixPlayer
             * @instance
             */

            LonghuListMixPlayer.prototype.createTime = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
             * Encodes the specified LonghuListMixPlayer message. Does not implicitly {@link longhuProto.LonghuListMixPlayer.verify|verify} messages.
             * @function encode
             * @memberof longhuProto.LonghuListMixPlayer
             * @static
             * @param {longhuProto.ILonghuListMixPlayer} message LonghuListMixPlayer message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */

            LonghuListMixPlayer.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.no != null && Object.hasOwnProperty.call(message, "no")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.no);
              if (message.account != null && Object.hasOwnProperty.call(message, "account")) writer.uint32(
              /* id 2, wireType 2 =*/
              18).string(message.account);
              if (message.nickname != null && Object.hasOwnProperty.call(message, "nickname")) writer.uint32(
              /* id 3, wireType 2 =*/
              26).string(message.nickname);
              if (message.gameID != null && Object.hasOwnProperty.call(message, "gameID")) writer.uint32(
              /* id 4, wireType 0 =*/
              32).int32(message.gameID);
              if (message.win != null && Object.hasOwnProperty.call(message, "win")) writer.uint32(
              /* id 5, wireType 1 =*/
              41)["double"](message.win);
              if (message.odd != null && Object.hasOwnProperty.call(message, "odd")) writer.uint32(
              /* id 6, wireType 1 =*/
              49)["double"](message.odd);
              if (message.createTime != null && Object.hasOwnProperty.call(message, "createTime")) writer.uint32(
              /* id 7, wireType 0 =*/
              56).int64(message.createTime);
              return writer;
            };
            /**
             * Decodes a LonghuListMixPlayer message from the specified reader or buffer.
             * @function decode
             * @memberof longhuProto.LonghuListMixPlayer
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {longhuProto.LonghuListMixPlayer} LonghuListMixPlayer
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            LonghuListMixPlayer.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.longhuProto.LonghuListMixPlayer();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      message.no = reader.int32();
                      break;
                    }

                  case 2:
                    {
                      message.account = reader.string();
                      break;
                    }

                  case 3:
                    {
                      message.nickname = reader.string();
                      break;
                    }

                  case 4:
                    {
                      message.gameID = reader.int32();
                      break;
                    }

                  case 5:
                    {
                      message.win = reader["double"]();
                      break;
                    }

                  case 6:
                    {
                      message.odd = reader["double"]();
                      break;
                    }

                  case 7:
                    {
                      message.createTime = reader.int64();
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
             * Gets the default type url for LonghuListMixPlayer
             * @function getTypeUrl
             * @memberof longhuProto.LonghuListMixPlayer
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */


            LonghuListMixPlayer.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/longhuProto.LonghuListMixPlayer";
            };

            return LonghuListMixPlayer;
          }();

          longhuProto.LonghuListMixPlayerAdmin = function () {
            /**
             * Properties of a LonghuListMixPlayerAdmin.
             * @memberof longhuProto
             * @interface ILonghuListMixPlayerAdmin
             * @property {longhuProto.ILonghuListMixPlayer|null} [player] LonghuListMixPlayerAdmin player
             * @property {Array.<longhuProto.ILonghuListMixPlayer>|null} [playerList] LonghuListMixPlayerAdmin playerList
             */

            /**
             * Constructs a new LonghuListMixPlayerAdmin.
             * @memberof longhuProto
             * @classdesc Represents a LonghuListMixPlayerAdmin.
             * @implements ILonghuListMixPlayerAdmin
             * @constructor
             * @param {longhuProto.ILonghuListMixPlayerAdmin=} [properties] Properties to set
             */
            function LonghuListMixPlayerAdmin(properties) {
              this.playerList = [];
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * LonghuListMixPlayerAdmin player.
             * @member {longhuProto.ILonghuListMixPlayer|null|undefined} player
             * @memberof longhuProto.LonghuListMixPlayerAdmin
             * @instance
             */


            LonghuListMixPlayerAdmin.prototype.player = null;
            /**
             * LonghuListMixPlayerAdmin playerList.
             * @member {Array.<longhuProto.ILonghuListMixPlayer>} playerList
             * @memberof longhuProto.LonghuListMixPlayerAdmin
             * @instance
             */

            LonghuListMixPlayerAdmin.prototype.playerList = $util.emptyArray;
            /**
             * Encodes the specified LonghuListMixPlayerAdmin message. Does not implicitly {@link longhuProto.LonghuListMixPlayerAdmin.verify|verify} messages.
             * @function encode
             * @memberof longhuProto.LonghuListMixPlayerAdmin
             * @static
             * @param {longhuProto.ILonghuListMixPlayerAdmin} message LonghuListMixPlayerAdmin message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */

            LonghuListMixPlayerAdmin.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.player != null && Object.hasOwnProperty.call(message, "player")) $root.longhuProto.LonghuListMixPlayer.encode(message.player, writer.uint32(
              /* id 1, wireType 2 =*/
              10).fork()).ldelim();
              if (message.playerList != null && message.playerList.length) for (var i = 0; i < message.playerList.length; ++i) {
                $root.longhuProto.LonghuListMixPlayer.encode(message.playerList[i], writer.uint32(
                /* id 2, wireType 2 =*/
                18).fork()).ldelim();
              }
              return writer;
            };
            /**
             * Decodes a LonghuListMixPlayerAdmin message from the specified reader or buffer.
             * @function decode
             * @memberof longhuProto.LonghuListMixPlayerAdmin
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {longhuProto.LonghuListMixPlayerAdmin} LonghuListMixPlayerAdmin
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            LonghuListMixPlayerAdmin.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.longhuProto.LonghuListMixPlayerAdmin();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      message.player = $root.longhuProto.LonghuListMixPlayer.decode(reader, reader.uint32());
                      break;
                    }

                  case 2:
                    {
                      if (!(message.playerList && message.playerList.length)) message.playerList = [];
                      message.playerList.push($root.longhuProto.LonghuListMixPlayer.decode(reader, reader.uint32()));
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
             * Gets the default type url for LonghuListMixPlayerAdmin
             * @function getTypeUrl
             * @memberof longhuProto.LonghuListMixPlayerAdmin
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */


            LonghuListMixPlayerAdmin.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/longhuProto.LonghuListMixPlayerAdmin";
            };

            return LonghuListMixPlayerAdmin;
          }();

          longhuProto.LonghuListMix = function () {
            /**
             * Properties of a LonghuListMix.
             * @memberof longhuProto
             * @interface ILonghuListMix
             * @property {longhuProto.ILonghuListMixPlayerAdmin|null} [win] LonghuListMix win
             * @property {longhuProto.ILonghuListMixPlayerAdmin|null} [odd] LonghuListMix odd
             */

            /**
             * Constructs a new LonghuListMix.
             * @memberof longhuProto
             * @classdesc Represents a LonghuListMix.
             * @implements ILonghuListMix
             * @constructor
             * @param {longhuProto.ILonghuListMix=} [properties] Properties to set
             */
            function LonghuListMix(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * LonghuListMix win.
             * @member {longhuProto.ILonghuListMixPlayerAdmin|null|undefined} win
             * @memberof longhuProto.LonghuListMix
             * @instance
             */


            LonghuListMix.prototype.win = null;
            /**
             * LonghuListMix odd.
             * @member {longhuProto.ILonghuListMixPlayerAdmin|null|undefined} odd
             * @memberof longhuProto.LonghuListMix
             * @instance
             */

            LonghuListMix.prototype.odd = null;
            /**
             * Encodes the specified LonghuListMix message. Does not implicitly {@link longhuProto.LonghuListMix.verify|verify} messages.
             * @function encode
             * @memberof longhuProto.LonghuListMix
             * @static
             * @param {longhuProto.ILonghuListMix} message LonghuListMix message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */

            LonghuListMix.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.win != null && Object.hasOwnProperty.call(message, "win")) $root.longhuProto.LonghuListMixPlayerAdmin.encode(message.win, writer.uint32(
              /* id 1, wireType 2 =*/
              10).fork()).ldelim();
              if (message.odd != null && Object.hasOwnProperty.call(message, "odd")) $root.longhuProto.LonghuListMixPlayerAdmin.encode(message.odd, writer.uint32(
              /* id 2, wireType 2 =*/
              18).fork()).ldelim();
              return writer;
            };
            /**
             * Decodes a LonghuListMix message from the specified reader or buffer.
             * @function decode
             * @memberof longhuProto.LonghuListMix
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {longhuProto.LonghuListMix} LonghuListMix
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            LonghuListMix.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.longhuProto.LonghuListMix();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      message.win = $root.longhuProto.LonghuListMixPlayerAdmin.decode(reader, reader.uint32());
                      break;
                    }

                  case 2:
                    {
                      message.odd = $root.longhuProto.LonghuListMixPlayerAdmin.decode(reader, reader.uint32());
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
             * Gets the default type url for LonghuListMix
             * @function getTypeUrl
             * @memberof longhuProto.LonghuListMix
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */


            LonghuListMix.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/longhuProto.LonghuListMix";
            };

            return LonghuListMix;
          }();

          longhuProto.LonghuListResponse = function () {
            /**
             * Properties of a LonghuListResponse.
             * @memberof longhuProto
             * @interface ILonghuListResponse
             * @property {number|null} [errorCode] LonghuListResponse errorCode
             * @property {string|null} [message] LonghuListResponse message
             * @property {longhuProto.ILonghuListMix|null} [data] LonghuListResponse data
             * @property {Long|null} [resetTime] LonghuListResponse resetTime
             */

            /**
             * Constructs a new LonghuListResponse.
             * @memberof longhuProto
             * @classdesc Represents a LonghuListResponse.
             * @implements ILonghuListResponse
             * @constructor
             * @param {longhuProto.ILonghuListResponse=} [properties] Properties to set
             */
            function LonghuListResponse(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * LonghuListResponse errorCode.
             * @member {number} errorCode
             * @memberof longhuProto.LonghuListResponse
             * @instance
             */


            LonghuListResponse.prototype.errorCode = 0;
            /**
             * LonghuListResponse message.
             * @member {string} message
             * @memberof longhuProto.LonghuListResponse
             * @instance
             */

            LonghuListResponse.prototype.message = "";
            /**
             * LonghuListResponse data.
             * @member {longhuProto.ILonghuListMix|null|undefined} data
             * @memberof longhuProto.LonghuListResponse
             * @instance
             */

            LonghuListResponse.prototype.data = null;
            /**
             * LonghuListResponse resetTime.
             * @member {Long} resetTime
             * @memberof longhuProto.LonghuListResponse
             * @instance
             */

            LonghuListResponse.prototype.resetTime = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
             * Encodes the specified LonghuListResponse message. Does not implicitly {@link longhuProto.LonghuListResponse.verify|verify} messages.
             * @function encode
             * @memberof longhuProto.LonghuListResponse
             * @static
             * @param {longhuProto.ILonghuListResponse} message LonghuListResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */

            LonghuListResponse.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.errorCode != null && Object.hasOwnProperty.call(message, "errorCode")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.errorCode);
              if (message.message != null && Object.hasOwnProperty.call(message, "message")) writer.uint32(
              /* id 2, wireType 2 =*/
              18).string(message.message);
              if (message.data != null && Object.hasOwnProperty.call(message, "data")) $root.longhuProto.LonghuListMix.encode(message.data, writer.uint32(
              /* id 3, wireType 2 =*/
              26).fork()).ldelim();
              if (message.resetTime != null && Object.hasOwnProperty.call(message, "resetTime")) writer.uint32(
              /* id 4, wireType 0 =*/
              32).int64(message.resetTime);
              return writer;
            };
            /**
             * Decodes a LonghuListResponse message from the specified reader or buffer.
             * @function decode
             * @memberof longhuProto.LonghuListResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {longhuProto.LonghuListResponse} LonghuListResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            LonghuListResponse.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.longhuProto.LonghuListResponse();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      message.errorCode = reader.int32();
                      break;
                    }

                  case 2:
                    {
                      message.message = reader.string();
                      break;
                    }

                  case 3:
                    {
                      message.data = $root.longhuProto.LonghuListMix.decode(reader, reader.uint32());
                      break;
                    }

                  case 4:
                    {
                      message.resetTime = reader.int64();
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
             * Gets the default type url for LonghuListResponse
             * @function getTypeUrl
             * @memberof longhuProto.LonghuListResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */


            LonghuListResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/longhuProto.LonghuListResponse";
            };

            return LonghuListResponse;
          }();

          return longhuProto;
        }();

        module.exports = $root; // #endregion ORIGINAL CODE

        _cjsExports = exports('default', module.exports);
      }, function () {
        return {
          'protobufjs/minimal': __cjsMetaURL$1
        };
      });
    }
  };
});

System.register("chunks:///_virtual/longhu.mjs_cjs=&original=.js", ['./longhu.js', './cjs-loader.mjs'], function (exports, module) {
  'use strict';

  var __cjsMetaURL, loader;

  return {
    setters: [function (module) {
      __cjsMetaURL = module.__cjsMetaURL;
      var _setter = {};
      _setter.__cjsMetaURL = module.__cjsMetaURL;
      _setter.default = module.default;
      exports(_setter);
    }, function (module) {
      loader = module.default;
    }],
    execute: function () {
      // I am the facade module who provides access to the CommonJS module './longhu.js'~
      if (!__cjsMetaURL) {
        loader.throwInvalidWrapper('./longhu.js', module.meta.url);
      }

      loader.require(__cjsMetaURL);
    }
  };
});

System.register("chunks:///_virtual/lotto.js", ['./cjs-loader.mjs', './minimal.js'], function (exports, module) {
  'use strict';

  var loader, __cjsMetaURL$1;

  return {
    setters: [function (module) {
      loader = module.default;
    }, function (module) {
      __cjsMetaURL$1 = module.__cjsMetaURL;
    }],
    execute: function () {
      exports('default', void 0);

      var _cjsExports;

      var __cjsMetaURL = exports('__cjsMetaURL', module.meta.url);

      loader.define(__cjsMetaURL, function (exports$1, require, module, __filename, __dirname) {
        var $protobuf = require("protobufjs/minimal"); // Common aliases


        var $Reader = $protobuf.Reader,
            $Writer = $protobuf.Writer,
            $util = $protobuf.util; // Exported root namespace

        var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

        $root.lottoProto = function () {
          /**
           * Namespace lottoProto.
           * @exports lottoProto
           * @namespace
           */
          var lottoProto = {};

          lottoProto.LotteryReq = function () {
            /**
             * Properties of a LotteryReq.
             * @memberof lottoProto
             * @interface ILotteryReq
             * @property {number|null} [LottoSerial] LotteryReq LottoSerial
             * @property {string|null} [LottoJiliSerial] LotteryReq LottoJiliSerial
             */

            /**
             * Constructs a new LotteryReq.
             * @memberof lottoProto
             * @classdesc Represents a LotteryReq.
             * @implements ILotteryReq
             * @constructor
             * @param {lottoProto.ILotteryReq=} [properties] Properties to set
             */
            function LotteryReq(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * LotteryReq LottoSerial.
             * @member {number} LottoSerial
             * @memberof lottoProto.LotteryReq
             * @instance
             */


            LotteryReq.prototype.LottoSerial = 0;
            /**
             * LotteryReq LottoJiliSerial.
             * @member {string} LottoJiliSerial
             * @memberof lottoProto.LotteryReq
             * @instance
             */

            LotteryReq.prototype.LottoJiliSerial = "";
            /**
             * Creates a new LotteryReq instance using the specified properties.
             * @function create
             * @memberof lottoProto.LotteryReq
             * @static
             * @param {lottoProto.ILotteryReq=} [properties] Properties to set
             * @returns {lottoProto.LotteryReq} LotteryReq instance
             */

            LotteryReq.create = function create(properties) {
              return new LotteryReq(properties);
            };
            /**
             * Encodes the specified LotteryReq message. Does not implicitly {@link lottoProto.LotteryReq.verify|verify} messages.
             * @function encode
             * @memberof lottoProto.LotteryReq
             * @static
             * @param {lottoProto.ILotteryReq} message LotteryReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            LotteryReq.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.LottoSerial != null && Object.hasOwnProperty.call(message, "LottoSerial")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.LottoSerial);
              if (message.LottoJiliSerial != null && Object.hasOwnProperty.call(message, "LottoJiliSerial")) writer.uint32(
              /* id 2, wireType 2 =*/
              18).string(message.LottoJiliSerial);
              return writer;
            };
            /**
             * Encodes the specified LotteryReq message, length delimited. Does not implicitly {@link lottoProto.LotteryReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lottoProto.LotteryReq
             * @static
             * @param {lottoProto.ILotteryReq} message LotteryReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            LotteryReq.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a LotteryReq message from the specified reader or buffer.
             * @function decode
             * @memberof lottoProto.LotteryReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lottoProto.LotteryReq} LotteryReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            LotteryReq.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.lottoProto.LotteryReq();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.LottoSerial = reader.int32();
                    break;

                  case 2:
                    message.LottoJiliSerial = reader.string();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
             * Decodes a LotteryReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lottoProto.LotteryReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lottoProto.LotteryReq} LotteryReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            LotteryReq.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a LotteryReq message.
             * @function verify
             * @memberof lottoProto.LotteryReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */


            LotteryReq.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.LottoSerial != null && message.hasOwnProperty("LottoSerial")) if (!$util.isInteger(message.LottoSerial)) return "LottoSerial: integer expected";
              if (message.LottoJiliSerial != null && message.hasOwnProperty("LottoJiliSerial")) if (!$util.isString(message.LottoJiliSerial)) return "LottoJiliSerial: string expected";
              return null;
            };
            /**
             * Creates a LotteryReq message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lottoProto.LotteryReq
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lottoProto.LotteryReq} LotteryReq
             */


            LotteryReq.fromObject = function fromObject(object) {
              if (object instanceof $root.lottoProto.LotteryReq) return object;
              var message = new $root.lottoProto.LotteryReq();
              if (object.LottoSerial != null) message.LottoSerial = object.LottoSerial | 0;
              if (object.LottoJiliSerial != null) message.LottoJiliSerial = String(object.LottoJiliSerial);
              return message;
            };
            /**
             * Creates a plain object from a LotteryReq message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lottoProto.LotteryReq
             * @static
             * @param {lottoProto.LotteryReq} message LotteryReq
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */


            LotteryReq.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.LottoSerial = 0;
                object.LottoJiliSerial = "";
              }

              if (message.LottoSerial != null && message.hasOwnProperty("LottoSerial")) object.LottoSerial = message.LottoSerial;
              if (message.LottoJiliSerial != null && message.hasOwnProperty("LottoJiliSerial")) object.LottoJiliSerial = message.LottoJiliSerial;
              return object;
            };
            /**
             * Converts this LotteryReq to JSON.
             * @function toJSON
             * @memberof lottoProto.LotteryReq
             * @instance
             * @returns {Object.<string,*>} JSON object
             */


            LotteryReq.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return LotteryReq;
          }();

          lottoProto.LotteryInfoResp = function () {
            /**
             * Properties of a LotteryInfoResp.
             * @memberof lottoProto
             * @interface ILotteryInfoResp
             * @property {lottoProto.ILotteryInfo|null} [Cur] LotteryInfoResp Cur
             * @property {Array.<lottoProto.ILotteryInfo>|null} [Last] LotteryInfoResp Last
             * @property {Array.<lottoProto.ILotteryInfo>|null} [JiliLasts] LotteryInfoResp JiliLasts
             * @property {Array.<lottoProto.ILotteryRewardList>|null} [LastReward] LotteryInfoResp LastReward
             * @property {Array.<lottoProto.IRewardInfo>|null} [LottoRewards] LotteryInfoResp LottoRewards
             * @property {Array.<lottoProto.IRewardInfo>|null} [JiliRewards] LotteryInfoResp JiliRewards
             * @property {lottoProto.LotteryType|null} [Type] LotteryInfoResp Type
             */

            /**
             * Constructs a new LotteryInfoResp.
             * @memberof lottoProto
             * @classdesc Represents a LotteryInfoResp.
             * @implements ILotteryInfoResp
             * @constructor
             * @param {lottoProto.ILotteryInfoResp=} [properties] Properties to set
             */
            function LotteryInfoResp(properties) {
              this.Last = [];
              this.JiliLasts = [];
              this.LastReward = [];
              this.LottoRewards = [];
              this.JiliRewards = [];
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * LotteryInfoResp Cur.
             * @member {lottoProto.ILotteryInfo|null|undefined} Cur
             * @memberof lottoProto.LotteryInfoResp
             * @instance
             */


            LotteryInfoResp.prototype.Cur = null;
            /**
             * LotteryInfoResp Last.
             * @member {Array.<lottoProto.ILotteryInfo>} Last
             * @memberof lottoProto.LotteryInfoResp
             * @instance
             */

            LotteryInfoResp.prototype.Last = $util.emptyArray;
            /**
             * LotteryInfoResp JiliLasts.
             * @member {Array.<lottoProto.ILotteryInfo>} JiliLasts
             * @memberof lottoProto.LotteryInfoResp
             * @instance
             */

            LotteryInfoResp.prototype.JiliLasts = $util.emptyArray;
            /**
             * LotteryInfoResp LastReward.
             * @member {Array.<lottoProto.ILotteryRewardList>} LastReward
             * @memberof lottoProto.LotteryInfoResp
             * @instance
             */

            LotteryInfoResp.prototype.LastReward = $util.emptyArray;
            /**
             * LotteryInfoResp LottoRewards.
             * @member {Array.<lottoProto.IRewardInfo>} LottoRewards
             * @memberof lottoProto.LotteryInfoResp
             * @instance
             */

            LotteryInfoResp.prototype.LottoRewards = $util.emptyArray;
            /**
             * LotteryInfoResp JiliRewards.
             * @member {Array.<lottoProto.IRewardInfo>} JiliRewards
             * @memberof lottoProto.LotteryInfoResp
             * @instance
             */

            LotteryInfoResp.prototype.JiliRewards = $util.emptyArray;
            /**
             * LotteryInfoResp Type.
             * @member {lottoProto.LotteryType} Type
             * @memberof lottoProto.LotteryInfoResp
             * @instance
             */

            LotteryInfoResp.prototype.Type = 0;
            /**
             * Creates a new LotteryInfoResp instance using the specified properties.
             * @function create
             * @memberof lottoProto.LotteryInfoResp
             * @static
             * @param {lottoProto.ILotteryInfoResp=} [properties] Properties to set
             * @returns {lottoProto.LotteryInfoResp} LotteryInfoResp instance
             */

            LotteryInfoResp.create = function create(properties) {
              return new LotteryInfoResp(properties);
            };
            /**
             * Encodes the specified LotteryInfoResp message. Does not implicitly {@link lottoProto.LotteryInfoResp.verify|verify} messages.
             * @function encode
             * @memberof lottoProto.LotteryInfoResp
             * @static
             * @param {lottoProto.ILotteryInfoResp} message LotteryInfoResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            LotteryInfoResp.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.Cur != null && Object.hasOwnProperty.call(message, "Cur")) $root.lottoProto.LotteryInfo.encode(message.Cur, writer.uint32(
              /* id 1, wireType 2 =*/
              10).fork()).ldelim();
              if (message.Last != null && message.Last.length) for (var i = 0; i < message.Last.length; ++i) {
                $root.lottoProto.LotteryInfo.encode(message.Last[i], writer.uint32(
                /* id 2, wireType 2 =*/
                18).fork()).ldelim();
              }
              if (message.JiliLasts != null && message.JiliLasts.length) for (var i = 0; i < message.JiliLasts.length; ++i) {
                $root.lottoProto.LotteryInfo.encode(message.JiliLasts[i], writer.uint32(
                /* id 3, wireType 2 =*/
                26).fork()).ldelim();
              }
              if (message.LastReward != null && message.LastReward.length) for (var i = 0; i < message.LastReward.length; ++i) {
                $root.lottoProto.LotteryRewardList.encode(message.LastReward[i], writer.uint32(
                /* id 4, wireType 2 =*/
                34).fork()).ldelim();
              }
              if (message.LottoRewards != null && message.LottoRewards.length) for (var i = 0; i < message.LottoRewards.length; ++i) {
                $root.lottoProto.RewardInfo.encode(message.LottoRewards[i], writer.uint32(
                /* id 5, wireType 2 =*/
                42).fork()).ldelim();
              }
              if (message.JiliRewards != null && message.JiliRewards.length) for (var i = 0; i < message.JiliRewards.length; ++i) {
                $root.lottoProto.RewardInfo.encode(message.JiliRewards[i], writer.uint32(
                /* id 6, wireType 2 =*/
                50).fork()).ldelim();
              }
              if (message.Type != null && Object.hasOwnProperty.call(message, "Type")) writer.uint32(
              /* id 7, wireType 0 =*/
              56).int32(message.Type);
              return writer;
            };
            /**
             * Encodes the specified LotteryInfoResp message, length delimited. Does not implicitly {@link lottoProto.LotteryInfoResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lottoProto.LotteryInfoResp
             * @static
             * @param {lottoProto.ILotteryInfoResp} message LotteryInfoResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            LotteryInfoResp.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a LotteryInfoResp message from the specified reader or buffer.
             * @function decode
             * @memberof lottoProto.LotteryInfoResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lottoProto.LotteryInfoResp} LotteryInfoResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            LotteryInfoResp.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.lottoProto.LotteryInfoResp();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.Cur = $root.lottoProto.LotteryInfo.decode(reader, reader.uint32());
                    break;

                  case 2:
                    if (!(message.Last && message.Last.length)) message.Last = [];
                    message.Last.push($root.lottoProto.LotteryInfo.decode(reader, reader.uint32()));
                    break;

                  case 3:
                    if (!(message.JiliLasts && message.JiliLasts.length)) message.JiliLasts = [];
                    message.JiliLasts.push($root.lottoProto.LotteryInfo.decode(reader, reader.uint32()));
                    break;

                  case 4:
                    if (!(message.LastReward && message.LastReward.length)) message.LastReward = [];
                    message.LastReward.push($root.lottoProto.LotteryRewardList.decode(reader, reader.uint32()));
                    break;

                  case 5:
                    if (!(message.LottoRewards && message.LottoRewards.length)) message.LottoRewards = [];
                    message.LottoRewards.push($root.lottoProto.RewardInfo.decode(reader, reader.uint32()));
                    break;

                  case 6:
                    if (!(message.JiliRewards && message.JiliRewards.length)) message.JiliRewards = [];
                    message.JiliRewards.push($root.lottoProto.RewardInfo.decode(reader, reader.uint32()));
                    break;

                  case 7:
                    message.Type = reader.int32();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
             * Decodes a LotteryInfoResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lottoProto.LotteryInfoResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lottoProto.LotteryInfoResp} LotteryInfoResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            LotteryInfoResp.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a LotteryInfoResp message.
             * @function verify
             * @memberof lottoProto.LotteryInfoResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */


            LotteryInfoResp.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";

              if (message.Cur != null && message.hasOwnProperty("Cur")) {
                var error = $root.lottoProto.LotteryInfo.verify(message.Cur);
                if (error) return "Cur." + error;
              }

              if (message.Last != null && message.hasOwnProperty("Last")) {
                if (!Array.isArray(message.Last)) return "Last: array expected";

                for (var i = 0; i < message.Last.length; ++i) {
                  var error = $root.lottoProto.LotteryInfo.verify(message.Last[i]);
                  if (error) return "Last." + error;
                }
              }

              if (message.JiliLasts != null && message.hasOwnProperty("JiliLasts")) {
                if (!Array.isArray(message.JiliLasts)) return "JiliLasts: array expected";

                for (var i = 0; i < message.JiliLasts.length; ++i) {
                  var error = $root.lottoProto.LotteryInfo.verify(message.JiliLasts[i]);
                  if (error) return "JiliLasts." + error;
                }
              }

              if (message.LastReward != null && message.hasOwnProperty("LastReward")) {
                if (!Array.isArray(message.LastReward)) return "LastReward: array expected";

                for (var i = 0; i < message.LastReward.length; ++i) {
                  var error = $root.lottoProto.LotteryRewardList.verify(message.LastReward[i]);
                  if (error) return "LastReward." + error;
                }
              }

              if (message.LottoRewards != null && message.hasOwnProperty("LottoRewards")) {
                if (!Array.isArray(message.LottoRewards)) return "LottoRewards: array expected";

                for (var i = 0; i < message.LottoRewards.length; ++i) {
                  var error = $root.lottoProto.RewardInfo.verify(message.LottoRewards[i]);
                  if (error) return "LottoRewards." + error;
                }
              }

              if (message.JiliRewards != null && message.hasOwnProperty("JiliRewards")) {
                if (!Array.isArray(message.JiliRewards)) return "JiliRewards: array expected";

                for (var i = 0; i < message.JiliRewards.length; ++i) {
                  var error = $root.lottoProto.RewardInfo.verify(message.JiliRewards[i]);
                  if (error) return "JiliRewards." + error;
                }
              }

              if (message.Type != null && message.hasOwnProperty("Type")) switch (message.Type) {
                default:
                  return "Type: enum value expected";

                case 0:
                case 1:
                case 2:
                case 3:
                  break;
              }
              return null;
            };
            /**
             * Creates a LotteryInfoResp message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lottoProto.LotteryInfoResp
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lottoProto.LotteryInfoResp} LotteryInfoResp
             */


            LotteryInfoResp.fromObject = function fromObject(object) {
              if (object instanceof $root.lottoProto.LotteryInfoResp) return object;
              var message = new $root.lottoProto.LotteryInfoResp();

              if (object.Cur != null) {
                if (typeof object.Cur !== "object") throw TypeError(".lottoProto.LotteryInfoResp.Cur: object expected");
                message.Cur = $root.lottoProto.LotteryInfo.fromObject(object.Cur);
              }

              if (object.Last) {
                if (!Array.isArray(object.Last)) throw TypeError(".lottoProto.LotteryInfoResp.Last: array expected");
                message.Last = [];

                for (var i = 0; i < object.Last.length; ++i) {
                  if (typeof object.Last[i] !== "object") throw TypeError(".lottoProto.LotteryInfoResp.Last: object expected");
                  message.Last[i] = $root.lottoProto.LotteryInfo.fromObject(object.Last[i]);
                }
              }

              if (object.JiliLasts) {
                if (!Array.isArray(object.JiliLasts)) throw TypeError(".lottoProto.LotteryInfoResp.JiliLasts: array expected");
                message.JiliLasts = [];

                for (var i = 0; i < object.JiliLasts.length; ++i) {
                  if (typeof object.JiliLasts[i] !== "object") throw TypeError(".lottoProto.LotteryInfoResp.JiliLasts: object expected");
                  message.JiliLasts[i] = $root.lottoProto.LotteryInfo.fromObject(object.JiliLasts[i]);
                }
              }

              if (object.LastReward) {
                if (!Array.isArray(object.LastReward)) throw TypeError(".lottoProto.LotteryInfoResp.LastReward: array expected");
                message.LastReward = [];

                for (var i = 0; i < object.LastReward.length; ++i) {
                  if (typeof object.LastReward[i] !== "object") throw TypeError(".lottoProto.LotteryInfoResp.LastReward: object expected");
                  message.LastReward[i] = $root.lottoProto.LotteryRewardList.fromObject(object.LastReward[i]);
                }
              }

              if (object.LottoRewards) {
                if (!Array.isArray(object.LottoRewards)) throw TypeError(".lottoProto.LotteryInfoResp.LottoRewards: array expected");
                message.LottoRewards = [];

                for (var i = 0; i < object.LottoRewards.length; ++i) {
                  if (typeof object.LottoRewards[i] !== "object") throw TypeError(".lottoProto.LotteryInfoResp.LottoRewards: object expected");
                  message.LottoRewards[i] = $root.lottoProto.RewardInfo.fromObject(object.LottoRewards[i]);
                }
              }

              if (object.JiliRewards) {
                if (!Array.isArray(object.JiliRewards)) throw TypeError(".lottoProto.LotteryInfoResp.JiliRewards: array expected");
                message.JiliRewards = [];

                for (var i = 0; i < object.JiliRewards.length; ++i) {
                  if (typeof object.JiliRewards[i] !== "object") throw TypeError(".lottoProto.LotteryInfoResp.JiliRewards: object expected");
                  message.JiliRewards[i] = $root.lottoProto.RewardInfo.fromObject(object.JiliRewards[i]);
                }
              }

              switch (object.Type) {
                case "None":
                case 0:
                  message.Type = 0;
                  break;

                case "Thai":
                case 1:
                  message.Type = 1;
                  break;

                case "ThaiJili":
                case 2:
                  message.Type = 2;
                  break;

                case "Mala":
                case 3:
                  message.Type = 3;
                  break;
              }

              return message;
            };
            /**
             * Creates a plain object from a LotteryInfoResp message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lottoProto.LotteryInfoResp
             * @static
             * @param {lottoProto.LotteryInfoResp} message LotteryInfoResp
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */


            LotteryInfoResp.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.arrays || options.defaults) {
                object.Last = [];
                object.JiliLasts = [];
                object.LastReward = [];
                object.LottoRewards = [];
                object.JiliRewards = [];
              }

              if (options.defaults) {
                object.Cur = null;
                object.Type = options.enums === String ? "None" : 0;
              }

              if (message.Cur != null && message.hasOwnProperty("Cur")) object.Cur = $root.lottoProto.LotteryInfo.toObject(message.Cur, options);

              if (message.Last && message.Last.length) {
                object.Last = [];

                for (var j = 0; j < message.Last.length; ++j) {
                  object.Last[j] = $root.lottoProto.LotteryInfo.toObject(message.Last[j], options);
                }
              }

              if (message.JiliLasts && message.JiliLasts.length) {
                object.JiliLasts = [];

                for (var j = 0; j < message.JiliLasts.length; ++j) {
                  object.JiliLasts[j] = $root.lottoProto.LotteryInfo.toObject(message.JiliLasts[j], options);
                }
              }

              if (message.LastReward && message.LastReward.length) {
                object.LastReward = [];

                for (var j = 0; j < message.LastReward.length; ++j) {
                  object.LastReward[j] = $root.lottoProto.LotteryRewardList.toObject(message.LastReward[j], options);
                }
              }

              if (message.LottoRewards && message.LottoRewards.length) {
                object.LottoRewards = [];

                for (var j = 0; j < message.LottoRewards.length; ++j) {
                  object.LottoRewards[j] = $root.lottoProto.RewardInfo.toObject(message.LottoRewards[j], options);
                }
              }

              if (message.JiliRewards && message.JiliRewards.length) {
                object.JiliRewards = [];

                for (var j = 0; j < message.JiliRewards.length; ++j) {
                  object.JiliRewards[j] = $root.lottoProto.RewardInfo.toObject(message.JiliRewards[j], options);
                }
              }

              if (message.Type != null && message.hasOwnProperty("Type")) object.Type = options.enums === String ? $root.lottoProto.LotteryType[message.Type] : message.Type;
              return object;
            };
            /**
             * Converts this LotteryInfoResp to JSON.
             * @function toJSON
             * @memberof lottoProto.LotteryInfoResp
             * @instance
             * @returns {Object.<string,*>} JSON object
             */


            LotteryInfoResp.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return LotteryInfoResp;
          }();

          lottoProto.RewardInfo = function () {
            /**
             * Properties of a RewardInfo.
             * @memberof lottoProto
             * @interface IRewardInfo
             * @property {lottoProto.AwardType|null} [Type] RewardInfo Type
             * @property {number|null} [Reward] RewardInfo Reward
             * @property {lottoProto.RewardType|null} [RewardType] RewardInfo RewardType
             */

            /**
             * Constructs a new RewardInfo.
             * @memberof lottoProto
             * @classdesc Represents a RewardInfo.
             * @implements IRewardInfo
             * @constructor
             * @param {lottoProto.IRewardInfo=} [properties] Properties to set
             */
            function RewardInfo(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * RewardInfo Type.
             * @member {lottoProto.AwardType} Type
             * @memberof lottoProto.RewardInfo
             * @instance
             */


            RewardInfo.prototype.Type = 0;
            /**
             * RewardInfo Reward.
             * @member {number} Reward
             * @memberof lottoProto.RewardInfo
             * @instance
             */

            RewardInfo.prototype.Reward = 0;
            /**
             * RewardInfo RewardType.
             * @member {lottoProto.RewardType} RewardType
             * @memberof lottoProto.RewardInfo
             * @instance
             */

            RewardInfo.prototype.RewardType = 0;
            /**
             * Creates a new RewardInfo instance using the specified properties.
             * @function create
             * @memberof lottoProto.RewardInfo
             * @static
             * @param {lottoProto.IRewardInfo=} [properties] Properties to set
             * @returns {lottoProto.RewardInfo} RewardInfo instance
             */

            RewardInfo.create = function create(properties) {
              return new RewardInfo(properties);
            };
            /**
             * Encodes the specified RewardInfo message. Does not implicitly {@link lottoProto.RewardInfo.verify|verify} messages.
             * @function encode
             * @memberof lottoProto.RewardInfo
             * @static
             * @param {lottoProto.IRewardInfo} message RewardInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            RewardInfo.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.Type != null && Object.hasOwnProperty.call(message, "Type")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.Type);
              if (message.Reward != null && Object.hasOwnProperty.call(message, "Reward")) writer.uint32(
              /* id 2, wireType 1 =*/
              17)["double"](message.Reward);
              if (message.RewardType != null && Object.hasOwnProperty.call(message, "RewardType")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.RewardType);
              return writer;
            };
            /**
             * Encodes the specified RewardInfo message, length delimited. Does not implicitly {@link lottoProto.RewardInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lottoProto.RewardInfo
             * @static
             * @param {lottoProto.IRewardInfo} message RewardInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            RewardInfo.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a RewardInfo message from the specified reader or buffer.
             * @function decode
             * @memberof lottoProto.RewardInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lottoProto.RewardInfo} RewardInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            RewardInfo.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.lottoProto.RewardInfo();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.Type = reader.int32();
                    break;

                  case 2:
                    message.Reward = reader["double"]();
                    break;

                  case 3:
                    message.RewardType = reader.int32();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
             * Decodes a RewardInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lottoProto.RewardInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lottoProto.RewardInfo} RewardInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            RewardInfo.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a RewardInfo message.
             * @function verify
             * @memberof lottoProto.RewardInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */


            RewardInfo.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.Type != null && message.hasOwnProperty("Type")) switch (message.Type) {
                default:
                  return "Type: enum value expected";

                case 0:
                case 1:
                case 2:
                case 4:
                case 8:
                case 16:
                  break;
              }
              if (message.Reward != null && message.hasOwnProperty("Reward")) if (typeof message.Reward !== "number") return "Reward: number expected";
              if (message.RewardType != null && message.hasOwnProperty("RewardType")) switch (message.RewardType) {
                default:
                  return "RewardType: enum value expected";

                case 0:
                case 1:
                case 2:
                case 3:
                case 5:
                case 6:
                  break;
              }
              return null;
            };
            /**
             * Creates a RewardInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lottoProto.RewardInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lottoProto.RewardInfo} RewardInfo
             */


            RewardInfo.fromObject = function fromObject(object) {
              if (object instanceof $root.lottoProto.RewardInfo) return object;
              var message = new $root.lottoProto.RewardInfo();

              switch (object.Type) {
                case "ZERO":
                case 0:
                  message.Type = 0;
                  break;

                case "LastTwo":
                case 1:
                  message.Type = 1;
                  break;

                case "LastThree":
                case 2:
                  message.Type = 2;
                  break;

                case "FirstThree":
                case 4:
                  message.Type = 4;
                  break;

                case "Special":
                case 8:
                  message.Type = 8;
                  break;

                case "First":
                case 16:
                  message.Type = 16;
                  break;
              }

              if (object.Reward != null) message.Reward = Number(object.Reward);

              switch (object.RewardType) {
                case "NoReward":
                case 0:
                  message.RewardType = 0;
                  break;

                case "Coin":
                case 1:
                  message.RewardType = 1;
                  break;

                case "SlotItem":
                case 2:
                  message.RewardType = 2;
                  break;

                case "FishSkin":
                case 3:
                  message.RewardType = 3;
                  break;

                case "FishItem":
                case 5:
                  message.RewardType = 5;
                  break;

                case "Rubby":
                case 6:
                  message.RewardType = 6;
                  break;
              }

              return message;
            };
            /**
             * Creates a plain object from a RewardInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lottoProto.RewardInfo
             * @static
             * @param {lottoProto.RewardInfo} message RewardInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */


            RewardInfo.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.Type = options.enums === String ? "ZERO" : 0;
                object.Reward = 0;
                object.RewardType = options.enums === String ? "NoReward" : 0;
              }

              if (message.Type != null && message.hasOwnProperty("Type")) object.Type = options.enums === String ? $root.lottoProto.AwardType[message.Type] : message.Type;
              if (message.Reward != null && message.hasOwnProperty("Reward")) object.Reward = options.json && !isFinite(message.Reward) ? String(message.Reward) : message.Reward;
              if (message.RewardType != null && message.hasOwnProperty("RewardType")) object.RewardType = options.enums === String ? $root.lottoProto.RewardType[message.RewardType] : message.RewardType;
              return object;
            };
            /**
             * Converts this RewardInfo to JSON.
             * @function toJSON
             * @memberof lottoProto.RewardInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */


            RewardInfo.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RewardInfo;
          }();

          lottoProto.LotteryInfo = function () {
            /**
             * Properties of a LotteryInfo.
             * @memberof lottoProto
             * @interface ILotteryInfo
             * @property {number|null} [LottoSerial] LotteryInfo LottoSerial
             * @property {string|null} [LottoJiliSerial] LotteryInfo LottoJiliSerial
             * @property {google.protobuf.ITimestamp|null} [EndTime] LotteryInfo EndTime
             * @property {google.protobuf.ITimestamp|null} [DrawTime] LotteryInfo DrawTime
             * @property {google.protobuf.ITimestamp|null} [JiliDrawTime] LotteryInfo JiliDrawTime
             * @property {Array.<lottoProto.ILotteryRewardNumber>|null} [DrawNumber] LotteryInfo DrawNumber
             * @property {lottoProto.ILotteryTicketList|null} [TicketList] LotteryInfo TicketList
             */

            /**
             * Constructs a new LotteryInfo.
             * @memberof lottoProto
             * @classdesc Represents a LotteryInfo.
             * @implements ILotteryInfo
             * @constructor
             * @param {lottoProto.ILotteryInfo=} [properties] Properties to set
             */
            function LotteryInfo(properties) {
              this.DrawNumber = [];
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * LotteryInfo LottoSerial.
             * @member {number} LottoSerial
             * @memberof lottoProto.LotteryInfo
             * @instance
             */


            LotteryInfo.prototype.LottoSerial = 0;
            /**
             * LotteryInfo LottoJiliSerial.
             * @member {string} LottoJiliSerial
             * @memberof lottoProto.LotteryInfo
             * @instance
             */

            LotteryInfo.prototype.LottoJiliSerial = "";
            /**
             * LotteryInfo EndTime.
             * @member {google.protobuf.ITimestamp|null|undefined} EndTime
             * @memberof lottoProto.LotteryInfo
             * @instance
             */

            LotteryInfo.prototype.EndTime = null;
            /**
             * LotteryInfo DrawTime.
             * @member {google.protobuf.ITimestamp|null|undefined} DrawTime
             * @memberof lottoProto.LotteryInfo
             * @instance
             */

            LotteryInfo.prototype.DrawTime = null;
            /**
             * LotteryInfo JiliDrawTime.
             * @member {google.protobuf.ITimestamp|null|undefined} JiliDrawTime
             * @memberof lottoProto.LotteryInfo
             * @instance
             */

            LotteryInfo.prototype.JiliDrawTime = null;
            /**
             * LotteryInfo DrawNumber.
             * @member {Array.<lottoProto.ILotteryRewardNumber>} DrawNumber
             * @memberof lottoProto.LotteryInfo
             * @instance
             */

            LotteryInfo.prototype.DrawNumber = $util.emptyArray;
            /**
             * LotteryInfo TicketList.
             * @member {lottoProto.ILotteryTicketList|null|undefined} TicketList
             * @memberof lottoProto.LotteryInfo
             * @instance
             */

            LotteryInfo.prototype.TicketList = null;
            /**
             * Creates a new LotteryInfo instance using the specified properties.
             * @function create
             * @memberof lottoProto.LotteryInfo
             * @static
             * @param {lottoProto.ILotteryInfo=} [properties] Properties to set
             * @returns {lottoProto.LotteryInfo} LotteryInfo instance
             */

            LotteryInfo.create = function create(properties) {
              return new LotteryInfo(properties);
            };
            /**
             * Encodes the specified LotteryInfo message. Does not implicitly {@link lottoProto.LotteryInfo.verify|verify} messages.
             * @function encode
             * @memberof lottoProto.LotteryInfo
             * @static
             * @param {lottoProto.ILotteryInfo} message LotteryInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            LotteryInfo.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.LottoSerial != null && Object.hasOwnProperty.call(message, "LottoSerial")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.LottoSerial);
              if (message.LottoJiliSerial != null && Object.hasOwnProperty.call(message, "LottoJiliSerial")) writer.uint32(
              /* id 2, wireType 2 =*/
              18).string(message.LottoJiliSerial);
              if (message.EndTime != null && Object.hasOwnProperty.call(message, "EndTime")) $root.google.protobuf.Timestamp.encode(message.EndTime, writer.uint32(
              /* id 3, wireType 2 =*/
              26).fork()).ldelim();
              if (message.DrawTime != null && Object.hasOwnProperty.call(message, "DrawTime")) $root.google.protobuf.Timestamp.encode(message.DrawTime, writer.uint32(
              /* id 4, wireType 2 =*/
              34).fork()).ldelim();
              if (message.JiliDrawTime != null && Object.hasOwnProperty.call(message, "JiliDrawTime")) $root.google.protobuf.Timestamp.encode(message.JiliDrawTime, writer.uint32(
              /* id 5, wireType 2 =*/
              42).fork()).ldelim();
              if (message.DrawNumber != null && message.DrawNumber.length) for (var i = 0; i < message.DrawNumber.length; ++i) {
                $root.lottoProto.LotteryRewardNumber.encode(message.DrawNumber[i], writer.uint32(
                /* id 6, wireType 2 =*/
                50).fork()).ldelim();
              }
              if (message.TicketList != null && Object.hasOwnProperty.call(message, "TicketList")) $root.lottoProto.LotteryTicketList.encode(message.TicketList, writer.uint32(
              /* id 7, wireType 2 =*/
              58).fork()).ldelim();
              return writer;
            };
            /**
             * Encodes the specified LotteryInfo message, length delimited. Does not implicitly {@link lottoProto.LotteryInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lottoProto.LotteryInfo
             * @static
             * @param {lottoProto.ILotteryInfo} message LotteryInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            LotteryInfo.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a LotteryInfo message from the specified reader or buffer.
             * @function decode
             * @memberof lottoProto.LotteryInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lottoProto.LotteryInfo} LotteryInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            LotteryInfo.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.lottoProto.LotteryInfo();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.LottoSerial = reader.int32();
                    break;

                  case 2:
                    message.LottoJiliSerial = reader.string();
                    break;

                  case 3:
                    message.EndTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                    break;

                  case 4:
                    message.DrawTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                    break;

                  case 5:
                    message.JiliDrawTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                    break;

                  case 6:
                    if (!(message.DrawNumber && message.DrawNumber.length)) message.DrawNumber = [];
                    message.DrawNumber.push($root.lottoProto.LotteryRewardNumber.decode(reader, reader.uint32()));
                    break;

                  case 7:
                    message.TicketList = $root.lottoProto.LotteryTicketList.decode(reader, reader.uint32());
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
             * Decodes a LotteryInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lottoProto.LotteryInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lottoProto.LotteryInfo} LotteryInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            LotteryInfo.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a LotteryInfo message.
             * @function verify
             * @memberof lottoProto.LotteryInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */


            LotteryInfo.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.LottoSerial != null && message.hasOwnProperty("LottoSerial")) if (!$util.isInteger(message.LottoSerial)) return "LottoSerial: integer expected";
              if (message.LottoJiliSerial != null && message.hasOwnProperty("LottoJiliSerial")) if (!$util.isString(message.LottoJiliSerial)) return "LottoJiliSerial: string expected";

              if (message.EndTime != null && message.hasOwnProperty("EndTime")) {
                var error = $root.google.protobuf.Timestamp.verify(message.EndTime);
                if (error) return "EndTime." + error;
              }

              if (message.DrawTime != null && message.hasOwnProperty("DrawTime")) {
                var error = $root.google.protobuf.Timestamp.verify(message.DrawTime);
                if (error) return "DrawTime." + error;
              }

              if (message.JiliDrawTime != null && message.hasOwnProperty("JiliDrawTime")) {
                var error = $root.google.protobuf.Timestamp.verify(message.JiliDrawTime);
                if (error) return "JiliDrawTime." + error;
              }

              if (message.DrawNumber != null && message.hasOwnProperty("DrawNumber")) {
                if (!Array.isArray(message.DrawNumber)) return "DrawNumber: array expected";

                for (var i = 0; i < message.DrawNumber.length; ++i) {
                  var error = $root.lottoProto.LotteryRewardNumber.verify(message.DrawNumber[i]);
                  if (error) return "DrawNumber." + error;
                }
              }

              if (message.TicketList != null && message.hasOwnProperty("TicketList")) {
                var error = $root.lottoProto.LotteryTicketList.verify(message.TicketList);
                if (error) return "TicketList." + error;
              }

              return null;
            };
            /**
             * Creates a LotteryInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lottoProto.LotteryInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lottoProto.LotteryInfo} LotteryInfo
             */


            LotteryInfo.fromObject = function fromObject(object) {
              if (object instanceof $root.lottoProto.LotteryInfo) return object;
              var message = new $root.lottoProto.LotteryInfo();
              if (object.LottoSerial != null) message.LottoSerial = object.LottoSerial | 0;
              if (object.LottoJiliSerial != null) message.LottoJiliSerial = String(object.LottoJiliSerial);

              if (object.EndTime != null) {
                if (typeof object.EndTime !== "object") throw TypeError(".lottoProto.LotteryInfo.EndTime: object expected");
                message.EndTime = $root.google.protobuf.Timestamp.fromObject(object.EndTime);
              }

              if (object.DrawTime != null) {
                if (typeof object.DrawTime !== "object") throw TypeError(".lottoProto.LotteryInfo.DrawTime: object expected");
                message.DrawTime = $root.google.protobuf.Timestamp.fromObject(object.DrawTime);
              }

              if (object.JiliDrawTime != null) {
                if (typeof object.JiliDrawTime !== "object") throw TypeError(".lottoProto.LotteryInfo.JiliDrawTime: object expected");
                message.JiliDrawTime = $root.google.protobuf.Timestamp.fromObject(object.JiliDrawTime);
              }

              if (object.DrawNumber) {
                if (!Array.isArray(object.DrawNumber)) throw TypeError(".lottoProto.LotteryInfo.DrawNumber: array expected");
                message.DrawNumber = [];

                for (var i = 0; i < object.DrawNumber.length; ++i) {
                  if (typeof object.DrawNumber[i] !== "object") throw TypeError(".lottoProto.LotteryInfo.DrawNumber: object expected");
                  message.DrawNumber[i] = $root.lottoProto.LotteryRewardNumber.fromObject(object.DrawNumber[i]);
                }
              }

              if (object.TicketList != null) {
                if (typeof object.TicketList !== "object") throw TypeError(".lottoProto.LotteryInfo.TicketList: object expected");
                message.TicketList = $root.lottoProto.LotteryTicketList.fromObject(object.TicketList);
              }

              return message;
            };
            /**
             * Creates a plain object from a LotteryInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lottoProto.LotteryInfo
             * @static
             * @param {lottoProto.LotteryInfo} message LotteryInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */


            LotteryInfo.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};
              if (options.arrays || options.defaults) object.DrawNumber = [];

              if (options.defaults) {
                object.LottoSerial = 0;
                object.LottoJiliSerial = "";
                object.EndTime = null;
                object.DrawTime = null;
                object.JiliDrawTime = null;
                object.TicketList = null;
              }

              if (message.LottoSerial != null && message.hasOwnProperty("LottoSerial")) object.LottoSerial = message.LottoSerial;
              if (message.LottoJiliSerial != null && message.hasOwnProperty("LottoJiliSerial")) object.LottoJiliSerial = message.LottoJiliSerial;
              if (message.EndTime != null && message.hasOwnProperty("EndTime")) object.EndTime = $root.google.protobuf.Timestamp.toObject(message.EndTime, options);
              if (message.DrawTime != null && message.hasOwnProperty("DrawTime")) object.DrawTime = $root.google.protobuf.Timestamp.toObject(message.DrawTime, options);
              if (message.JiliDrawTime != null && message.hasOwnProperty("JiliDrawTime")) object.JiliDrawTime = $root.google.protobuf.Timestamp.toObject(message.JiliDrawTime, options);

              if (message.DrawNumber && message.DrawNumber.length) {
                object.DrawNumber = [];

                for (var j = 0; j < message.DrawNumber.length; ++j) {
                  object.DrawNumber[j] = $root.lottoProto.LotteryRewardNumber.toObject(message.DrawNumber[j], options);
                }
              }

              if (message.TicketList != null && message.hasOwnProperty("TicketList")) object.TicketList = $root.lottoProto.LotteryTicketList.toObject(message.TicketList, options);
              return object;
            };
            /**
             * Converts this LotteryInfo to JSON.
             * @function toJSON
             * @memberof lottoProto.LotteryInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */


            LotteryInfo.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return LotteryInfo;
          }();

          lottoProto.LotteryRewardNumber = function () {
            /**
             * Properties of a LotteryRewardNumber.
             * @memberof lottoProto
             * @interface ILotteryRewardNumber
             * @property {lottoProto.AwardType|null} [Type] LotteryRewardNumber Type
             * @property {Array.<number>|null} [Number] LotteryRewardNumber Number
             */

            /**
             * Constructs a new LotteryRewardNumber.
             * @memberof lottoProto
             * @classdesc Represents a LotteryRewardNumber.
             * @implements ILotteryRewardNumber
             * @constructor
             * @param {lottoProto.ILotteryRewardNumber=} [properties] Properties to set
             */
            function LotteryRewardNumber(properties) {
              this.Number = [];
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * LotteryRewardNumber Type.
             * @member {lottoProto.AwardType} Type
             * @memberof lottoProto.LotteryRewardNumber
             * @instance
             */


            LotteryRewardNumber.prototype.Type = 0;
            /**
             * LotteryRewardNumber Number.
             * @member {Array.<number>} Number
             * @memberof lottoProto.LotteryRewardNumber
             * @instance
             */

            LotteryRewardNumber.prototype.Number = $util.emptyArray;
            /**
             * Creates a new LotteryRewardNumber instance using the specified properties.
             * @function create
             * @memberof lottoProto.LotteryRewardNumber
             * @static
             * @param {lottoProto.ILotteryRewardNumber=} [properties] Properties to set
             * @returns {lottoProto.LotteryRewardNumber} LotteryRewardNumber instance
             */

            LotteryRewardNumber.create = function create(properties) {
              return new LotteryRewardNumber(properties);
            };
            /**
             * Encodes the specified LotteryRewardNumber message. Does not implicitly {@link lottoProto.LotteryRewardNumber.verify|verify} messages.
             * @function encode
             * @memberof lottoProto.LotteryRewardNumber
             * @static
             * @param {lottoProto.ILotteryRewardNumber} message LotteryRewardNumber message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            LotteryRewardNumber.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.Type != null && Object.hasOwnProperty.call(message, "Type")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.Type);

              if (message.Number != null && message.Number.length) {
                writer.uint32(
                /* id 2, wireType 2 =*/
                18).fork();

                for (var i = 0; i < message.Number.length; ++i) {
                  writer.int32(message.Number[i]);
                }

                writer.ldelim();
              }

              return writer;
            };
            /**
             * Encodes the specified LotteryRewardNumber message, length delimited. Does not implicitly {@link lottoProto.LotteryRewardNumber.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lottoProto.LotteryRewardNumber
             * @static
             * @param {lottoProto.ILotteryRewardNumber} message LotteryRewardNumber message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            LotteryRewardNumber.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a LotteryRewardNumber message from the specified reader or buffer.
             * @function decode
             * @memberof lottoProto.LotteryRewardNumber
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lottoProto.LotteryRewardNumber} LotteryRewardNumber
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            LotteryRewardNumber.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.lottoProto.LotteryRewardNumber();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.Type = reader.int32();
                    break;

                  case 2:
                    if (!(message.Number && message.Number.length)) message.Number = [];

                    if ((tag & 7) === 2) {
                      var end2 = reader.uint32() + reader.pos;

                      while (reader.pos < end2) {
                        message.Number.push(reader.int32());
                      }
                    } else message.Number.push(reader.int32());

                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
             * Decodes a LotteryRewardNumber message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lottoProto.LotteryRewardNumber
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lottoProto.LotteryRewardNumber} LotteryRewardNumber
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            LotteryRewardNumber.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a LotteryRewardNumber message.
             * @function verify
             * @memberof lottoProto.LotteryRewardNumber
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */


            LotteryRewardNumber.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.Type != null && message.hasOwnProperty("Type")) switch (message.Type) {
                default:
                  return "Type: enum value expected";

                case 0:
                case 1:
                case 2:
                case 4:
                case 8:
                case 16:
                  break;
              }

              if (message.Number != null && message.hasOwnProperty("Number")) {
                if (!Array.isArray(message.Number)) return "Number: array expected";

                for (var i = 0; i < message.Number.length; ++i) {
                  if (!$util.isInteger(message.Number[i])) return "Number: integer[] expected";
                }
              }

              return null;
            };
            /**
             * Creates a LotteryRewardNumber message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lottoProto.LotteryRewardNumber
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lottoProto.LotteryRewardNumber} LotteryRewardNumber
             */


            LotteryRewardNumber.fromObject = function fromObject(object) {
              if (object instanceof $root.lottoProto.LotteryRewardNumber) return object;
              var message = new $root.lottoProto.LotteryRewardNumber();

              switch (object.Type) {
                case "ZERO":
                case 0:
                  message.Type = 0;
                  break;

                case "LastTwo":
                case 1:
                  message.Type = 1;
                  break;

                case "LastThree":
                case 2:
                  message.Type = 2;
                  break;

                case "FirstThree":
                case 4:
                  message.Type = 4;
                  break;

                case "Special":
                case 8:
                  message.Type = 8;
                  break;

                case "First":
                case 16:
                  message.Type = 16;
                  break;
              }

              if (object.Number) {
                if (!Array.isArray(object.Number)) throw TypeError(".lottoProto.LotteryRewardNumber.Number: array expected");
                message.Number = [];

                for (var i = 0; i < object.Number.length; ++i) {
                  message.Number[i] = object.Number[i] | 0;
                }
              }

              return message;
            };
            /**
             * Creates a plain object from a LotteryRewardNumber message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lottoProto.LotteryRewardNumber
             * @static
             * @param {lottoProto.LotteryRewardNumber} message LotteryRewardNumber
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */


            LotteryRewardNumber.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};
              if (options.arrays || options.defaults) object.Number = [];
              if (options.defaults) object.Type = options.enums === String ? "ZERO" : 0;
              if (message.Type != null && message.hasOwnProperty("Type")) object.Type = options.enums === String ? $root.lottoProto.AwardType[message.Type] : message.Type;

              if (message.Number && message.Number.length) {
                object.Number = [];

                for (var j = 0; j < message.Number.length; ++j) {
                  object.Number[j] = message.Number[j];
                }
              }

              return object;
            };
            /**
             * Converts this LotteryRewardNumber to JSON.
             * @function toJSON
             * @memberof lottoProto.LotteryRewardNumber
             * @instance
             * @returns {Object.<string,*>} JSON object
             */


            LotteryRewardNumber.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return LotteryRewardNumber;
          }();
          /**
           * LotteryType enum.
           * @name lottoProto.LotteryType
           * @enum {number}
           * @property {number} None=0 None value
           * @property {number} Thai=1 Thai value
           * @property {number} ThaiJili=2 ThaiJili value
           * @property {number} Mala=3 Mala value
           */


          lottoProto.LotteryType = function () {
            var valuesById = {},
                values = Object.create(valuesById);
            values[valuesById[0] = "None"] = 0;
            values[valuesById[1] = "Thai"] = 1;
            values[valuesById[2] = "ThaiJili"] = 2;
            values[valuesById[3] = "Mala"] = 3;
            return values;
          }();
          /**
           * RewardType enum.
           * @name lottoProto.RewardType
           * @enum {number}
           * @property {number} NoReward=0 NoReward value
           * @property {number} Coin=1 Coin value
           * @property {number} SlotItem=2 SlotItem value
           * @property {number} FishSkin=3 FishSkin value
           * @property {number} FishItem=5 FishItem value
           * @property {number} Rubby=6 Rubby value
           */


          lottoProto.RewardType = function () {
            var valuesById = {},
                values = Object.create(valuesById);
            values[valuesById[0] = "NoReward"] = 0;
            values[valuesById[1] = "Coin"] = 1;
            values[valuesById[2] = "SlotItem"] = 2;
            values[valuesById[3] = "FishSkin"] = 3;
            values[valuesById[5] = "FishItem"] = 5;
            values[valuesById[6] = "Rubby"] = 6;
            return values;
          }();

          lottoProto.LottoLogReq = function () {
            /**
             * Properties of a LottoLogReq.
             * @memberof lottoProto
             * @interface ILottoLogReq
             * @property {number|null} [LottoSerial] LottoLogReq LottoSerial
             */

            /**
             * Constructs a new LottoLogReq.
             * @memberof lottoProto
             * @classdesc Represents a LottoLogReq.
             * @implements ILottoLogReq
             * @constructor
             * @param {lottoProto.ILottoLogReq=} [properties] Properties to set
             */
            function LottoLogReq(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * LottoLogReq LottoSerial.
             * @member {number} LottoSerial
             * @memberof lottoProto.LottoLogReq
             * @instance
             */


            LottoLogReq.prototype.LottoSerial = 0;
            /**
             * Creates a new LottoLogReq instance using the specified properties.
             * @function create
             * @memberof lottoProto.LottoLogReq
             * @static
             * @param {lottoProto.ILottoLogReq=} [properties] Properties to set
             * @returns {lottoProto.LottoLogReq} LottoLogReq instance
             */

            LottoLogReq.create = function create(properties) {
              return new LottoLogReq(properties);
            };
            /**
             * Encodes the specified LottoLogReq message. Does not implicitly {@link lottoProto.LottoLogReq.verify|verify} messages.
             * @function encode
             * @memberof lottoProto.LottoLogReq
             * @static
             * @param {lottoProto.ILottoLogReq} message LottoLogReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            LottoLogReq.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.LottoSerial != null && Object.hasOwnProperty.call(message, "LottoSerial")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.LottoSerial);
              return writer;
            };
            /**
             * Encodes the specified LottoLogReq message, length delimited. Does not implicitly {@link lottoProto.LottoLogReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lottoProto.LottoLogReq
             * @static
             * @param {lottoProto.ILottoLogReq} message LottoLogReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            LottoLogReq.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a LottoLogReq message from the specified reader or buffer.
             * @function decode
             * @memberof lottoProto.LottoLogReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lottoProto.LottoLogReq} LottoLogReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            LottoLogReq.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.lottoProto.LottoLogReq();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.LottoSerial = reader.int32();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
             * Decodes a LottoLogReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lottoProto.LottoLogReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lottoProto.LottoLogReq} LottoLogReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            LottoLogReq.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a LottoLogReq message.
             * @function verify
             * @memberof lottoProto.LottoLogReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */


            LottoLogReq.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.LottoSerial != null && message.hasOwnProperty("LottoSerial")) if (!$util.isInteger(message.LottoSerial)) return "LottoSerial: integer expected";
              return null;
            };
            /**
             * Creates a LottoLogReq message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lottoProto.LottoLogReq
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lottoProto.LottoLogReq} LottoLogReq
             */


            LottoLogReq.fromObject = function fromObject(object) {
              if (object instanceof $root.lottoProto.LottoLogReq) return object;
              var message = new $root.lottoProto.LottoLogReq();
              if (object.LottoSerial != null) message.LottoSerial = object.LottoSerial | 0;
              return message;
            };
            /**
             * Creates a plain object from a LottoLogReq message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lottoProto.LottoLogReq
             * @static
             * @param {lottoProto.LottoLogReq} message LottoLogReq
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */


            LottoLogReq.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};
              if (options.defaults) object.LottoSerial = 0;
              if (message.LottoSerial != null && message.hasOwnProperty("LottoSerial")) object.LottoSerial = message.LottoSerial;
              return object;
            };
            /**
             * Converts this LottoLogReq to JSON.
             * @function toJSON
             * @memberof lottoProto.LottoLogReq
             * @instance
             * @returns {Object.<string,*>} JSON object
             */


            LottoLogReq.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return LottoLogReq;
          }();

          lottoProto.LotteryTicketList = function () {
            /**
             * Properties of a LotteryTicketList.
             * @memberof lottoProto
             * @interface ILotteryTicketList
             * @property {Array.<lottoProto.ILotteryTicket>|null} [Lotterys] LotteryTicketList Lotterys
             */

            /**
             * Constructs a new LotteryTicketList.
             * @memberof lottoProto
             * @classdesc Represents a LotteryTicketList.
             * @implements ILotteryTicketList
             * @constructor
             * @param {lottoProto.ILotteryTicketList=} [properties] Properties to set
             */
            function LotteryTicketList(properties) {
              this.Lotterys = [];
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * LotteryTicketList Lotterys.
             * @member {Array.<lottoProto.ILotteryTicket>} Lotterys
             * @memberof lottoProto.LotteryTicketList
             * @instance
             */


            LotteryTicketList.prototype.Lotterys = $util.emptyArray;
            /**
             * Creates a new LotteryTicketList instance using the specified properties.
             * @function create
             * @memberof lottoProto.LotteryTicketList
             * @static
             * @param {lottoProto.ILotteryTicketList=} [properties] Properties to set
             * @returns {lottoProto.LotteryTicketList} LotteryTicketList instance
             */

            LotteryTicketList.create = function create(properties) {
              return new LotteryTicketList(properties);
            };
            /**
             * Encodes the specified LotteryTicketList message. Does not implicitly {@link lottoProto.LotteryTicketList.verify|verify} messages.
             * @function encode
             * @memberof lottoProto.LotteryTicketList
             * @static
             * @param {lottoProto.ILotteryTicketList} message LotteryTicketList message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            LotteryTicketList.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.Lotterys != null && message.Lotterys.length) for (var i = 0; i < message.Lotterys.length; ++i) {
                $root.lottoProto.LotteryTicket.encode(message.Lotterys[i], writer.uint32(
                /* id 1, wireType 2 =*/
                10).fork()).ldelim();
              }
              return writer;
            };
            /**
             * Encodes the specified LotteryTicketList message, length delimited. Does not implicitly {@link lottoProto.LotteryTicketList.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lottoProto.LotteryTicketList
             * @static
             * @param {lottoProto.ILotteryTicketList} message LotteryTicketList message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            LotteryTicketList.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a LotteryTicketList message from the specified reader or buffer.
             * @function decode
             * @memberof lottoProto.LotteryTicketList
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lottoProto.LotteryTicketList} LotteryTicketList
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            LotteryTicketList.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.lottoProto.LotteryTicketList();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    if (!(message.Lotterys && message.Lotterys.length)) message.Lotterys = [];
                    message.Lotterys.push($root.lottoProto.LotteryTicket.decode(reader, reader.uint32()));
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
             * Decodes a LotteryTicketList message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lottoProto.LotteryTicketList
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lottoProto.LotteryTicketList} LotteryTicketList
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            LotteryTicketList.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a LotteryTicketList message.
             * @function verify
             * @memberof lottoProto.LotteryTicketList
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */


            LotteryTicketList.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";

              if (message.Lotterys != null && message.hasOwnProperty("Lotterys")) {
                if (!Array.isArray(message.Lotterys)) return "Lotterys: array expected";

                for (var i = 0; i < message.Lotterys.length; ++i) {
                  var error = $root.lottoProto.LotteryTicket.verify(message.Lotterys[i]);
                  if (error) return "Lotterys." + error;
                }
              }

              return null;
            };
            /**
             * Creates a LotteryTicketList message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lottoProto.LotteryTicketList
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lottoProto.LotteryTicketList} LotteryTicketList
             */


            LotteryTicketList.fromObject = function fromObject(object) {
              if (object instanceof $root.lottoProto.LotteryTicketList) return object;
              var message = new $root.lottoProto.LotteryTicketList();

              if (object.Lotterys) {
                if (!Array.isArray(object.Lotterys)) throw TypeError(".lottoProto.LotteryTicketList.Lotterys: array expected");
                message.Lotterys = [];

                for (var i = 0; i < object.Lotterys.length; ++i) {
                  if (typeof object.Lotterys[i] !== "object") throw TypeError(".lottoProto.LotteryTicketList.Lotterys: object expected");
                  message.Lotterys[i] = $root.lottoProto.LotteryTicket.fromObject(object.Lotterys[i]);
                }
              }

              return message;
            };
            /**
             * Creates a plain object from a LotteryTicketList message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lottoProto.LotteryTicketList
             * @static
             * @param {lottoProto.LotteryTicketList} message LotteryTicketList
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */


            LotteryTicketList.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};
              if (options.arrays || options.defaults) object.Lotterys = [];

              if (message.Lotterys && message.Lotterys.length) {
                object.Lotterys = [];

                for (var j = 0; j < message.Lotterys.length; ++j) {
                  object.Lotterys[j] = $root.lottoProto.LotteryTicket.toObject(message.Lotterys[j], options);
                }
              }

              return object;
            };
            /**
             * Converts this LotteryTicketList to JSON.
             * @function toJSON
             * @memberof lottoProto.LotteryTicketList
             * @instance
             * @returns {Object.<string,*>} JSON object
             */


            LotteryTicketList.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return LotteryTicketList;
          }();

          lottoProto.LotteryTicket = function () {
            /**
             * Properties of a LotteryTicket.
             * @memberof lottoProto
             * @interface ILotteryTicket
             * @property {number|null} [LottoSerial] LotteryTicket LottoSerial
             * @property {string|null} [LottoJiliSerial] LotteryTicket LottoJiliSerial
             * @property {number|null} [LotterySet] LotteryTicket LotterySet
             * @property {number|null} [LotteryNumber] LotteryTicket LotteryNumber
             * @property {google.protobuf.ITimestamp|null} [GetTime] LotteryTicket GetTime
             */

            /**
             * Constructs a new LotteryTicket.
             * @memberof lottoProto
             * @classdesc Represents a LotteryTicket.
             * @implements ILotteryTicket
             * @constructor
             * @param {lottoProto.ILotteryTicket=} [properties] Properties to set
             */
            function LotteryTicket(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * LotteryTicket LottoSerial.
             * @member {number} LottoSerial
             * @memberof lottoProto.LotteryTicket
             * @instance
             */


            LotteryTicket.prototype.LottoSerial = 0;
            /**
             * LotteryTicket LottoJiliSerial.
             * @member {string} LottoJiliSerial
             * @memberof lottoProto.LotteryTicket
             * @instance
             */

            LotteryTicket.prototype.LottoJiliSerial = "";
            /**
             * LotteryTicket LotterySet.
             * @member {number} LotterySet
             * @memberof lottoProto.LotteryTicket
             * @instance
             */

            LotteryTicket.prototype.LotterySet = 0;
            /**
             * LotteryTicket LotteryNumber.
             * @member {number} LotteryNumber
             * @memberof lottoProto.LotteryTicket
             * @instance
             */

            LotteryTicket.prototype.LotteryNumber = 0;
            /**
             * LotteryTicket GetTime.
             * @member {google.protobuf.ITimestamp|null|undefined} GetTime
             * @memberof lottoProto.LotteryTicket
             * @instance
             */

            LotteryTicket.prototype.GetTime = null;
            /**
             * Creates a new LotteryTicket instance using the specified properties.
             * @function create
             * @memberof lottoProto.LotteryTicket
             * @static
             * @param {lottoProto.ILotteryTicket=} [properties] Properties to set
             * @returns {lottoProto.LotteryTicket} LotteryTicket instance
             */

            LotteryTicket.create = function create(properties) {
              return new LotteryTicket(properties);
            };
            /**
             * Encodes the specified LotteryTicket message. Does not implicitly {@link lottoProto.LotteryTicket.verify|verify} messages.
             * @function encode
             * @memberof lottoProto.LotteryTicket
             * @static
             * @param {lottoProto.ILotteryTicket} message LotteryTicket message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            LotteryTicket.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.LottoSerial != null && Object.hasOwnProperty.call(message, "LottoSerial")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.LottoSerial);
              if (message.LottoJiliSerial != null && Object.hasOwnProperty.call(message, "LottoJiliSerial")) writer.uint32(
              /* id 2, wireType 2 =*/
              18).string(message.LottoJiliSerial);
              if (message.LotterySet != null && Object.hasOwnProperty.call(message, "LotterySet")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.LotterySet);
              if (message.LotteryNumber != null && Object.hasOwnProperty.call(message, "LotteryNumber")) writer.uint32(
              /* id 4, wireType 0 =*/
              32).int32(message.LotteryNumber);
              if (message.GetTime != null && Object.hasOwnProperty.call(message, "GetTime")) $root.google.protobuf.Timestamp.encode(message.GetTime, writer.uint32(
              /* id 6, wireType 2 =*/
              50).fork()).ldelim();
              return writer;
            };
            /**
             * Encodes the specified LotteryTicket message, length delimited. Does not implicitly {@link lottoProto.LotteryTicket.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lottoProto.LotteryTicket
             * @static
             * @param {lottoProto.ILotteryTicket} message LotteryTicket message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            LotteryTicket.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a LotteryTicket message from the specified reader or buffer.
             * @function decode
             * @memberof lottoProto.LotteryTicket
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lottoProto.LotteryTicket} LotteryTicket
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            LotteryTicket.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.lottoProto.LotteryTicket();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.LottoSerial = reader.int32();
                    break;

                  case 2:
                    message.LottoJiliSerial = reader.string();
                    break;

                  case 3:
                    message.LotterySet = reader.int32();
                    break;

                  case 4:
                    message.LotteryNumber = reader.int32();
                    break;

                  case 6:
                    message.GetTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
             * Decodes a LotteryTicket message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lottoProto.LotteryTicket
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lottoProto.LotteryTicket} LotteryTicket
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            LotteryTicket.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a LotteryTicket message.
             * @function verify
             * @memberof lottoProto.LotteryTicket
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */


            LotteryTicket.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.LottoSerial != null && message.hasOwnProperty("LottoSerial")) if (!$util.isInteger(message.LottoSerial)) return "LottoSerial: integer expected";
              if (message.LottoJiliSerial != null && message.hasOwnProperty("LottoJiliSerial")) if (!$util.isString(message.LottoJiliSerial)) return "LottoJiliSerial: string expected";
              if (message.LotterySet != null && message.hasOwnProperty("LotterySet")) if (!$util.isInteger(message.LotterySet)) return "LotterySet: integer expected";
              if (message.LotteryNumber != null && message.hasOwnProperty("LotteryNumber")) if (!$util.isInteger(message.LotteryNumber)) return "LotteryNumber: integer expected";

              if (message.GetTime != null && message.hasOwnProperty("GetTime")) {
                var error = $root.google.protobuf.Timestamp.verify(message.GetTime);
                if (error) return "GetTime." + error;
              }

              return null;
            };
            /**
             * Creates a LotteryTicket message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lottoProto.LotteryTicket
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lottoProto.LotteryTicket} LotteryTicket
             */


            LotteryTicket.fromObject = function fromObject(object) {
              if (object instanceof $root.lottoProto.LotteryTicket) return object;
              var message = new $root.lottoProto.LotteryTicket();
              if (object.LottoSerial != null) message.LottoSerial = object.LottoSerial | 0;
              if (object.LottoJiliSerial != null) message.LottoJiliSerial = String(object.LottoJiliSerial);
              if (object.LotterySet != null) message.LotterySet = object.LotterySet | 0;
              if (object.LotteryNumber != null) message.LotteryNumber = object.LotteryNumber | 0;

              if (object.GetTime != null) {
                if (typeof object.GetTime !== "object") throw TypeError(".lottoProto.LotteryTicket.GetTime: object expected");
                message.GetTime = $root.google.protobuf.Timestamp.fromObject(object.GetTime);
              }

              return message;
            };
            /**
             * Creates a plain object from a LotteryTicket message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lottoProto.LotteryTicket
             * @static
             * @param {lottoProto.LotteryTicket} message LotteryTicket
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */


            LotteryTicket.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.LottoSerial = 0;
                object.LottoJiliSerial = "";
                object.LotterySet = 0;
                object.LotteryNumber = 0;
                object.GetTime = null;
              }

              if (message.LottoSerial != null && message.hasOwnProperty("LottoSerial")) object.LottoSerial = message.LottoSerial;
              if (message.LottoJiliSerial != null && message.hasOwnProperty("LottoJiliSerial")) object.LottoJiliSerial = message.LottoJiliSerial;
              if (message.LotterySet != null && message.hasOwnProperty("LotterySet")) object.LotterySet = message.LotterySet;
              if (message.LotteryNumber != null && message.hasOwnProperty("LotteryNumber")) object.LotteryNumber = message.LotteryNumber;
              if (message.GetTime != null && message.hasOwnProperty("GetTime")) object.GetTime = $root.google.protobuf.Timestamp.toObject(message.GetTime, options);
              return object;
            };
            /**
             * Converts this LotteryTicket to JSON.
             * @function toJSON
             * @memberof lottoProto.LotteryTicket
             * @instance
             * @returns {Object.<string,*>} JSON object
             */


            LotteryTicket.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return LotteryTicket;
          }();

          lottoProto.LotteryRewardList = function () {
            /**
             * Properties of a LotteryRewardList.
             * @memberof lottoProto
             * @interface ILotteryRewardList
             * @property {Array.<lottoProto.ILotteryReward>|null} [Lotterys] LotteryRewardList Lotterys
             */

            /**
             * Constructs a new LotteryRewardList.
             * @memberof lottoProto
             * @classdesc Represents a LotteryRewardList.
             * @implements ILotteryRewardList
             * @constructor
             * @param {lottoProto.ILotteryRewardList=} [properties] Properties to set
             */
            function LotteryRewardList(properties) {
              this.Lotterys = [];
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * LotteryRewardList Lotterys.
             * @member {Array.<lottoProto.ILotteryReward>} Lotterys
             * @memberof lottoProto.LotteryRewardList
             * @instance
             */


            LotteryRewardList.prototype.Lotterys = $util.emptyArray;
            /**
             * Creates a new LotteryRewardList instance using the specified properties.
             * @function create
             * @memberof lottoProto.LotteryRewardList
             * @static
             * @param {lottoProto.ILotteryRewardList=} [properties] Properties to set
             * @returns {lottoProto.LotteryRewardList} LotteryRewardList instance
             */

            LotteryRewardList.create = function create(properties) {
              return new LotteryRewardList(properties);
            };
            /**
             * Encodes the specified LotteryRewardList message. Does not implicitly {@link lottoProto.LotteryRewardList.verify|verify} messages.
             * @function encode
             * @memberof lottoProto.LotteryRewardList
             * @static
             * @param {lottoProto.ILotteryRewardList} message LotteryRewardList message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            LotteryRewardList.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.Lotterys != null && message.Lotterys.length) for (var i = 0; i < message.Lotterys.length; ++i) {
                $root.lottoProto.LotteryReward.encode(message.Lotterys[i], writer.uint32(
                /* id 1, wireType 2 =*/
                10).fork()).ldelim();
              }
              return writer;
            };
            /**
             * Encodes the specified LotteryRewardList message, length delimited. Does not implicitly {@link lottoProto.LotteryRewardList.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lottoProto.LotteryRewardList
             * @static
             * @param {lottoProto.ILotteryRewardList} message LotteryRewardList message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            LotteryRewardList.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a LotteryRewardList message from the specified reader or buffer.
             * @function decode
             * @memberof lottoProto.LotteryRewardList
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lottoProto.LotteryRewardList} LotteryRewardList
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            LotteryRewardList.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.lottoProto.LotteryRewardList();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    if (!(message.Lotterys && message.Lotterys.length)) message.Lotterys = [];
                    message.Lotterys.push($root.lottoProto.LotteryReward.decode(reader, reader.uint32()));
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
             * Decodes a LotteryRewardList message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lottoProto.LotteryRewardList
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lottoProto.LotteryRewardList} LotteryRewardList
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            LotteryRewardList.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a LotteryRewardList message.
             * @function verify
             * @memberof lottoProto.LotteryRewardList
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */


            LotteryRewardList.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";

              if (message.Lotterys != null && message.hasOwnProperty("Lotterys")) {
                if (!Array.isArray(message.Lotterys)) return "Lotterys: array expected";

                for (var i = 0; i < message.Lotterys.length; ++i) {
                  var error = $root.lottoProto.LotteryReward.verify(message.Lotterys[i]);
                  if (error) return "Lotterys." + error;
                }
              }

              return null;
            };
            /**
             * Creates a LotteryRewardList message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lottoProto.LotteryRewardList
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lottoProto.LotteryRewardList} LotteryRewardList
             */


            LotteryRewardList.fromObject = function fromObject(object) {
              if (object instanceof $root.lottoProto.LotteryRewardList) return object;
              var message = new $root.lottoProto.LotteryRewardList();

              if (object.Lotterys) {
                if (!Array.isArray(object.Lotterys)) throw TypeError(".lottoProto.LotteryRewardList.Lotterys: array expected");
                message.Lotterys = [];

                for (var i = 0; i < object.Lotterys.length; ++i) {
                  if (typeof object.Lotterys[i] !== "object") throw TypeError(".lottoProto.LotteryRewardList.Lotterys: object expected");
                  message.Lotterys[i] = $root.lottoProto.LotteryReward.fromObject(object.Lotterys[i]);
                }
              }

              return message;
            };
            /**
             * Creates a plain object from a LotteryRewardList message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lottoProto.LotteryRewardList
             * @static
             * @param {lottoProto.LotteryRewardList} message LotteryRewardList
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */


            LotteryRewardList.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};
              if (options.arrays || options.defaults) object.Lotterys = [];

              if (message.Lotterys && message.Lotterys.length) {
                object.Lotterys = [];

                for (var j = 0; j < message.Lotterys.length; ++j) {
                  object.Lotterys[j] = $root.lottoProto.LotteryReward.toObject(message.Lotterys[j], options);
                }
              }

              return object;
            };
            /**
             * Converts this LotteryRewardList to JSON.
             * @function toJSON
             * @memberof lottoProto.LotteryRewardList
             * @instance
             * @returns {Object.<string,*>} JSON object
             */


            LotteryRewardList.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return LotteryRewardList;
          }();
          /**
           * AwardType enum.
           * @name lottoProto.AwardType
           * @enum {number}
           * @property {number} ZERO=0 ZERO value
           * @property {number} LastTwo=1 LastTwo value
           * @property {number} LastThree=2 LastThree value
           * @property {number} FirstThree=4 FirstThree value
           * @property {number} Special=8 Special value
           * @property {number} First=16 First value
           */


          lottoProto.AwardType = function () {
            var valuesById = {},
                values = Object.create(valuesById);
            values[valuesById[0] = "ZERO"] = 0;
            values[valuesById[1] = "LastTwo"] = 1;
            values[valuesById[2] = "LastThree"] = 2;
            values[valuesById[4] = "FirstThree"] = 4;
            values[valuesById[8] = "Special"] = 8;
            values[valuesById[16] = "First"] = 16;
            return values;
          }();

          lottoProto.LotteryReward = function () {
            /**
             * Properties of a LotteryReward.
             * @memberof lottoProto
             * @interface ILotteryReward
             * @property {number|null} [LottoSerial] LotteryReward LottoSerial
             * @property {string|null} [LottoJiliSerial] LotteryReward LottoJiliSerial
             * @property {number|null} [LotteryNumber] LotteryReward LotteryNumber
             * @property {lottoProto.AwardType|null} [AwardType] LotteryReward AwardType
             * @property {number|null} [Reward] LotteryReward Reward
             * @property {lottoProto.RewardType|null} [RewardType] LotteryReward RewardType
             */

            /**
             * Constructs a new LotteryReward.
             * @memberof lottoProto
             * @classdesc Represents a LotteryReward.
             * @implements ILotteryReward
             * @constructor
             * @param {lottoProto.ILotteryReward=} [properties] Properties to set
             */
            function LotteryReward(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * LotteryReward LottoSerial.
             * @member {number} LottoSerial
             * @memberof lottoProto.LotteryReward
             * @instance
             */


            LotteryReward.prototype.LottoSerial = 0;
            /**
             * LotteryReward LottoJiliSerial.
             * @member {string} LottoJiliSerial
             * @memberof lottoProto.LotteryReward
             * @instance
             */

            LotteryReward.prototype.LottoJiliSerial = "";
            /**
             * LotteryReward LotteryNumber.
             * @member {number} LotteryNumber
             * @memberof lottoProto.LotteryReward
             * @instance
             */

            LotteryReward.prototype.LotteryNumber = 0;
            /**
             * LotteryReward AwardType.
             * @member {lottoProto.AwardType} AwardType
             * @memberof lottoProto.LotteryReward
             * @instance
             */

            LotteryReward.prototype.AwardType = 0;
            /**
             * LotteryReward Reward.
             * @member {number} Reward
             * @memberof lottoProto.LotteryReward
             * @instance
             */

            LotteryReward.prototype.Reward = 0;
            /**
             * LotteryReward RewardType.
             * @member {lottoProto.RewardType} RewardType
             * @memberof lottoProto.LotteryReward
             * @instance
             */

            LotteryReward.prototype.RewardType = 0;
            /**
             * Creates a new LotteryReward instance using the specified properties.
             * @function create
             * @memberof lottoProto.LotteryReward
             * @static
             * @param {lottoProto.ILotteryReward=} [properties] Properties to set
             * @returns {lottoProto.LotteryReward} LotteryReward instance
             */

            LotteryReward.create = function create(properties) {
              return new LotteryReward(properties);
            };
            /**
             * Encodes the specified LotteryReward message. Does not implicitly {@link lottoProto.LotteryReward.verify|verify} messages.
             * @function encode
             * @memberof lottoProto.LotteryReward
             * @static
             * @param {lottoProto.ILotteryReward} message LotteryReward message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            LotteryReward.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.LottoSerial != null && Object.hasOwnProperty.call(message, "LottoSerial")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.LottoSerial);
              if (message.LottoJiliSerial != null && Object.hasOwnProperty.call(message, "LottoJiliSerial")) writer.uint32(
              /* id 2, wireType 2 =*/
              18).string(message.LottoJiliSerial);
              if (message.LotteryNumber != null && Object.hasOwnProperty.call(message, "LotteryNumber")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.LotteryNumber);
              if (message.AwardType != null && Object.hasOwnProperty.call(message, "AwardType")) writer.uint32(
              /* id 4, wireType 0 =*/
              32).int32(message.AwardType);
              if (message.Reward != null && Object.hasOwnProperty.call(message, "Reward")) writer.uint32(
              /* id 5, wireType 1 =*/
              41)["double"](message.Reward);
              if (message.RewardType != null && Object.hasOwnProperty.call(message, "RewardType")) writer.uint32(
              /* id 6, wireType 0 =*/
              48).int32(message.RewardType);
              return writer;
            };
            /**
             * Encodes the specified LotteryReward message, length delimited. Does not implicitly {@link lottoProto.LotteryReward.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lottoProto.LotteryReward
             * @static
             * @param {lottoProto.ILotteryReward} message LotteryReward message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            LotteryReward.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a LotteryReward message from the specified reader or buffer.
             * @function decode
             * @memberof lottoProto.LotteryReward
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lottoProto.LotteryReward} LotteryReward
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            LotteryReward.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.lottoProto.LotteryReward();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.LottoSerial = reader.int32();
                    break;

                  case 2:
                    message.LottoJiliSerial = reader.string();
                    break;

                  case 3:
                    message.LotteryNumber = reader.int32();
                    break;

                  case 4:
                    message.AwardType = reader.int32();
                    break;

                  case 5:
                    message.Reward = reader["double"]();
                    break;

                  case 6:
                    message.RewardType = reader.int32();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
             * Decodes a LotteryReward message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lottoProto.LotteryReward
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lottoProto.LotteryReward} LotteryReward
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            LotteryReward.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a LotteryReward message.
             * @function verify
             * @memberof lottoProto.LotteryReward
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */


            LotteryReward.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.LottoSerial != null && message.hasOwnProperty("LottoSerial")) if (!$util.isInteger(message.LottoSerial)) return "LottoSerial: integer expected";
              if (message.LottoJiliSerial != null && message.hasOwnProperty("LottoJiliSerial")) if (!$util.isString(message.LottoJiliSerial)) return "LottoJiliSerial: string expected";
              if (message.LotteryNumber != null && message.hasOwnProperty("LotteryNumber")) if (!$util.isInteger(message.LotteryNumber)) return "LotteryNumber: integer expected";
              if (message.AwardType != null && message.hasOwnProperty("AwardType")) switch (message.AwardType) {
                default:
                  return "AwardType: enum value expected";

                case 0:
                case 1:
                case 2:
                case 4:
                case 8:
                case 16:
                  break;
              }
              if (message.Reward != null && message.hasOwnProperty("Reward")) if (typeof message.Reward !== "number") return "Reward: number expected";
              if (message.RewardType != null && message.hasOwnProperty("RewardType")) switch (message.RewardType) {
                default:
                  return "RewardType: enum value expected";

                case 0:
                case 1:
                case 2:
                case 3:
                case 5:
                case 6:
                  break;
              }
              return null;
            };
            /**
             * Creates a LotteryReward message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lottoProto.LotteryReward
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lottoProto.LotteryReward} LotteryReward
             */


            LotteryReward.fromObject = function fromObject(object) {
              if (object instanceof $root.lottoProto.LotteryReward) return object;
              var message = new $root.lottoProto.LotteryReward();
              if (object.LottoSerial != null) message.LottoSerial = object.LottoSerial | 0;
              if (object.LottoJiliSerial != null) message.LottoJiliSerial = String(object.LottoJiliSerial);
              if (object.LotteryNumber != null) message.LotteryNumber = object.LotteryNumber | 0;

              switch (object.AwardType) {
                case "ZERO":
                case 0:
                  message.AwardType = 0;
                  break;

                case "LastTwo":
                case 1:
                  message.AwardType = 1;
                  break;

                case "LastThree":
                case 2:
                  message.AwardType = 2;
                  break;

                case "FirstThree":
                case 4:
                  message.AwardType = 4;
                  break;

                case "Special":
                case 8:
                  message.AwardType = 8;
                  break;

                case "First":
                case 16:
                  message.AwardType = 16;
                  break;
              }

              if (object.Reward != null) message.Reward = Number(object.Reward);

              switch (object.RewardType) {
                case "NoReward":
                case 0:
                  message.RewardType = 0;
                  break;

                case "Coin":
                case 1:
                  message.RewardType = 1;
                  break;

                case "SlotItem":
                case 2:
                  message.RewardType = 2;
                  break;

                case "FishSkin":
                case 3:
                  message.RewardType = 3;
                  break;

                case "FishItem":
                case 5:
                  message.RewardType = 5;
                  break;

                case "Rubby":
                case 6:
                  message.RewardType = 6;
                  break;
              }

              return message;
            };
            /**
             * Creates a plain object from a LotteryReward message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lottoProto.LotteryReward
             * @static
             * @param {lottoProto.LotteryReward} message LotteryReward
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */


            LotteryReward.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.LottoSerial = 0;
                object.LottoJiliSerial = "";
                object.LotteryNumber = 0;
                object.AwardType = options.enums === String ? "ZERO" : 0;
                object.Reward = 0;
                object.RewardType = options.enums === String ? "NoReward" : 0;
              }

              if (message.LottoSerial != null && message.hasOwnProperty("LottoSerial")) object.LottoSerial = message.LottoSerial;
              if (message.LottoJiliSerial != null && message.hasOwnProperty("LottoJiliSerial")) object.LottoJiliSerial = message.LottoJiliSerial;
              if (message.LotteryNumber != null && message.hasOwnProperty("LotteryNumber")) object.LotteryNumber = message.LotteryNumber;
              if (message.AwardType != null && message.hasOwnProperty("AwardType")) object.AwardType = options.enums === String ? $root.lottoProto.AwardType[message.AwardType] : message.AwardType;
              if (message.Reward != null && message.hasOwnProperty("Reward")) object.Reward = options.json && !isFinite(message.Reward) ? String(message.Reward) : message.Reward;
              if (message.RewardType != null && message.hasOwnProperty("RewardType")) object.RewardType = options.enums === String ? $root.lottoProto.RewardType[message.RewardType] : message.RewardType;
              return object;
            };
            /**
             * Converts this LotteryReward to JSON.
             * @function toJSON
             * @memberof lottoProto.LotteryReward
             * @instance
             * @returns {Object.<string,*>} JSON object
             */


            LotteryReward.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return LotteryReward;
          }();

          lottoProto.LotteryPlayer = function () {
            /**
             * Properties of a LotteryPlayer.
             * @memberof lottoProto
             * @interface ILotteryPlayer
             * @property {lottoProto.LotteryType|null} [Type] LotteryPlayer Type
             * @property {number|null} [BetAmount] LotteryPlayer BetAmount
             * @property {number|null} [GainLotteryBet] LotteryPlayer GainLotteryBet
             * @property {number|null} [NextLotteryAmount] LotteryPlayer NextLotteryAmount
             */

            /**
             * Constructs a new LotteryPlayer.
             * @memberof lottoProto
             * @classdesc Represents a LotteryPlayer.
             * @implements ILotteryPlayer
             * @constructor
             * @param {lottoProto.ILotteryPlayer=} [properties] Properties to set
             */
            function LotteryPlayer(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * LotteryPlayer Type.
             * @member {lottoProto.LotteryType} Type
             * @memberof lottoProto.LotteryPlayer
             * @instance
             */


            LotteryPlayer.prototype.Type = 0;
            /**
             * LotteryPlayer BetAmount.
             * @member {number} BetAmount
             * @memberof lottoProto.LotteryPlayer
             * @instance
             */

            LotteryPlayer.prototype.BetAmount = 0;
            /**
             * LotteryPlayer GainLotteryBet.
             * @member {number} GainLotteryBet
             * @memberof lottoProto.LotteryPlayer
             * @instance
             */

            LotteryPlayer.prototype.GainLotteryBet = 0;
            /**
             * LotteryPlayer NextLotteryAmount.
             * @member {number} NextLotteryAmount
             * @memberof lottoProto.LotteryPlayer
             * @instance
             */

            LotteryPlayer.prototype.NextLotteryAmount = 0;
            /**
             * Creates a new LotteryPlayer instance using the specified properties.
             * @function create
             * @memberof lottoProto.LotteryPlayer
             * @static
             * @param {lottoProto.ILotteryPlayer=} [properties] Properties to set
             * @returns {lottoProto.LotteryPlayer} LotteryPlayer instance
             */

            LotteryPlayer.create = function create(properties) {
              return new LotteryPlayer(properties);
            };
            /**
             * Encodes the specified LotteryPlayer message. Does not implicitly {@link lottoProto.LotteryPlayer.verify|verify} messages.
             * @function encode
             * @memberof lottoProto.LotteryPlayer
             * @static
             * @param {lottoProto.ILotteryPlayer} message LotteryPlayer message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            LotteryPlayer.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.Type != null && Object.hasOwnProperty.call(message, "Type")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.Type);
              if (message.BetAmount != null && Object.hasOwnProperty.call(message, "BetAmount")) writer.uint32(
              /* id 2, wireType 1 =*/
              17)["double"](message.BetAmount);
              if (message.GainLotteryBet != null && Object.hasOwnProperty.call(message, "GainLotteryBet")) writer.uint32(
              /* id 3, wireType 1 =*/
              25)["double"](message.GainLotteryBet);
              if (message.NextLotteryAmount != null && Object.hasOwnProperty.call(message, "NextLotteryAmount")) writer.uint32(
              /* id 4, wireType 0 =*/
              32).int32(message.NextLotteryAmount);
              return writer;
            };
            /**
             * Encodes the specified LotteryPlayer message, length delimited. Does not implicitly {@link lottoProto.LotteryPlayer.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lottoProto.LotteryPlayer
             * @static
             * @param {lottoProto.ILotteryPlayer} message LotteryPlayer message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            LotteryPlayer.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a LotteryPlayer message from the specified reader or buffer.
             * @function decode
             * @memberof lottoProto.LotteryPlayer
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lottoProto.LotteryPlayer} LotteryPlayer
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            LotteryPlayer.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.lottoProto.LotteryPlayer();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.Type = reader.int32();
                    break;

                  case 2:
                    message.BetAmount = reader["double"]();
                    break;

                  case 3:
                    message.GainLotteryBet = reader["double"]();
                    break;

                  case 4:
                    message.NextLotteryAmount = reader.int32();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
             * Decodes a LotteryPlayer message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lottoProto.LotteryPlayer
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lottoProto.LotteryPlayer} LotteryPlayer
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            LotteryPlayer.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a LotteryPlayer message.
             * @function verify
             * @memberof lottoProto.LotteryPlayer
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */


            LotteryPlayer.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.Type != null && message.hasOwnProperty("Type")) switch (message.Type) {
                default:
                  return "Type: enum value expected";

                case 0:
                case 1:
                case 2:
                case 3:
                  break;
              }
              if (message.BetAmount != null && message.hasOwnProperty("BetAmount")) if (typeof message.BetAmount !== "number") return "BetAmount: number expected";
              if (message.GainLotteryBet != null && message.hasOwnProperty("GainLotteryBet")) if (typeof message.GainLotteryBet !== "number") return "GainLotteryBet: number expected";
              if (message.NextLotteryAmount != null && message.hasOwnProperty("NextLotteryAmount")) if (!$util.isInteger(message.NextLotteryAmount)) return "NextLotteryAmount: integer expected";
              return null;
            };
            /**
             * Creates a LotteryPlayer message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lottoProto.LotteryPlayer
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lottoProto.LotteryPlayer} LotteryPlayer
             */


            LotteryPlayer.fromObject = function fromObject(object) {
              if (object instanceof $root.lottoProto.LotteryPlayer) return object;
              var message = new $root.lottoProto.LotteryPlayer();

              switch (object.Type) {
                case "None":
                case 0:
                  message.Type = 0;
                  break;

                case "Thai":
                case 1:
                  message.Type = 1;
                  break;

                case "ThaiJili":
                case 2:
                  message.Type = 2;
                  break;

                case "Mala":
                case 3:
                  message.Type = 3;
                  break;
              }

              if (object.BetAmount != null) message.BetAmount = Number(object.BetAmount);
              if (object.GainLotteryBet != null) message.GainLotteryBet = Number(object.GainLotteryBet);
              if (object.NextLotteryAmount != null) message.NextLotteryAmount = object.NextLotteryAmount | 0;
              return message;
            };
            /**
             * Creates a plain object from a LotteryPlayer message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lottoProto.LotteryPlayer
             * @static
             * @param {lottoProto.LotteryPlayer} message LotteryPlayer
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */


            LotteryPlayer.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.Type = options.enums === String ? "None" : 0;
                object.BetAmount = 0;
                object.GainLotteryBet = 0;
                object.NextLotteryAmount = 0;
              }

              if (message.Type != null && message.hasOwnProperty("Type")) object.Type = options.enums === String ? $root.lottoProto.LotteryType[message.Type] : message.Type;
              if (message.BetAmount != null && message.hasOwnProperty("BetAmount")) object.BetAmount = options.json && !isFinite(message.BetAmount) ? String(message.BetAmount) : message.BetAmount;
              if (message.GainLotteryBet != null && message.hasOwnProperty("GainLotteryBet")) object.GainLotteryBet = options.json && !isFinite(message.GainLotteryBet) ? String(message.GainLotteryBet) : message.GainLotteryBet;
              if (message.NextLotteryAmount != null && message.hasOwnProperty("NextLotteryAmount")) object.NextLotteryAmount = message.NextLotteryAmount;
              return object;
            };
            /**
             * Converts this LotteryPlayer to JSON.
             * @function toJSON
             * @memberof lottoProto.LotteryPlayer
             * @instance
             * @returns {Object.<string,*>} JSON object
             */


            LotteryPlayer.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return LotteryPlayer;
          }();

          return lottoProto;
        }();

        $root.google = function () {
          /**
           * Namespace google.
           * @exports google
           * @namespace
           */
          var google = {};

          google.protobuf = function () {
            /**
             * Namespace protobuf.
             * @memberof google
             * @namespace
             */
            var protobuf = {};

            protobuf.Timestamp = function () {
              /**
               * Properties of a Timestamp.
               * @memberof google.protobuf
               * @interface ITimestamp
               * @property {number|Long|null} [seconds] Timestamp seconds
               * @property {number|null} [nanos] Timestamp nanos
               */

              /**
               * Constructs a new Timestamp.
               * @memberof google.protobuf
               * @classdesc Represents a Timestamp.
               * @implements ITimestamp
               * @constructor
               * @param {google.protobuf.ITimestamp=} [properties] Properties to set
               */
              function Timestamp(properties) {
                if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                  if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
                }
              }
              /**
               * Timestamp seconds.
               * @member {number|Long} seconds
               * @memberof google.protobuf.Timestamp
               * @instance
               */


              Timestamp.prototype.seconds = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
              /**
               * Timestamp nanos.
               * @member {number} nanos
               * @memberof google.protobuf.Timestamp
               * @instance
               */

              Timestamp.prototype.nanos = 0;
              /**
               * Creates a new Timestamp instance using the specified properties.
               * @function create
               * @memberof google.protobuf.Timestamp
               * @static
               * @param {google.protobuf.ITimestamp=} [properties] Properties to set
               * @returns {google.protobuf.Timestamp} Timestamp instance
               */

              Timestamp.create = function create(properties) {
                return new Timestamp(properties);
              };
              /**
               * Encodes the specified Timestamp message. Does not implicitly {@link google.protobuf.Timestamp.verify|verify} messages.
               * @function encode
               * @memberof google.protobuf.Timestamp
               * @static
               * @param {google.protobuf.ITimestamp} message Timestamp message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              Timestamp.encode = function encode(message, writer) {
                if (!writer) writer = $Writer.create();
                if (message.seconds != null && Object.hasOwnProperty.call(message, "seconds")) writer.uint32(
                /* id 1, wireType 0 =*/
                8).int64(message.seconds);
                if (message.nanos != null && Object.hasOwnProperty.call(message, "nanos")) writer.uint32(
                /* id 2, wireType 0 =*/
                16).int32(message.nanos);
                return writer;
              };
              /**
               * Encodes the specified Timestamp message, length delimited. Does not implicitly {@link google.protobuf.Timestamp.verify|verify} messages.
               * @function encodeDelimited
               * @memberof google.protobuf.Timestamp
               * @static
               * @param {google.protobuf.ITimestamp} message Timestamp message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */


              Timestamp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              /**
               * Decodes a Timestamp message from the specified reader or buffer.
               * @function decode
               * @memberof google.protobuf.Timestamp
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {google.protobuf.Timestamp} Timestamp
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              Timestamp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length,
                    message = new $root.google.protobuf.Timestamp();

                while (reader.pos < end) {
                  var tag = reader.uint32();

                  switch (tag >>> 3) {
                    case 1:
                      message.seconds = reader.int64();
                      break;

                    case 2:
                      message.nanos = reader.int32();
                      break;

                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }

                return message;
              };
              /**
               * Decodes a Timestamp message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof google.protobuf.Timestamp
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {google.protobuf.Timestamp} Timestamp
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */


              Timestamp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader)) reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              /**
               * Verifies a Timestamp message.
               * @function verify
               * @memberof google.protobuf.Timestamp
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */


              Timestamp.verify = function verify(message) {
                if (typeof message !== "object" || message === null) return "object expected";
                if (message.seconds != null && message.hasOwnProperty("seconds")) if (!$util.isInteger(message.seconds) && !(message.seconds && $util.isInteger(message.seconds.low) && $util.isInteger(message.seconds.high))) return "seconds: integer|Long expected";
                if (message.nanos != null && message.hasOwnProperty("nanos")) if (!$util.isInteger(message.nanos)) return "nanos: integer expected";
                return null;
              };
              /**
               * Creates a Timestamp message from a plain object. Also converts values to their respective internal types.
               * @function fromObject
               * @memberof google.protobuf.Timestamp
               * @static
               * @param {Object.<string,*>} object Plain object
               * @returns {google.protobuf.Timestamp} Timestamp
               */


              Timestamp.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Timestamp) return object;
                var message = new $root.google.protobuf.Timestamp();
                if (object.seconds != null) if ($util.Long) (message.seconds = $util.Long.fromValue(object.seconds)).unsigned = false;else if (typeof object.seconds === "string") message.seconds = parseInt(object.seconds, 10);else if (typeof object.seconds === "number") message.seconds = object.seconds;else if (typeof object.seconds === "object") message.seconds = new $util.LongBits(object.seconds.low >>> 0, object.seconds.high >>> 0).toNumber();
                if (object.nanos != null) message.nanos = object.nanos | 0;
                return message;
              };
              /**
               * Creates a plain object from a Timestamp message. Also converts values to other types if specified.
               * @function toObject
               * @memberof google.protobuf.Timestamp
               * @static
               * @param {google.protobuf.Timestamp} message Timestamp
               * @param {$protobuf.IConversionOptions} [options] Conversion options
               * @returns {Object.<string,*>} Plain object
               */


              Timestamp.toObject = function toObject(message, options) {
                if (!options) options = {};
                var object = {};

                if (options.defaults) {
                  if ($util.Long) {
                    var _long = new $util.Long(0, 0, false);

                    object.seconds = options.longs === String ? _long.toString() : options.longs === Number ? _long.toNumber() : _long;
                  } else object.seconds = options.longs === String ? "0" : 0;

                  object.nanos = 0;
                }

                if (message.seconds != null && message.hasOwnProperty("seconds")) if (typeof message.seconds === "number") object.seconds = options.longs === String ? String(message.seconds) : message.seconds;else object.seconds = options.longs === String ? $util.Long.prototype.toString.call(message.seconds) : options.longs === Number ? new $util.LongBits(message.seconds.low >>> 0, message.seconds.high >>> 0).toNumber() : message.seconds;
                if (message.nanos != null && message.hasOwnProperty("nanos")) object.nanos = message.nanos;
                return object;
              };
              /**
               * Converts this Timestamp to JSON.
               * @function toJSON
               * @memberof google.protobuf.Timestamp
               * @instance
               * @returns {Object.<string,*>} JSON object
               */


              Timestamp.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              };

              return Timestamp;
            }();

            return protobuf;
          }();

          return google;
        }();

        module.exports = $root; // #endregion ORIGINAL CODE

        _cjsExports = exports('default', module.exports);
      }, function () {
        return {
          'protobufjs/minimal': __cjsMetaURL$1
        };
      });
    }
  };
});

System.register("chunks:///_virtual/lotto.mjs_cjs=&original=.js", ['./lotto.js', './cjs-loader.mjs'], function (exports, module) {
  'use strict';

  var __cjsMetaURL, loader;

  return {
    setters: [function (module) {
      __cjsMetaURL = module.__cjsMetaURL;
      var _setter = {};
      _setter.__cjsMetaURL = module.__cjsMetaURL;
      _setter.default = module.default;
      exports(_setter);
    }, function (module) {
      loader = module.default;
    }],
    execute: function () {
      // I am the facade module who provides access to the CommonJS module './lotto.js'~
      if (!__cjsMetaURL) {
        loader.throwInvalidWrapper('./lotto.js', module.meta.url);
      }

      loader.require(__cjsMetaURL);
    }
  };
});

System.register("chunks:///_virtual/mapfield.js", ['./cjs-loader.mjs', './field.js', './types.js', './util.js'], function (exports, module) {
  'use strict';

  var loader, __cjsMetaURL$1, __cjsMetaURL$2, __cjsMetaURL$3;

  return {
    setters: [function (module) {
      loader = module.default;
    }, function (module) {
      __cjsMetaURL$1 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$2 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$3 = module.__cjsMetaURL;
    }],
    execute: function () {
      var __cjsMetaURL = exports('__cjsMetaURL', module.meta.url);

      loader.define(__cjsMetaURL, function (exports, require, module, __filename, __dirname) {
        module.exports = MapField; // extends Field

        var Field = require("./field");

        ((MapField.prototype = Object.create(Field.prototype)).constructor = MapField).className = "MapField";

        var types = require("./types"),
            util = require("./util");
        /**
         * Constructs a new map field instance.
         * @classdesc Reflected map field.
         * @extends FieldBase
         * @constructor
         * @param {string} name Unique name within its namespace
         * @param {number} id Unique id within its namespace
         * @param {string} keyType Key type
         * @param {string} type Value type
         * @param {Object.<string,*>} [options] Declared options
         * @param {string} [comment] Comment associated with this field
         */


        function MapField(name, id, keyType, type, options, comment) {
          Field.call(this, name, id, type, undefined, undefined, options, comment);
          /* istanbul ignore if */

          if (!util.isString(keyType)) throw TypeError("keyType must be a string");
          /**
           * Key type.
           * @type {string}
           */

          this.keyType = keyType; // toJSON, marker

          /**
           * Resolved key type if not a basic type.
           * @type {ReflectionObject|null}
           */

          this.resolvedKeyType = null; // Overrides Field#map

          this.map = true;
        }
        /**
         * Map field descriptor.
         * @interface IMapField
         * @extends {IField}
         * @property {string} keyType Key type
         */

        /**
         * Extension map field descriptor.
         * @interface IExtensionMapField
         * @extends IMapField
         * @property {string} extend Extended type
         */

        /**
         * Constructs a map field from a map field descriptor.
         * @param {string} name Field name
         * @param {IMapField} json Map field descriptor
         * @returns {MapField} Created map field
         * @throws {TypeError} If arguments are invalid
         */


        MapField.fromJSON = function fromJSON(name, json) {
          return new MapField(name, json.id, json.keyType, json.type, json.options, json.comment);
        };
        /**
         * Converts this map field to a map field descriptor.
         * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
         * @returns {IMapField} Map field descriptor
         */


        MapField.prototype.toJSON = function toJSON(toJSONOptions) {
          var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
          return util.toObject(["keyType", this.keyType, "type", this.type, "id", this.id, "extend", this.extend, "options", this.options, "comment", keepComments ? this.comment : undefined]);
        };
        /**
         * @override
         */


        MapField.prototype.resolve = function resolve() {
          if (this.resolved) return this; // Besides a value type, map fields have a key type that may be "any scalar type except for floating point types and bytes"

          if (types.mapKey[this.keyType] === undefined) throw Error("invalid key type: " + this.keyType);
          return Field.prototype.resolve.call(this);
        };
        /**
         * Map field decorator (TypeScript).
         * @name MapField.d
         * @function
         * @param {number} fieldId Field id
         * @param {"int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"bool"|"string"} fieldKeyType Field key type
         * @param {"double"|"float"|"int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"bool"|"string"|"bytes"|Object|Constructor<{}>} fieldValueType Field value type
         * @returns {FieldDecorator} Decorator function
         * @template T extends { [key: string]: number | Long | string | boolean | Uint8Array | Buffer | number[] | Message<{}> }
         */


        MapField.d = function decorateMapField(fieldId, fieldKeyType, fieldValueType) {
          // submessage value: decorate the submessage and use its name as the type
          if (typeof fieldValueType === "function") fieldValueType = util.decorateType(fieldValueType).name; // enum reference value: create a reflected copy of the enum and keep reuseing it
          else if (fieldValueType && typeof fieldValueType === "object") fieldValueType = util.decorateEnum(fieldValueType).name;
          return function mapFieldDecorator(prototype, fieldName) {
            util.decorateType(prototype.constructor).add(new MapField(fieldName, fieldId, fieldKeyType, fieldValueType));
          };
        }; // #endregion ORIGINAL CODE


        module.exports;
      }, function () {
        return {
          './field': __cjsMetaURL$1,
          './types': __cjsMetaURL$2,
          './util': __cjsMetaURL$3
        };
      });
    }
  };
});

System.register("chunks:///_virtual/message.js", ['./cjs-loader.mjs', './minimal2.js'], function (exports, module) {
  'use strict';

  var loader, __cjsMetaURL$1;

  return {
    setters: [function (module) {
      loader = module.default;
    }, function (module) {
      __cjsMetaURL$1 = module.__cjsMetaURL;
    }],
    execute: function () {
      var __cjsMetaURL = exports('__cjsMetaURL', module.meta.url);

      loader.define(__cjsMetaURL, function (exports, require, module, __filename, __dirname) {
        module.exports = Message;

        var util = require("./util/minimal");
        /**
         * Constructs a new message instance.
         * @classdesc Abstract runtime message.
         * @constructor
         * @param {Properties<T>} [properties] Properties to set
         * @template T extends object = object
         */


        function Message(properties) {
          // not used internally
          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
            this[keys[i]] = properties[keys[i]];
          }
        }
        /**
         * Reference to the reflected type.
         * @name Message.$type
         * @type {Type}
         * @readonly
         */

        /**
         * Reference to the reflected type.
         * @name Message#$type
         * @type {Type}
         * @readonly
         */

        /*eslint-disable valid-jsdoc*/

        /**
         * Creates a new message of this type using the specified properties.
         * @param {Object.<string,*>} [properties] Properties to set
         * @returns {Message<T>} Message instance
         * @template T extends Message<T>
         * @this Constructor<T>
         */


        Message.create = function create(properties) {
          return this.$type.create(properties);
        };
        /**
         * Encodes a message of this type.
         * @param {T|Object.<string,*>} message Message to encode
         * @param {Writer} [writer] Writer to use
         * @returns {Writer} Writer
         * @template T extends Message<T>
         * @this Constructor<T>
         */


        Message.encode = function encode(message, writer) {
          return this.$type.encode(message, writer);
        };
        /**
         * Encodes a message of this type preceeded by its length as a varint.
         * @param {T|Object.<string,*>} message Message to encode
         * @param {Writer} [writer] Writer to use
         * @returns {Writer} Writer
         * @template T extends Message<T>
         * @this Constructor<T>
         */


        Message.encodeDelimited = function encodeDelimited(message, writer) {
          return this.$type.encodeDelimited(message, writer);
        };
        /**
         * Decodes a message of this type.
         * @name Message.decode
         * @function
         * @param {Reader|Uint8Array} reader Reader or buffer to decode
         * @returns {T} Decoded message
         * @template T extends Message<T>
         * @this Constructor<T>
         */


        Message.decode = function decode(reader) {
          return this.$type.decode(reader);
        };
        /**
         * Decodes a message of this type preceeded by its length as a varint.
         * @name Message.decodeDelimited
         * @function
         * @param {Reader|Uint8Array} reader Reader or buffer to decode
         * @returns {T} Decoded message
         * @template T extends Message<T>
         * @this Constructor<T>
         */


        Message.decodeDelimited = function decodeDelimited(reader) {
          return this.$type.decodeDelimited(reader);
        };
        /**
         * Verifies a message of this type.
         * @name Message.verify
         * @function
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */


        Message.verify = function verify(message) {
          return this.$type.verify(message);
        };
        /**
         * Creates a new message of this type from a plain object. Also converts values to their respective internal types.
         * @param {Object.<string,*>} object Plain object
         * @returns {T} Message instance
         * @template T extends Message<T>
         * @this Constructor<T>
         */


        Message.fromObject = function fromObject(object) {
          return this.$type.fromObject(object);
        };
        /**
         * Creates a plain object from a message of this type. Also converts values to other types if specified.
         * @param {T} message Message instance
         * @param {IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         * @template T extends Message<T>
         * @this Constructor<T>
         */


        Message.toObject = function toObject(message, options) {
          return this.$type.toObject(message, options);
        };
        /**
         * Converts this message to JSON.
         * @returns {Object.<string,*>} JSON object
         */


        Message.prototype.toJSON = function toJSON() {
          return this.$type.toObject(this, util.toJSONOptions);
        };
        /*eslint-enable valid-jsdoc*/
        // #endregion ORIGINAL CODE


        module.exports;
      }, function () {
        return {
          './util/minimal': __cjsMetaURL$1
        };
      });
    }
  };
});

System.register("chunks:///_virtual/method.js", ['./cjs-loader.mjs', './object.js', './util.js'], function (exports, module) {
  'use strict';

  var loader, __cjsMetaURL$1, __cjsMetaURL$2;

  return {
    setters: [function (module) {
      loader = module.default;
    }, function (module) {
      __cjsMetaURL$1 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$2 = module.__cjsMetaURL;
    }],
    execute: function () {
      var __cjsMetaURL = exports('__cjsMetaURL', module.meta.url);

      loader.define(__cjsMetaURL, function (exports, require, module, __filename, __dirname) {
        module.exports = Method; // extends ReflectionObject

        var ReflectionObject = require("./object");

        ((Method.prototype = Object.create(ReflectionObject.prototype)).constructor = Method).className = "Method";

        var util = require("./util");
        /**
         * Constructs a new service method instance.
         * @classdesc Reflected service method.
         * @extends ReflectionObject
         * @constructor
         * @param {string} name Method name
         * @param {string|undefined} type Method type, usually `"rpc"`
         * @param {string} requestType Request message type
         * @param {string} responseType Response message type
         * @param {boolean|Object.<string,*>} [requestStream] Whether the request is streamed
         * @param {boolean|Object.<string,*>} [responseStream] Whether the response is streamed
         * @param {Object.<string,*>} [options] Declared options
         * @param {string} [comment] The comment for this method
         * @param {Object.<string,*>} [parsedOptions] Declared options, properly parsed into an object
         */


        function Method(name, type, requestType, responseType, requestStream, responseStream, options, comment, parsedOptions) {
          /* istanbul ignore next */
          if (util.isObject(requestStream)) {
            options = requestStream;
            requestStream = responseStream = undefined;
          } else if (util.isObject(responseStream)) {
            options = responseStream;
            responseStream = undefined;
          }
          /* istanbul ignore if */


          if (!(type === undefined || util.isString(type))) throw TypeError("type must be a string");
          /* istanbul ignore if */

          if (!util.isString(requestType)) throw TypeError("requestType must be a string");
          /* istanbul ignore if */

          if (!util.isString(responseType)) throw TypeError("responseType must be a string");
          ReflectionObject.call(this, name, options);
          /**
           * Method type.
           * @type {string}
           */

          this.type = type || "rpc"; // toJSON

          /**
           * Request type.
           * @type {string}
           */

          this.requestType = requestType; // toJSON, marker

          /**
           * Whether requests are streamed or not.
           * @type {boolean|undefined}
           */

          this.requestStream = requestStream ? true : undefined; // toJSON

          /**
           * Response type.
           * @type {string}
           */

          this.responseType = responseType; // toJSON

          /**
           * Whether responses are streamed or not.
           * @type {boolean|undefined}
           */

          this.responseStream = responseStream ? true : undefined; // toJSON

          /**
           * Resolved request type.
           * @type {Type|null}
           */

          this.resolvedRequestType = null;
          /**
           * Resolved response type.
           * @type {Type|null}
           */

          this.resolvedResponseType = null;
          /**
           * Comment for this method
           * @type {string|null}
           */

          this.comment = comment;
          /**
           * Options properly parsed into an object
           */

          this.parsedOptions = parsedOptions;
        }
        /**
         * Method descriptor.
         * @interface IMethod
         * @property {string} [type="rpc"] Method type
         * @property {string} requestType Request type
         * @property {string} responseType Response type
         * @property {boolean} [requestStream=false] Whether requests are streamed
         * @property {boolean} [responseStream=false] Whether responses are streamed
         * @property {Object.<string,*>} [options] Method options
         * @property {string} comment Method comments
         * @property {Object.<string,*>} [parsedOptions] Method options properly parsed into an object
         */

        /**
         * Constructs a method from a method descriptor.
         * @param {string} name Method name
         * @param {IMethod} json Method descriptor
         * @returns {Method} Created method
         * @throws {TypeError} If arguments are invalid
         */


        Method.fromJSON = function fromJSON(name, json) {
          return new Method(name, json.type, json.requestType, json.responseType, json.requestStream, json.responseStream, json.options, json.comment, json.parsedOptions);
        };
        /**
         * Converts this method to a method descriptor.
         * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
         * @returns {IMethod} Method descriptor
         */


        Method.prototype.toJSON = function toJSON(toJSONOptions) {
          var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
          return util.toObject(["type", this.type !== "rpc" &&
          /* istanbul ignore next */
          this.type || undefined, "requestType", this.requestType, "requestStream", this.requestStream, "responseType", this.responseType, "responseStream", this.responseStream, "options", this.options, "comment", keepComments ? this.comment : undefined, "parsedOptions", this.parsedOptions]);
        };
        /**
         * @override
         */


        Method.prototype.resolve = function resolve() {
          /* istanbul ignore if */
          if (this.resolved) return this;
          this.resolvedRequestType = this.parent.lookupType(this.requestType);
          this.resolvedResponseType = this.parent.lookupType(this.responseType);
          return ReflectionObject.prototype.resolve.call(this);
        }; // #endregion ORIGINAL CODE


        module.exports;
      }, function () {
        return {
          './object': __cjsMetaURL$1,
          './util': __cjsMetaURL$2
        };
      });
    }
  };
});

System.register("chunks:///_virtual/minimal.js", ['./cjs-loader.mjs', './index-minimal.js'], function (exports, module) {
  'use strict';

  var loader, __cjsMetaURL$1;

  return {
    setters: [function (module) {
      loader = module.default;
    }, function (module) {
      __cjsMetaURL$1 = module.__cjsMetaURL;
    }],
    execute: function () {
      var __cjsMetaURL = exports('__cjsMetaURL', module.meta.url);

      loader.define(__cjsMetaURL, function (exports, require, module, __filename, __dirname) {
        module.exports = require("./src/index-minimal"); // #endregion ORIGINAL CODE

        module.exports;
      }, function () {
        return {
          './src/index-minimal': __cjsMetaURL$1
        };
      });
    }
  };
});

System.register("chunks:///_virtual/minimal2.js", ['./cjs-loader.mjs', './index4.js', './index5.js', './index6.js', './index3.js', './index7.js', './index8.js', './index9.js', './longbits.js'], function (exports, module) {
  'use strict';

  var loader, __cjsMetaURL$1, __cjsMetaURL$2, __cjsMetaURL$3, __cjsMetaURL$4, __cjsMetaURL$5, __cjsMetaURL$6, __cjsMetaURL$7, __cjsMetaURL$8;

  return {
    setters: [function (module) {
      loader = module.default;
    }, function (module) {
      __cjsMetaURL$1 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$2 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$3 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$4 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$5 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$6 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$7 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$8 = module.__cjsMetaURL;
    }],
    execute: function () {
      var __cjsMetaURL = exports('__cjsMetaURL', module.meta.url);

      loader.define(__cjsMetaURL, function (exports, require, module, __filename, __dirname) {
        var util = exports; // used to return a Promise where callback is omitted

        util.asPromise = require("@protobufjs/aspromise"); // converts to / from base64 encoded strings

        util.base64 = require("@protobufjs/base64"); // base class of rpc.Service

        util.EventEmitter = require("@protobufjs/eventemitter"); // float handling accross browsers

        util["float"] = require("@protobufjs/float"); // requires modules optionally and hides the call from bundlers

        util.inquire = require("@protobufjs/inquire"); // converts to / from utf8 encoded strings

        util.utf8 = require("@protobufjs/utf8"); // provides a node-like buffer pool in the browser

        util.pool = require("@protobufjs/pool"); // utility to work with the low and high bits of a 64 bit value

        util.LongBits = require("./longbits");
        /**
         * Whether running within node or not.
         * @memberof util
         * @type {boolean}
         */

        util.isNode = Boolean(typeof global !== "undefined" && global && global.process && global.process.versions && global.process.versions.node);
        /**
         * Global object reference.
         * @memberof util
         * @type {Object}
         */

        util.global = util.isNode && global || typeof window !== "undefined" && window || typeof self !== "undefined" && self || this; // eslint-disable-line no-invalid-this

        /**
         * An immuable empty array.
         * @memberof util
         * @type {Array.<*>}
         * @const
         */

        util.emptyArray = Object.freeze ? Object.freeze([]) :
        /* istanbul ignore next */
        []; // used on prototypes

        /**
         * An immutable empty object.
         * @type {Object}
         * @const
         */

        util.emptyObject = Object.freeze ? Object.freeze({}) :
        /* istanbul ignore next */
        {}; // used on prototypes

        /**
         * Tests if the specified value is an integer.
         * @function
         * @param {*} value Value to test
         * @returns {boolean} `true` if the value is an integer
         */

        util.isInteger = Number.isInteger ||
        /* istanbul ignore next */
        function isInteger(value) {
          return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
        };
        /**
         * Tests if the specified value is a string.
         * @param {*} value Value to test
         * @returns {boolean} `true` if the value is a string
         */


        util.isString = function isString(value) {
          return typeof value === "string" || value instanceof String;
        };
        /**
         * Tests if the specified value is a non-null object.
         * @param {*} value Value to test
         * @returns {boolean} `true` if the value is a non-null object
         */


        util.isObject = function isObject(value) {
          return value && typeof value === "object";
        };
        /**
         * Checks if a property on a message is considered to be present.
         * This is an alias of {@link util.isSet}.
         * @function
         * @param {Object} obj Plain object or message instance
         * @param {string} prop Property name
         * @returns {boolean} `true` if considered to be present, otherwise `false`
         */


        util.isset =
        /**
         * Checks if a property on a message is considered to be present.
         * @param {Object} obj Plain object or message instance
         * @param {string} prop Property name
         * @returns {boolean} `true` if considered to be present, otherwise `false`
         */
        util.isSet = function isSet(obj, prop) {
          var value = obj[prop];
          if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins
            return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
          return false;
        };
        /**
         * Any compatible Buffer instance.
         * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.
         * @interface Buffer
         * @extends Uint8Array
         */

        /**
         * Node's Buffer class if available.
         * @type {Constructor<Buffer>}
         */


        util.Buffer = function () {
          try {
            var Buffer = util.inquire("buffer").Buffer; // refuse to use non-node buffers if not explicitly assigned (perf reasons):

            return Buffer.prototype.utf8Write ? Buffer :
            /* istanbul ignore next */
            null;
          } catch (e) {
            /* istanbul ignore next */
            return null;
          }
        }(); // Internal alias of or polyfull for Buffer.from.


        util._Buffer_from = null; // Internal alias of or polyfill for Buffer.allocUnsafe.

        util._Buffer_allocUnsafe = null;
        /**
         * Creates a new buffer of whatever type supported by the environment.
         * @param {number|number[]} [sizeOrArray=0] Buffer size or number array
         * @returns {Uint8Array|Buffer} Buffer
         */

        util.newBuffer = function newBuffer(sizeOrArray) {
          /* istanbul ignore next */
          return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
        };
        /**
         * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.
         * @type {Constructor<Uint8Array>}
         */


        util.Array = typeof Uint8Array !== "undefined" ? Uint8Array
        /* istanbul ignore next */
        : Array;
        /**
         * Any compatible Long instance.
         * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.
         * @interface Long
         * @property {number} low Low bits
         * @property {number} high High bits
         * @property {boolean} unsigned Whether unsigned or not
         */

        /**
         * Long.js's Long class if available.
         * @type {Constructor<Long>}
         */

        util.Long =
        /* istanbul ignore next */
        util.global.dcodeIO &&
        /* istanbul ignore next */
        util.global.dcodeIO.Long ||
        /* istanbul ignore next */
        util.global.Long || util.inquire("long");
        /**
         * Regular expression used to verify 2 bit (`bool`) map keys.
         * @type {RegExp}
         * @const
         */

        util.key2Re = /^true|false|0|1$/;
        /**
         * Regular expression used to verify 32 bit (`int32` etc.) map keys.
         * @type {RegExp}
         * @const
         */

        util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
        /**
         * Regular expression used to verify 64 bit (`int64` etc.) map keys.
         * @type {RegExp}
         * @const
         */

        util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
        /**
         * Converts a number or long to an 8 characters long hash string.
         * @param {Long|number} value Value to convert
         * @returns {string} Hash
         */

        util.longToHash = function longToHash(value) {
          return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
        };
        /**
         * Converts an 8 characters long hash string to a long or number.
         * @param {string} hash Hash
         * @param {boolean} [unsigned=false] Whether unsigned or not
         * @returns {Long|number} Original value
         */


        util.longFromHash = function longFromHash(hash, unsigned) {
          var bits = util.LongBits.fromHash(hash);
          if (util.Long) return util.Long.fromBits(bits.lo, bits.hi, unsigned);
          return bits.toNumber(Boolean(unsigned));
        };
        /**
         * Merges the properties of the source object into the destination object.
         * @memberof util
         * @param {Object.<string,*>} dst Destination object
         * @param {Object.<string,*>} src Source object
         * @param {boolean} [ifNotSet=false] Merges only if the key is not already set
         * @returns {Object.<string,*>} Destination object
         */


        function merge(dst, src, ifNotSet) {
          // used by converters
          for (var keys = Object.keys(src), i = 0; i < keys.length; ++i) {
            if (dst[keys[i]] === undefined || !ifNotSet) dst[keys[i]] = src[keys[i]];
          }

          return dst;
        }

        util.merge = merge;
        /**
         * Converts the first character of a string to lower case.
         * @param {string} str String to convert
         * @returns {string} Converted string
         */

        util.lcFirst = function lcFirst(str) {
          return str.charAt(0).toLowerCase() + str.substring(1);
        };
        /**
         * Creates a custom error constructor.
         * @memberof util
         * @param {string} name Error name
         * @returns {Constructor<Error>} Custom error constructor
         */


        function newError(name) {
          function CustomError(message, properties) {
            if (!(this instanceof CustomError)) return new CustomError(message, properties); // Error.call(this, message);
            // ^ just returns a new error instance because the ctor can be called as a function

            Object.defineProperty(this, "message", {
              get: function get() {
                return message;
              }
            });
            /* istanbul ignore next */

            if (Error.captureStackTrace) // node
              Error.captureStackTrace(this, CustomError);else Object.defineProperty(this, "stack", {
              value: new Error().stack || ""
            });
            if (properties) merge(this, properties);
          }

          (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;
          Object.defineProperty(CustomError.prototype, "name", {
            get: function get() {
              return name;
            }
          });

          CustomError.prototype.toString = function toString() {
            return this.name + ": " + this.message;
          };

          return CustomError;
        }

        util.newError = newError;
        /**
         * Constructs a new protocol error.
         * @classdesc Error subclass indicating a protocol specifc error.
         * @memberof util
         * @extends Error
         * @template T extends Message<T>
         * @constructor
         * @param {string} message Error message
         * @param {Object.<string,*>} [properties] Additional properties
         * @example
         * try {
         *     MyMessage.decode(someBuffer); // throws if required fields are missing
         * } catch (e) {
         *     if (e instanceof ProtocolError && e.instance)
         *         console.log("decoded so far: " + JSON.stringify(e.instance));
         * }
         */

        util.ProtocolError = newError("ProtocolError");
        /**
         * So far decoded message instance.
         * @name util.ProtocolError#instance
         * @type {Message<T>}
         */

        /**
         * A OneOf getter as returned by {@link util.oneOfGetter}.
         * @typedef OneOfGetter
         * @type {function}
         * @returns {string|undefined} Set field name, if any
         */

        /**
         * Builds a getter for a oneof's present field name.
         * @param {string[]} fieldNames Field names
         * @returns {OneOfGetter} Unbound getter
         */

        util.oneOfGetter = function getOneOf(fieldNames) {
          var fieldMap = {};

          for (var i = 0; i < fieldNames.length; ++i) {
            fieldMap[fieldNames[i]] = 1;
          }
          /**
           * @returns {string|undefined} Set field name, if any
           * @this Object
           * @ignore
           */


          return function () {
            // eslint-disable-line consistent-return
            for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i) {
              if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null) return keys[i];
            }
          };
        };
        /**
         * A OneOf setter as returned by {@link util.oneOfSetter}.
         * @typedef OneOfSetter
         * @type {function}
         * @param {string|undefined} value Field name
         * @returns {undefined}
         */

        /**
         * Builds a setter for a oneof's present field name.
         * @param {string[]} fieldNames Field names
         * @returns {OneOfSetter} Unbound setter
         */


        util.oneOfSetter = function setOneOf(fieldNames) {
          /**
           * @param {string} name Field name
           * @returns {undefined}
           * @this Object
           * @ignore
           */
          return function (name) {
            for (var i = 0; i < fieldNames.length; ++i) {
              if (fieldNames[i] !== name) delete this[fieldNames[i]];
            }
          };
        };
        /**
         * Default conversion options used for {@link Message#toJSON} implementations.
         *
         * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:
         *
         * - Longs become strings
         * - Enums become string keys
         * - Bytes become base64 encoded strings
         * - (Sub-)Messages become plain objects
         * - Maps become plain objects with all string keys
         * - Repeated fields become arrays
         * - NaN and Infinity for float and double fields become strings
         *
         * @type {IConversionOptions}
         * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json
         */


        util.toJSONOptions = {
          longs: String,
          enums: String,
          bytes: String,
          json: true
        }; // Sets up buffer utility according to the environment (called in index-minimal)

        util._configure = function () {
          var Buffer = util.Buffer;
          /* istanbul ignore if */

          if (!Buffer) {
            util._Buffer_from = util._Buffer_allocUnsafe = null;
            return;
          } // because node 4.x buffers are incompatible & immutable
          // see: https://github.com/dcodeIO/protobuf.js/pull/665


          util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||
          /* istanbul ignore next */
          function Buffer_from(value, encoding) {
            return new Buffer(value, encoding);
          };

          util._Buffer_allocUnsafe = Buffer.allocUnsafe ||
          /* istanbul ignore next */
          function Buffer_allocUnsafe(size) {
            return new Buffer(size);
          };
        }; // #endregion ORIGINAL CODE


        module.exports;
      }, function () {
        return {
          '@protobufjs/aspromise': __cjsMetaURL$1,
          '@protobufjs/base64': __cjsMetaURL$2,
          '@protobufjs/eventemitter': __cjsMetaURL$3,
          '@protobufjs/float': __cjsMetaURL$4,
          '@protobufjs/inquire': __cjsMetaURL$5,
          '@protobufjs/utf8': __cjsMetaURL$6,
          '@protobufjs/pool': __cjsMetaURL$7,
          './longbits': __cjsMetaURL$8
        };
      });
    }
  };
});

System.register("chunks:///_virtual/missionCProto.js", ['./cjs-loader.mjs', './minimal.js'], function (exports, module) {
  'use strict';

  var loader, __cjsMetaURL$1;

  return {
    setters: [function (module) {
      loader = module.default;
    }, function (module) {
      __cjsMetaURL$1 = module.__cjsMetaURL;
    }],
    execute: function () {
      exports('default', void 0);

      var _cjsExports;

      var __cjsMetaURL = exports('__cjsMetaURL', module.meta.url);

      loader.define(__cjsMetaURL, function (exports$1, require, module, __filename, __dirname) {
        var $protobuf = require("protobufjs/minimal"); // Common aliases


        var $Reader = $protobuf.Reader,
            $Writer = $protobuf.Writer,
            $util = $protobuf.util; // Exported root namespace

        var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

        $root.missionProto = function () {
          /**
           * Namespace missionProto.
           * @exports missionProto
           * @namespace
           */
          var missionProto = {};
          /**
           * Error enum.
           * @name missionProto.Error
           * @enum {number}
           * @property {number} success=0 success value
           * @property {number} failed=1 failed value
           * @property {number} unknow=999 unknow value
           */

          missionProto.Error = function () {
            var valuesById = {},
                values = Object.create(valuesById);
            values[valuesById[0] = "success"] = 0;
            values[valuesById[1] = "failed"] = 1;
            values[valuesById[999] = "unknow"] = 999;
            return values;
          }();

          missionProto.MissionReportReq = function () {
            /**
             * Properties of a MissionReportReq.
             * @memberof missionProto
             * @interface IMissionReportReq
             * @property {number|null} [accountID] MissionReportReq accountID
             * @property {number|null} [apiID] MissionReportReq apiID
             * @property {number|null} [gameID] MissionReportReq gameID
             * @property {number|null} [bet] MissionReportReq bet
             * @property {number|null} [win] MissionReportReq win
             * @property {boolean|null} [isFG] MissionReportReq isFG
             * @property {number|null} [currencyNumber] MissionReportReq currencyNumber
             * @property {number|null} [siteID] MissionReportReq siteID
             * @property {number|null} [subAgentCode] MissionReportReq subAgentCode
             * @property {number|null} [ratio] MissionReportReq ratio
             * @property {number|null} [rate] MissionReportReq rate
             * @property {number|null} [themeID] MissionReportReq themeID
             * @property {number|null} [point] MissionReportReq point
             * @property {boolean|null} [buy] MissionReportReq buy
             * @property {Array.<number>|null} [combo] MissionReportReq combo
             * @property {number|null} [fullplate] MissionReportReq fullplate
             * @property {number|null} [property] MissionReportReq property
             * @property {number|null} [level] MissionReportReq level
             */

            /**
             * Constructs a new MissionReportReq.
             * @memberof missionProto
             * @classdesc Represents a MissionReportReq.
             * @implements IMissionReportReq
             * @constructor
             * @param {missionProto.IMissionReportReq=} [properties] Properties to set
             */
            function MissionReportReq(properties) {
              this.combo = [];
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * MissionReportReq accountID.
             * @member {number} accountID
             * @memberof missionProto.MissionReportReq
             * @instance
             */


            MissionReportReq.prototype.accountID = 0;
            /**
             * MissionReportReq apiID.
             * @member {number} apiID
             * @memberof missionProto.MissionReportReq
             * @instance
             */

            MissionReportReq.prototype.apiID = 0;
            /**
             * MissionReportReq gameID.
             * @member {number} gameID
             * @memberof missionProto.MissionReportReq
             * @instance
             */

            MissionReportReq.prototype.gameID = 0;
            /**
             * MissionReportReq bet.
             * @member {number} bet
             * @memberof missionProto.MissionReportReq
             * @instance
             */

            MissionReportReq.prototype.bet = 0;
            /**
             * MissionReportReq win.
             * @member {number} win
             * @memberof missionProto.MissionReportReq
             * @instance
             */

            MissionReportReq.prototype.win = 0;
            /**
             * MissionReportReq isFG.
             * @member {boolean} isFG
             * @memberof missionProto.MissionReportReq
             * @instance
             */

            MissionReportReq.prototype.isFG = false;
            /**
             * MissionReportReq currencyNumber.
             * @member {number} currencyNumber
             * @memberof missionProto.MissionReportReq
             * @instance
             */

            MissionReportReq.prototype.currencyNumber = 0;
            /**
             * MissionReportReq siteID.
             * @member {number} siteID
             * @memberof missionProto.MissionReportReq
             * @instance
             */

            MissionReportReq.prototype.siteID = 0;
            /**
             * MissionReportReq subAgentCode.
             * @member {number} subAgentCode
             * @memberof missionProto.MissionReportReq
             * @instance
             */

            MissionReportReq.prototype.subAgentCode = 0;
            /**
             * MissionReportReq ratio.
             * @member {number} ratio
             * @memberof missionProto.MissionReportReq
             * @instance
             */

            MissionReportReq.prototype.ratio = 0;
            /**
             * MissionReportReq rate.
             * @member {number} rate
             * @memberof missionProto.MissionReportReq
             * @instance
             */

            MissionReportReq.prototype.rate = 0;
            /**
             * MissionReportReq themeID.
             * @member {number} themeID
             * @memberof missionProto.MissionReportReq
             * @instance
             */

            MissionReportReq.prototype.themeID = 0;
            /**
             * MissionReportReq point.
             * @member {number} point
             * @memberof missionProto.MissionReportReq
             * @instance
             */

            MissionReportReq.prototype.point = 0;
            /**
             * MissionReportReq buy.
             * @member {boolean} buy
             * @memberof missionProto.MissionReportReq
             * @instance
             */

            MissionReportReq.prototype.buy = false;
            /**
             * MissionReportReq combo.
             * @member {Array.<number>} combo
             * @memberof missionProto.MissionReportReq
             * @instance
             */

            MissionReportReq.prototype.combo = $util.emptyArray;
            /**
             * MissionReportReq fullplate.
             * @member {number} fullplate
             * @memberof missionProto.MissionReportReq
             * @instance
             */

            MissionReportReq.prototype.fullplate = 0;
            /**
             * MissionReportReq property.
             * @member {number} property
             * @memberof missionProto.MissionReportReq
             * @instance
             */

            MissionReportReq.prototype.property = 0;
            /**
             * MissionReportReq level.
             * @member {number} level
             * @memberof missionProto.MissionReportReq
             * @instance
             */

            MissionReportReq.prototype.level = 0;
            /**
             * Creates a new MissionReportReq instance using the specified properties.
             * @function create
             * @memberof missionProto.MissionReportReq
             * @static
             * @param {missionProto.IMissionReportReq=} [properties] Properties to set
             * @returns {missionProto.MissionReportReq} MissionReportReq instance
             */

            MissionReportReq.create = function create(properties) {
              return new MissionReportReq(properties);
            };
            /**
             * Encodes the specified MissionReportReq message. Does not implicitly {@link missionProto.MissionReportReq.verify|verify} messages.
             * @function encode
             * @memberof missionProto.MissionReportReq
             * @static
             * @param {missionProto.IMissionReportReq} message MissionReportReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            MissionReportReq.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.accountID != null && Object.hasOwnProperty.call(message, "accountID")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.accountID);
              if (message.apiID != null && Object.hasOwnProperty.call(message, "apiID")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).uint32(message.apiID);
              if (message.gameID != null && Object.hasOwnProperty.call(message, "gameID")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).uint32(message.gameID);
              if (message.bet != null && Object.hasOwnProperty.call(message, "bet")) writer.uint32(
              /* id 4, wireType 1 =*/
              33)["double"](message.bet);
              if (message.win != null && Object.hasOwnProperty.call(message, "win")) writer.uint32(
              /* id 5, wireType 1 =*/
              41)["double"](message.win);
              if (message.isFG != null && Object.hasOwnProperty.call(message, "isFG")) writer.uint32(
              /* id 6, wireType 0 =*/
              48).bool(message.isFG);
              if (message.currencyNumber != null && Object.hasOwnProperty.call(message, "currencyNumber")) writer.uint32(
              /* id 7, wireType 0 =*/
              56).int32(message.currencyNumber);
              if (message.siteID != null && Object.hasOwnProperty.call(message, "siteID")) writer.uint32(
              /* id 8, wireType 0 =*/
              64).uint32(message.siteID);
              if (message.subAgentCode != null && Object.hasOwnProperty.call(message, "subAgentCode")) writer.uint32(
              /* id 9, wireType 0 =*/
              72).int32(message.subAgentCode);
              if (message.ratio != null && Object.hasOwnProperty.call(message, "ratio")) writer.uint32(
              /* id 10, wireType 1 =*/
              81)["double"](message.ratio);
              if (message.rate != null && Object.hasOwnProperty.call(message, "rate")) writer.uint32(
              /* id 11, wireType 1 =*/
              89)["double"](message.rate);
              if (message.themeID != null && Object.hasOwnProperty.call(message, "themeID")) writer.uint32(
              /* id 12, wireType 0 =*/
              96).int32(message.themeID);
              if (message.point != null && Object.hasOwnProperty.call(message, "point")) writer.uint32(
              /* id 13, wireType 0 =*/
              104).int32(message.point);
              if (message.buy != null && Object.hasOwnProperty.call(message, "buy")) writer.uint32(
              /* id 14, wireType 0 =*/
              112).bool(message.buy);

              if (message.combo != null && message.combo.length) {
                writer.uint32(
                /* id 15, wireType 2 =*/
                122).fork();

                for (var i = 0; i < message.combo.length; ++i) {
                  writer.uint32(message.combo[i]);
                }

                writer.ldelim();
              }

              if (message.fullplate != null && Object.hasOwnProperty.call(message, "fullplate")) writer.uint32(
              /* id 16, wireType 0 =*/
              128).uint32(message.fullplate);
              if (message.property != null && Object.hasOwnProperty.call(message, "property")) writer.uint32(
              /* id 17, wireType 1 =*/
              137)["double"](message.property);
              if (message.level != null && Object.hasOwnProperty.call(message, "level")) writer.uint32(
              /* id 18, wireType 0 =*/
              144).int32(message.level);
              return writer;
            };
            /**
             * Encodes the specified MissionReportReq message, length delimited. Does not implicitly {@link missionProto.MissionReportReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof missionProto.MissionReportReq
             * @static
             * @param {missionProto.IMissionReportReq} message MissionReportReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            MissionReportReq.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a MissionReportReq message from the specified reader or buffer.
             * @function decode
             * @memberof missionProto.MissionReportReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {missionProto.MissionReportReq} MissionReportReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            MissionReportReq.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.missionProto.MissionReportReq();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.accountID = reader.int32();
                    break;

                  case 2:
                    message.apiID = reader.uint32();
                    break;

                  case 3:
                    message.gameID = reader.uint32();
                    break;

                  case 4:
                    message.bet = reader["double"]();
                    break;

                  case 5:
                    message.win = reader["double"]();
                    break;

                  case 6:
                    message.isFG = reader.bool();
                    break;

                  case 7:
                    message.currencyNumber = reader.int32();
                    break;

                  case 8:
                    message.siteID = reader.uint32();
                    break;

                  case 9:
                    message.subAgentCode = reader.int32();
                    break;

                  case 10:
                    message.ratio = reader["double"]();
                    break;

                  case 11:
                    message.rate = reader["double"]();
                    break;

                  case 12:
                    message.themeID = reader.int32();
                    break;

                  case 13:
                    message.point = reader.int32();
                    break;

                  case 14:
                    message.buy = reader.bool();
                    break;

                  case 15:
                    if (!(message.combo && message.combo.length)) message.combo = [];

                    if ((tag & 7) === 2) {
                      var end2 = reader.uint32() + reader.pos;

                      while (reader.pos < end2) {
                        message.combo.push(reader.uint32());
                      }
                    } else message.combo.push(reader.uint32());

                    break;

                  case 16:
                    message.fullplate = reader.uint32();
                    break;

                  case 17:
                    message.property = reader["double"]();
                    break;

                  case 18:
                    message.level = reader.int32();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
             * Decodes a MissionReportReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof missionProto.MissionReportReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {missionProto.MissionReportReq} MissionReportReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            MissionReportReq.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a MissionReportReq message.
             * @function verify
             * @memberof missionProto.MissionReportReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */


            MissionReportReq.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.accountID != null && message.hasOwnProperty("accountID")) if (!$util.isInteger(message.accountID)) return "accountID: integer expected";
              if (message.apiID != null && message.hasOwnProperty("apiID")) if (!$util.isInteger(message.apiID)) return "apiID: integer expected";
              if (message.gameID != null && message.hasOwnProperty("gameID")) if (!$util.isInteger(message.gameID)) return "gameID: integer expected";
              if (message.bet != null && message.hasOwnProperty("bet")) if (typeof message.bet !== "number") return "bet: number expected";
              if (message.win != null && message.hasOwnProperty("win")) if (typeof message.win !== "number") return "win: number expected";
              if (message.isFG != null && message.hasOwnProperty("isFG")) if (typeof message.isFG !== "boolean") return "isFG: boolean expected";
              if (message.currencyNumber != null && message.hasOwnProperty("currencyNumber")) if (!$util.isInteger(message.currencyNumber)) return "currencyNumber: integer expected";
              if (message.siteID != null && message.hasOwnProperty("siteID")) if (!$util.isInteger(message.siteID)) return "siteID: integer expected";
              if (message.subAgentCode != null && message.hasOwnProperty("subAgentCode")) if (!$util.isInteger(message.subAgentCode)) return "subAgentCode: integer expected";
              if (message.ratio != null && message.hasOwnProperty("ratio")) if (typeof message.ratio !== "number") return "ratio: number expected";
              if (message.rate != null && message.hasOwnProperty("rate")) if (typeof message.rate !== "number") return "rate: number expected";
              if (message.themeID != null && message.hasOwnProperty("themeID")) if (!$util.isInteger(message.themeID)) return "themeID: integer expected";
              if (message.point != null && message.hasOwnProperty("point")) if (!$util.isInteger(message.point)) return "point: integer expected";
              if (message.buy != null && message.hasOwnProperty("buy")) if (typeof message.buy !== "boolean") return "buy: boolean expected";

              if (message.combo != null && message.hasOwnProperty("combo")) {
                if (!Array.isArray(message.combo)) return "combo: array expected";

                for (var i = 0; i < message.combo.length; ++i) {
                  if (!$util.isInteger(message.combo[i])) return "combo: integer[] expected";
                }
              }

              if (message.fullplate != null && message.hasOwnProperty("fullplate")) if (!$util.isInteger(message.fullplate)) return "fullplate: integer expected";
              if (message.property != null && message.hasOwnProperty("property")) if (typeof message.property !== "number") return "property: number expected";
              if (message.level != null && message.hasOwnProperty("level")) if (!$util.isInteger(message.level)) return "level: integer expected";
              return null;
            };
            /**
             * Creates a MissionReportReq message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof missionProto.MissionReportReq
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {missionProto.MissionReportReq} MissionReportReq
             */


            MissionReportReq.fromObject = function fromObject(object) {
              if (object instanceof $root.missionProto.MissionReportReq) return object;
              var message = new $root.missionProto.MissionReportReq();
              if (object.accountID != null) message.accountID = object.accountID | 0;
              if (object.apiID != null) message.apiID = object.apiID >>> 0;
              if (object.gameID != null) message.gameID = object.gameID >>> 0;
              if (object.bet != null) message.bet = Number(object.bet);
              if (object.win != null) message.win = Number(object.win);
              if (object.isFG != null) message.isFG = Boolean(object.isFG);
              if (object.currencyNumber != null) message.currencyNumber = object.currencyNumber | 0;
              if (object.siteID != null) message.siteID = object.siteID >>> 0;
              if (object.subAgentCode != null) message.subAgentCode = object.subAgentCode | 0;
              if (object.ratio != null) message.ratio = Number(object.ratio);
              if (object.rate != null) message.rate = Number(object.rate);
              if (object.themeID != null) message.themeID = object.themeID | 0;
              if (object.point != null) message.point = object.point | 0;
              if (object.buy != null) message.buy = Boolean(object.buy);

              if (object.combo) {
                if (!Array.isArray(object.combo)) throw TypeError(".missionProto.MissionReportReq.combo: array expected");
                message.combo = [];

                for (var i = 0; i < object.combo.length; ++i) {
                  message.combo[i] = object.combo[i] >>> 0;
                }
              }

              if (object.fullplate != null) message.fullplate = object.fullplate >>> 0;
              if (object.property != null) message.property = Number(object.property);
              if (object.level != null) message.level = object.level | 0;
              return message;
            };
            /**
             * Creates a plain object from a MissionReportReq message. Also converts values to other types if specified.
             * @function toObject
             * @memberof missionProto.MissionReportReq
             * @static
             * @param {missionProto.MissionReportReq} message MissionReportReq
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */


            MissionReportReq.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};
              if (options.arrays || options.defaults) object.combo = [];

              if (options.defaults) {
                object.accountID = 0;
                object.apiID = 0;
                object.gameID = 0;
                object.bet = 0;
                object.win = 0;
                object.isFG = false;
                object.currencyNumber = 0;
                object.siteID = 0;
                object.subAgentCode = 0;
                object.ratio = 0;
                object.rate = 0;
                object.themeID = 0;
                object.point = 0;
                object.buy = false;
                object.fullplate = 0;
                object.property = 0;
                object.level = 0;
              }

              if (message.accountID != null && message.hasOwnProperty("accountID")) object.accountID = message.accountID;
              if (message.apiID != null && message.hasOwnProperty("apiID")) object.apiID = message.apiID;
              if (message.gameID != null && message.hasOwnProperty("gameID")) object.gameID = message.gameID;
              if (message.bet != null && message.hasOwnProperty("bet")) object.bet = options.json && !isFinite(message.bet) ? String(message.bet) : message.bet;
              if (message.win != null && message.hasOwnProperty("win")) object.win = options.json && !isFinite(message.win) ? String(message.win) : message.win;
              if (message.isFG != null && message.hasOwnProperty("isFG")) object.isFG = message.isFG;
              if (message.currencyNumber != null && message.hasOwnProperty("currencyNumber")) object.currencyNumber = message.currencyNumber;
              if (message.siteID != null && message.hasOwnProperty("siteID")) object.siteID = message.siteID;
              if (message.subAgentCode != null && message.hasOwnProperty("subAgentCode")) object.subAgentCode = message.subAgentCode;
              if (message.ratio != null && message.hasOwnProperty("ratio")) object.ratio = options.json && !isFinite(message.ratio) ? String(message.ratio) : message.ratio;
              if (message.rate != null && message.hasOwnProperty("rate")) object.rate = options.json && !isFinite(message.rate) ? String(message.rate) : message.rate;
              if (message.themeID != null && message.hasOwnProperty("themeID")) object.themeID = message.themeID;
              if (message.point != null && message.hasOwnProperty("point")) object.point = message.point;
              if (message.buy != null && message.hasOwnProperty("buy")) object.buy = message.buy;

              if (message.combo && message.combo.length) {
                object.combo = [];

                for (var j = 0; j < message.combo.length; ++j) {
                  object.combo[j] = message.combo[j];
                }
              }

              if (message.fullplate != null && message.hasOwnProperty("fullplate")) object.fullplate = message.fullplate;
              if (message.property != null && message.hasOwnProperty("property")) object.property = options.json && !isFinite(message.property) ? String(message.property) : message.property;
              if (message.level != null && message.hasOwnProperty("level")) object.level = message.level;
              return object;
            };
            /**
             * Converts this MissionReportReq to JSON.
             * @function toJSON
             * @memberof missionProto.MissionReportReq
             * @instance
             * @returns {Object.<string,*>} JSON object
             */


            MissionReportReq.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MissionReportReq;
          }();

          missionProto.Reward = function () {
            /**
             * Properties of a Reward.
             * @memberof missionProto
             * @interface IReward
             * @property {number|null} [ItemID] Reward ItemID
             * @property {number|null} [ItemCount] Reward ItemCount
             * @property {Long|null} [ExtendID] Reward ExtendID
             */

            /**
             * Constructs a new Reward.
             * @memberof missionProto
             * @classdesc Represents a Reward.
             * @implements IReward
             * @constructor
             * @param {missionProto.IReward=} [properties] Properties to set
             */
            function Reward(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * Reward ItemID.
             * @member {number} ItemID
             * @memberof missionProto.Reward
             * @instance
             */


            Reward.prototype.ItemID = 0;
            /**
             * Reward ItemCount.
             * @member {number} ItemCount
             * @memberof missionProto.Reward
             * @instance
             */

            Reward.prototype.ItemCount = 0;
            /**
             * Reward ExtendID.
             * @member {Long} ExtendID
             * @memberof missionProto.Reward
             * @instance
             */

            Reward.prototype.ExtendID = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
             * Creates a new Reward instance using the specified properties.
             * @function create
             * @memberof missionProto.Reward
             * @static
             * @param {missionProto.IReward=} [properties] Properties to set
             * @returns {missionProto.Reward} Reward instance
             */

            Reward.create = function create(properties) {
              return new Reward(properties);
            };
            /**
             * Encodes the specified Reward message. Does not implicitly {@link missionProto.Reward.verify|verify} messages.
             * @function encode
             * @memberof missionProto.Reward
             * @static
             * @param {missionProto.IReward} message Reward message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            Reward.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.ItemID != null && Object.hasOwnProperty.call(message, "ItemID")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).uint32(message.ItemID);
              if (message.ItemCount != null && Object.hasOwnProperty.call(message, "ItemCount")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).uint32(message.ItemCount);
              if (message.ExtendID != null && Object.hasOwnProperty.call(message, "ExtendID")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int64(message.ExtendID);
              return writer;
            };
            /**
             * Encodes the specified Reward message, length delimited. Does not implicitly {@link missionProto.Reward.verify|verify} messages.
             * @function encodeDelimited
             * @memberof missionProto.Reward
             * @static
             * @param {missionProto.IReward} message Reward message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            Reward.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a Reward message from the specified reader or buffer.
             * @function decode
             * @memberof missionProto.Reward
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {missionProto.Reward} Reward
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            Reward.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.missionProto.Reward();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.ItemID = reader.uint32();
                    break;

                  case 2:
                    message.ItemCount = reader.uint32();
                    break;

                  case 3:
                    message.ExtendID = reader.int64();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
             * Decodes a Reward message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof missionProto.Reward
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {missionProto.Reward} Reward
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            Reward.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a Reward message.
             * @function verify
             * @memberof missionProto.Reward
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */


            Reward.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.ItemID != null && message.hasOwnProperty("ItemID")) if (!$util.isInteger(message.ItemID)) return "ItemID: integer expected";
              if (message.ItemCount != null && message.hasOwnProperty("ItemCount")) if (!$util.isInteger(message.ItemCount)) return "ItemCount: integer expected";
              if (message.ExtendID != null && message.hasOwnProperty("ExtendID")) if (!$util.isInteger(message.ExtendID) && !(message.ExtendID && $util.isInteger(message.ExtendID.low) && $util.isInteger(message.ExtendID.high))) return "ExtendID: integer|Long expected";
              return null;
            };
            /**
             * Creates a Reward message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof missionProto.Reward
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {missionProto.Reward} Reward
             */


            Reward.fromObject = function fromObject(object) {
              if (object instanceof $root.missionProto.Reward) return object;
              var message = new $root.missionProto.Reward();
              if (object.ItemID != null) message.ItemID = object.ItemID >>> 0;
              if (object.ItemCount != null) message.ItemCount = object.ItemCount >>> 0;
              if (object.ExtendID != null) if ($util.Long) (message.ExtendID = $util.Long.fromValue(object.ExtendID)).unsigned = false;else if (typeof object.ExtendID === "string") message.ExtendID = parseInt(object.ExtendID, 10);else if (typeof object.ExtendID === "number") message.ExtendID = object.ExtendID;else if (typeof object.ExtendID === "object") message.ExtendID = new $util.LongBits(object.ExtendID.low >>> 0, object.ExtendID.high >>> 0).toNumber();
              return message;
            };
            /**
             * Creates a plain object from a Reward message. Also converts values to other types if specified.
             * @function toObject
             * @memberof missionProto.Reward
             * @static
             * @param {missionProto.Reward} message Reward
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */


            Reward.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.ItemID = 0;
                object.ItemCount = 0;

                if ($util.Long) {
                  var _long = new $util.Long(0, 0, false);

                  object.ExtendID = options.longs === String ? _long.toString() : options.longs === Number ? _long.toNumber() : _long;
                } else object.ExtendID = options.longs === String ? "0" : 0;
              }

              if (message.ItemID != null && message.hasOwnProperty("ItemID")) object.ItemID = message.ItemID;
              if (message.ItemCount != null && message.hasOwnProperty("ItemCount")) object.ItemCount = message.ItemCount;
              if (message.ExtendID != null && message.hasOwnProperty("ExtendID")) if (typeof message.ExtendID === "number") object.ExtendID = options.longs === String ? String(message.ExtendID) : message.ExtendID;else object.ExtendID = options.longs === String ? $util.Long.prototype.toString.call(message.ExtendID) : options.longs === Number ? new $util.LongBits(message.ExtendID.low >>> 0, message.ExtendID.high >>> 0).toNumber() : message.ExtendID;
              return object;
            };
            /**
             * Converts this Reward to JSON.
             * @function toJSON
             * @memberof missionProto.Reward
             * @instance
             * @returns {Object.<string,*>} JSON object
             */


            Reward.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Reward;
          }();

          missionProto.MissionReportResponse = function () {
            /**
             * Properties of a MissionReportResponse.
             * @memberof missionProto
             * @interface IMissionReportResponse
             * @property {number|null} [missionReward] MissionReportResponse missionReward
             * @property {missionProto.Error|null} [error] MissionReportResponse error
             * @property {Array.<missionProto.IReward>|null} [list] MissionReportResponse list
             */

            /**
             * Constructs a new MissionReportResponse.
             * @memberof missionProto
             * @classdesc Represents a MissionReportResponse.
             * @implements IMissionReportResponse
             * @constructor
             * @param {missionProto.IMissionReportResponse=} [properties] Properties to set
             */
            function MissionReportResponse(properties) {
              this.list = [];
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * MissionReportResponse missionReward.
             * @member {number} missionReward
             * @memberof missionProto.MissionReportResponse
             * @instance
             */


            MissionReportResponse.prototype.missionReward = 0;
            /**
             * MissionReportResponse error.
             * @member {missionProto.Error} error
             * @memberof missionProto.MissionReportResponse
             * @instance
             */

            MissionReportResponse.prototype.error = 0;
            /**
             * MissionReportResponse list.
             * @member {Array.<missionProto.IReward>} list
             * @memberof missionProto.MissionReportResponse
             * @instance
             */

            MissionReportResponse.prototype.list = $util.emptyArray;
            /**
             * Creates a new MissionReportResponse instance using the specified properties.
             * @function create
             * @memberof missionProto.MissionReportResponse
             * @static
             * @param {missionProto.IMissionReportResponse=} [properties] Properties to set
             * @returns {missionProto.MissionReportResponse} MissionReportResponse instance
             */

            MissionReportResponse.create = function create(properties) {
              return new MissionReportResponse(properties);
            };
            /**
             * Encodes the specified MissionReportResponse message. Does not implicitly {@link missionProto.MissionReportResponse.verify|verify} messages.
             * @function encode
             * @memberof missionProto.MissionReportResponse
             * @static
             * @param {missionProto.IMissionReportResponse} message MissionReportResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            MissionReportResponse.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.missionReward != null && Object.hasOwnProperty.call(message, "missionReward")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).uint32(message.missionReward);
              if (message.error != null && Object.hasOwnProperty.call(message, "error")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int32(message.error);
              if (message.list != null && message.list.length) for (var i = 0; i < message.list.length; ++i) {
                $root.missionProto.Reward.encode(message.list[i], writer.uint32(
                /* id 3, wireType 2 =*/
                26).fork()).ldelim();
              }
              return writer;
            };
            /**
             * Encodes the specified MissionReportResponse message, length delimited. Does not implicitly {@link missionProto.MissionReportResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof missionProto.MissionReportResponse
             * @static
             * @param {missionProto.IMissionReportResponse} message MissionReportResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            MissionReportResponse.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a MissionReportResponse message from the specified reader or buffer.
             * @function decode
             * @memberof missionProto.MissionReportResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {missionProto.MissionReportResponse} MissionReportResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            MissionReportResponse.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.missionProto.MissionReportResponse();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.missionReward = reader.uint32();
                    break;

                  case 2:
                    message.error = reader.int32();
                    break;

                  case 3:
                    if (!(message.list && message.list.length)) message.list = [];
                    message.list.push($root.missionProto.Reward.decode(reader, reader.uint32()));
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
             * Decodes a MissionReportResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof missionProto.MissionReportResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {missionProto.MissionReportResponse} MissionReportResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            MissionReportResponse.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a MissionReportResponse message.
             * @function verify
             * @memberof missionProto.MissionReportResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */


            MissionReportResponse.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.missionReward != null && message.hasOwnProperty("missionReward")) if (!$util.isInteger(message.missionReward)) return "missionReward: integer expected";
              if (message.error != null && message.hasOwnProperty("error")) switch (message.error) {
                default:
                  return "error: enum value expected";

                case 0:
                case 1:
                case 999:
                  break;
              }

              if (message.list != null && message.hasOwnProperty("list")) {
                if (!Array.isArray(message.list)) return "list: array expected";

                for (var i = 0; i < message.list.length; ++i) {
                  var error = $root.missionProto.Reward.verify(message.list[i]);
                  if (error) return "list." + error;
                }
              }

              return null;
            };
            /**
             * Creates a MissionReportResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof missionProto.MissionReportResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {missionProto.MissionReportResponse} MissionReportResponse
             */


            MissionReportResponse.fromObject = function fromObject(object) {
              if (object instanceof $root.missionProto.MissionReportResponse) return object;
              var message = new $root.missionProto.MissionReportResponse();
              if (object.missionReward != null) message.missionReward = object.missionReward >>> 0;

              switch (object.error) {
                case "success":
                case 0:
                  message.error = 0;
                  break;

                case "failed":
                case 1:
                  message.error = 1;
                  break;

                case "unknow":
                case 999:
                  message.error = 999;
                  break;
              }

              if (object.list) {
                if (!Array.isArray(object.list)) throw TypeError(".missionProto.MissionReportResponse.list: array expected");
                message.list = [];

                for (var i = 0; i < object.list.length; ++i) {
                  if (typeof object.list[i] !== "object") throw TypeError(".missionProto.MissionReportResponse.list: object expected");
                  message.list[i] = $root.missionProto.Reward.fromObject(object.list[i]);
                }
              }

              return message;
            };
            /**
             * Creates a plain object from a MissionReportResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof missionProto.MissionReportResponse
             * @static
             * @param {missionProto.MissionReportResponse} message MissionReportResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */


            MissionReportResponse.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};
              if (options.arrays || options.defaults) object.list = [];

              if (options.defaults) {
                object.missionReward = 0;
                object.error = options.enums === String ? "success" : 0;
              }

              if (message.missionReward != null && message.hasOwnProperty("missionReward")) object.missionReward = message.missionReward;
              if (message.error != null && message.hasOwnProperty("error")) object.error = options.enums === String ? $root.missionProto.Error[message.error] : message.error;

              if (message.list && message.list.length) {
                object.list = [];

                for (var j = 0; j < message.list.length; ++j) {
                  object.list[j] = $root.missionProto.Reward.toObject(message.list[j], options);
                }
              }

              return object;
            };
            /**
             * Converts this MissionReportResponse to JSON.
             * @function toJSON
             * @memberof missionProto.MissionReportResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */


            MissionReportResponse.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MissionReportResponse;
          }();

          missionProto.DailyMissionDataReq = function () {
            /**
             * Properties of a DailyMissionDataReq.
             * @memberof missionProto
             * @interface IDailyMissionDataReq
             * @property {number|null} [accountID] DailyMissionDataReq accountID
             * @property {number|null} [apiID] DailyMissionDataReq apiID
             * @property {number|null} [gameID] DailyMissionDataReq gameID
             * @property {boolean|null} [isNow] DailyMissionDataReq isNow
             * @property {string|null} [lang] DailyMissionDataReq lang
             * @property {number|null} [currencyNumber] DailyMissionDataReq currencyNumber
             * @property {number|null} [siteID] DailyMissionDataReq siteID
             * @property {number|null} [subAgentCode] DailyMissionDataReq subAgentCode
             * @property {number|null} [ratio] DailyMissionDataReq ratio
             * @property {number|null} [rate] DailyMissionDataReq rate
             * @property {number|null} [gameType] DailyMissionDataReq gameType
             * @property {number|null} [property] DailyMissionDataReq property
             * @property {number|null} [level] DailyMissionDataReq level
             */

            /**
             * Constructs a new DailyMissionDataReq.
             * @memberof missionProto
             * @classdesc Represents a DailyMissionDataReq.
             * @implements IDailyMissionDataReq
             * @constructor
             * @param {missionProto.IDailyMissionDataReq=} [properties] Properties to set
             */
            function DailyMissionDataReq(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * DailyMissionDataReq accountID.
             * @member {number} accountID
             * @memberof missionProto.DailyMissionDataReq
             * @instance
             */


            DailyMissionDataReq.prototype.accountID = 0;
            /**
             * DailyMissionDataReq apiID.
             * @member {number} apiID
             * @memberof missionProto.DailyMissionDataReq
             * @instance
             */

            DailyMissionDataReq.prototype.apiID = 0;
            /**
             * DailyMissionDataReq gameID.
             * @member {number} gameID
             * @memberof missionProto.DailyMissionDataReq
             * @instance
             */

            DailyMissionDataReq.prototype.gameID = 0;
            /**
             * DailyMissionDataReq isNow.
             * @member {boolean} isNow
             * @memberof missionProto.DailyMissionDataReq
             * @instance
             */

            DailyMissionDataReq.prototype.isNow = false;
            /**
             * DailyMissionDataReq lang.
             * @member {string} lang
             * @memberof missionProto.DailyMissionDataReq
             * @instance
             */

            DailyMissionDataReq.prototype.lang = "";
            /**
             * DailyMissionDataReq currencyNumber.
             * @member {number} currencyNumber
             * @memberof missionProto.DailyMissionDataReq
             * @instance
             */

            DailyMissionDataReq.prototype.currencyNumber = 0;
            /**
             * DailyMissionDataReq siteID.
             * @member {number} siteID
             * @memberof missionProto.DailyMissionDataReq
             * @instance
             */

            DailyMissionDataReq.prototype.siteID = 0;
            /**
             * DailyMissionDataReq subAgentCode.
             * @member {number} subAgentCode
             * @memberof missionProto.DailyMissionDataReq
             * @instance
             */

            DailyMissionDataReq.prototype.subAgentCode = 0;
            /**
             * DailyMissionDataReq ratio.
             * @member {number} ratio
             * @memberof missionProto.DailyMissionDataReq
             * @instance
             */

            DailyMissionDataReq.prototype.ratio = 0;
            /**
             * DailyMissionDataReq rate.
             * @member {number} rate
             * @memberof missionProto.DailyMissionDataReq
             * @instance
             */

            DailyMissionDataReq.prototype.rate = 0;
            /**
             * DailyMissionDataReq gameType.
             * @member {number} gameType
             * @memberof missionProto.DailyMissionDataReq
             * @instance
             */

            DailyMissionDataReq.prototype.gameType = 0;
            /**
             * DailyMissionDataReq property.
             * @member {number} property
             * @memberof missionProto.DailyMissionDataReq
             * @instance
             */

            DailyMissionDataReq.prototype.property = 0;
            /**
             * DailyMissionDataReq level.
             * @member {number} level
             * @memberof missionProto.DailyMissionDataReq
             * @instance
             */

            DailyMissionDataReq.prototype.level = 0;
            /**
             * Creates a new DailyMissionDataReq instance using the specified properties.
             * @function create
             * @memberof missionProto.DailyMissionDataReq
             * @static
             * @param {missionProto.IDailyMissionDataReq=} [properties] Properties to set
             * @returns {missionProto.DailyMissionDataReq} DailyMissionDataReq instance
             */

            DailyMissionDataReq.create = function create(properties) {
              return new DailyMissionDataReq(properties);
            };
            /**
             * Encodes the specified DailyMissionDataReq message. Does not implicitly {@link missionProto.DailyMissionDataReq.verify|verify} messages.
             * @function encode
             * @memberof missionProto.DailyMissionDataReq
             * @static
             * @param {missionProto.IDailyMissionDataReq} message DailyMissionDataReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            DailyMissionDataReq.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.accountID != null && Object.hasOwnProperty.call(message, "accountID")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.accountID);
              if (message.apiID != null && Object.hasOwnProperty.call(message, "apiID")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).uint32(message.apiID);
              if (message.gameID != null && Object.hasOwnProperty.call(message, "gameID")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).uint32(message.gameID);
              if (message.isNow != null && Object.hasOwnProperty.call(message, "isNow")) writer.uint32(
              /* id 4, wireType 0 =*/
              32).bool(message.isNow);
              if (message.lang != null && Object.hasOwnProperty.call(message, "lang")) writer.uint32(
              /* id 5, wireType 2 =*/
              42).string(message.lang);
              if (message.currencyNumber != null && Object.hasOwnProperty.call(message, "currencyNumber")) writer.uint32(
              /* id 6, wireType 0 =*/
              48).int32(message.currencyNumber);
              if (message.siteID != null && Object.hasOwnProperty.call(message, "siteID")) writer.uint32(
              /* id 7, wireType 0 =*/
              56).uint32(message.siteID);
              if (message.subAgentCode != null && Object.hasOwnProperty.call(message, "subAgentCode")) writer.uint32(
              /* id 8, wireType 0 =*/
              64).int32(message.subAgentCode);
              if (message.ratio != null && Object.hasOwnProperty.call(message, "ratio")) writer.uint32(
              /* id 9, wireType 1 =*/
              73)["double"](message.ratio);
              if (message.rate != null && Object.hasOwnProperty.call(message, "rate")) writer.uint32(
              /* id 10, wireType 1 =*/
              81)["double"](message.rate);
              if (message.gameType != null && Object.hasOwnProperty.call(message, "gameType")) writer.uint32(
              /* id 11, wireType 0 =*/
              88).int32(message.gameType);
              if (message.property != null && Object.hasOwnProperty.call(message, "property")) writer.uint32(
              /* id 12, wireType 1 =*/
              97)["double"](message.property);
              if (message.level != null && Object.hasOwnProperty.call(message, "level")) writer.uint32(
              /* id 13, wireType 0 =*/
              104).int32(message.level);
              return writer;
            };
            /**
             * Encodes the specified DailyMissionDataReq message, length delimited. Does not implicitly {@link missionProto.DailyMissionDataReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof missionProto.DailyMissionDataReq
             * @static
             * @param {missionProto.IDailyMissionDataReq} message DailyMissionDataReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            DailyMissionDataReq.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a DailyMissionDataReq message from the specified reader or buffer.
             * @function decode
             * @memberof missionProto.DailyMissionDataReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {missionProto.DailyMissionDataReq} DailyMissionDataReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            DailyMissionDataReq.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.missionProto.DailyMissionDataReq();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.accountID = reader.int32();
                    break;

                  case 2:
                    message.apiID = reader.uint32();
                    break;

                  case 3:
                    message.gameID = reader.uint32();
                    break;

                  case 4:
                    message.isNow = reader.bool();
                    break;

                  case 5:
                    message.lang = reader.string();
                    break;

                  case 6:
                    message.currencyNumber = reader.int32();
                    break;

                  case 7:
                    message.siteID = reader.uint32();
                    break;

                  case 8:
                    message.subAgentCode = reader.int32();
                    break;

                  case 9:
                    message.ratio = reader["double"]();
                    break;

                  case 10:
                    message.rate = reader["double"]();
                    break;

                  case 11:
                    message.gameType = reader.int32();
                    break;

                  case 12:
                    message.property = reader["double"]();
                    break;

                  case 13:
                    message.level = reader.int32();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
             * Decodes a DailyMissionDataReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof missionProto.DailyMissionDataReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {missionProto.DailyMissionDataReq} DailyMissionDataReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            DailyMissionDataReq.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a DailyMissionDataReq message.
             * @function verify
             * @memberof missionProto.DailyMissionDataReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */


            DailyMissionDataReq.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.accountID != null && message.hasOwnProperty("accountID")) if (!$util.isInteger(message.accountID)) return "accountID: integer expected";
              if (message.apiID != null && message.hasOwnProperty("apiID")) if (!$util.isInteger(message.apiID)) return "apiID: integer expected";
              if (message.gameID != null && message.hasOwnProperty("gameID")) if (!$util.isInteger(message.gameID)) return "gameID: integer expected";
              if (message.isNow != null && message.hasOwnProperty("isNow")) if (typeof message.isNow !== "boolean") return "isNow: boolean expected";
              if (message.lang != null && message.hasOwnProperty("lang")) if (!$util.isString(message.lang)) return "lang: string expected";
              if (message.currencyNumber != null && message.hasOwnProperty("currencyNumber")) if (!$util.isInteger(message.currencyNumber)) return "currencyNumber: integer expected";
              if (message.siteID != null && message.hasOwnProperty("siteID")) if (!$util.isInteger(message.siteID)) return "siteID: integer expected";
              if (message.subAgentCode != null && message.hasOwnProperty("subAgentCode")) if (!$util.isInteger(message.subAgentCode)) return "subAgentCode: integer expected";
              if (message.ratio != null && message.hasOwnProperty("ratio")) if (typeof message.ratio !== "number") return "ratio: number expected";
              if (message.rate != null && message.hasOwnProperty("rate")) if (typeof message.rate !== "number") return "rate: number expected";
              if (message.gameType != null && message.hasOwnProperty("gameType")) if (!$util.isInteger(message.gameType)) return "gameType: integer expected";
              if (message.property != null && message.hasOwnProperty("property")) if (typeof message.property !== "number") return "property: number expected";
              if (message.level != null && message.hasOwnProperty("level")) if (!$util.isInteger(message.level)) return "level: integer expected";
              return null;
            };
            /**
             * Creates a DailyMissionDataReq message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof missionProto.DailyMissionDataReq
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {missionProto.DailyMissionDataReq} DailyMissionDataReq
             */


            DailyMissionDataReq.fromObject = function fromObject(object) {
              if (object instanceof $root.missionProto.DailyMissionDataReq) return object;
              var message = new $root.missionProto.DailyMissionDataReq();
              if (object.accountID != null) message.accountID = object.accountID | 0;
              if (object.apiID != null) message.apiID = object.apiID >>> 0;
              if (object.gameID != null) message.gameID = object.gameID >>> 0;
              if (object.isNow != null) message.isNow = Boolean(object.isNow);
              if (object.lang != null) message.lang = String(object.lang);
              if (object.currencyNumber != null) message.currencyNumber = object.currencyNumber | 0;
              if (object.siteID != null) message.siteID = object.siteID >>> 0;
              if (object.subAgentCode != null) message.subAgentCode = object.subAgentCode | 0;
              if (object.ratio != null) message.ratio = Number(object.ratio);
              if (object.rate != null) message.rate = Number(object.rate);
              if (object.gameType != null) message.gameType = object.gameType | 0;
              if (object.property != null) message.property = Number(object.property);
              if (object.level != null) message.level = object.level | 0;
              return message;
            };
            /**
             * Creates a plain object from a DailyMissionDataReq message. Also converts values to other types if specified.
             * @function toObject
             * @memberof missionProto.DailyMissionDataReq
             * @static
             * @param {missionProto.DailyMissionDataReq} message DailyMissionDataReq
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */


            DailyMissionDataReq.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.accountID = 0;
                object.apiID = 0;
                object.gameID = 0;
                object.isNow = false;
                object.lang = "";
                object.currencyNumber = 0;
                object.siteID = 0;
                object.subAgentCode = 0;
                object.ratio = 0;
                object.rate = 0;
                object.gameType = 0;
                object.property = 0;
                object.level = 0;
              }

              if (message.accountID != null && message.hasOwnProperty("accountID")) object.accountID = message.accountID;
              if (message.apiID != null && message.hasOwnProperty("apiID")) object.apiID = message.apiID;
              if (message.gameID != null && message.hasOwnProperty("gameID")) object.gameID = message.gameID;
              if (message.isNow != null && message.hasOwnProperty("isNow")) object.isNow = message.isNow;
              if (message.lang != null && message.hasOwnProperty("lang")) object.lang = message.lang;
              if (message.currencyNumber != null && message.hasOwnProperty("currencyNumber")) object.currencyNumber = message.currencyNumber;
              if (message.siteID != null && message.hasOwnProperty("siteID")) object.siteID = message.siteID;
              if (message.subAgentCode != null && message.hasOwnProperty("subAgentCode")) object.subAgentCode = message.subAgentCode;
              if (message.ratio != null && message.hasOwnProperty("ratio")) object.ratio = options.json && !isFinite(message.ratio) ? String(message.ratio) : message.ratio;
              if (message.rate != null && message.hasOwnProperty("rate")) object.rate = options.json && !isFinite(message.rate) ? String(message.rate) : message.rate;
              if (message.gameType != null && message.hasOwnProperty("gameType")) object.gameType = message.gameType;
              if (message.property != null && message.hasOwnProperty("property")) object.property = options.json && !isFinite(message.property) ? String(message.property) : message.property;
              if (message.level != null && message.hasOwnProperty("level")) object.level = message.level;
              return object;
            };
            /**
             * Converts this DailyMissionDataReq to JSON.
             * @function toJSON
             * @memberof missionProto.DailyMissionDataReq
             * @instance
             * @returns {Object.<string,*>} JSON object
             */


            DailyMissionDataReq.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DailyMissionDataReq;
          }();

          missionProto.DailyMissionDataResponse = function () {
            /**
             * Properties of a DailyMissionDataResponse.
             * @memberof missionProto
             * @interface IDailyMissionDataResponse
             * @property {string|null} [message] DailyMissionDataResponse message
             * @property {missionProto.Error|null} [error] DailyMissionDataResponse error
             * @property {number|null} [missionReward] DailyMissionDataResponse missionReward
             * @property {Uint8Array|null} [messageb] DailyMissionDataResponse messageb
             * @property {Array.<missionProto.IReward>|null} [list] DailyMissionDataResponse list
             */

            /**
             * Constructs a new DailyMissionDataResponse.
             * @memberof missionProto
             * @classdesc Represents a DailyMissionDataResponse.
             * @implements IDailyMissionDataResponse
             * @constructor
             * @param {missionProto.IDailyMissionDataResponse=} [properties] Properties to set
             */
            function DailyMissionDataResponse(properties) {
              this.list = [];
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * DailyMissionDataResponse message.
             * @member {string} message
             * @memberof missionProto.DailyMissionDataResponse
             * @instance
             */


            DailyMissionDataResponse.prototype.message = "";
            /**
             * DailyMissionDataResponse error.
             * @member {missionProto.Error} error
             * @memberof missionProto.DailyMissionDataResponse
             * @instance
             */

            DailyMissionDataResponse.prototype.error = 0;
            /**
             * DailyMissionDataResponse missionReward.
             * @member {number} missionReward
             * @memberof missionProto.DailyMissionDataResponse
             * @instance
             */

            DailyMissionDataResponse.prototype.missionReward = 0;
            /**
             * DailyMissionDataResponse messageb.
             * @member {Uint8Array} messageb
             * @memberof missionProto.DailyMissionDataResponse
             * @instance
             */

            DailyMissionDataResponse.prototype.messageb = $util.newBuffer([]);
            /**
             * DailyMissionDataResponse list.
             * @member {Array.<missionProto.IReward>} list
             * @memberof missionProto.DailyMissionDataResponse
             * @instance
             */

            DailyMissionDataResponse.prototype.list = $util.emptyArray;
            /**
             * Creates a new DailyMissionDataResponse instance using the specified properties.
             * @function create
             * @memberof missionProto.DailyMissionDataResponse
             * @static
             * @param {missionProto.IDailyMissionDataResponse=} [properties] Properties to set
             * @returns {missionProto.DailyMissionDataResponse} DailyMissionDataResponse instance
             */

            DailyMissionDataResponse.create = function create(properties) {
              return new DailyMissionDataResponse(properties);
            };
            /**
             * Encodes the specified DailyMissionDataResponse message. Does not implicitly {@link missionProto.DailyMissionDataResponse.verify|verify} messages.
             * @function encode
             * @memberof missionProto.DailyMissionDataResponse
             * @static
             * @param {missionProto.IDailyMissionDataResponse} message DailyMissionDataResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            DailyMissionDataResponse.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.message != null && Object.hasOwnProperty.call(message, "message")) writer.uint32(
              /* id 1, wireType 2 =*/
              10).string(message.message);
              if (message.error != null && Object.hasOwnProperty.call(message, "error")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int32(message.error);
              if (message.missionReward != null && Object.hasOwnProperty.call(message, "missionReward")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).uint32(message.missionReward);
              if (message.messageb != null && Object.hasOwnProperty.call(message, "messageb")) writer.uint32(
              /* id 4, wireType 2 =*/
              34).bytes(message.messageb);
              if (message.list != null && message.list.length) for (var i = 0; i < message.list.length; ++i) {
                $root.missionProto.Reward.encode(message.list[i], writer.uint32(
                /* id 5, wireType 2 =*/
                42).fork()).ldelim();
              }
              return writer;
            };
            /**
             * Encodes the specified DailyMissionDataResponse message, length delimited. Does not implicitly {@link missionProto.DailyMissionDataResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof missionProto.DailyMissionDataResponse
             * @static
             * @param {missionProto.IDailyMissionDataResponse} message DailyMissionDataResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            DailyMissionDataResponse.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a DailyMissionDataResponse message from the specified reader or buffer.
             * @function decode
             * @memberof missionProto.DailyMissionDataResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {missionProto.DailyMissionDataResponse} DailyMissionDataResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            DailyMissionDataResponse.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.missionProto.DailyMissionDataResponse();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.message = reader.string();
                    break;

                  case 2:
                    message.error = reader.int32();
                    break;

                  case 3:
                    message.missionReward = reader.uint32();
                    break;

                  case 4:
                    message.messageb = reader.bytes();
                    break;

                  case 5:
                    if (!(message.list && message.list.length)) message.list = [];
                    message.list.push($root.missionProto.Reward.decode(reader, reader.uint32()));
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
             * Decodes a DailyMissionDataResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof missionProto.DailyMissionDataResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {missionProto.DailyMissionDataResponse} DailyMissionDataResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            DailyMissionDataResponse.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a DailyMissionDataResponse message.
             * @function verify
             * @memberof missionProto.DailyMissionDataResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */


            DailyMissionDataResponse.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.message != null && message.hasOwnProperty("message")) if (!$util.isString(message.message)) return "message: string expected";
              if (message.error != null && message.hasOwnProperty("error")) switch (message.error) {
                default:
                  return "error: enum value expected";

                case 0:
                case 1:
                case 999:
                  break;
              }
              if (message.missionReward != null && message.hasOwnProperty("missionReward")) if (!$util.isInteger(message.missionReward)) return "missionReward: integer expected";
              if (message.messageb != null && message.hasOwnProperty("messageb")) if (!(message.messageb && typeof message.messageb.length === "number" || $util.isString(message.messageb))) return "messageb: buffer expected";

              if (message.list != null && message.hasOwnProperty("list")) {
                if (!Array.isArray(message.list)) return "list: array expected";

                for (var i = 0; i < message.list.length; ++i) {
                  var error = $root.missionProto.Reward.verify(message.list[i]);
                  if (error) return "list." + error;
                }
              }

              return null;
            };
            /**
             * Creates a DailyMissionDataResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof missionProto.DailyMissionDataResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {missionProto.DailyMissionDataResponse} DailyMissionDataResponse
             */


            DailyMissionDataResponse.fromObject = function fromObject(object) {
              if (object instanceof $root.missionProto.DailyMissionDataResponse) return object;
              var message = new $root.missionProto.DailyMissionDataResponse();
              if (object.message != null) message.message = String(object.message);

              switch (object.error) {
                case "success":
                case 0:
                  message.error = 0;
                  break;

                case "failed":
                case 1:
                  message.error = 1;
                  break;

                case "unknow":
                case 999:
                  message.error = 999;
                  break;
              }

              if (object.missionReward != null) message.missionReward = object.missionReward >>> 0;
              if (object.messageb != null) if (typeof object.messageb === "string") $util.base64.decode(object.messageb, message.messageb = $util.newBuffer($util.base64.length(object.messageb)), 0);else if (object.messageb.length) message.messageb = object.messageb;

              if (object.list) {
                if (!Array.isArray(object.list)) throw TypeError(".missionProto.DailyMissionDataResponse.list: array expected");
                message.list = [];

                for (var i = 0; i < object.list.length; ++i) {
                  if (typeof object.list[i] !== "object") throw TypeError(".missionProto.DailyMissionDataResponse.list: object expected");
                  message.list[i] = $root.missionProto.Reward.fromObject(object.list[i]);
                }
              }

              return message;
            };
            /**
             * Creates a plain object from a DailyMissionDataResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof missionProto.DailyMissionDataResponse
             * @static
             * @param {missionProto.DailyMissionDataResponse} message DailyMissionDataResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */


            DailyMissionDataResponse.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};
              if (options.arrays || options.defaults) object.list = [];

              if (options.defaults) {
                object.message = "";
                object.error = options.enums === String ? "success" : 0;
                object.missionReward = 0;
                if (options.bytes === String) object.messageb = "";else {
                  object.messageb = [];
                  if (options.bytes !== Array) object.messageb = $util.newBuffer(object.messageb);
                }
              }

              if (message.message != null && message.hasOwnProperty("message")) object.message = message.message;
              if (message.error != null && message.hasOwnProperty("error")) object.error = options.enums === String ? $root.missionProto.Error[message.error] : message.error;
              if (message.missionReward != null && message.hasOwnProperty("missionReward")) object.missionReward = message.missionReward;
              if (message.messageb != null && message.hasOwnProperty("messageb")) object.messageb = options.bytes === String ? $util.base64.encode(message.messageb, 0, message.messageb.length) : options.bytes === Array ? Array.prototype.slice.call(message.messageb) : message.messageb;

              if (message.list && message.list.length) {
                object.list = [];

                for (var j = 0; j < message.list.length; ++j) {
                  object.list[j] = $root.missionProto.Reward.toObject(message.list[j], options);
                }
              }

              return object;
            };
            /**
             * Converts this DailyMissionDataResponse to JSON.
             * @function toJSON
             * @memberof missionProto.DailyMissionDataResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */


            DailyMissionDataResponse.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DailyMissionDataResponse;
          }();

          missionProto.DailyMissionInfo = function () {
            /**
             * Properties of a DailyMissionInfo.
             * @memberof missionProto
             * @interface IDailyMissionInfo
             * @property {string|null} [Desc] DailyMissionInfo Desc
             * @property {string|null} [StartTime] DailyMissionInfo StartTime
             * @property {string|null} [EndTime] DailyMissionInfo EndTime
             * @property {string|null} [StartTimestamp] DailyMissionInfo StartTimestamp
             * @property {string|null} [EndTimestamp] DailyMissionInfo EndTimestamp
             * @property {string|null} [CurrentDate] DailyMissionInfo CurrentDate
             * @property {number|null} [OverDay] DailyMissionInfo OverDay
             * @property {number|null} [OverDayMin] DailyMissionInfo OverDayMin
             * @property {Array.<missionProto.IDailyMissionData>|null} [DailyMissionList] DailyMissionInfo DailyMissionList
             * @property {Object.<string,missionProto.IItemCard>|null} [ItemInfo] DailyMissionInfo ItemInfo
             * @property {Array.<number>|null} [NextGameIDList] DailyMissionInfo NextGameIDList
             * @property {Object.<string,missionProto.IGiftPack>|null} [GiftInfo] DailyMissionInfo GiftInfo
             */

            /**
             * Constructs a new DailyMissionInfo.
             * @memberof missionProto
             * @classdesc Represents a DailyMissionInfo.
             * @implements IDailyMissionInfo
             * @constructor
             * @param {missionProto.IDailyMissionInfo=} [properties] Properties to set
             */
            function DailyMissionInfo(properties) {
              this.DailyMissionList = [];
              this.ItemInfo = {};
              this.NextGameIDList = [];
              this.GiftInfo = {};
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * DailyMissionInfo Desc.
             * @member {string} Desc
             * @memberof missionProto.DailyMissionInfo
             * @instance
             */


            DailyMissionInfo.prototype.Desc = "";
            /**
             * DailyMissionInfo StartTime.
             * @member {string} StartTime
             * @memberof missionProto.DailyMissionInfo
             * @instance
             */

            DailyMissionInfo.prototype.StartTime = "";
            /**
             * DailyMissionInfo EndTime.
             * @member {string} EndTime
             * @memberof missionProto.DailyMissionInfo
             * @instance
             */

            DailyMissionInfo.prototype.EndTime = "";
            /**
             * DailyMissionInfo StartTimestamp.
             * @member {string} StartTimestamp
             * @memberof missionProto.DailyMissionInfo
             * @instance
             */

            DailyMissionInfo.prototype.StartTimestamp = "";
            /**
             * DailyMissionInfo EndTimestamp.
             * @member {string} EndTimestamp
             * @memberof missionProto.DailyMissionInfo
             * @instance
             */

            DailyMissionInfo.prototype.EndTimestamp = "";
            /**
             * DailyMissionInfo CurrentDate.
             * @member {string} CurrentDate
             * @memberof missionProto.DailyMissionInfo
             * @instance
             */

            DailyMissionInfo.prototype.CurrentDate = "";
            /**
             * DailyMissionInfo OverDay.
             * @member {number} OverDay
             * @memberof missionProto.DailyMissionInfo
             * @instance
             */

            DailyMissionInfo.prototype.OverDay = 0;
            /**
             * DailyMissionInfo OverDayMin.
             * @member {number} OverDayMin
             * @memberof missionProto.DailyMissionInfo
             * @instance
             */

            DailyMissionInfo.prototype.OverDayMin = 0;
            /**
             * DailyMissionInfo DailyMissionList.
             * @member {Array.<missionProto.IDailyMissionData>} DailyMissionList
             * @memberof missionProto.DailyMissionInfo
             * @instance
             */

            DailyMissionInfo.prototype.DailyMissionList = $util.emptyArray;
            /**
             * DailyMissionInfo ItemInfo.
             * @member {Object.<string,missionProto.IItemCard>} ItemInfo
             * @memberof missionProto.DailyMissionInfo
             * @instance
             */

            DailyMissionInfo.prototype.ItemInfo = $util.emptyObject;
            /**
             * DailyMissionInfo NextGameIDList.
             * @member {Array.<number>} NextGameIDList
             * @memberof missionProto.DailyMissionInfo
             * @instance
             */

            DailyMissionInfo.prototype.NextGameIDList = $util.emptyArray;
            /**
             * DailyMissionInfo GiftInfo.
             * @member {Object.<string,missionProto.IGiftPack>} GiftInfo
             * @memberof missionProto.DailyMissionInfo
             * @instance
             */

            DailyMissionInfo.prototype.GiftInfo = $util.emptyObject;
            /**
             * Creates a new DailyMissionInfo instance using the specified properties.
             * @function create
             * @memberof missionProto.DailyMissionInfo
             * @static
             * @param {missionProto.IDailyMissionInfo=} [properties] Properties to set
             * @returns {missionProto.DailyMissionInfo} DailyMissionInfo instance
             */

            DailyMissionInfo.create = function create(properties) {
              return new DailyMissionInfo(properties);
            };
            /**
             * Encodes the specified DailyMissionInfo message. Does not implicitly {@link missionProto.DailyMissionInfo.verify|verify} messages.
             * @function encode
             * @memberof missionProto.DailyMissionInfo
             * @static
             * @param {missionProto.IDailyMissionInfo} message DailyMissionInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            DailyMissionInfo.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.Desc != null && Object.hasOwnProperty.call(message, "Desc")) writer.uint32(
              /* id 1, wireType 2 =*/
              10).string(message.Desc);
              if (message.StartTime != null && Object.hasOwnProperty.call(message, "StartTime")) writer.uint32(
              /* id 2, wireType 2 =*/
              18).string(message.StartTime);
              if (message.EndTime != null && Object.hasOwnProperty.call(message, "EndTime")) writer.uint32(
              /* id 3, wireType 2 =*/
              26).string(message.EndTime);
              if (message.StartTimestamp != null && Object.hasOwnProperty.call(message, "StartTimestamp")) writer.uint32(
              /* id 4, wireType 2 =*/
              34).string(message.StartTimestamp);
              if (message.EndTimestamp != null && Object.hasOwnProperty.call(message, "EndTimestamp")) writer.uint32(
              /* id 5, wireType 2 =*/
              42).string(message.EndTimestamp);
              if (message.CurrentDate != null && Object.hasOwnProperty.call(message, "CurrentDate")) writer.uint32(
              /* id 6, wireType 2 =*/
              50).string(message.CurrentDate);
              if (message.OverDay != null && Object.hasOwnProperty.call(message, "OverDay")) writer.uint32(
              /* id 7, wireType 0 =*/
              56).int32(message.OverDay);
              if (message.OverDayMin != null && Object.hasOwnProperty.call(message, "OverDayMin")) writer.uint32(
              /* id 8, wireType 0 =*/
              64).int32(message.OverDayMin);
              if (message.DailyMissionList != null && message.DailyMissionList.length) for (var i = 0; i < message.DailyMissionList.length; ++i) {
                $root.missionProto.DailyMissionData.encode(message.DailyMissionList[i], writer.uint32(
                /* id 9, wireType 2 =*/
                74).fork()).ldelim();
              }
              if (message.ItemInfo != null && Object.hasOwnProperty.call(message, "ItemInfo")) for (var keys = Object.keys(message.ItemInfo), i = 0; i < keys.length; ++i) {
                writer.uint32(
                /* id 10, wireType 2 =*/
                82).fork().uint32(
                /* id 1, wireType 0 =*/
                8).uint32(keys[i]);
                $root.missionProto.ItemCard.encode(message.ItemInfo[keys[i]], writer.uint32(
                /* id 2, wireType 2 =*/
                18).fork()).ldelim().ldelim();
              }

              if (message.NextGameIDList != null && message.NextGameIDList.length) {
                writer.uint32(
                /* id 11, wireType 2 =*/
                90).fork();

                for (var i = 0; i < message.NextGameIDList.length; ++i) {
                  writer.int32(message.NextGameIDList[i]);
                }

                writer.ldelim();
              }

              if (message.GiftInfo != null && Object.hasOwnProperty.call(message, "GiftInfo")) for (var keys = Object.keys(message.GiftInfo), i = 0; i < keys.length; ++i) {
                writer.uint32(
                /* id 12, wireType 2 =*/
                98).fork().uint32(
                /* id 1, wireType 0 =*/
                8).uint32(keys[i]);
                $root.missionProto.GiftPack.encode(message.GiftInfo[keys[i]], writer.uint32(
                /* id 2, wireType 2 =*/
                18).fork()).ldelim().ldelim();
              }
              return writer;
            };
            /**
             * Encodes the specified DailyMissionInfo message, length delimited. Does not implicitly {@link missionProto.DailyMissionInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof missionProto.DailyMissionInfo
             * @static
             * @param {missionProto.IDailyMissionInfo} message DailyMissionInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            DailyMissionInfo.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a DailyMissionInfo message from the specified reader or buffer.
             * @function decode
             * @memberof missionProto.DailyMissionInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {missionProto.DailyMissionInfo} DailyMissionInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            DailyMissionInfo.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.missionProto.DailyMissionInfo(),
                  key,
                  value;

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.Desc = reader.string();
                    break;

                  case 2:
                    message.StartTime = reader.string();
                    break;

                  case 3:
                    message.EndTime = reader.string();
                    break;

                  case 4:
                    message.StartTimestamp = reader.string();
                    break;

                  case 5:
                    message.EndTimestamp = reader.string();
                    break;

                  case 6:
                    message.CurrentDate = reader.string();
                    break;

                  case 7:
                    message.OverDay = reader.int32();
                    break;

                  case 8:
                    message.OverDayMin = reader.int32();
                    break;

                  case 9:
                    if (!(message.DailyMissionList && message.DailyMissionList.length)) message.DailyMissionList = [];
                    message.DailyMissionList.push($root.missionProto.DailyMissionData.decode(reader, reader.uint32()));
                    break;

                  case 10:
                    if (message.ItemInfo === $util.emptyObject) message.ItemInfo = {};
                    var end2 = reader.uint32() + reader.pos;
                    key = 0;
                    value = null;

                    while (reader.pos < end2) {
                      var tag2 = reader.uint32();

                      switch (tag2 >>> 3) {
                        case 1:
                          key = reader.uint32();
                          break;

                        case 2:
                          value = $root.missionProto.ItemCard.decode(reader, reader.uint32());
                          break;

                        default:
                          reader.skipType(tag2 & 7);
                          break;
                      }
                    }

                    message.ItemInfo[key] = value;
                    break;

                  case 11:
                    if (!(message.NextGameIDList && message.NextGameIDList.length)) message.NextGameIDList = [];

                    if ((tag & 7) === 2) {
                      var end2 = reader.uint32() + reader.pos;

                      while (reader.pos < end2) {
                        message.NextGameIDList.push(reader.int32());
                      }
                    } else message.NextGameIDList.push(reader.int32());

                    break;

                  case 12:
                    if (message.GiftInfo === $util.emptyObject) message.GiftInfo = {};
                    var end2 = reader.uint32() + reader.pos;
                    key = 0;
                    value = null;

                    while (reader.pos < end2) {
                      var tag2 = reader.uint32();

                      switch (tag2 >>> 3) {
                        case 1:
                          key = reader.uint32();
                          break;

                        case 2:
                          value = $root.missionProto.GiftPack.decode(reader, reader.uint32());
                          break;

                        default:
                          reader.skipType(tag2 & 7);
                          break;
                      }
                    }

                    message.GiftInfo[key] = value;
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
             * Decodes a DailyMissionInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof missionProto.DailyMissionInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {missionProto.DailyMissionInfo} DailyMissionInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            DailyMissionInfo.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a DailyMissionInfo message.
             * @function verify
             * @memberof missionProto.DailyMissionInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */


            DailyMissionInfo.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.Desc != null && message.hasOwnProperty("Desc")) if (!$util.isString(message.Desc)) return "Desc: string expected";
              if (message.StartTime != null && message.hasOwnProperty("StartTime")) if (!$util.isString(message.StartTime)) return "StartTime: string expected";
              if (message.EndTime != null && message.hasOwnProperty("EndTime")) if (!$util.isString(message.EndTime)) return "EndTime: string expected";
              if (message.StartTimestamp != null && message.hasOwnProperty("StartTimestamp")) if (!$util.isString(message.StartTimestamp)) return "StartTimestamp: string expected";
              if (message.EndTimestamp != null && message.hasOwnProperty("EndTimestamp")) if (!$util.isString(message.EndTimestamp)) return "EndTimestamp: string expected";
              if (message.CurrentDate != null && message.hasOwnProperty("CurrentDate")) if (!$util.isString(message.CurrentDate)) return "CurrentDate: string expected";
              if (message.OverDay != null && message.hasOwnProperty("OverDay")) if (!$util.isInteger(message.OverDay)) return "OverDay: integer expected";
              if (message.OverDayMin != null && message.hasOwnProperty("OverDayMin")) if (!$util.isInteger(message.OverDayMin)) return "OverDayMin: integer expected";

              if (message.DailyMissionList != null && message.hasOwnProperty("DailyMissionList")) {
                if (!Array.isArray(message.DailyMissionList)) return "DailyMissionList: array expected";

                for (var i = 0; i < message.DailyMissionList.length; ++i) {
                  var error = $root.missionProto.DailyMissionData.verify(message.DailyMissionList[i]);
                  if (error) return "DailyMissionList." + error;
                }
              }

              if (message.ItemInfo != null && message.hasOwnProperty("ItemInfo")) {
                if (!$util.isObject(message.ItemInfo)) return "ItemInfo: object expected";
                var key = Object.keys(message.ItemInfo);

                for (var i = 0; i < key.length; ++i) {
                  if (!$util.key32Re.test(key[i])) return "ItemInfo: integer key{k:uint32} expected";
                  {
                    var error = $root.missionProto.ItemCard.verify(message.ItemInfo[key[i]]);
                    if (error) return "ItemInfo." + error;
                  }
                }
              }

              if (message.NextGameIDList != null && message.hasOwnProperty("NextGameIDList")) {
                if (!Array.isArray(message.NextGameIDList)) return "NextGameIDList: array expected";

                for (var i = 0; i < message.NextGameIDList.length; ++i) {
                  if (!$util.isInteger(message.NextGameIDList[i])) return "NextGameIDList: integer[] expected";
                }
              }

              if (message.GiftInfo != null && message.hasOwnProperty("GiftInfo")) {
                if (!$util.isObject(message.GiftInfo)) return "GiftInfo: object expected";
                var key = Object.keys(message.GiftInfo);

                for (var i = 0; i < key.length; ++i) {
                  if (!$util.key32Re.test(key[i])) return "GiftInfo: integer key{k:uint32} expected";
                  {
                    var error = $root.missionProto.GiftPack.verify(message.GiftInfo[key[i]]);
                    if (error) return "GiftInfo." + error;
                  }
                }
              }

              return null;
            };
            /**
             * Creates a DailyMissionInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof missionProto.DailyMissionInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {missionProto.DailyMissionInfo} DailyMissionInfo
             */


            DailyMissionInfo.fromObject = function fromObject(object) {
              if (object instanceof $root.missionProto.DailyMissionInfo) return object;
              var message = new $root.missionProto.DailyMissionInfo();
              if (object.Desc != null) message.Desc = String(object.Desc);
              if (object.StartTime != null) message.StartTime = String(object.StartTime);
              if (object.EndTime != null) message.EndTime = String(object.EndTime);
              if (object.StartTimestamp != null) message.StartTimestamp = String(object.StartTimestamp);
              if (object.EndTimestamp != null) message.EndTimestamp = String(object.EndTimestamp);
              if (object.CurrentDate != null) message.CurrentDate = String(object.CurrentDate);
              if (object.OverDay != null) message.OverDay = object.OverDay | 0;
              if (object.OverDayMin != null) message.OverDayMin = object.OverDayMin | 0;

              if (object.DailyMissionList) {
                if (!Array.isArray(object.DailyMissionList)) throw TypeError(".missionProto.DailyMissionInfo.DailyMissionList: array expected");
                message.DailyMissionList = [];

                for (var i = 0; i < object.DailyMissionList.length; ++i) {
                  if (typeof object.DailyMissionList[i] !== "object") throw TypeError(".missionProto.DailyMissionInfo.DailyMissionList: object expected");
                  message.DailyMissionList[i] = $root.missionProto.DailyMissionData.fromObject(object.DailyMissionList[i]);
                }
              }

              if (object.ItemInfo) {
                if (typeof object.ItemInfo !== "object") throw TypeError(".missionProto.DailyMissionInfo.ItemInfo: object expected");
                message.ItemInfo = {};

                for (var keys = Object.keys(object.ItemInfo), i = 0; i < keys.length; ++i) {
                  if (typeof object.ItemInfo[keys[i]] !== "object") throw TypeError(".missionProto.DailyMissionInfo.ItemInfo: object expected");
                  message.ItemInfo[keys[i]] = $root.missionProto.ItemCard.fromObject(object.ItemInfo[keys[i]]);
                }
              }

              if (object.NextGameIDList) {
                if (!Array.isArray(object.NextGameIDList)) throw TypeError(".missionProto.DailyMissionInfo.NextGameIDList: array expected");
                message.NextGameIDList = [];

                for (var i = 0; i < object.NextGameIDList.length; ++i) {
                  message.NextGameIDList[i] = object.NextGameIDList[i] | 0;
                }
              }

              if (object.GiftInfo) {
                if (typeof object.GiftInfo !== "object") throw TypeError(".missionProto.DailyMissionInfo.GiftInfo: object expected");
                message.GiftInfo = {};

                for (var keys = Object.keys(object.GiftInfo), i = 0; i < keys.length; ++i) {
                  if (typeof object.GiftInfo[keys[i]] !== "object") throw TypeError(".missionProto.DailyMissionInfo.GiftInfo: object expected");
                  message.GiftInfo[keys[i]] = $root.missionProto.GiftPack.fromObject(object.GiftInfo[keys[i]]);
                }
              }

              return message;
            };
            /**
             * Creates a plain object from a DailyMissionInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof missionProto.DailyMissionInfo
             * @static
             * @param {missionProto.DailyMissionInfo} message DailyMissionInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */


            DailyMissionInfo.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.arrays || options.defaults) {
                object.DailyMissionList = [];
                object.NextGameIDList = [];
              }

              if (options.objects || options.defaults) {
                object.ItemInfo = {};
                object.GiftInfo = {};
              }

              if (options.defaults) {
                object.Desc = "";
                object.StartTime = "";
                object.EndTime = "";
                object.StartTimestamp = "";
                object.EndTimestamp = "";
                object.CurrentDate = "";
                object.OverDay = 0;
                object.OverDayMin = 0;
              }

              if (message.Desc != null && message.hasOwnProperty("Desc")) object.Desc = message.Desc;
              if (message.StartTime != null && message.hasOwnProperty("StartTime")) object.StartTime = message.StartTime;
              if (message.EndTime != null && message.hasOwnProperty("EndTime")) object.EndTime = message.EndTime;
              if (message.StartTimestamp != null && message.hasOwnProperty("StartTimestamp")) object.StartTimestamp = message.StartTimestamp;
              if (message.EndTimestamp != null && message.hasOwnProperty("EndTimestamp")) object.EndTimestamp = message.EndTimestamp;
              if (message.CurrentDate != null && message.hasOwnProperty("CurrentDate")) object.CurrentDate = message.CurrentDate;
              if (message.OverDay != null && message.hasOwnProperty("OverDay")) object.OverDay = message.OverDay;
              if (message.OverDayMin != null && message.hasOwnProperty("OverDayMin")) object.OverDayMin = message.OverDayMin;

              if (message.DailyMissionList && message.DailyMissionList.length) {
                object.DailyMissionList = [];

                for (var j = 0; j < message.DailyMissionList.length; ++j) {
                  object.DailyMissionList[j] = $root.missionProto.DailyMissionData.toObject(message.DailyMissionList[j], options);
                }
              }

              var keys2;

              if (message.ItemInfo && (keys2 = Object.keys(message.ItemInfo)).length) {
                object.ItemInfo = {};

                for (var j = 0; j < keys2.length; ++j) {
                  object.ItemInfo[keys2[j]] = $root.missionProto.ItemCard.toObject(message.ItemInfo[keys2[j]], options);
                }
              }

              if (message.NextGameIDList && message.NextGameIDList.length) {
                object.NextGameIDList = [];

                for (var j = 0; j < message.NextGameIDList.length; ++j) {
                  object.NextGameIDList[j] = message.NextGameIDList[j];
                }
              }

              if (message.GiftInfo && (keys2 = Object.keys(message.GiftInfo)).length) {
                object.GiftInfo = {};

                for (var j = 0; j < keys2.length; ++j) {
                  object.GiftInfo[keys2[j]] = $root.missionProto.GiftPack.toObject(message.GiftInfo[keys2[j]], options);
                }
              }

              return object;
            };
            /**
             * Converts this DailyMissionInfo to JSON.
             * @function toJSON
             * @memberof missionProto.DailyMissionInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */


            DailyMissionInfo.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DailyMissionInfo;
          }();

          missionProto.DailyMissionData = function () {
            /**
             * Properties of a DailyMissionData.
             * @memberof missionProto
             * @interface IDailyMissionData
             * @property {string|null} [Date] DailyMissionData Date
             * @property {string|null} [ConditionDesc] DailyMissionData ConditionDesc
             * @property {number|null} [CurrentCount] DailyMissionData CurrentCount
             * @property {number|null} [TotalCount] DailyMissionData TotalCount
             * @property {number|null} [ItemID] DailyMissionData ItemID
             * @property {number|null} [ItemCount] DailyMissionData ItemCount
             * @property {boolean|null} [Finished] DailyMissionData Finished
             * @property {number|null} [Vip] DailyMissionData Vip
             * @property {number|null} [Type] DailyMissionData Type
             * @property {number|null} [Coin] DailyMissionData Coin
             * @property {number|null} [Show] DailyMissionData Show
             * @property {boolean|null} [Lock] DailyMissionData Lock
             * @property {number|null} [GameID] DailyMissionData GameID
             * @property {number|null} [ChainID] DailyMissionData ChainID
             * @property {number|null} [MissionIndex] DailyMissionData MissionIndex
             * @property {Long|null} [ExtendID] DailyMissionData ExtendID
             */

            /**
             * Constructs a new DailyMissionData.
             * @memberof missionProto
             * @classdesc Represents a DailyMissionData.
             * @implements IDailyMissionData
             * @constructor
             * @param {missionProto.IDailyMissionData=} [properties] Properties to set
             */
            function DailyMissionData(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * DailyMissionData Date.
             * @member {string} Date
             * @memberof missionProto.DailyMissionData
             * @instance
             */


            DailyMissionData.prototype.Date = "";
            /**
             * DailyMissionData ConditionDesc.
             * @member {string} ConditionDesc
             * @memberof missionProto.DailyMissionData
             * @instance
             */

            DailyMissionData.prototype.ConditionDesc = "";
            /**
             * DailyMissionData CurrentCount.
             * @member {number} CurrentCount
             * @memberof missionProto.DailyMissionData
             * @instance
             */

            DailyMissionData.prototype.CurrentCount = 0;
            /**
             * DailyMissionData TotalCount.
             * @member {number} TotalCount
             * @memberof missionProto.DailyMissionData
             * @instance
             */

            DailyMissionData.prototype.TotalCount = 0;
            /**
             * DailyMissionData ItemID.
             * @member {number} ItemID
             * @memberof missionProto.DailyMissionData
             * @instance
             */

            DailyMissionData.prototype.ItemID = 0;
            /**
             * DailyMissionData ItemCount.
             * @member {number} ItemCount
             * @memberof missionProto.DailyMissionData
             * @instance
             */

            DailyMissionData.prototype.ItemCount = 0;
            /**
             * DailyMissionData Finished.
             * @member {boolean} Finished
             * @memberof missionProto.DailyMissionData
             * @instance
             */

            DailyMissionData.prototype.Finished = false;
            /**
             * DailyMissionData Vip.
             * @member {number} Vip
             * @memberof missionProto.DailyMissionData
             * @instance
             */

            DailyMissionData.prototype.Vip = 0;
            /**
             * DailyMissionData Type.
             * @member {number} Type
             * @memberof missionProto.DailyMissionData
             * @instance
             */

            DailyMissionData.prototype.Type = 0;
            /**
             * DailyMissionData Coin.
             * @member {number} Coin
             * @memberof missionProto.DailyMissionData
             * @instance
             */

            DailyMissionData.prototype.Coin = 0;
            /**
             * DailyMissionData Show.
             * @member {number} Show
             * @memberof missionProto.DailyMissionData
             * @instance
             */

            DailyMissionData.prototype.Show = 0;
            /**
             * DailyMissionData Lock.
             * @member {boolean} Lock
             * @memberof missionProto.DailyMissionData
             * @instance
             */

            DailyMissionData.prototype.Lock = false;
            /**
             * DailyMissionData GameID.
             * @member {number} GameID
             * @memberof missionProto.DailyMissionData
             * @instance
             */

            DailyMissionData.prototype.GameID = 0;
            /**
             * DailyMissionData ChainID.
             * @member {number} ChainID
             * @memberof missionProto.DailyMissionData
             * @instance
             */

            DailyMissionData.prototype.ChainID = 0;
            /**
             * DailyMissionData MissionIndex.
             * @member {number} MissionIndex
             * @memberof missionProto.DailyMissionData
             * @instance
             */

            DailyMissionData.prototype.MissionIndex = 0;
            /**
             * DailyMissionData ExtendID.
             * @member {Long} ExtendID
             * @memberof missionProto.DailyMissionData
             * @instance
             */

            DailyMissionData.prototype.ExtendID = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
             * Creates a new DailyMissionData instance using the specified properties.
             * @function create
             * @memberof missionProto.DailyMissionData
             * @static
             * @param {missionProto.IDailyMissionData=} [properties] Properties to set
             * @returns {missionProto.DailyMissionData} DailyMissionData instance
             */

            DailyMissionData.create = function create(properties) {
              return new DailyMissionData(properties);
            };
            /**
             * Encodes the specified DailyMissionData message. Does not implicitly {@link missionProto.DailyMissionData.verify|verify} messages.
             * @function encode
             * @memberof missionProto.DailyMissionData
             * @static
             * @param {missionProto.IDailyMissionData} message DailyMissionData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            DailyMissionData.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.Date != null && Object.hasOwnProperty.call(message, "Date")) writer.uint32(
              /* id 1, wireType 2 =*/
              10).string(message.Date);
              if (message.ConditionDesc != null && Object.hasOwnProperty.call(message, "ConditionDesc")) writer.uint32(
              /* id 2, wireType 2 =*/
              18).string(message.ConditionDesc);
              if (message.CurrentCount != null && Object.hasOwnProperty.call(message, "CurrentCount")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.CurrentCount);
              if (message.TotalCount != null && Object.hasOwnProperty.call(message, "TotalCount")) writer.uint32(
              /* id 4, wireType 0 =*/
              32).int32(message.TotalCount);
              if (message.ItemID != null && Object.hasOwnProperty.call(message, "ItemID")) writer.uint32(
              /* id 5, wireType 0 =*/
              40).uint32(message.ItemID);
              if (message.ItemCount != null && Object.hasOwnProperty.call(message, "ItemCount")) writer.uint32(
              /* id 6, wireType 0 =*/
              48).uint32(message.ItemCount);
              if (message.Finished != null && Object.hasOwnProperty.call(message, "Finished")) writer.uint32(
              /* id 7, wireType 0 =*/
              56).bool(message.Finished);
              if (message.Vip != null && Object.hasOwnProperty.call(message, "Vip")) writer.uint32(
              /* id 8, wireType 0 =*/
              64).int32(message.Vip);
              if (message.Type != null && Object.hasOwnProperty.call(message, "Type")) writer.uint32(
              /* id 9, wireType 0 =*/
              72).int32(message.Type);
              if (message.Coin != null && Object.hasOwnProperty.call(message, "Coin")) writer.uint32(
              /* id 10, wireType 1 =*/
              81)["double"](message.Coin);
              if (message.Show != null && Object.hasOwnProperty.call(message, "Show")) writer.uint32(
              /* id 11, wireType 0 =*/
              88).int32(message.Show);
              if (message.Lock != null && Object.hasOwnProperty.call(message, "Lock")) writer.uint32(
              /* id 12, wireType 0 =*/
              96).bool(message.Lock);
              if (message.GameID != null && Object.hasOwnProperty.call(message, "GameID")) writer.uint32(
              /* id 13, wireType 0 =*/
              104).int32(message.GameID);
              if (message.ChainID != null && Object.hasOwnProperty.call(message, "ChainID")) writer.uint32(
              /* id 14, wireType 0 =*/
              112).int32(message.ChainID);
              if (message.MissionIndex != null && Object.hasOwnProperty.call(message, "MissionIndex")) writer.uint32(
              /* id 15, wireType 0 =*/
              120).int32(message.MissionIndex);
              if (message.ExtendID != null && Object.hasOwnProperty.call(message, "ExtendID")) writer.uint32(
              /* id 16, wireType 0 =*/
              128).int64(message.ExtendID);
              return writer;
            };
            /**
             * Encodes the specified DailyMissionData message, length delimited. Does not implicitly {@link missionProto.DailyMissionData.verify|verify} messages.
             * @function encodeDelimited
             * @memberof missionProto.DailyMissionData
             * @static
             * @param {missionProto.IDailyMissionData} message DailyMissionData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            DailyMissionData.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a DailyMissionData message from the specified reader or buffer.
             * @function decode
             * @memberof missionProto.DailyMissionData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {missionProto.DailyMissionData} DailyMissionData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            DailyMissionData.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.missionProto.DailyMissionData();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.Date = reader.string();
                    break;

                  case 2:
                    message.ConditionDesc = reader.string();
                    break;

                  case 3:
                    message.CurrentCount = reader.int32();
                    break;

                  case 4:
                    message.TotalCount = reader.int32();
                    break;

                  case 5:
                    message.ItemID = reader.uint32();
                    break;

                  case 6:
                    message.ItemCount = reader.uint32();
                    break;

                  case 7:
                    message.Finished = reader.bool();
                    break;

                  case 8:
                    message.Vip = reader.int32();
                    break;

                  case 9:
                    message.Type = reader.int32();
                    break;

                  case 10:
                    message.Coin = reader["double"]();
                    break;

                  case 11:
                    message.Show = reader.int32();
                    break;

                  case 12:
                    message.Lock = reader.bool();
                    break;

                  case 13:
                    message.GameID = reader.int32();
                    break;

                  case 14:
                    message.ChainID = reader.int32();
                    break;

                  case 15:
                    message.MissionIndex = reader.int32();
                    break;

                  case 16:
                    message.ExtendID = reader.int64();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
             * Decodes a DailyMissionData message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof missionProto.DailyMissionData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {missionProto.DailyMissionData} DailyMissionData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            DailyMissionData.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a DailyMissionData message.
             * @function verify
             * @memberof missionProto.DailyMissionData
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */


            DailyMissionData.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.Date != null && message.hasOwnProperty("Date")) if (!$util.isString(message.Date)) return "Date: string expected";
              if (message.ConditionDesc != null && message.hasOwnProperty("ConditionDesc")) if (!$util.isString(message.ConditionDesc)) return "ConditionDesc: string expected";
              if (message.CurrentCount != null && message.hasOwnProperty("CurrentCount")) if (!$util.isInteger(message.CurrentCount)) return "CurrentCount: integer expected";
              if (message.TotalCount != null && message.hasOwnProperty("TotalCount")) if (!$util.isInteger(message.TotalCount)) return "TotalCount: integer expected";
              if (message.ItemID != null && message.hasOwnProperty("ItemID")) if (!$util.isInteger(message.ItemID)) return "ItemID: integer expected";
              if (message.ItemCount != null && message.hasOwnProperty("ItemCount")) if (!$util.isInteger(message.ItemCount)) return "ItemCount: integer expected";
              if (message.Finished != null && message.hasOwnProperty("Finished")) if (typeof message.Finished !== "boolean") return "Finished: boolean expected";
              if (message.Vip != null && message.hasOwnProperty("Vip")) if (!$util.isInteger(message.Vip)) return "Vip: integer expected";
              if (message.Type != null && message.hasOwnProperty("Type")) if (!$util.isInteger(message.Type)) return "Type: integer expected";
              if (message.Coin != null && message.hasOwnProperty("Coin")) if (typeof message.Coin !== "number") return "Coin: number expected";
              if (message.Show != null && message.hasOwnProperty("Show")) if (!$util.isInteger(message.Show)) return "Show: integer expected";
              if (message.Lock != null && message.hasOwnProperty("Lock")) if (typeof message.Lock !== "boolean") return "Lock: boolean expected";
              if (message.GameID != null && message.hasOwnProperty("GameID")) if (!$util.isInteger(message.GameID)) return "GameID: integer expected";
              if (message.ChainID != null && message.hasOwnProperty("ChainID")) if (!$util.isInteger(message.ChainID)) return "ChainID: integer expected";
              if (message.MissionIndex != null && message.hasOwnProperty("MissionIndex")) if (!$util.isInteger(message.MissionIndex)) return "MissionIndex: integer expected";
              if (message.ExtendID != null && message.hasOwnProperty("ExtendID")) if (!$util.isInteger(message.ExtendID) && !(message.ExtendID && $util.isInteger(message.ExtendID.low) && $util.isInteger(message.ExtendID.high))) return "ExtendID: integer|Long expected";
              return null;
            };
            /**
             * Creates a DailyMissionData message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof missionProto.DailyMissionData
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {missionProto.DailyMissionData} DailyMissionData
             */


            DailyMissionData.fromObject = function fromObject(object) {
              if (object instanceof $root.missionProto.DailyMissionData) return object;
              var message = new $root.missionProto.DailyMissionData();
              if (object.Date != null) message.Date = String(object.Date);
              if (object.ConditionDesc != null) message.ConditionDesc = String(object.ConditionDesc);
              if (object.CurrentCount != null) message.CurrentCount = object.CurrentCount | 0;
              if (object.TotalCount != null) message.TotalCount = object.TotalCount | 0;
              if (object.ItemID != null) message.ItemID = object.ItemID >>> 0;
              if (object.ItemCount != null) message.ItemCount = object.ItemCount >>> 0;
              if (object.Finished != null) message.Finished = Boolean(object.Finished);
              if (object.Vip != null) message.Vip = object.Vip | 0;
              if (object.Type != null) message.Type = object.Type | 0;
              if (object.Coin != null) message.Coin = Number(object.Coin);
              if (object.Show != null) message.Show = object.Show | 0;
              if (object.Lock != null) message.Lock = Boolean(object.Lock);
              if (object.GameID != null) message.GameID = object.GameID | 0;
              if (object.ChainID != null) message.ChainID = object.ChainID | 0;
              if (object.MissionIndex != null) message.MissionIndex = object.MissionIndex | 0;
              if (object.ExtendID != null) if ($util.Long) (message.ExtendID = $util.Long.fromValue(object.ExtendID)).unsigned = false;else if (typeof object.ExtendID === "string") message.ExtendID = parseInt(object.ExtendID, 10);else if (typeof object.ExtendID === "number") message.ExtendID = object.ExtendID;else if (typeof object.ExtendID === "object") message.ExtendID = new $util.LongBits(object.ExtendID.low >>> 0, object.ExtendID.high >>> 0).toNumber();
              return message;
            };
            /**
             * Creates a plain object from a DailyMissionData message. Also converts values to other types if specified.
             * @function toObject
             * @memberof missionProto.DailyMissionData
             * @static
             * @param {missionProto.DailyMissionData} message DailyMissionData
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */


            DailyMissionData.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.Date = "";
                object.ConditionDesc = "";
                object.CurrentCount = 0;
                object.TotalCount = 0;
                object.ItemID = 0;
                object.ItemCount = 0;
                object.Finished = false;
                object.Vip = 0;
                object.Type = 0;
                object.Coin = 0;
                object.Show = 0;
                object.Lock = false;
                object.GameID = 0;
                object.ChainID = 0;
                object.MissionIndex = 0;

                if ($util.Long) {
                  var _long2 = new $util.Long(0, 0, false);

                  object.ExtendID = options.longs === String ? _long2.toString() : options.longs === Number ? _long2.toNumber() : _long2;
                } else object.ExtendID = options.longs === String ? "0" : 0;
              }

              if (message.Date != null && message.hasOwnProperty("Date")) object.Date = message.Date;
              if (message.ConditionDesc != null && message.hasOwnProperty("ConditionDesc")) object.ConditionDesc = message.ConditionDesc;
              if (message.CurrentCount != null && message.hasOwnProperty("CurrentCount")) object.CurrentCount = message.CurrentCount;
              if (message.TotalCount != null && message.hasOwnProperty("TotalCount")) object.TotalCount = message.TotalCount;
              if (message.ItemID != null && message.hasOwnProperty("ItemID")) object.ItemID = message.ItemID;
              if (message.ItemCount != null && message.hasOwnProperty("ItemCount")) object.ItemCount = message.ItemCount;
              if (message.Finished != null && message.hasOwnProperty("Finished")) object.Finished = message.Finished;
              if (message.Vip != null && message.hasOwnProperty("Vip")) object.Vip = message.Vip;
              if (message.Type != null && message.hasOwnProperty("Type")) object.Type = message.Type;
              if (message.Coin != null && message.hasOwnProperty("Coin")) object.Coin = options.json && !isFinite(message.Coin) ? String(message.Coin) : message.Coin;
              if (message.Show != null && message.hasOwnProperty("Show")) object.Show = message.Show;
              if (message.Lock != null && message.hasOwnProperty("Lock")) object.Lock = message.Lock;
              if (message.GameID != null && message.hasOwnProperty("GameID")) object.GameID = message.GameID;
              if (message.ChainID != null && message.hasOwnProperty("ChainID")) object.ChainID = message.ChainID;
              if (message.MissionIndex != null && message.hasOwnProperty("MissionIndex")) object.MissionIndex = message.MissionIndex;
              if (message.ExtendID != null && message.hasOwnProperty("ExtendID")) if (typeof message.ExtendID === "number") object.ExtendID = options.longs === String ? String(message.ExtendID) : message.ExtendID;else object.ExtendID = options.longs === String ? $util.Long.prototype.toString.call(message.ExtendID) : options.longs === Number ? new $util.LongBits(message.ExtendID.low >>> 0, message.ExtendID.high >>> 0).toNumber() : message.ExtendID;
              return object;
            };
            /**
             * Converts this DailyMissionData to JSON.
             * @function toJSON
             * @memberof missionProto.DailyMissionData
             * @instance
             * @returns {Object.<string,*>} JSON object
             */


            DailyMissionData.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DailyMissionData;
          }();

          missionProto.ItemCard = function () {
            /**
             * Properties of an ItemCard.
             * @memberof missionProto
             * @interface IItemCard
             * @property {number|null} [GameID] ItemCard GameID
             * @property {string|null} [Game] ItemCard Game
             * @property {string|null} [ItemName] ItemCard ItemName
             * @property {number|null} [Icon] ItemCard Icon
             * @property {number|null} [ItemValue] ItemCard ItemValue
             * @property {number|null} [Bet] ItemCard Bet
             * @property {string|null} [GameName] ItemCard GameName
             * @property {number|null} [Star] ItemCard Star
             * @property {number|null} [WinType] ItemCard WinType
             * @property {number|null} [WinMultiplier] ItemCard WinMultiplier
             * @property {number|null} [WinMaxMag] ItemCard WinMaxMag
             * @property {number|null} [PlayValue] ItemCard PlayValue
             */

            /**
             * Constructs a new ItemCard.
             * @memberof missionProto
             * @classdesc Represents an ItemCard.
             * @implements IItemCard
             * @constructor
             * @param {missionProto.IItemCard=} [properties] Properties to set
             */
            function ItemCard(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * ItemCard GameID.
             * @member {number} GameID
             * @memberof missionProto.ItemCard
             * @instance
             */


            ItemCard.prototype.GameID = 0;
            /**
             * ItemCard Game.
             * @member {string} Game
             * @memberof missionProto.ItemCard
             * @instance
             */

            ItemCard.prototype.Game = "";
            /**
             * ItemCard ItemName.
             * @member {string} ItemName
             * @memberof missionProto.ItemCard
             * @instance
             */

            ItemCard.prototype.ItemName = "";
            /**
             * ItemCard Icon.
             * @member {number} Icon
             * @memberof missionProto.ItemCard
             * @instance
             */

            ItemCard.prototype.Icon = 0;
            /**
             * ItemCard ItemValue.
             * @member {number} ItemValue
             * @memberof missionProto.ItemCard
             * @instance
             */

            ItemCard.prototype.ItemValue = 0;
            /**
             * ItemCard Bet.
             * @member {number} Bet
             * @memberof missionProto.ItemCard
             * @instance
             */

            ItemCard.prototype.Bet = 0;
            /**
             * ItemCard GameName.
             * @member {string} GameName
             * @memberof missionProto.ItemCard
             * @instance
             */

            ItemCard.prototype.GameName = "";
            /**
             * ItemCard Star.
             * @member {number} Star
             * @memberof missionProto.ItemCard
             * @instance
             */

            ItemCard.prototype.Star = 0;
            /**
             * ItemCard WinType.
             * @member {number} WinType
             * @memberof missionProto.ItemCard
             * @instance
             */

            ItemCard.prototype.WinType = 0;
            /**
             * ItemCard WinMultiplier.
             * @member {number} WinMultiplier
             * @memberof missionProto.ItemCard
             * @instance
             */

            ItemCard.prototype.WinMultiplier = 0;
            /**
             * ItemCard WinMaxMag.
             * @member {number} WinMaxMag
             * @memberof missionProto.ItemCard
             * @instance
             */

            ItemCard.prototype.WinMaxMag = 0;
            /**
             * ItemCard PlayValue.
             * @member {number} PlayValue
             * @memberof missionProto.ItemCard
             * @instance
             */

            ItemCard.prototype.PlayValue = 0;
            /**
             * Creates a new ItemCard instance using the specified properties.
             * @function create
             * @memberof missionProto.ItemCard
             * @static
             * @param {missionProto.IItemCard=} [properties] Properties to set
             * @returns {missionProto.ItemCard} ItemCard instance
             */

            ItemCard.create = function create(properties) {
              return new ItemCard(properties);
            };
            /**
             * Encodes the specified ItemCard message. Does not implicitly {@link missionProto.ItemCard.verify|verify} messages.
             * @function encode
             * @memberof missionProto.ItemCard
             * @static
             * @param {missionProto.IItemCard} message ItemCard message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            ItemCard.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.GameID != null && Object.hasOwnProperty.call(message, "GameID")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.GameID);
              if (message.Game != null && Object.hasOwnProperty.call(message, "Game")) writer.uint32(
              /* id 2, wireType 2 =*/
              18).string(message.Game);
              if (message.ItemName != null && Object.hasOwnProperty.call(message, "ItemName")) writer.uint32(
              /* id 3, wireType 2 =*/
              26).string(message.ItemName);
              if (message.Icon != null && Object.hasOwnProperty.call(message, "Icon")) writer.uint32(
              /* id 4, wireType 0 =*/
              32).int32(message.Icon);
              if (message.ItemValue != null && Object.hasOwnProperty.call(message, "ItemValue")) writer.uint32(
              /* id 5, wireType 1 =*/
              41)["double"](message.ItemValue);
              if (message.Bet != null && Object.hasOwnProperty.call(message, "Bet")) writer.uint32(
              /* id 6, wireType 1 =*/
              49)["double"](message.Bet);
              if (message.GameName != null && Object.hasOwnProperty.call(message, "GameName")) writer.uint32(
              /* id 7, wireType 2 =*/
              58).string(message.GameName);
              if (message.Star != null && Object.hasOwnProperty.call(message, "Star")) writer.uint32(
              /* id 8, wireType 0 =*/
              64).int32(message.Star);
              if (message.WinType != null && Object.hasOwnProperty.call(message, "WinType")) writer.uint32(
              /* id 9, wireType 0 =*/
              72).int32(message.WinType);
              if (message.WinMultiplier != null && Object.hasOwnProperty.call(message, "WinMultiplier")) writer.uint32(
              /* id 10, wireType 1 =*/
              81)["double"](message.WinMultiplier);
              if (message.WinMaxMag != null && Object.hasOwnProperty.call(message, "WinMaxMag")) writer.uint32(
              /* id 11, wireType 1 =*/
              89)["double"](message.WinMaxMag);
              if (message.PlayValue != null && Object.hasOwnProperty.call(message, "PlayValue")) writer.uint32(
              /* id 12, wireType 1 =*/
              97)["double"](message.PlayValue);
              return writer;
            };
            /**
             * Encodes the specified ItemCard message, length delimited. Does not implicitly {@link missionProto.ItemCard.verify|verify} messages.
             * @function encodeDelimited
             * @memberof missionProto.ItemCard
             * @static
             * @param {missionProto.IItemCard} message ItemCard message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            ItemCard.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes an ItemCard message from the specified reader or buffer.
             * @function decode
             * @memberof missionProto.ItemCard
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {missionProto.ItemCard} ItemCard
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            ItemCard.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.missionProto.ItemCard();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.GameID = reader.int32();
                    break;

                  case 2:
                    message.Game = reader.string();
                    break;

                  case 3:
                    message.ItemName = reader.string();
                    break;

                  case 4:
                    message.Icon = reader.int32();
                    break;

                  case 5:
                    message.ItemValue = reader["double"]();
                    break;

                  case 6:
                    message.Bet = reader["double"]();
                    break;

                  case 7:
                    message.GameName = reader.string();
                    break;

                  case 8:
                    message.Star = reader.int32();
                    break;

                  case 9:
                    message.WinType = reader.int32();
                    break;

                  case 10:
                    message.WinMultiplier = reader["double"]();
                    break;

                  case 11:
                    message.WinMaxMag = reader["double"]();
                    break;

                  case 12:
                    message.PlayValue = reader["double"]();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
             * Decodes an ItemCard message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof missionProto.ItemCard
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {missionProto.ItemCard} ItemCard
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            ItemCard.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies an ItemCard message.
             * @function verify
             * @memberof missionProto.ItemCard
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */


            ItemCard.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.GameID != null && message.hasOwnProperty("GameID")) if (!$util.isInteger(message.GameID)) return "GameID: integer expected";
              if (message.Game != null && message.hasOwnProperty("Game")) if (!$util.isString(message.Game)) return "Game: string expected";
              if (message.ItemName != null && message.hasOwnProperty("ItemName")) if (!$util.isString(message.ItemName)) return "ItemName: string expected";
              if (message.Icon != null && message.hasOwnProperty("Icon")) if (!$util.isInteger(message.Icon)) return "Icon: integer expected";
              if (message.ItemValue != null && message.hasOwnProperty("ItemValue")) if (typeof message.ItemValue !== "number") return "ItemValue: number expected";
              if (message.Bet != null && message.hasOwnProperty("Bet")) if (typeof message.Bet !== "number") return "Bet: number expected";
              if (message.GameName != null && message.hasOwnProperty("GameName")) if (!$util.isString(message.GameName)) return "GameName: string expected";
              if (message.Star != null && message.hasOwnProperty("Star")) if (!$util.isInteger(message.Star)) return "Star: integer expected";
              if (message.WinType != null && message.hasOwnProperty("WinType")) if (!$util.isInteger(message.WinType)) return "WinType: integer expected";
              if (message.WinMultiplier != null && message.hasOwnProperty("WinMultiplier")) if (typeof message.WinMultiplier !== "number") return "WinMultiplier: number expected";
              if (message.WinMaxMag != null && message.hasOwnProperty("WinMaxMag")) if (typeof message.WinMaxMag !== "number") return "WinMaxMag: number expected";
              if (message.PlayValue != null && message.hasOwnProperty("PlayValue")) if (typeof message.PlayValue !== "number") return "PlayValue: number expected";
              return null;
            };
            /**
             * Creates an ItemCard message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof missionProto.ItemCard
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {missionProto.ItemCard} ItemCard
             */


            ItemCard.fromObject = function fromObject(object) {
              if (object instanceof $root.missionProto.ItemCard) return object;
              var message = new $root.missionProto.ItemCard();
              if (object.GameID != null) message.GameID = object.GameID | 0;
              if (object.Game != null) message.Game = String(object.Game);
              if (object.ItemName != null) message.ItemName = String(object.ItemName);
              if (object.Icon != null) message.Icon = object.Icon | 0;
              if (object.ItemValue != null) message.ItemValue = Number(object.ItemValue);
              if (object.Bet != null) message.Bet = Number(object.Bet);
              if (object.GameName != null) message.GameName = String(object.GameName);
              if (object.Star != null) message.Star = object.Star | 0;
              if (object.WinType != null) message.WinType = object.WinType | 0;
              if (object.WinMultiplier != null) message.WinMultiplier = Number(object.WinMultiplier);
              if (object.WinMaxMag != null) message.WinMaxMag = Number(object.WinMaxMag);
              if (object.PlayValue != null) message.PlayValue = Number(object.PlayValue);
              return message;
            };
            /**
             * Creates a plain object from an ItemCard message. Also converts values to other types if specified.
             * @function toObject
             * @memberof missionProto.ItemCard
             * @static
             * @param {missionProto.ItemCard} message ItemCard
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */


            ItemCard.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.GameID = 0;
                object.Game = "";
                object.ItemName = "";
                object.Icon = 0;
                object.ItemValue = 0;
                object.Bet = 0;
                object.GameName = "";
                object.Star = 0;
                object.WinType = 0;
                object.WinMultiplier = 0;
                object.WinMaxMag = 0;
                object.PlayValue = 0;
              }

              if (message.GameID != null && message.hasOwnProperty("GameID")) object.GameID = message.GameID;
              if (message.Game != null && message.hasOwnProperty("Game")) object.Game = message.Game;
              if (message.ItemName != null && message.hasOwnProperty("ItemName")) object.ItemName = message.ItemName;
              if (message.Icon != null && message.hasOwnProperty("Icon")) object.Icon = message.Icon;
              if (message.ItemValue != null && message.hasOwnProperty("ItemValue")) object.ItemValue = options.json && !isFinite(message.ItemValue) ? String(message.ItemValue) : message.ItemValue;
              if (message.Bet != null && message.hasOwnProperty("Bet")) object.Bet = options.json && !isFinite(message.Bet) ? String(message.Bet) : message.Bet;
              if (message.GameName != null && message.hasOwnProperty("GameName")) object.GameName = message.GameName;
              if (message.Star != null && message.hasOwnProperty("Star")) object.Star = message.Star;
              if (message.WinType != null && message.hasOwnProperty("WinType")) object.WinType = message.WinType;
              if (message.WinMultiplier != null && message.hasOwnProperty("WinMultiplier")) object.WinMultiplier = options.json && !isFinite(message.WinMultiplier) ? String(message.WinMultiplier) : message.WinMultiplier;
              if (message.WinMaxMag != null && message.hasOwnProperty("WinMaxMag")) object.WinMaxMag = options.json && !isFinite(message.WinMaxMag) ? String(message.WinMaxMag) : message.WinMaxMag;
              if (message.PlayValue != null && message.hasOwnProperty("PlayValue")) object.PlayValue = options.json && !isFinite(message.PlayValue) ? String(message.PlayValue) : message.PlayValue;
              return object;
            };
            /**
             * Converts this ItemCard to JSON.
             * @function toJSON
             * @memberof missionProto.ItemCard
             * @instance
             * @returns {Object.<string,*>} JSON object
             */


            ItemCard.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ItemCard;
          }();

          missionProto.GiftPack = function () {
            /**
             * Properties of a GiftPack.
             * @memberof missionProto
             * @interface IGiftPack
             * @property {Array.<missionProto.IGift>|null} [List] GiftPack List
             */

            /**
             * Constructs a new GiftPack.
             * @memberof missionProto
             * @classdesc Represents a GiftPack.
             * @implements IGiftPack
             * @constructor
             * @param {missionProto.IGiftPack=} [properties] Properties to set
             */
            function GiftPack(properties) {
              this.List = [];
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * GiftPack List.
             * @member {Array.<missionProto.IGift>} List
             * @memberof missionProto.GiftPack
             * @instance
             */


            GiftPack.prototype.List = $util.emptyArray;
            /**
             * Creates a new GiftPack instance using the specified properties.
             * @function create
             * @memberof missionProto.GiftPack
             * @static
             * @param {missionProto.IGiftPack=} [properties] Properties to set
             * @returns {missionProto.GiftPack} GiftPack instance
             */

            GiftPack.create = function create(properties) {
              return new GiftPack(properties);
            };
            /**
             * Encodes the specified GiftPack message. Does not implicitly {@link missionProto.GiftPack.verify|verify} messages.
             * @function encode
             * @memberof missionProto.GiftPack
             * @static
             * @param {missionProto.IGiftPack} message GiftPack message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            GiftPack.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.List != null && message.List.length) for (var i = 0; i < message.List.length; ++i) {
                $root.missionProto.Gift.encode(message.List[i], writer.uint32(
                /* id 1, wireType 2 =*/
                10).fork()).ldelim();
              }
              return writer;
            };
            /**
             * Encodes the specified GiftPack message, length delimited. Does not implicitly {@link missionProto.GiftPack.verify|verify} messages.
             * @function encodeDelimited
             * @memberof missionProto.GiftPack
             * @static
             * @param {missionProto.IGiftPack} message GiftPack message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            GiftPack.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a GiftPack message from the specified reader or buffer.
             * @function decode
             * @memberof missionProto.GiftPack
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {missionProto.GiftPack} GiftPack
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            GiftPack.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.missionProto.GiftPack();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    if (!(message.List && message.List.length)) message.List = [];
                    message.List.push($root.missionProto.Gift.decode(reader, reader.uint32()));
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
             * Decodes a GiftPack message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof missionProto.GiftPack
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {missionProto.GiftPack} GiftPack
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            GiftPack.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a GiftPack message.
             * @function verify
             * @memberof missionProto.GiftPack
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */


            GiftPack.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";

              if (message.List != null && message.hasOwnProperty("List")) {
                if (!Array.isArray(message.List)) return "List: array expected";

                for (var i = 0; i < message.List.length; ++i) {
                  var error = $root.missionProto.Gift.verify(message.List[i]);
                  if (error) return "List." + error;
                }
              }

              return null;
            };
            /**
             * Creates a GiftPack message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof missionProto.GiftPack
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {missionProto.GiftPack} GiftPack
             */


            GiftPack.fromObject = function fromObject(object) {
              if (object instanceof $root.missionProto.GiftPack) return object;
              var message = new $root.missionProto.GiftPack();

              if (object.List) {
                if (!Array.isArray(object.List)) throw TypeError(".missionProto.GiftPack.List: array expected");
                message.List = [];

                for (var i = 0; i < object.List.length; ++i) {
                  if (typeof object.List[i] !== "object") throw TypeError(".missionProto.GiftPack.List: object expected");
                  message.List[i] = $root.missionProto.Gift.fromObject(object.List[i]);
                }
              }

              return message;
            };
            /**
             * Creates a plain object from a GiftPack message. Also converts values to other types if specified.
             * @function toObject
             * @memberof missionProto.GiftPack
             * @static
             * @param {missionProto.GiftPack} message GiftPack
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */


            GiftPack.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};
              if (options.arrays || options.defaults) object.List = [];

              if (message.List && message.List.length) {
                object.List = [];

                for (var j = 0; j < message.List.length; ++j) {
                  object.List[j] = $root.missionProto.Gift.toObject(message.List[j], options);
                }
              }

              return object;
            };
            /**
             * Converts this GiftPack to JSON.
             * @function toJSON
             * @memberof missionProto.GiftPack
             * @instance
             * @returns {Object.<string,*>} JSON object
             */


            GiftPack.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GiftPack;
          }();

          missionProto.Gift = function () {
            /**
             * Properties of a Gift.
             * @memberof missionProto
             * @interface IGift
             * @property {number|null} [ItemID] Gift ItemID
             * @property {number|null} [ItemCount] Gift ItemCount
             * @property {Long|null} [ExtendID] Gift ExtendID
             */

            /**
             * Constructs a new Gift.
             * @memberof missionProto
             * @classdesc Represents a Gift.
             * @implements IGift
             * @constructor
             * @param {missionProto.IGift=} [properties] Properties to set
             */
            function Gift(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * Gift ItemID.
             * @member {number} ItemID
             * @memberof missionProto.Gift
             * @instance
             */


            Gift.prototype.ItemID = 0;
            /**
             * Gift ItemCount.
             * @member {number} ItemCount
             * @memberof missionProto.Gift
             * @instance
             */

            Gift.prototype.ItemCount = 0;
            /**
             * Gift ExtendID.
             * @member {Long} ExtendID
             * @memberof missionProto.Gift
             * @instance
             */

            Gift.prototype.ExtendID = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
             * Creates a new Gift instance using the specified properties.
             * @function create
             * @memberof missionProto.Gift
             * @static
             * @param {missionProto.IGift=} [properties] Properties to set
             * @returns {missionProto.Gift} Gift instance
             */

            Gift.create = function create(properties) {
              return new Gift(properties);
            };
            /**
             * Encodes the specified Gift message. Does not implicitly {@link missionProto.Gift.verify|verify} messages.
             * @function encode
             * @memberof missionProto.Gift
             * @static
             * @param {missionProto.IGift} message Gift message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            Gift.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.ItemID != null && Object.hasOwnProperty.call(message, "ItemID")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).uint32(message.ItemID);
              if (message.ItemCount != null && Object.hasOwnProperty.call(message, "ItemCount")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).uint32(message.ItemCount);
              if (message.ExtendID != null && Object.hasOwnProperty.call(message, "ExtendID")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int64(message.ExtendID);
              return writer;
            };
            /**
             * Encodes the specified Gift message, length delimited. Does not implicitly {@link missionProto.Gift.verify|verify} messages.
             * @function encodeDelimited
             * @memberof missionProto.Gift
             * @static
             * @param {missionProto.IGift} message Gift message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            Gift.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a Gift message from the specified reader or buffer.
             * @function decode
             * @memberof missionProto.Gift
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {missionProto.Gift} Gift
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            Gift.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.missionProto.Gift();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.ItemID = reader.uint32();
                    break;

                  case 2:
                    message.ItemCount = reader.uint32();
                    break;

                  case 3:
                    message.ExtendID = reader.int64();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
             * Decodes a Gift message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof missionProto.Gift
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {missionProto.Gift} Gift
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            Gift.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a Gift message.
             * @function verify
             * @memberof missionProto.Gift
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */


            Gift.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.ItemID != null && message.hasOwnProperty("ItemID")) if (!$util.isInteger(message.ItemID)) return "ItemID: integer expected";
              if (message.ItemCount != null && message.hasOwnProperty("ItemCount")) if (!$util.isInteger(message.ItemCount)) return "ItemCount: integer expected";
              if (message.ExtendID != null && message.hasOwnProperty("ExtendID")) if (!$util.isInteger(message.ExtendID) && !(message.ExtendID && $util.isInteger(message.ExtendID.low) && $util.isInteger(message.ExtendID.high))) return "ExtendID: integer|Long expected";
              return null;
            };
            /**
             * Creates a Gift message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof missionProto.Gift
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {missionProto.Gift} Gift
             */


            Gift.fromObject = function fromObject(object) {
              if (object instanceof $root.missionProto.Gift) return object;
              var message = new $root.missionProto.Gift();
              if (object.ItemID != null) message.ItemID = object.ItemID >>> 0;
              if (object.ItemCount != null) message.ItemCount = object.ItemCount >>> 0;
              if (object.ExtendID != null) if ($util.Long) (message.ExtendID = $util.Long.fromValue(object.ExtendID)).unsigned = false;else if (typeof object.ExtendID === "string") message.ExtendID = parseInt(object.ExtendID, 10);else if (typeof object.ExtendID === "number") message.ExtendID = object.ExtendID;else if (typeof object.ExtendID === "object") message.ExtendID = new $util.LongBits(object.ExtendID.low >>> 0, object.ExtendID.high >>> 0).toNumber();
              return message;
            };
            /**
             * Creates a plain object from a Gift message. Also converts values to other types if specified.
             * @function toObject
             * @memberof missionProto.Gift
             * @static
             * @param {missionProto.Gift} message Gift
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */


            Gift.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.ItemID = 0;
                object.ItemCount = 0;

                if ($util.Long) {
                  var _long3 = new $util.Long(0, 0, false);

                  object.ExtendID = options.longs === String ? _long3.toString() : options.longs === Number ? _long3.toNumber() : _long3;
                } else object.ExtendID = options.longs === String ? "0" : 0;
              }

              if (message.ItemID != null && message.hasOwnProperty("ItemID")) object.ItemID = message.ItemID;
              if (message.ItemCount != null && message.hasOwnProperty("ItemCount")) object.ItemCount = message.ItemCount;
              if (message.ExtendID != null && message.hasOwnProperty("ExtendID")) if (typeof message.ExtendID === "number") object.ExtendID = options.longs === String ? String(message.ExtendID) : message.ExtendID;else object.ExtendID = options.longs === String ? $util.Long.prototype.toString.call(message.ExtendID) : options.longs === Number ? new $util.LongBits(message.ExtendID.low >>> 0, message.ExtendID.high >>> 0).toNumber() : message.ExtendID;
              return object;
            };
            /**
             * Converts this Gift to JSON.
             * @function toJSON
             * @memberof missionProto.Gift
             * @instance
             * @returns {Object.<string,*>} JSON object
             */


            Gift.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Gift;
          }();

          return missionProto;
        }();

        module.exports = $root; // #endregion ORIGINAL CODE

        _cjsExports = exports('default', module.exports);
      }, function () {
        return {
          'protobufjs/minimal': __cjsMetaURL$1
        };
      });
    }
  };
});

System.register("chunks:///_virtual/missionCProto.mjs_cjs=&original=.js", ['./missionCProto.js', './cjs-loader.mjs'], function (exports, module) {
  'use strict';

  var __cjsMetaURL, loader;

  return {
    setters: [function (module) {
      __cjsMetaURL = module.__cjsMetaURL;
      var _setter = {};
      _setter.__cjsMetaURL = module.__cjsMetaURL;
      _setter.default = module.default;
      exports(_setter);
    }, function (module) {
      loader = module.default;
    }],
    execute: function () {
      // I am the facade module who provides access to the CommonJS module './missionCProto.js'~
      if (!__cjsMetaURL) {
        loader.throwInvalidWrapper('./missionCProto.js', module.meta.url);
      }

      loader.require(__cjsMetaURL);
    }
  };
});

System.register("chunks:///_virtual/namespace.js", ['./cjs-loader.mjs', './object.js', './field.js', './oneof.js', './util.js'], function (exports, module) {
  'use strict';

  var loader, __cjsMetaURL$1, __cjsMetaURL$2, __cjsMetaURL$3, __cjsMetaURL$4;

  return {
    setters: [function (module) {
      loader = module.default;
    }, function (module) {
      __cjsMetaURL$1 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$2 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$3 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$4 = module.__cjsMetaURL;
    }],
    execute: function () {
      var __cjsMetaURL = exports('__cjsMetaURL', module.meta.url);

      loader.define(__cjsMetaURL, function (exports, require, module, __filename, __dirname) {
        module.exports = Namespace; // extends ReflectionObject

        var ReflectionObject = require("./object");

        ((Namespace.prototype = Object.create(ReflectionObject.prototype)).constructor = Namespace).className = "Namespace";

        var Field = require("./field"),
            OneOf = require("./oneof"),
            util = require("./util");

        var Type, // cyclic
        Service, Enum;
        /**
         * Constructs a new namespace instance.
         * @name Namespace
         * @classdesc Reflected namespace.
         * @extends NamespaceBase
         * @constructor
         * @param {string} name Namespace name
         * @param {Object.<string,*>} [options] Declared options
         */

        /**
         * Constructs a namespace from JSON.
         * @memberof Namespace
         * @function
         * @param {string} name Namespace name
         * @param {Object.<string,*>} json JSON object
         * @returns {Namespace} Created namespace
         * @throws {TypeError} If arguments are invalid
         */

        Namespace.fromJSON = function fromJSON(name, json) {
          return new Namespace(name, json.options).addJSON(json.nested);
        };
        /**
         * Converts an array of reflection objects to JSON.
         * @memberof Namespace
         * @param {ReflectionObject[]} array Object array
         * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
         * @returns {Object.<string,*>|undefined} JSON object or `undefined` when array is empty
         */


        function arrayToJSON(array, toJSONOptions) {
          if (!(array && array.length)) return undefined;
          var obj = {};

          for (var i = 0; i < array.length; ++i) {
            obj[array[i].name] = array[i].toJSON(toJSONOptions);
          }

          return obj;
        }

        Namespace.arrayToJSON = arrayToJSON;
        /**
         * Tests if the specified id is reserved.
         * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names
         * @param {number} id Id to test
         * @returns {boolean} `true` if reserved, otherwise `false`
         */

        Namespace.isReservedId = function isReservedId(reserved, id) {
          if (reserved) for (var i = 0; i < reserved.length; ++i) {
            if (typeof reserved[i] !== "string" && reserved[i][0] <= id && reserved[i][1] > id) return true;
          }
          return false;
        };
        /**
         * Tests if the specified name is reserved.
         * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names
         * @param {string} name Name to test
         * @returns {boolean} `true` if reserved, otherwise `false`
         */


        Namespace.isReservedName = function isReservedName(reserved, name) {
          if (reserved) for (var i = 0; i < reserved.length; ++i) {
            if (reserved[i] === name) return true;
          }
          return false;
        };
        /**
         * Not an actual constructor. Use {@link Namespace} instead.
         * @classdesc Base class of all reflection objects containing nested objects. This is not an actual class but here for the sake of having consistent type definitions.
         * @exports NamespaceBase
         * @extends ReflectionObject
         * @abstract
         * @constructor
         * @param {string} name Namespace name
         * @param {Object.<string,*>} [options] Declared options
         * @see {@link Namespace}
         */


        function Namespace(name, options) {
          ReflectionObject.call(this, name, options);
          /**
           * Nested objects by name.
           * @type {Object.<string,ReflectionObject>|undefined}
           */

          this.nested = undefined; // toJSON

          /**
           * Cached nested objects as an array.
           * @type {ReflectionObject[]|null}
           * @private
           */

          this._nestedArray = null;
        }

        function clearCache(namespace) {
          namespace._nestedArray = null;
          return namespace;
        }
        /**
         * Nested objects of this namespace as an array for iteration.
         * @name NamespaceBase#nestedArray
         * @type {ReflectionObject[]}
         * @readonly
         */


        Object.defineProperty(Namespace.prototype, "nestedArray", {
          get: function get() {
            return this._nestedArray || (this._nestedArray = util.toArray(this.nested));
          }
        });
        /**
         * Namespace descriptor.
         * @interface INamespace
         * @property {Object.<string,*>} [options] Namespace options
         * @property {Object.<string,AnyNestedObject>} [nested] Nested object descriptors
         */

        /**
         * Any extension field descriptor.
         * @typedef AnyExtensionField
         * @type {IExtensionField|IExtensionMapField}
         */

        /**
         * Any nested object descriptor.
         * @typedef AnyNestedObject
         * @type {IEnum|IType|IService|AnyExtensionField|INamespace}
         */
        // ^ BEWARE: VSCode hangs forever when using more than 5 types (that's why AnyExtensionField exists in the first place)

        /**
         * Converts this namespace to a namespace descriptor.
         * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
         * @returns {INamespace} Namespace descriptor
         */

        Namespace.prototype.toJSON = function toJSON(toJSONOptions) {
          return util.toObject(["options", this.options, "nested", arrayToJSON(this.nestedArray, toJSONOptions)]);
        };
        /**
         * Adds nested objects to this namespace from nested object descriptors.
         * @param {Object.<string,AnyNestedObject>} nestedJson Any nested object descriptors
         * @returns {Namespace} `this`
         */


        Namespace.prototype.addJSON = function addJSON(nestedJson) {
          var ns = this;
          /* istanbul ignore else */

          if (nestedJson) {
            for (var names = Object.keys(nestedJson), i = 0, nested; i < names.length; ++i) {
              nested = nestedJson[names[i]];
              ns.add( // most to least likely
              (nested.fields !== undefined ? Type.fromJSON : nested.values !== undefined ? Enum.fromJSON : nested.methods !== undefined ? Service.fromJSON : nested.id !== undefined ? Field.fromJSON : Namespace.fromJSON)(names[i], nested));
            }
          }

          return this;
        };
        /**
         * Gets the nested object of the specified name.
         * @param {string} name Nested object name
         * @returns {ReflectionObject|null} The reflection object or `null` if it doesn't exist
         */


        Namespace.prototype.get = function get(name) {
          return this.nested && this.nested[name] || null;
        };
        /**
         * Gets the values of the nested {@link Enum|enum} of the specified name.
         * This methods differs from {@link Namespace#get|get} in that it returns an enum's values directly and throws instead of returning `null`.
         * @param {string} name Nested enum name
         * @returns {Object.<string,number>} Enum values
         * @throws {Error} If there is no such enum
         */


        Namespace.prototype.getEnum = function getEnum(name) {
          if (this.nested && this.nested[name] instanceof Enum) return this.nested[name].values;
          throw Error("no such enum: " + name);
        };
        /**
         * Adds a nested object to this namespace.
         * @param {ReflectionObject} object Nested object to add
         * @returns {Namespace} `this`
         * @throws {TypeError} If arguments are invalid
         * @throws {Error} If there is already a nested object with this name
         */


        Namespace.prototype.add = function add(object) {
          if (!(object instanceof Field && object.extend !== undefined || object instanceof Type || object instanceof Enum || object instanceof Service || object instanceof Namespace || object instanceof OneOf)) throw TypeError("object must be a valid nested object");
          if (!this.nested) this.nested = {};else {
            var prev = this.get(object.name);

            if (prev) {
              if (prev instanceof Namespace && object instanceof Namespace && !(prev instanceof Type || prev instanceof Service)) {
                // replace plain namespace but keep existing nested elements and options
                var nested = prev.nestedArray;

                for (var i = 0; i < nested.length; ++i) {
                  object.add(nested[i]);
                }

                this.remove(prev);
                if (!this.nested) this.nested = {};
                object.setOptions(prev.options, true);
              } else throw Error("duplicate name '" + object.name + "' in " + this);
            }
          }
          this.nested[object.name] = object;
          object.onAdd(this);
          return clearCache(this);
        };
        /**
         * Removes a nested object from this namespace.
         * @param {ReflectionObject} object Nested object to remove
         * @returns {Namespace} `this`
         * @throws {TypeError} If arguments are invalid
         * @throws {Error} If `object` is not a member of this namespace
         */


        Namespace.prototype.remove = function remove(object) {
          if (!(object instanceof ReflectionObject)) throw TypeError("object must be a ReflectionObject");
          if (object.parent !== this) throw Error(object + " is not a member of " + this);
          delete this.nested[object.name];
          if (!Object.keys(this.nested).length) this.nested = undefined;
          object.onRemove(this);
          return clearCache(this);
        };
        /**
         * Defines additial namespaces within this one if not yet existing.
         * @param {string|string[]} path Path to create
         * @param {*} [json] Nested types to create from JSON
         * @returns {Namespace} Pointer to the last namespace created or `this` if path is empty
         */


        Namespace.prototype.define = function define(path, json) {
          if (util.isString(path)) path = path.split(".");else if (!Array.isArray(path)) throw TypeError("illegal path");
          if (path && path.length && path[0] === "") throw Error("path must be relative");
          var ptr = this;

          while (path.length > 0) {
            var part = path.shift();

            if (ptr.nested && ptr.nested[part]) {
              ptr = ptr.nested[part];
              if (!(ptr instanceof Namespace)) throw Error("path conflicts with non-namespace objects");
            } else ptr.add(ptr = new Namespace(part));
          }

          if (json) ptr.addJSON(json);
          return ptr;
        };
        /**
         * Resolves this namespace's and all its nested objects' type references. Useful to validate a reflection tree, but comes at a cost.
         * @returns {Namespace} `this`
         */


        Namespace.prototype.resolveAll = function resolveAll() {
          var nested = this.nestedArray,
              i = 0;

          while (i < nested.length) {
            if (nested[i] instanceof Namespace) nested[i++].resolveAll();else nested[i++].resolve();
          }

          return this.resolve();
        };
        /**
         * Recursively looks up the reflection object matching the specified path in the scope of this namespace.
         * @param {string|string[]} path Path to look up
         * @param {*|Array.<*>} filterTypes Filter types, any combination of the constructors of `protobuf.Type`, `protobuf.Enum`, `protobuf.Service` etc.
         * @param {boolean} [parentAlreadyChecked=false] If known, whether the parent has already been checked
         * @returns {ReflectionObject|null} Looked up object or `null` if none could be found
         */


        Namespace.prototype.lookup = function lookup(path, filterTypes, parentAlreadyChecked) {
          /* istanbul ignore next */
          if (typeof filterTypes === "boolean") {
            parentAlreadyChecked = filterTypes;
            filterTypes = undefined;
          } else if (filterTypes && !Array.isArray(filterTypes)) filterTypes = [filterTypes];

          if (util.isString(path) && path.length) {
            if (path === ".") return this.root;
            path = path.split(".");
          } else if (!path.length) return this; // Start at root if path is absolute


          if (path[0] === "") return this.root.lookup(path.slice(1), filterTypes); // Test if the first part matches any nested object, and if so, traverse if path contains more

          var found = this.get(path[0]);

          if (found) {
            if (path.length === 1) {
              if (!filterTypes || filterTypes.indexOf(found.constructor) > -1) return found;
            } else if (found instanceof Namespace && (found = found.lookup(path.slice(1), filterTypes, true))) return found; // Otherwise try each nested namespace

          } else for (var i = 0; i < this.nestedArray.length; ++i) {
            if (this._nestedArray[i] instanceof Namespace && (found = this._nestedArray[i].lookup(path, filterTypes, true))) return found;
          } // If there hasn't been a match, try again at the parent


          if (this.parent === null || parentAlreadyChecked) return null;
          return this.parent.lookup(path, filterTypes);
        };
        /**
         * Looks up the reflection object at the specified path, relative to this namespace.
         * @name NamespaceBase#lookup
         * @function
         * @param {string|string[]} path Path to look up
         * @param {boolean} [parentAlreadyChecked=false] Whether the parent has already been checked
         * @returns {ReflectionObject|null} Looked up object or `null` if none could be found
         * @variation 2
         */
        // lookup(path: string, [parentAlreadyChecked: boolean])

        /**
         * Looks up the {@link Type|type} at the specified path, relative to this namespace.
         * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
         * @param {string|string[]} path Path to look up
         * @returns {Type} Looked up type
         * @throws {Error} If `path` does not point to a type
         */


        Namespace.prototype.lookupType = function lookupType(path) {
          var found = this.lookup(path, [Type]);
          if (!found) throw Error("no such type: " + path);
          return found;
        };
        /**
         * Looks up the values of the {@link Enum|enum} at the specified path, relative to this namespace.
         * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
         * @param {string|string[]} path Path to look up
         * @returns {Enum} Looked up enum
         * @throws {Error} If `path` does not point to an enum
         */


        Namespace.prototype.lookupEnum = function lookupEnum(path) {
          var found = this.lookup(path, [Enum]);
          if (!found) throw Error("no such Enum '" + path + "' in " + this);
          return found;
        };
        /**
         * Looks up the {@link Type|type} or {@link Enum|enum} at the specified path, relative to this namespace.
         * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
         * @param {string|string[]} path Path to look up
         * @returns {Type} Looked up type or enum
         * @throws {Error} If `path` does not point to a type or enum
         */


        Namespace.prototype.lookupTypeOrEnum = function lookupTypeOrEnum(path) {
          var found = this.lookup(path, [Type, Enum]);
          if (!found) throw Error("no such Type or Enum '" + path + "' in " + this);
          return found;
        };
        /**
         * Looks up the {@link Service|service} at the specified path, relative to this namespace.
         * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
         * @param {string|string[]} path Path to look up
         * @returns {Service} Looked up service
         * @throws {Error} If `path` does not point to a service
         */


        Namespace.prototype.lookupService = function lookupService(path) {
          var found = this.lookup(path, [Service]);
          if (!found) throw Error("no such Service '" + path + "' in " + this);
          return found;
        }; // Sets up cyclic dependencies (called in index-light)


        Namespace._configure = function (Type_, Service_, Enum_) {
          Type = Type_;
          Service = Service_;
          Enum = Enum_;
        }; // #endregion ORIGINAL CODE


        module.exports;
      }, function () {
        return {
          './object': __cjsMetaURL$1,
          './field': __cjsMetaURL$2,
          './oneof': __cjsMetaURL$3,
          './util': __cjsMetaURL$4
        };
      });
    }
  };
});

System.register("chunks:///_virtual/object.js", ['./cjs-loader.mjs', './util.js'], function (exports, module) {
  'use strict';

  var loader, __cjsMetaURL$1;

  return {
    setters: [function (module) {
      loader = module.default;
    }, function (module) {
      __cjsMetaURL$1 = module.__cjsMetaURL;
    }],
    execute: function () {
      var __cjsMetaURL = exports('__cjsMetaURL', module.meta.url);

      loader.define(__cjsMetaURL, function (exports, require, module, __filename, __dirname) {
        module.exports = ReflectionObject;
        ReflectionObject.className = "ReflectionObject";

        var util = require("./util");

        var Root; // cyclic

        /**
         * Constructs a new reflection object instance.
         * @classdesc Base class of all reflection objects.
         * @constructor
         * @param {string} name Object name
         * @param {Object.<string,*>} [options] Declared options
         * @abstract
         */

        function ReflectionObject(name, options) {
          if (!util.isString(name)) throw TypeError("name must be a string");
          if (options && !util.isObject(options)) throw TypeError("options must be an object");
          /**
           * Options.
           * @type {Object.<string,*>|undefined}
           */

          this.options = options; // toJSON

          /**
           * Parsed Options.
           * @type {Array.<Object.<string,*>>|undefined}
           */

          this.parsedOptions = null;
          /**
           * Unique name within its namespace.
           * @type {string}
           */

          this.name = name;
          /**
           * Parent namespace.
           * @type {Namespace|null}
           */

          this.parent = null;
          /**
           * Whether already resolved or not.
           * @type {boolean}
           */

          this.resolved = false;
          /**
           * Comment text, if any.
           * @type {string|null}
           */

          this.comment = null;
          /**
           * Defining file name.
           * @type {string|null}
           */

          this.filename = null;
        }

        Object.defineProperties(ReflectionObject.prototype, {
          /**
           * Reference to the root namespace.
           * @name ReflectionObject#root
           * @type {Root}
           * @readonly
           */
          root: {
            get: function get() {
              var ptr = this;

              while (ptr.parent !== null) {
                ptr = ptr.parent;
              }

              return ptr;
            }
          },

          /**
           * Full name including leading dot.
           * @name ReflectionObject#fullName
           * @type {string}
           * @readonly
           */
          fullName: {
            get: function get() {
              var path = [this.name],
                  ptr = this.parent;

              while (ptr) {
                path.unshift(ptr.name);
                ptr = ptr.parent;
              }

              return path.join(".");
            }
          }
        });
        /**
         * Converts this reflection object to its descriptor representation.
         * @returns {Object.<string,*>} Descriptor
         * @abstract
         */

        ReflectionObject.prototype.toJSON =
        /* istanbul ignore next */
        function toJSON() {
          throw Error(); // not implemented, shouldn't happen
        };
        /**
         * Called when this object is added to a parent.
         * @param {ReflectionObject} parent Parent added to
         * @returns {undefined}
         */


        ReflectionObject.prototype.onAdd = function onAdd(parent) {
          if (this.parent && this.parent !== parent) this.parent.remove(this);
          this.parent = parent;
          this.resolved = false;
          var root = parent.root;
          if (root instanceof Root) root._handleAdd(this);
        };
        /**
         * Called when this object is removed from a parent.
         * @param {ReflectionObject} parent Parent removed from
         * @returns {undefined}
         */


        ReflectionObject.prototype.onRemove = function onRemove(parent) {
          var root = parent.root;
          if (root instanceof Root) root._handleRemove(this);
          this.parent = null;
          this.resolved = false;
        };
        /**
         * Resolves this objects type references.
         * @returns {ReflectionObject} `this`
         */


        ReflectionObject.prototype.resolve = function resolve() {
          if (this.resolved) return this;
          if (this.root instanceof Root) this.resolved = true; // only if part of a root

          return this;
        };
        /**
         * Gets an option value.
         * @param {string} name Option name
         * @returns {*} Option value or `undefined` if not set
         */


        ReflectionObject.prototype.getOption = function getOption(name) {
          if (this.options) return this.options[name];
          return undefined;
        };
        /**
         * Sets an option.
         * @param {string} name Option name
         * @param {*} value Option value
         * @param {boolean} [ifNotSet] Sets the option only if it isn't currently set
         * @returns {ReflectionObject} `this`
         */


        ReflectionObject.prototype.setOption = function setOption(name, value, ifNotSet) {
          if (!ifNotSet || !this.options || this.options[name] === undefined) (this.options || (this.options = {}))[name] = value;
          return this;
        };
        /**
         * Sets a parsed option.
         * @param {string} name parsed Option name
         * @param {*} value Option value
         * @param {string} propName dot '.' delimited full path of property within the option to set. if undefined\empty, will add a new option with that value
         * @returns {ReflectionObject} `this`
         */


        ReflectionObject.prototype.setParsedOption = function setParsedOption(name, value, propName) {
          if (!this.parsedOptions) {
            this.parsedOptions = [];
          }

          var parsedOptions = this.parsedOptions;

          if (propName) {
            // If setting a sub property of an option then try to merge it
            // with an existing option
            var opt = parsedOptions.find(function (opt) {
              return Object.prototype.hasOwnProperty.call(opt, name);
            });

            if (opt) {
              // If we found an existing option - just merge the property value
              var newValue = opt[name];
              util.setProperty(newValue, propName, value);
            } else {
              // otherwise, create a new option, set it's property and add it to the list
              opt = {};
              opt[name] = util.setProperty({}, propName, value);
              parsedOptions.push(opt);
            }
          } else {
            // Always create a new option when setting the value of the option itself
            var newOpt = {};
            newOpt[name] = value;
            parsedOptions.push(newOpt);
          }

          return this;
        };
        /**
         * Sets multiple options.
         * @param {Object.<string,*>} options Options to set
         * @param {boolean} [ifNotSet] Sets an option only if it isn't currently set
         * @returns {ReflectionObject} `this`
         */


        ReflectionObject.prototype.setOptions = function setOptions(options, ifNotSet) {
          if (options) for (var keys = Object.keys(options), i = 0; i < keys.length; ++i) {
            this.setOption(keys[i], options[keys[i]], ifNotSet);
          }
          return this;
        };
        /**
         * Converts this instance to its string representation.
         * @returns {string} Class name[, space, full name]
         */


        ReflectionObject.prototype.toString = function toString() {
          var className = this.constructor.className,
              fullName = this.fullName;
          if (fullName.length) return className + " " + fullName;
          return className;
        }; // Sets up cyclic dependencies (called in index-light)


        ReflectionObject._configure = function (Root_) {
          Root = Root_;
        }; // #endregion ORIGINAL CODE


        module.exports;
      }, function () {
        return {
          './util': __cjsMetaURL$1
        };
      });
    }
  };
});

System.register("chunks:///_virtual/oneof.js", ['./cjs-loader.mjs', './object.js', './field.js', './util.js'], function (exports, module) {
  'use strict';

  var loader, __cjsMetaURL$1, __cjsMetaURL$2, __cjsMetaURL$3;

  return {
    setters: [function (module) {
      loader = module.default;
    }, function (module) {
      __cjsMetaURL$1 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$2 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$3 = module.__cjsMetaURL;
    }],
    execute: function () {
      var __cjsMetaURL = exports('__cjsMetaURL', module.meta.url);

      loader.define(__cjsMetaURL, function (exports, require, module, __filename, __dirname) {
        module.exports = OneOf; // extends ReflectionObject

        var ReflectionObject = require("./object");

        ((OneOf.prototype = Object.create(ReflectionObject.prototype)).constructor = OneOf).className = "OneOf";

        var Field = require("./field"),
            util = require("./util");
        /**
         * Constructs a new oneof instance.
         * @classdesc Reflected oneof.
         * @extends ReflectionObject
         * @constructor
         * @param {string} name Oneof name
         * @param {string[]|Object.<string,*>} [fieldNames] Field names
         * @param {Object.<string,*>} [options] Declared options
         * @param {string} [comment] Comment associated with this field
         */


        function OneOf(name, fieldNames, options, comment) {
          if (!Array.isArray(fieldNames)) {
            options = fieldNames;
            fieldNames = undefined;
          }

          ReflectionObject.call(this, name, options);
          /* istanbul ignore if */

          if (!(fieldNames === undefined || Array.isArray(fieldNames))) throw TypeError("fieldNames must be an Array");
          /**
           * Field names that belong to this oneof.
           * @type {string[]}
           */

          this.oneof = fieldNames || []; // toJSON, marker

          /**
           * Fields that belong to this oneof as an array for iteration.
           * @type {Field[]}
           * @readonly
           */

          this.fieldsArray = []; // declared readonly for conformance, possibly not yet added to parent

          /**
           * Comment for this field.
           * @type {string|null}
           */

          this.comment = comment;
        }
        /**
         * Oneof descriptor.
         * @interface IOneOf
         * @property {Array.<string>} oneof Oneof field names
         * @property {Object.<string,*>} [options] Oneof options
         */

        /**
         * Constructs a oneof from a oneof descriptor.
         * @param {string} name Oneof name
         * @param {IOneOf} json Oneof descriptor
         * @returns {OneOf} Created oneof
         * @throws {TypeError} If arguments are invalid
         */


        OneOf.fromJSON = function fromJSON(name, json) {
          return new OneOf(name, json.oneof, json.options, json.comment);
        };
        /**
         * Converts this oneof to a oneof descriptor.
         * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
         * @returns {IOneOf} Oneof descriptor
         */


        OneOf.prototype.toJSON = function toJSON(toJSONOptions) {
          var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
          return util.toObject(["options", this.options, "oneof", this.oneof, "comment", keepComments ? this.comment : undefined]);
        };
        /**
         * Adds the fields of the specified oneof to the parent if not already done so.
         * @param {OneOf} oneof The oneof
         * @returns {undefined}
         * @inner
         * @ignore
         */


        function addFieldsToParent(oneof) {
          if (oneof.parent) for (var i = 0; i < oneof.fieldsArray.length; ++i) {
            if (!oneof.fieldsArray[i].parent) oneof.parent.add(oneof.fieldsArray[i]);
          }
        }
        /**
         * Adds a field to this oneof and removes it from its current parent, if any.
         * @param {Field} field Field to add
         * @returns {OneOf} `this`
         */


        OneOf.prototype.add = function add(field) {
          /* istanbul ignore if */
          if (!(field instanceof Field)) throw TypeError("field must be a Field");
          if (field.parent && field.parent !== this.parent) field.parent.remove(field);
          this.oneof.push(field.name);
          this.fieldsArray.push(field);
          field.partOf = this; // field.parent remains null

          addFieldsToParent(this);
          return this;
        };
        /**
         * Removes a field from this oneof and puts it back to the oneof's parent.
         * @param {Field} field Field to remove
         * @returns {OneOf} `this`
         */


        OneOf.prototype.remove = function remove(field) {
          /* istanbul ignore if */
          if (!(field instanceof Field)) throw TypeError("field must be a Field");
          var index = this.fieldsArray.indexOf(field);
          /* istanbul ignore if */

          if (index < 0) throw Error(field + " is not a member of " + this);
          this.fieldsArray.splice(index, 1);
          index = this.oneof.indexOf(field.name);
          /* istanbul ignore else */

          if (index > -1) // theoretical
            this.oneof.splice(index, 1);
          field.partOf = null;
          return this;
        };
        /**
         * @override
         */


        OneOf.prototype.onAdd = function onAdd(parent) {
          ReflectionObject.prototype.onAdd.call(this, parent);
          var self = this; // Collect present fields

          for (var i = 0; i < this.oneof.length; ++i) {
            var field = parent.get(this.oneof[i]);

            if (field && !field.partOf) {
              field.partOf = self;
              self.fieldsArray.push(field);
            }
          } // Add not yet present fields


          addFieldsToParent(this);
        };
        /**
         * @override
         */


        OneOf.prototype.onRemove = function onRemove(parent) {
          for (var i = 0, field; i < this.fieldsArray.length; ++i) {
            if ((field = this.fieldsArray[i]).parent) field.parent.remove(field);
          }

          ReflectionObject.prototype.onRemove.call(this, parent);
        };
        /**
         * Decorator function as returned by {@link OneOf.d} (TypeScript).
         * @typedef OneOfDecorator
         * @type {function}
         * @param {Object} prototype Target prototype
         * @param {string} oneofName OneOf name
         * @returns {undefined}
         */

        /**
         * OneOf decorator (TypeScript).
         * @function
         * @param {...string} fieldNames Field names
         * @returns {OneOfDecorator} Decorator function
         * @template T extends string
         */


        OneOf.d = function decorateOneOf() {
          var fieldNames = new Array(arguments.length),
              index = 0;

          while (index < arguments.length) {
            fieldNames[index] = arguments[index++];
          }

          return function oneOfDecorator(prototype, oneofName) {
            util.decorateType(prototype.constructor).add(new OneOf(oneofName, fieldNames));
            Object.defineProperty(prototype, oneofName, {
              get: util.oneOfGetter(fieldNames),
              set: util.oneOfSetter(fieldNames)
            });
          };
        }; // #endregion ORIGINAL CODE


        module.exports;
      }, function () {
        return {
          './object': __cjsMetaURL$1,
          './field': __cjsMetaURL$2,
          './util': __cjsMetaURL$3
        };
      });
    }
  };
});

System.register("chunks:///_virtual/parse.js", ['./cjs-loader.mjs', './tokenize.js', './root.js', './type.js', './field.js', './mapfield.js', './oneof.js', './enum.js', './service.js', './method.js', './types.js', './util.js'], function (exports, module) {
  'use strict';

  var loader, __cjsMetaURL$1, __cjsMetaURL$2, __cjsMetaURL$3, __cjsMetaURL$4, __cjsMetaURL$5, __cjsMetaURL$6, __cjsMetaURL$7, __cjsMetaURL$8, __cjsMetaURL$9, __cjsMetaURL$a, __cjsMetaURL$b;

  return {
    setters: [function (module) {
      loader = module.default;
    }, function (module) {
      __cjsMetaURL$1 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$2 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$3 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$4 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$5 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$6 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$7 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$8 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$9 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$a = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$b = module.__cjsMetaURL;
    }],
    execute: function () {
      var __cjsMetaURL = exports('__cjsMetaURL', module.meta.url);

      loader.define(__cjsMetaURL, function (exports, require, module, __filename, __dirname) {
        module.exports = parse;
        parse.filename = null;
        parse.defaults = {
          keepCase: false
        };

        var tokenize = require("./tokenize"),
            Root = require("./root"),
            Type = require("./type"),
            Field = require("./field"),
            MapField = require("./mapfield"),
            OneOf = require("./oneof"),
            Enum = require("./enum"),
            Service = require("./service"),
            Method = require("./method"),
            types = require("./types"),
            util = require("./util");

        var base10Re = /^[1-9][0-9]*$/,
            base10NegRe = /^-?[1-9][0-9]*$/,
            base16Re = /^0[x][0-9a-fA-F]+$/,
            base16NegRe = /^-?0[x][0-9a-fA-F]+$/,
            base8Re = /^0[0-7]+$/,
            base8NegRe = /^-?0[0-7]+$/,
            numberRe = /^(?![eE])[0-9]*(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/,
            nameRe = /^[a-zA-Z_][a-zA-Z_0-9]*$/,
            typeRefRe = /^(?:\.?[a-zA-Z_][a-zA-Z_0-9]*)(?:\.[a-zA-Z_][a-zA-Z_0-9]*)*$/,
            fqTypeRefRe = /^(?:\.[a-zA-Z_][a-zA-Z_0-9]*)+$/;
        /**
         * Result object returned from {@link parse}.
         * @interface IParserResult
         * @property {string|undefined} package Package name, if declared
         * @property {string[]|undefined} imports Imports, if any
         * @property {string[]|undefined} weakImports Weak imports, if any
         * @property {string|undefined} syntax Syntax, if specified (either `"proto2"` or `"proto3"`)
         * @property {Root} root Populated root instance
         */

        /**
         * Options modifying the behavior of {@link parse}.
         * @interface IParseOptions
         * @property {boolean} [keepCase=false] Keeps field casing instead of converting to camel case
         * @property {boolean} [alternateCommentMode=false] Recognize double-slash comments in addition to doc-block comments.
         * @property {boolean} [preferTrailingComment=false] Use trailing comment when both leading comment and trailing comment exist.
         */

        /**
         * Options modifying the behavior of JSON serialization.
         * @interface IToJSONOptions
         * @property {boolean} [keepComments=false] Serializes comments.
         */

        /**
         * Parses the given .proto source and returns an object with the parsed contents.
         * @param {string} source Source contents
         * @param {Root} root Root to populate
         * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
         * @returns {IParserResult} Parser result
         * @property {string} filename=null Currently processing file name for error reporting, if known
         * @property {IParseOptions} defaults Default {@link IParseOptions}
         */

        function parse(source, root, options) {
          /* eslint-disable callback-return */
          if (!(root instanceof Root)) {
            options = root;
            root = new Root();
          }

          if (!options) options = parse.defaults;
          var preferTrailingComment = options.preferTrailingComment || false;
          var tn = tokenize(source, options.alternateCommentMode || false),
              next = tn.next,
              push = tn.push,
              peek = tn.peek,
              skip = tn.skip,
              cmnt = tn.cmnt;
          var head = true,
              pkg,
              imports,
              weakImports,
              syntax,
              isProto3 = false;
          var ptr = root;
          var applyCase = options.keepCase ? function (name) {
            return name;
          } : util.camelCase;
          /* istanbul ignore next */

          function illegal(token, name, insideTryCatch) {
            var filename = parse.filename;
            if (!insideTryCatch) parse.filename = null;
            return Error("illegal " + (name || "token") + " '" + token + "' (" + (filename ? filename + ", " : "") + "line " + tn.line + ")");
          }

          function readString() {
            var values = [],
                token;

            do {
              /* istanbul ignore if */
              if ((token = next()) !== "\"" && token !== "'") throw illegal(token);
              values.push(next());
              skip(token);
              token = peek();
            } while (token === "\"" || token === "'");

            return values.join("");
          }

          function readValue(acceptTypeRef) {
            var token = next();

            switch (token) {
              case "'":
              case "\"":
                push(token);
                return readString();

              case "true":
              case "TRUE":
                return true;

              case "false":
              case "FALSE":
                return false;
            }

            try {
              return parseNumber(token,
              /* insideTryCatch */
              true);
            } catch (e) {
              /* istanbul ignore else */
              if (acceptTypeRef && typeRefRe.test(token)) return token;
              /* istanbul ignore next */

              throw illegal(token, "value");
            }
          }

          function readRanges(target, acceptStrings) {
            var token, start;

            do {
              if (acceptStrings && ((token = peek()) === "\"" || token === "'")) target.push(readString());else target.push([start = parseId(next()), skip("to", true) ? parseId(next()) : start]);
            } while (skip(",", true));

            skip(";");
          }

          function parseNumber(token, insideTryCatch) {
            var sign = 1;

            if (token.charAt(0) === "-") {
              sign = -1;
              token = token.substring(1);
            }

            switch (token) {
              case "inf":
              case "INF":
              case "Inf":
                return sign * Infinity;

              case "nan":
              case "NAN":
              case "Nan":
              case "NaN":
                return NaN;

              case "0":
                return 0;
            }

            if (base10Re.test(token)) return sign * parseInt(token, 10);
            if (base16Re.test(token)) return sign * parseInt(token, 16);
            if (base8Re.test(token)) return sign * parseInt(token, 8);
            /* istanbul ignore else */

            if (numberRe.test(token)) return sign * parseFloat(token);
            /* istanbul ignore next */

            throw illegal(token, "number", insideTryCatch);
          }

          function parseId(token, acceptNegative) {
            switch (token) {
              case "max":
              case "MAX":
              case "Max":
                return 536870911;

              case "0":
                return 0;
            }
            /* istanbul ignore if */


            if (!acceptNegative && token.charAt(0) === "-") throw illegal(token, "id");
            if (base10NegRe.test(token)) return parseInt(token, 10);
            if (base16NegRe.test(token)) return parseInt(token, 16);
            /* istanbul ignore else */

            if (base8NegRe.test(token)) return parseInt(token, 8);
            /* istanbul ignore next */

            throw illegal(token, "id");
          }

          function parsePackage() {
            /* istanbul ignore if */
            if (pkg !== undefined) throw illegal("package");
            pkg = next();
            /* istanbul ignore if */

            if (!typeRefRe.test(pkg)) throw illegal(pkg, "name");
            ptr = ptr.define(pkg);
            skip(";");
          }

          function parseImport() {
            var token = peek();
            var whichImports;

            switch (token) {
              case "weak":
                whichImports = weakImports || (weakImports = []);
                next();
                break;

              case "public":
                next();
              // eslint-disable-line no-fallthrough

              default:
                whichImports = imports || (imports = []);
                break;
            }

            token = readString();
            skip(";");
            whichImports.push(token);
          }

          function parseSyntax() {
            skip("=");
            syntax = readString();
            isProto3 = syntax === "proto3";
            /* istanbul ignore if */

            if (!isProto3 && syntax !== "proto2") throw illegal(syntax, "syntax");
            skip(";");
          }

          function parseCommon(parent, token) {
            switch (token) {
              case "option":
                parseOption(parent, token);
                skip(";");
                return true;

              case "message":
                parseType(parent, token);
                return true;

              case "enum":
                parseEnum(parent, token);
                return true;

              case "service":
                parseService(parent, token);
                return true;

              case "extend":
                parseExtension(parent, token);
                return true;
            }

            return false;
          }

          function ifBlock(obj, fnIf, fnElse) {
            var trailingLine = tn.line;

            if (obj) {
              if (typeof obj.comment !== "string") {
                obj.comment = cmnt(); // try block-type comment
              }

              obj.filename = parse.filename;
            }

            if (skip("{", true)) {
              var token;

              while ((token = next()) !== "}") {
                fnIf(token);
              }

              skip(";", true);
            } else {
              if (fnElse) fnElse();
              skip(";");
              if (obj && (typeof obj.comment !== "string" || preferTrailingComment)) obj.comment = cmnt(trailingLine) || obj.comment; // try line-type comment
            }
          }

          function parseType(parent, token) {
            /* istanbul ignore if */
            if (!nameRe.test(token = next())) throw illegal(token, "type name");
            var type = new Type(token);
            ifBlock(type, function parseType_block(token) {
              if (parseCommon(type, token)) return;

              switch (token) {
                case "map":
                  parseMapField(type);
                  break;

                case "required":
                case "repeated":
                  parseField(type, token);
                  break;

                case "optional":
                  /* istanbul ignore if */
                  if (isProto3) {
                    parseField(type, "proto3_optional");
                  } else {
                    parseField(type, "optional");
                  }

                  break;

                case "oneof":
                  parseOneOf(type, token);
                  break;

                case "extensions":
                  readRanges(type.extensions || (type.extensions = []));
                  break;

                case "reserved":
                  readRanges(type.reserved || (type.reserved = []), true);
                  break;

                default:
                  /* istanbul ignore if */
                  if (!isProto3 || !typeRefRe.test(token)) throw illegal(token);
                  push(token);
                  parseField(type, "optional");
                  break;
              }
            });
            parent.add(type);
          }

          function parseField(parent, rule, extend) {
            var type = next();

            if (type === "group") {
              parseGroup(parent, rule);
              return;
            }
            /* istanbul ignore if */


            if (!typeRefRe.test(type)) throw illegal(type, "type");
            var name = next();
            /* istanbul ignore if */

            if (!nameRe.test(name)) throw illegal(name, "name");
            name = applyCase(name);
            skip("=");
            var field = new Field(name, parseId(next()), type, rule, extend);
            ifBlock(field, function parseField_block(token) {
              /* istanbul ignore else */
              if (token === "option") {
                parseOption(field, token);
                skip(";");
              } else throw illegal(token);
            }, function parseField_line() {
              parseInlineOptions(field);
            });

            if (rule === "proto3_optional") {
              // for proto3 optional fields, we create a single-member Oneof to mimic "optional" behavior
              var oneof = new OneOf("_" + name);
              field.setOption("proto3_optional", true);
              oneof.add(field);
              parent.add(oneof);
            } else {
              parent.add(field);
            } // JSON defaults to packed=true if not set so we have to set packed=false explicity when
            // parsing proto2 descriptors without the option, where applicable. This must be done for
            // all known packable types and anything that could be an enum (= is not a basic type).


            if (!isProto3 && field.repeated && (types.packed[type] !== undefined || types.basic[type] === undefined)) field.setOption("packed", false,
            /* ifNotSet */
            true);
          }

          function parseGroup(parent, rule) {
            var name = next();
            /* istanbul ignore if */

            if (!nameRe.test(name)) throw illegal(name, "name");
            var fieldName = util.lcFirst(name);
            if (name === fieldName) name = util.ucFirst(name);
            skip("=");
            var id = parseId(next());
            var type = new Type(name);
            type.group = true;
            var field = new Field(fieldName, id, name, rule);
            field.filename = parse.filename;
            ifBlock(type, function parseGroup_block(token) {
              switch (token) {
                case "option":
                  parseOption(type, token);
                  skip(";");
                  break;

                case "required":
                case "repeated":
                  parseField(type, token);
                  break;

                case "optional":
                  /* istanbul ignore if */
                  if (isProto3) {
                    parseField(type, "proto3_optional");
                  } else {
                    parseField(type, "optional");
                  }

                  break;

                /* istanbul ignore next */

                default:
                  throw illegal(token);
                // there are no groups with proto3 semantics
              }
            });
            parent.add(type).add(field);
          }

          function parseMapField(parent) {
            skip("<");
            var keyType = next();
            /* istanbul ignore if */

            if (types.mapKey[keyType] === undefined) throw illegal(keyType, "type");
            skip(",");
            var valueType = next();
            /* istanbul ignore if */

            if (!typeRefRe.test(valueType)) throw illegal(valueType, "type");
            skip(">");
            var name = next();
            /* istanbul ignore if */

            if (!nameRe.test(name)) throw illegal(name, "name");
            skip("=");
            var field = new MapField(applyCase(name), parseId(next()), keyType, valueType);
            ifBlock(field, function parseMapField_block(token) {
              /* istanbul ignore else */
              if (token === "option") {
                parseOption(field, token);
                skip(";");
              } else throw illegal(token);
            }, function parseMapField_line() {
              parseInlineOptions(field);
            });
            parent.add(field);
          }

          function parseOneOf(parent, token) {
            /* istanbul ignore if */
            if (!nameRe.test(token = next())) throw illegal(token, "name");
            var oneof = new OneOf(applyCase(token));
            ifBlock(oneof, function parseOneOf_block(token) {
              if (token === "option") {
                parseOption(oneof, token);
                skip(";");
              } else {
                push(token);
                parseField(oneof, "optional");
              }
            });
            parent.add(oneof);
          }

          function parseEnum(parent, token) {
            /* istanbul ignore if */
            if (!nameRe.test(token = next())) throw illegal(token, "name");
            var enm = new Enum(token);
            ifBlock(enm, function parseEnum_block(token) {
              switch (token) {
                case "option":
                  parseOption(enm, token);
                  skip(";");
                  break;

                case "reserved":
                  readRanges(enm.reserved || (enm.reserved = []), true);
                  break;

                default:
                  parseEnumValue(enm, token);
              }
            });
            parent.add(enm);
          }

          function parseEnumValue(parent, token) {
            /* istanbul ignore if */
            if (!nameRe.test(token)) throw illegal(token, "name");
            skip("=");
            var value = parseId(next(), true),
                dummy = {};
            ifBlock(dummy, function parseEnumValue_block(token) {
              /* istanbul ignore else */
              if (token === "option") {
                parseOption(dummy, token); // skip

                skip(";");
              } else throw illegal(token);
            }, function parseEnumValue_line() {
              parseInlineOptions(dummy); // skip
            });
            parent.add(token, value, dummy.comment);
          }

          function parseOption(parent, token) {
            var isCustom = skip("(", true);
            /* istanbul ignore if */

            if (!typeRefRe.test(token = next())) throw illegal(token, "name");
            var name = token;
            var option = name;
            var propName;

            if (isCustom) {
              skip(")");
              name = "(" + name + ")";
              option = name;
              token = peek();

              if (fqTypeRefRe.test(token)) {
                propName = token.substr(1); //remove '.' before property name

                name += token;
                next();
              }
            }

            skip("=");
            var optionValue = parseOptionValue(parent, name);
            setParsedOption(parent, option, optionValue, propName);
          }

          function parseOptionValue(parent, name) {
            if (skip("{", true)) {
              // { a: "foo" b { c: "bar" } }
              var result = {};

              while (!skip("}", true)) {
                /* istanbul ignore if */
                if (!nameRe.test(token = next())) throw illegal(token, "name");
                var value;
                var propName = token;
                if (peek() === "{") value = parseOptionValue(parent, name + "." + token);else {
                  skip(":");
                  if (peek() === "{") value = parseOptionValue(parent, name + "." + token);else {
                    value = readValue(true);
                    setOption(parent, name + "." + token, value);
                  }
                }
                var prevValue = result[propName];
                if (prevValue) value = [].concat(prevValue).concat(value);
                result[propName] = value;
                skip(",", true);
              }

              return result;
            }

            var simpleValue = readValue(true);
            setOption(parent, name, simpleValue);
            return simpleValue; // Does not enforce a delimiter to be universal
          }

          function setOption(parent, name, value) {
            if (parent.setOption) parent.setOption(name, value);
          }

          function setParsedOption(parent, name, value, propName) {
            if (parent.setParsedOption) parent.setParsedOption(name, value, propName);
          }

          function parseInlineOptions(parent) {
            if (skip("[", true)) {
              do {
                parseOption(parent, "option");
              } while (skip(",", true));

              skip("]");
            }

            return parent;
          }

          function parseService(parent, token) {
            /* istanbul ignore if */
            if (!nameRe.test(token = next())) throw illegal(token, "service name");
            var service = new Service(token);
            ifBlock(service, function parseService_block(token) {
              if (parseCommon(service, token)) return;
              /* istanbul ignore else */

              if (token === "rpc") parseMethod(service, token);else throw illegal(token);
            });
            parent.add(service);
          }

          function parseMethod(parent, token) {
            // Get the comment of the preceding line now (if one exists) in case the
            // method is defined across multiple lines.
            var commentText = cmnt();
            var type = token;
            /* istanbul ignore if */

            if (!nameRe.test(token = next())) throw illegal(token, "name");
            var name = token,
                requestType,
                requestStream,
                responseType,
                responseStream;
            skip("(");
            if (skip("stream", true)) requestStream = true;
            /* istanbul ignore if */

            if (!typeRefRe.test(token = next())) throw illegal(token);
            requestType = token;
            skip(")");
            skip("returns");
            skip("(");
            if (skip("stream", true)) responseStream = true;
            /* istanbul ignore if */

            if (!typeRefRe.test(token = next())) throw illegal(token);
            responseType = token;
            skip(")");
            var method = new Method(name, type, requestType, responseType, requestStream, responseStream);
            method.comment = commentText;
            ifBlock(method, function parseMethod_block(token) {
              /* istanbul ignore else */
              if (token === "option") {
                parseOption(method, token);
                skip(";");
              } else throw illegal(token);
            });
            parent.add(method);
          }

          function parseExtension(parent, token) {
            /* istanbul ignore if */
            if (!typeRefRe.test(token = next())) throw illegal(token, "reference");
            var reference = token;
            ifBlock(null, function parseExtension_block(token) {
              switch (token) {
                case "required":
                case "repeated":
                  parseField(parent, token, reference);
                  break;

                case "optional":
                  /* istanbul ignore if */
                  if (isProto3) {
                    parseField(parent, "proto3_optional", reference);
                  } else {
                    parseField(parent, "optional", reference);
                  }

                  break;

                default:
                  /* istanbul ignore if */
                  if (!isProto3 || !typeRefRe.test(token)) throw illegal(token);
                  push(token);
                  parseField(parent, "optional", reference);
                  break;
              }
            });
          }

          var token;

          while ((token = next()) !== null) {
            switch (token) {
              case "package":
                /* istanbul ignore if */
                if (!head) throw illegal(token);
                parsePackage();
                break;

              case "import":
                /* istanbul ignore if */
                if (!head) throw illegal(token);
                parseImport();
                break;

              case "syntax":
                /* istanbul ignore if */
                if (!head) throw illegal(token);
                parseSyntax();
                break;

              case "option":
                parseOption(ptr, token);
                skip(";");
                break;

              default:
                /* istanbul ignore else */
                if (parseCommon(ptr, token)) {
                  head = false;
                  continue;
                }
                /* istanbul ignore next */


                throw illegal(token);
            }
          }

          parse.filename = null;
          return {
            "package": pkg,
            "imports": imports,
            weakImports: weakImports,
            syntax: syntax,
            root: root
          };
        }
        /**
         * Parses the given .proto source and returns an object with the parsed contents.
         * @name parse
         * @function
         * @param {string} source Source contents
         * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
         * @returns {IParserResult} Parser result
         * @property {string} filename=null Currently processing file name for error reporting, if known
         * @property {IParseOptions} defaults Default {@link IParseOptions}
         * @variation 2
         */
        // #endregion ORIGINAL CODE


        module.exports;
      }, function () {
        return {
          './tokenize': __cjsMetaURL$1,
          './root': __cjsMetaURL$2,
          './type': __cjsMetaURL$3,
          './field': __cjsMetaURL$4,
          './mapfield': __cjsMetaURL$5,
          './oneof': __cjsMetaURL$6,
          './enum': __cjsMetaURL$7,
          './service': __cjsMetaURL$8,
          './method': __cjsMetaURL$9,
          './types': __cjsMetaURL$a,
          './util': __cjsMetaURL$b
        };
      });
    }
  };
});

System.register("chunks:///_virtual/pgame.js", ['./cjs-loader.mjs', './minimal.js'], function (exports, module) {
  'use strict';

  var loader, __cjsMetaURL$1;

  return {
    setters: [function (module) {
      loader = module.default;
    }, function (module) {
      __cjsMetaURL$1 = module.__cjsMetaURL;
    }],
    execute: function () {
      exports('default', void 0);

      var _cjsExports;

      var __cjsMetaURL = exports('__cjsMetaURL', module.meta.url);

      loader.define(__cjsMetaURL, function (exports$1, require, module, __filename, __dirname) {
        // #region ORIGINAL CODE
        var $protobuf = require("protobufjs/minimal"); // Common aliases


        var $Reader = $protobuf.Reader,
            $Writer = $protobuf.Writer,
            $util = $protobuf.util; // Exported root namespace

        var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

        $root.serverProto = function () {
          /**
          * Namespace serverProto.
          * @exports serverProto
          * @namespace
          */
          var serverProto = {};
          /**
          * Error enum.
          * @name serverProto.Error
          * @enum {number}
          * @property {number} success=0 success value
          * @property {number} SpecialError=123 SpecialError value
          * @property {number} plateInvalid=211 plateInvalid value
          * @property {number} gameInvalid=241 gameInvalid value
          * @property {number} paramter=251 paramter value
          * @property {number} ackType=252 ackType value
          * @property {number} reLogin=253 reLogin value
          * @property {number} spinBet=301 spinBet value
          * @property {number} spinRetry=303 spinRetry value
          * @property {number} spinReject=304 spinReject value
          * @property {number} spinCoinError=305 spinCoinError value
          * @property {number} spinCurrecny=311 spinCurrecny value
          * @property {number} missionUnavailable=400 missionUnavailable value
          * @property {number} itemUnavailable=500 itemUnavailable value
          * @property {number} signUnavailable=600 signUnavailable value
          * @property {number} trialUnavailable=700 trialUnavailable value
          * @property {number} trialIsEnd=701 trialIsEnd value
          * @property {number} vipSignUnavailable=800 vipSignUnavailable value
          * @property {number} DebrisUnavailable=801 DebrisUnavailable value
          * @property {number} DebrisError=802 DebrisError value
          * @property {number} GiftCodeEror=803 GiftCodeEror value
          * @property {number} unknow=9999 unknow value
          */

          serverProto.Error = function () {
            var valuesById = {},
                values = Object.create(valuesById);
            values[valuesById[0] = "success"] = 0;
            values[valuesById[123] = "SpecialError"] = 123;
            values[valuesById[211] = "plateInvalid"] = 211;
            values[valuesById[241] = "gameInvalid"] = 241;
            values[valuesById[251] = "paramter"] = 251;
            values[valuesById[252] = "ackType"] = 252;
            values[valuesById[253] = "reLogin"] = 253;
            values[valuesById[301] = "spinBet"] = 301;
            values[valuesById[303] = "spinRetry"] = 303;
            values[valuesById[304] = "spinReject"] = 304;
            values[valuesById[305] = "spinCoinError"] = 305;
            values[valuesById[311] = "spinCurrecny"] = 311;
            values[valuesById[400] = "missionUnavailable"] = 400;
            values[valuesById[500] = "itemUnavailable"] = 500;
            values[valuesById[600] = "signUnavailable"] = 600;
            values[valuesById[700] = "trialUnavailable"] = 700;
            values[valuesById[701] = "trialIsEnd"] = 701;
            values[valuesById[800] = "vipSignUnavailable"] = 800;
            values[valuesById[801] = "DebrisUnavailable"] = 801;
            values[valuesById[802] = "DebrisError"] = 802;
            values[valuesById[803] = "GiftCodeEror"] = 803;
            values[valuesById[9999] = "unknow"] = 9999;
            return values;
          }();
          /**
          * AckType enum.
          * @name serverProto.AckType
          * @enum {number}
          * @property {number} spin=0 spin value
          * @property {number} info=1 info value
          * @property {number} notice=2 notice value
          * @property {number} logout=3 logout value
          * @property {number} lastSpin=4 lastSpin value
          * @property {number} getBackPack=5 getBackPack value
          * @property {number} checkItem=6 checkItem value
          * @property {number} getMail=7 getMail value
          * @property {number} readMail=8 readMail value
          * @property {number} getDailyMission=9 getDailyMission value
          * @property {number} getNowMission=10 getNowMission value
          * @property {number} customAck=11 customAck value
          * @property {number} checkSignUpStatus=12 checkSignUpStatus value
          * @property {number} trialInfo=14 trialInfo value
          * @property {number} trialSpin=15 trialSpin value
          * @property {number} trialSignUp=16 trialSignUp value
          * @property {number} trialGiveUp=17 trialGiveUp value
          * @property {number} getAllItemCanUse=18 getAllItemCanUse value
          * @property {number} vipSignInfo=19 vipSignInfo value
          * @property {number} vipSignReward=20 vipSignReward value
          * @property {number} jpInfo=21 jpInfo value
          * @property {number} jpHistory=22 jpHistory value
          * @property {number} lotteryPlayerInfo=23 lotteryPlayerInfo value
          * @property {number} lotteryReward=24 lotteryReward value
          * @property {number} fullJpInfo=25 fullJpInfo value
          * @property {number} fullJpHistory=26 fullJpHistory value
          * @property {number} fullJpInfoAll=27 fullJpInfoAll value
          * @property {number} extraSpin=28 extraSpin value
          * @property {number} debrisInfo=29 debrisInfo value
          * @property {number} debrisPlayerInfo=30 debrisPlayerInfo value
          * @property {number} debrisGet=31 debrisGet value
          * @property {number} debrisExchange=32 debrisExchange value
          * @property {number} jpShowData=33 jpShowData value
          * @property {number} getPlayerLevel=34 getPlayerLevel value
          * @property {number} verifyGiftCode=35 verifyGiftCode value
          */


          serverProto.AckType = function () {
            var valuesById = {},
                values = Object.create(valuesById);
            values[valuesById[0] = "spin"] = 0;
            values[valuesById[1] = "info"] = 1;
            values[valuesById[2] = "notice"] = 2;
            values[valuesById[3] = "logout"] = 3;
            values[valuesById[4] = "lastSpin"] = 4;
            values[valuesById[5] = "getBackPack"] = 5;
            values[valuesById[6] = "checkItem"] = 6;
            values[valuesById[7] = "getMail"] = 7;
            values[valuesById[8] = "readMail"] = 8;
            values[valuesById[9] = "getDailyMission"] = 9;
            values[valuesById[10] = "getNowMission"] = 10;
            values[valuesById[11] = "customAck"] = 11;
            values[valuesById[12] = "checkSignUpStatus"] = 12;
            values[valuesById[14] = "trialInfo"] = 14;
            values[valuesById[15] = "trialSpin"] = 15;
            values[valuesById[16] = "trialSignUp"] = 16;
            values[valuesById[17] = "trialGiveUp"] = 17;
            values[valuesById[18] = "getAllItemCanUse"] = 18;
            values[valuesById[19] = "vipSignInfo"] = 19;
            values[valuesById[20] = "vipSignReward"] = 20;
            values[valuesById[21] = "jpInfo"] = 21;
            values[valuesById[22] = "jpHistory"] = 22;
            values[valuesById[23] = "lotteryPlayerInfo"] = 23;
            values[valuesById[24] = "lotteryReward"] = 24;
            values[valuesById[25] = "fullJpInfo"] = 25;
            values[valuesById[26] = "fullJpHistory"] = 26;
            values[valuesById[27] = "fullJpInfoAll"] = 27;
            values[valuesById[28] = "extraSpin"] = 28;
            values[valuesById[29] = "debrisInfo"] = 29;
            values[valuesById[30] = "debrisPlayerInfo"] = 30;
            values[valuesById[31] = "debrisGet"] = 31;
            values[valuesById[32] = "debrisExchange"] = 32;
            values[valuesById[33] = "jpShowData"] = 33;
            values[valuesById[34] = "getPlayerLevel"] = 34;
            values[valuesById[35] = "verifyGiftCode"] = 35;
            return values;
          }();

          serverProto.Response = function () {
            /**
            * Properties of a Response.
            * @memberof serverProto
            * @interface IResponse
            * @property {serverProto.AckType|null} [ack] Response ack
            * @property {Uint8Array|null} [response] Response response
            * @property {serverProto.Error|null} [error] Response error
            * @property {string|null} [ErrorMsg] Response ErrorMsg
            */

            /**
            * Constructs a new Response.
            * @memberof serverProto
            * @classdesc Represents a Response.
            * @implements IResponse
            * @constructor
            * @param {serverProto.IResponse=} [properties] Properties to set
            */
            function Response(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * Response ack.
            * @member {serverProto.AckType} ack
            * @memberof serverProto.Response
            * @instance
            */


            Response.prototype.ack = 0;
            /**
            * Response response.
            * @member {Uint8Array} response
            * @memberof serverProto.Response
            * @instance
            */

            Response.prototype.response = $util.newBuffer([]);
            /**
            * Response error.
            * @member {serverProto.Error} error
            * @memberof serverProto.Response
            * @instance
            */

            Response.prototype.error = 0;
            /**
            * Response ErrorMsg.
            * @member {string} ErrorMsg
            * @memberof serverProto.Response
            * @instance
            */

            Response.prototype.ErrorMsg = "";
            /**
            * Creates a new Response instance using the specified properties.
            * @function create
            * @memberof serverProto.Response
            * @static
            * @param {serverProto.IResponse=} [properties] Properties to set
            * @returns {serverProto.Response} Response instance
            */

            Response.create = function create(properties) {
              return new Response(properties);
            };
            /**
            * Encodes the specified Response message. Does not implicitly {@link serverProto.Response.verify|verify} messages.
            * @function encode
            * @memberof serverProto.Response
            * @static
            * @param {serverProto.IResponse} message Response message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            Response.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.ack != null && Object.hasOwnProperty.call(message, "ack")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.ack);
              if (message.response != null && Object.hasOwnProperty.call(message, "response")) writer.uint32(
              /* id 2, wireType 2 =*/
              18).bytes(message.response);
              if (message.error != null && Object.hasOwnProperty.call(message, "error")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.error);
              if (message.ErrorMsg != null && Object.hasOwnProperty.call(message, "ErrorMsg")) writer.uint32(
              /* id 4, wireType 2 =*/
              34).string(message.ErrorMsg);
              return writer;
            };
            /**
            * Encodes the specified Response message, length delimited. Does not implicitly {@link serverProto.Response.verify|verify} messages.
            * @function encodeDelimited
            * @memberof serverProto.Response
            * @static
            * @param {serverProto.IResponse} message Response message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            Response.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a Response message from the specified reader or buffer.
            * @function decode
            * @memberof serverProto.Response
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {serverProto.Response} Response
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            Response.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.serverProto.Response();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      message.ack = reader.int32();
                      break;
                    }

                  case 2:
                    {
                      message.response = reader.bytes();
                      break;
                    }

                  case 3:
                    {
                      message.error = reader.int32();
                      break;
                    }

                  case 4:
                    {
                      message.ErrorMsg = reader.string();
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a Response message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof serverProto.Response
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {serverProto.Response} Response
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            Response.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a Response message.
            * @function verify
            * @memberof serverProto.Response
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            Response.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.ack != null && message.hasOwnProperty("ack")) switch (message.ack) {
                default:
                  return "ack: enum value expected";

                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                case 29:
                case 30:
                case 31:
                case 32:
                case 33:
                case 34:
                case 35:
                  break;
              }
              if (message.response != null && message.hasOwnProperty("response")) if (!(message.response && typeof message.response.length === "number" || $util.isString(message.response))) return "response: buffer expected";
              if (message.error != null && message.hasOwnProperty("error")) switch (message.error) {
                default:
                  return "error: enum value expected";

                case 0:
                case 123:
                case 211:
                case 241:
                case 251:
                case 252:
                case 253:
                case 301:
                case 303:
                case 304:
                case 305:
                case 311:
                case 400:
                case 500:
                case 600:
                case 700:
                case 701:
                case 800:
                case 801:
                case 802:
                case 803:
                case 9999:
                  break;
              }
              if (message.ErrorMsg != null && message.hasOwnProperty("ErrorMsg")) if (!$util.isString(message.ErrorMsg)) return "ErrorMsg: string expected";
              return null;
            };
            /**
            * Creates a Response message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof serverProto.Response
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {serverProto.Response} Response
            */


            Response.fromObject = function fromObject(object) {
              if (object instanceof $root.serverProto.Response) return object;
              var message = new $root.serverProto.Response();

              switch (object.ack) {
                default:
                  if (typeof object.ack === "number") {
                    message.ack = object.ack;
                    break;
                  }

                  break;

                case "spin":
                case 0:
                  message.ack = 0;
                  break;

                case "info":
                case 1:
                  message.ack = 1;
                  break;

                case "notice":
                case 2:
                  message.ack = 2;
                  break;

                case "logout":
                case 3:
                  message.ack = 3;
                  break;

                case "lastSpin":
                case 4:
                  message.ack = 4;
                  break;

                case "getBackPack":
                case 5:
                  message.ack = 5;
                  break;

                case "checkItem":
                case 6:
                  message.ack = 6;
                  break;

                case "getMail":
                case 7:
                  message.ack = 7;
                  break;

                case "readMail":
                case 8:
                  message.ack = 8;
                  break;

                case "getDailyMission":
                case 9:
                  message.ack = 9;
                  break;

                case "getNowMission":
                case 10:
                  message.ack = 10;
                  break;

                case "customAck":
                case 11:
                  message.ack = 11;
                  break;

                case "checkSignUpStatus":
                case 12:
                  message.ack = 12;
                  break;

                case "trialInfo":
                case 14:
                  message.ack = 14;
                  break;

                case "trialSpin":
                case 15:
                  message.ack = 15;
                  break;

                case "trialSignUp":
                case 16:
                  message.ack = 16;
                  break;

                case "trialGiveUp":
                case 17:
                  message.ack = 17;
                  break;

                case "getAllItemCanUse":
                case 18:
                  message.ack = 18;
                  break;

                case "vipSignInfo":
                case 19:
                  message.ack = 19;
                  break;

                case "vipSignReward":
                case 20:
                  message.ack = 20;
                  break;

                case "jpInfo":
                case 21:
                  message.ack = 21;
                  break;

                case "jpHistory":
                case 22:
                  message.ack = 22;
                  break;

                case "lotteryPlayerInfo":
                case 23:
                  message.ack = 23;
                  break;

                case "lotteryReward":
                case 24:
                  message.ack = 24;
                  break;

                case "fullJpInfo":
                case 25:
                  message.ack = 25;
                  break;

                case "fullJpHistory":
                case 26:
                  message.ack = 26;
                  break;

                case "fullJpInfoAll":
                case 27:
                  message.ack = 27;
                  break;

                case "extraSpin":
                case 28:
                  message.ack = 28;
                  break;

                case "debrisInfo":
                case 29:
                  message.ack = 29;
                  break;

                case "debrisPlayerInfo":
                case 30:
                  message.ack = 30;
                  break;

                case "debrisGet":
                case 31:
                  message.ack = 31;
                  break;

                case "debrisExchange":
                case 32:
                  message.ack = 32;
                  break;

                case "jpShowData":
                case 33:
                  message.ack = 33;
                  break;

                case "getPlayerLevel":
                case 34:
                  message.ack = 34;
                  break;

                case "verifyGiftCode":
                case 35:
                  message.ack = 35;
                  break;
              }

              if (object.response != null) if (typeof object.response === "string") $util.base64.decode(object.response, message.response = $util.newBuffer($util.base64.length(object.response)), 0);else if (object.response.length >= 0) message.response = object.response;

              switch (object.error) {
                default:
                  if (typeof object.error === "number") {
                    message.error = object.error;
                    break;
                  }

                  break;

                case "success":
                case 0:
                  message.error = 0;
                  break;

                case "SpecialError":
                case 123:
                  message.error = 123;
                  break;

                case "plateInvalid":
                case 211:
                  message.error = 211;
                  break;

                case "gameInvalid":
                case 241:
                  message.error = 241;
                  break;

                case "paramter":
                case 251:
                  message.error = 251;
                  break;

                case "ackType":
                case 252:
                  message.error = 252;
                  break;

                case "reLogin":
                case 253:
                  message.error = 253;
                  break;

                case "spinBet":
                case 301:
                  message.error = 301;
                  break;

                case "spinRetry":
                case 303:
                  message.error = 303;
                  break;

                case "spinReject":
                case 304:
                  message.error = 304;
                  break;

                case "spinCoinError":
                case 305:
                  message.error = 305;
                  break;

                case "spinCurrecny":
                case 311:
                  message.error = 311;
                  break;

                case "missionUnavailable":
                case 400:
                  message.error = 400;
                  break;

                case "itemUnavailable":
                case 500:
                  message.error = 500;
                  break;

                case "signUnavailable":
                case 600:
                  message.error = 600;
                  break;

                case "trialUnavailable":
                case 700:
                  message.error = 700;
                  break;

                case "trialIsEnd":
                case 701:
                  message.error = 701;
                  break;

                case "vipSignUnavailable":
                case 800:
                  message.error = 800;
                  break;

                case "DebrisUnavailable":
                case 801:
                  message.error = 801;
                  break;

                case "DebrisError":
                case 802:
                  message.error = 802;
                  break;

                case "GiftCodeEror":
                case 803:
                  message.error = 803;
                  break;

                case "unknow":
                case 9999:
                  message.error = 9999;
                  break;
              }

              if (object.ErrorMsg != null) message.ErrorMsg = String(object.ErrorMsg);
              return message;
            };
            /**
            * Creates a plain object from a Response message. Also converts values to other types if specified.
            * @function toObject
            * @memberof serverProto.Response
            * @static
            * @param {serverProto.Response} message Response
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            Response.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.ack = options.enums === String ? "spin" : 0;
                if (options.bytes === String) object.response = "";else {
                  object.response = [];
                  if (options.bytes !== Array) object.response = $util.newBuffer(object.response);
                }
                object.error = options.enums === String ? "success" : 0;
                object.ErrorMsg = "";
              }

              if (message.ack != null && message.hasOwnProperty("ack")) object.ack = options.enums === String ? $root.serverProto.AckType[message.ack] === undefined ? message.ack : $root.serverProto.AckType[message.ack] : message.ack;
              if (message.response != null && message.hasOwnProperty("response")) object.response = options.bytes === String ? $util.base64.encode(message.response, 0, message.response.length) : options.bytes === Array ? Array.prototype.slice.call(message.response) : message.response;
              if (message.error != null && message.hasOwnProperty("error")) object.error = options.enums === String ? $root.serverProto.Error[message.error] === undefined ? message.error : $root.serverProto.Error[message.error] : message.error;
              if (message.ErrorMsg != null && message.hasOwnProperty("ErrorMsg")) object.ErrorMsg = message.ErrorMsg;
              return object;
            };
            /**
            * Converts this Response to JSON.
            * @function toJSON
            * @memberof serverProto.Response
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            Response.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
            * Gets the default type url for Response
            * @function getTypeUrl
            * @memberof serverProto.Response
            * @static
            * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
            * @returns {string} The default type url
            */


            Response.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/serverProto.Response";
            };

            return Response;
          }();

          serverProto.Request = function () {
            /**
            * Properties of a Request.
            * @memberof serverProto
            * @interface IRequest
            * @property {serverProto.AckType|null} [ack] Request ack
            * @property {Uint8Array|null} [req] Request req
            */

            /**
            * Constructs a new Request.
            * @memberof serverProto
            * @classdesc Represents a Request.
            * @implements IRequest
            * @constructor
            * @param {serverProto.IRequest=} [properties] Properties to set
            */
            function Request(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * Request ack.
            * @member {serverProto.AckType} ack
            * @memberof serverProto.Request
            * @instance
            */


            Request.prototype.ack = 0;
            /**
            * Request req.
            * @member {Uint8Array} req
            * @memberof serverProto.Request
            * @instance
            */

            Request.prototype.req = $util.newBuffer([]);
            /**
            * Creates a new Request instance using the specified properties.
            * @function create
            * @memberof serverProto.Request
            * @static
            * @param {serverProto.IRequest=} [properties] Properties to set
            * @returns {serverProto.Request} Request instance
            */

            Request.create = function create(properties) {
              return new Request(properties);
            };
            /**
            * Encodes the specified Request message. Does not implicitly {@link serverProto.Request.verify|verify} messages.
            * @function encode
            * @memberof serverProto.Request
            * @static
            * @param {serverProto.IRequest} message Request message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            Request.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.ack != null && Object.hasOwnProperty.call(message, "ack")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.ack);
              if (message.req != null && Object.hasOwnProperty.call(message, "req")) writer.uint32(
              /* id 2, wireType 2 =*/
              18).bytes(message.req);
              return writer;
            };
            /**
            * Encodes the specified Request message, length delimited. Does not implicitly {@link serverProto.Request.verify|verify} messages.
            * @function encodeDelimited
            * @memberof serverProto.Request
            * @static
            * @param {serverProto.IRequest} message Request message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            Request.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a Request message from the specified reader or buffer.
            * @function decode
            * @memberof serverProto.Request
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {serverProto.Request} Request
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            Request.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.serverProto.Request();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      message.ack = reader.int32();
                      break;
                    }

                  case 2:
                    {
                      message.req = reader.bytes();
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a Request message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof serverProto.Request
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {serverProto.Request} Request
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            Request.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a Request message.
            * @function verify
            * @memberof serverProto.Request
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            Request.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.ack != null && message.hasOwnProperty("ack")) switch (message.ack) {
                default:
                  return "ack: enum value expected";

                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                case 29:
                case 30:
                case 31:
                case 32:
                case 33:
                case 34:
                case 35:
                  break;
              }
              if (message.req != null && message.hasOwnProperty("req")) if (!(message.req && typeof message.req.length === "number" || $util.isString(message.req))) return "req: buffer expected";
              return null;
            };
            /**
            * Creates a Request message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof serverProto.Request
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {serverProto.Request} Request
            */


            Request.fromObject = function fromObject(object) {
              if (object instanceof $root.serverProto.Request) return object;
              var message = new $root.serverProto.Request();

              switch (object.ack) {
                default:
                  if (typeof object.ack === "number") {
                    message.ack = object.ack;
                    break;
                  }

                  break;

                case "spin":
                case 0:
                  message.ack = 0;
                  break;

                case "info":
                case 1:
                  message.ack = 1;
                  break;

                case "notice":
                case 2:
                  message.ack = 2;
                  break;

                case "logout":
                case 3:
                  message.ack = 3;
                  break;

                case "lastSpin":
                case 4:
                  message.ack = 4;
                  break;

                case "getBackPack":
                case 5:
                  message.ack = 5;
                  break;

                case "checkItem":
                case 6:
                  message.ack = 6;
                  break;

                case "getMail":
                case 7:
                  message.ack = 7;
                  break;

                case "readMail":
                case 8:
                  message.ack = 8;
                  break;

                case "getDailyMission":
                case 9:
                  message.ack = 9;
                  break;

                case "getNowMission":
                case 10:
                  message.ack = 10;
                  break;

                case "customAck":
                case 11:
                  message.ack = 11;
                  break;

                case "checkSignUpStatus":
                case 12:
                  message.ack = 12;
                  break;

                case "trialInfo":
                case 14:
                  message.ack = 14;
                  break;

                case "trialSpin":
                case 15:
                  message.ack = 15;
                  break;

                case "trialSignUp":
                case 16:
                  message.ack = 16;
                  break;

                case "trialGiveUp":
                case 17:
                  message.ack = 17;
                  break;

                case "getAllItemCanUse":
                case 18:
                  message.ack = 18;
                  break;

                case "vipSignInfo":
                case 19:
                  message.ack = 19;
                  break;

                case "vipSignReward":
                case 20:
                  message.ack = 20;
                  break;

                case "jpInfo":
                case 21:
                  message.ack = 21;
                  break;

                case "jpHistory":
                case 22:
                  message.ack = 22;
                  break;

                case "lotteryPlayerInfo":
                case 23:
                  message.ack = 23;
                  break;

                case "lotteryReward":
                case 24:
                  message.ack = 24;
                  break;

                case "fullJpInfo":
                case 25:
                  message.ack = 25;
                  break;

                case "fullJpHistory":
                case 26:
                  message.ack = 26;
                  break;

                case "fullJpInfoAll":
                case 27:
                  message.ack = 27;
                  break;

                case "extraSpin":
                case 28:
                  message.ack = 28;
                  break;

                case "debrisInfo":
                case 29:
                  message.ack = 29;
                  break;

                case "debrisPlayerInfo":
                case 30:
                  message.ack = 30;
                  break;

                case "debrisGet":
                case 31:
                  message.ack = 31;
                  break;

                case "debrisExchange":
                case 32:
                  message.ack = 32;
                  break;

                case "jpShowData":
                case 33:
                  message.ack = 33;
                  break;

                case "getPlayerLevel":
                case 34:
                  message.ack = 34;
                  break;

                case "verifyGiftCode":
                case 35:
                  message.ack = 35;
                  break;
              }

              if (object.req != null) if (typeof object.req === "string") $util.base64.decode(object.req, message.req = $util.newBuffer($util.base64.length(object.req)), 0);else if (object.req.length >= 0) message.req = object.req;
              return message;
            };
            /**
            * Creates a plain object from a Request message. Also converts values to other types if specified.
            * @function toObject
            * @memberof serverProto.Request
            * @static
            * @param {serverProto.Request} message Request
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            Request.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.ack = options.enums === String ? "spin" : 0;
                if (options.bytes === String) object.req = "";else {
                  object.req = [];
                  if (options.bytes !== Array) object.req = $util.newBuffer(object.req);
                }
              }

              if (message.ack != null && message.hasOwnProperty("ack")) object.ack = options.enums === String ? $root.serverProto.AckType[message.ack] === undefined ? message.ack : $root.serverProto.AckType[message.ack] : message.ack;
              if (message.req != null && message.hasOwnProperty("req")) object.req = options.bytes === String ? $util.base64.encode(message.req, 0, message.req.length) : options.bytes === Array ? Array.prototype.slice.call(message.req) : message.req;
              return object;
            };
            /**
            * Converts this Request to JSON.
            * @function toJSON
            * @memberof serverProto.Request
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            Request.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
            * Gets the default type url for Request
            * @function getTypeUrl
            * @memberof serverProto.Request
            * @static
            * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
            * @returns {string} The default type url
            */


            Request.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/serverProto.Request";
            };

            return Request;
          }();

          serverProto.SpinReq = function () {
            /**
            * Properties of a SpinReq.
            * @memberof serverProto
            * @interface ISpinReq
            * @property {number|Long|null} [bet] SpinReq bet
            * @property {number|null} [cheat] SpinReq cheat
            * @property {number|null} [itemIndex] SpinReq itemIndex
            * @property {number|null} [itemID] SpinReq itemID
            * @property {number|null} [amount] SpinReq amount
            * @property {number|null} [trialNo] SpinReq trialNo
            * @property {number|null} [currencyNumber] SpinReq currencyNumber
            * @property {number|Long|null} [mallBet] SpinReq mallBet
            * @property {number|null} [vip] SpinReq vip
            * @property {Uint8Array|null} [customReq] SpinReq customReq
            * @property {boolean|null} [isFree] SpinReq isFree
            */

            /**
            * Constructs a new SpinReq.
            * @memberof serverProto
            * @classdesc Represents a SpinReq.
            * @implements ISpinReq
            * @constructor
            * @param {serverProto.ISpinReq=} [properties] Properties to set
            */
            function SpinReq(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * SpinReq bet.
            * @member {number|Long} bet
            * @memberof serverProto.SpinReq
            * @instance
            */


            SpinReq.prototype.bet = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
            * SpinReq cheat.
            * @member {number} cheat
            * @memberof serverProto.SpinReq
            * @instance
            */

            SpinReq.prototype.cheat = 0;
            /**
            * SpinReq itemIndex.
            * @member {number} itemIndex
            * @memberof serverProto.SpinReq
            * @instance
            */

            SpinReq.prototype.itemIndex = 0;
            /**
            * SpinReq itemID.
            * @member {number} itemID
            * @memberof serverProto.SpinReq
            * @instance
            */

            SpinReq.prototype.itemID = 0;
            /**
            * SpinReq amount.
            * @member {number} amount
            * @memberof serverProto.SpinReq
            * @instance
            */

            SpinReq.prototype.amount = 0;
            /**
            * SpinReq trialNo.
            * @member {number} trialNo
            * @memberof serverProto.SpinReq
            * @instance
            */

            SpinReq.prototype.trialNo = 0;
            /**
            * SpinReq currencyNumber.
            * @member {number} currencyNumber
            * @memberof serverProto.SpinReq
            * @instance
            */

            SpinReq.prototype.currencyNumber = 0;
            /**
            * SpinReq mallBet.
            * @member {number|Long} mallBet
            * @memberof serverProto.SpinReq
            * @instance
            */

            SpinReq.prototype.mallBet = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
            * SpinReq vip.
            * @member {number} vip
            * @memberof serverProto.SpinReq
            * @instance
            */

            SpinReq.prototype.vip = 0;
            /**
            * SpinReq customReq.
            * @member {Uint8Array} customReq
            * @memberof serverProto.SpinReq
            * @instance
            */

            SpinReq.prototype.customReq = $util.newBuffer([]);
            /**
            * SpinReq isFree.
            * @member {boolean} isFree
            * @memberof serverProto.SpinReq
            * @instance
            */

            SpinReq.prototype.isFree = false;
            /**
            * Creates a new SpinReq instance using the specified properties.
            * @function create
            * @memberof serverProto.SpinReq
            * @static
            * @param {serverProto.ISpinReq=} [properties] Properties to set
            * @returns {serverProto.SpinReq} SpinReq instance
            */

            SpinReq.create = function create(properties) {
              return new SpinReq(properties);
            };
            /**
            * Encodes the specified SpinReq message. Does not implicitly {@link serverProto.SpinReq.verify|verify} messages.
            * @function encode
            * @memberof serverProto.SpinReq
            * @static
            * @param {serverProto.ISpinReq} message SpinReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            SpinReq.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.bet != null && Object.hasOwnProperty.call(message, "bet")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int64(message.bet);
              if (message.cheat != null && Object.hasOwnProperty.call(message, "cheat")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).uint32(message.cheat);
              if (message.itemIndex != null && Object.hasOwnProperty.call(message, "itemIndex")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).uint32(message.itemIndex);
              if (message.itemID != null && Object.hasOwnProperty.call(message, "itemID")) writer.uint32(
              /* id 4, wireType 0 =*/
              32).uint32(message.itemID);
              if (message.amount != null && Object.hasOwnProperty.call(message, "amount")) writer.uint32(
              /* id 5, wireType 0 =*/
              40).uint32(message.amount);
              if (message.trialNo != null && Object.hasOwnProperty.call(message, "trialNo")) writer.uint32(
              /* id 6, wireType 0 =*/
              48).int32(message.trialNo);
              if (message.currencyNumber != null && Object.hasOwnProperty.call(message, "currencyNumber")) writer.uint32(
              /* id 7, wireType 0 =*/
              56).int32(message.currencyNumber);
              if (message.mallBet != null && Object.hasOwnProperty.call(message, "mallBet")) writer.uint32(
              /* id 8, wireType 0 =*/
              64).int64(message.mallBet);
              if (message.vip != null && Object.hasOwnProperty.call(message, "vip")) writer.uint32(
              /* id 9, wireType 0 =*/
              72).uint32(message.vip);
              if (message.customReq != null && Object.hasOwnProperty.call(message, "customReq")) writer.uint32(
              /* id 10, wireType 2 =*/
              82).bytes(message.customReq);
              if (message.isFree != null && Object.hasOwnProperty.call(message, "isFree")) writer.uint32(
              /* id 11, wireType 0 =*/
              88).bool(message.isFree);
              return writer;
            };
            /**
            * Encodes the specified SpinReq message, length delimited. Does not implicitly {@link serverProto.SpinReq.verify|verify} messages.
            * @function encodeDelimited
            * @memberof serverProto.SpinReq
            * @static
            * @param {serverProto.ISpinReq} message SpinReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            SpinReq.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a SpinReq message from the specified reader or buffer.
            * @function decode
            * @memberof serverProto.SpinReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {serverProto.SpinReq} SpinReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            SpinReq.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.serverProto.SpinReq();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      message.bet = reader.int64();
                      break;
                    }

                  case 2:
                    {
                      message.cheat = reader.uint32();
                      break;
                    }

                  case 3:
                    {
                      message.itemIndex = reader.uint32();
                      break;
                    }

                  case 4:
                    {
                      message.itemID = reader.uint32();
                      break;
                    }

                  case 5:
                    {
                      message.amount = reader.uint32();
                      break;
                    }

                  case 6:
                    {
                      message.trialNo = reader.int32();
                      break;
                    }

                  case 7:
                    {
                      message.currencyNumber = reader.int32();
                      break;
                    }

                  case 8:
                    {
                      message.mallBet = reader.int64();
                      break;
                    }

                  case 9:
                    {
                      message.vip = reader.uint32();
                      break;
                    }

                  case 10:
                    {
                      message.customReq = reader.bytes();
                      break;
                    }

                  case 11:
                    {
                      message.isFree = reader.bool();
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a SpinReq message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof serverProto.SpinReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {serverProto.SpinReq} SpinReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            SpinReq.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a SpinReq message.
            * @function verify
            * @memberof serverProto.SpinReq
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            SpinReq.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.bet != null && message.hasOwnProperty("bet")) if (!$util.isInteger(message.bet) && !(message.bet && $util.isInteger(message.bet.low) && $util.isInteger(message.bet.high))) return "bet: integer|Long expected";
              if (message.cheat != null && message.hasOwnProperty("cheat")) if (!$util.isInteger(message.cheat)) return "cheat: integer expected";
              if (message.itemIndex != null && message.hasOwnProperty("itemIndex")) if (!$util.isInteger(message.itemIndex)) return "itemIndex: integer expected";
              if (message.itemID != null && message.hasOwnProperty("itemID")) if (!$util.isInteger(message.itemID)) return "itemID: integer expected";
              if (message.amount != null && message.hasOwnProperty("amount")) if (!$util.isInteger(message.amount)) return "amount: integer expected";
              if (message.trialNo != null && message.hasOwnProperty("trialNo")) if (!$util.isInteger(message.trialNo)) return "trialNo: integer expected";
              if (message.currencyNumber != null && message.hasOwnProperty("currencyNumber")) if (!$util.isInteger(message.currencyNumber)) return "currencyNumber: integer expected";
              if (message.mallBet != null && message.hasOwnProperty("mallBet")) if (!$util.isInteger(message.mallBet) && !(message.mallBet && $util.isInteger(message.mallBet.low) && $util.isInteger(message.mallBet.high))) return "mallBet: integer|Long expected";
              if (message.vip != null && message.hasOwnProperty("vip")) if (!$util.isInteger(message.vip)) return "vip: integer expected";
              if (message.customReq != null && message.hasOwnProperty("customReq")) if (!(message.customReq && typeof message.customReq.length === "number" || $util.isString(message.customReq))) return "customReq: buffer expected";
              if (message.isFree != null && message.hasOwnProperty("isFree")) if (typeof message.isFree !== "boolean") return "isFree: boolean expected";
              return null;
            };
            /**
            * Creates a SpinReq message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof serverProto.SpinReq
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {serverProto.SpinReq} SpinReq
            */


            SpinReq.fromObject = function fromObject(object) {
              if (object instanceof $root.serverProto.SpinReq) return object;
              var message = new $root.serverProto.SpinReq();
              if (object.bet != null) if ($util.Long) (message.bet = $util.Long.fromValue(object.bet)).unsigned = false;else if (typeof object.bet === "string") message.bet = parseInt(object.bet, 10);else if (typeof object.bet === "number") message.bet = object.bet;else if (typeof object.bet === "object") message.bet = new $util.LongBits(object.bet.low >>> 0, object.bet.high >>> 0).toNumber();
              if (object.cheat != null) message.cheat = object.cheat >>> 0;
              if (object.itemIndex != null) message.itemIndex = object.itemIndex >>> 0;
              if (object.itemID != null) message.itemID = object.itemID >>> 0;
              if (object.amount != null) message.amount = object.amount >>> 0;
              if (object.trialNo != null) message.trialNo = object.trialNo | 0;
              if (object.currencyNumber != null) message.currencyNumber = object.currencyNumber | 0;
              if (object.mallBet != null) if ($util.Long) (message.mallBet = $util.Long.fromValue(object.mallBet)).unsigned = false;else if (typeof object.mallBet === "string") message.mallBet = parseInt(object.mallBet, 10);else if (typeof object.mallBet === "number") message.mallBet = object.mallBet;else if (typeof object.mallBet === "object") message.mallBet = new $util.LongBits(object.mallBet.low >>> 0, object.mallBet.high >>> 0).toNumber();
              if (object.vip != null) message.vip = object.vip >>> 0;
              if (object.customReq != null) if (typeof object.customReq === "string") $util.base64.decode(object.customReq, message.customReq = $util.newBuffer($util.base64.length(object.customReq)), 0);else if (object.customReq.length >= 0) message.customReq = object.customReq;
              if (object.isFree != null) message.isFree = Boolean(object.isFree);
              return message;
            };
            /**
            * Creates a plain object from a SpinReq message. Also converts values to other types if specified.
            * @function toObject
            * @memberof serverProto.SpinReq
            * @static
            * @param {serverProto.SpinReq} message SpinReq
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            SpinReq.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                if ($util.Long) {
                  var _long = new $util.Long(0, 0, false);

                  object.bet = options.longs === String ? _long.toString() : options.longs === Number ? _long.toNumber() : _long;
                } else object.bet = options.longs === String ? "0" : 0;

                object.cheat = 0;
                object.itemIndex = 0;
                object.itemID = 0;
                object.amount = 0;
                object.trialNo = 0;
                object.currencyNumber = 0;

                if ($util.Long) {
                  var _long = new $util.Long(0, 0, false);

                  object.mallBet = options.longs === String ? _long.toString() : options.longs === Number ? _long.toNumber() : _long;
                } else object.mallBet = options.longs === String ? "0" : 0;

                object.vip = 0;
                if (options.bytes === String) object.customReq = "";else {
                  object.customReq = [];
                  if (options.bytes !== Array) object.customReq = $util.newBuffer(object.customReq);
                }
                object.isFree = false;
              }

              if (message.bet != null && message.hasOwnProperty("bet")) if (typeof message.bet === "number") object.bet = options.longs === String ? String(message.bet) : message.bet;else object.bet = options.longs === String ? $util.Long.prototype.toString.call(message.bet) : options.longs === Number ? new $util.LongBits(message.bet.low >>> 0, message.bet.high >>> 0).toNumber() : message.bet;
              if (message.cheat != null && message.hasOwnProperty("cheat")) object.cheat = message.cheat;
              if (message.itemIndex != null && message.hasOwnProperty("itemIndex")) object.itemIndex = message.itemIndex;
              if (message.itemID != null && message.hasOwnProperty("itemID")) object.itemID = message.itemID;
              if (message.amount != null && message.hasOwnProperty("amount")) object.amount = message.amount;
              if (message.trialNo != null && message.hasOwnProperty("trialNo")) object.trialNo = message.trialNo;
              if (message.currencyNumber != null && message.hasOwnProperty("currencyNumber")) object.currencyNumber = message.currencyNumber;
              if (message.mallBet != null && message.hasOwnProperty("mallBet")) if (typeof message.mallBet === "number") object.mallBet = options.longs === String ? String(message.mallBet) : message.mallBet;else object.mallBet = options.longs === String ? $util.Long.prototype.toString.call(message.mallBet) : options.longs === Number ? new $util.LongBits(message.mallBet.low >>> 0, message.mallBet.high >>> 0).toNumber() : message.mallBet;
              if (message.vip != null && message.hasOwnProperty("vip")) object.vip = message.vip;
              if (message.customReq != null && message.hasOwnProperty("customReq")) object.customReq = options.bytes === String ? $util.base64.encode(message.customReq, 0, message.customReq.length) : options.bytes === Array ? Array.prototype.slice.call(message.customReq) : message.customReq;
              if (message.isFree != null && message.hasOwnProperty("isFree")) object.isFree = message.isFree;
              return object;
            };
            /**
            * Converts this SpinReq to JSON.
            * @function toJSON
            * @memberof serverProto.SpinReq
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            SpinReq.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
            * Gets the default type url for SpinReq
            * @function getTypeUrl
            * @memberof serverProto.SpinReq
            * @static
            * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
            * @returns {string} The default type url
            */


            SpinReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/serverProto.SpinReq";
            };

            return SpinReq;
          }();

          serverProto.SpinResponse = function () {
            /**
            * Properties of a SpinResponse.
            * @memberof serverProto
            * @interface ISpinResponse
            * @property {Uint8Array|null} [allPlate] SpinResponse allPlate
            * @property {number|null} [spinState] SpinResponse spinState
            * @property {number|Long|null} [totalWin] SpinResponse totalWin
            * @property {number|Long|null} [roundIndex] SpinResponse roundIndex
            * @property {number|null} [missionReward] SpinResponse missionReward
            * @property {number|Long|null} [postMoney] SpinResponse postMoney
            * @property {number|Long|null} [preMoney] SpinResponse preMoney
            * @property {serverProto.IJpOpen|null} [jp] SpinResponse jp
            * @property {Uint8Array|null} [lottery] SpinResponse lottery
            * @property {number|Long|null} [fullJpWin] SpinResponse fullJpWin
            * @property {number|null} [freeSpinCount] SpinResponse freeSpinCount
            * @property {serverProto.ITrialSpinResp|null} [trialResp] SpinResponse trialResp
            * @property {Uint8Array|null} [cardBookResp] SpinResponse cardBookResp
            */

            /**
            * Constructs a new SpinResponse.
            * @memberof serverProto
            * @classdesc Represents a SpinResponse.
            * @implements ISpinResponse
            * @constructor
            * @param {serverProto.ISpinResponse=} [properties] Properties to set
            */
            function SpinResponse(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * SpinResponse allPlate.
            * @member {Uint8Array} allPlate
            * @memberof serverProto.SpinResponse
            * @instance
            */


            SpinResponse.prototype.allPlate = $util.newBuffer([]);
            /**
            * SpinResponse spinState.
            * @member {number} spinState
            * @memberof serverProto.SpinResponse
            * @instance
            */

            SpinResponse.prototype.spinState = 0;
            /**
            * SpinResponse totalWin.
            * @member {number|Long} totalWin
            * @memberof serverProto.SpinResponse
            * @instance
            */

            SpinResponse.prototype.totalWin = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
            * SpinResponse roundIndex.
            * @member {number|Long} roundIndex
            * @memberof serverProto.SpinResponse
            * @instance
            */

            SpinResponse.prototype.roundIndex = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
            * SpinResponse missionReward.
            * @member {number} missionReward
            * @memberof serverProto.SpinResponse
            * @instance
            */

            SpinResponse.prototype.missionReward = 0;
            /**
            * SpinResponse postMoney.
            * @member {number|Long} postMoney
            * @memberof serverProto.SpinResponse
            * @instance
            */

            SpinResponse.prototype.postMoney = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
            * SpinResponse preMoney.
            * @member {number|Long} preMoney
            * @memberof serverProto.SpinResponse
            * @instance
            */

            SpinResponse.prototype.preMoney = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
            * SpinResponse jp.
            * @member {serverProto.IJpOpen|null|undefined} jp
            * @memberof serverProto.SpinResponse
            * @instance
            */

            SpinResponse.prototype.jp = null;
            /**
            * SpinResponse lottery.
            * @member {Uint8Array} lottery
            * @memberof serverProto.SpinResponse
            * @instance
            */

            SpinResponse.prototype.lottery = $util.newBuffer([]);
            /**
            * SpinResponse fullJpWin.
            * @member {number|Long} fullJpWin
            * @memberof serverProto.SpinResponse
            * @instance
            */

            SpinResponse.prototype.fullJpWin = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
            * SpinResponse freeSpinCount.
            * @member {number} freeSpinCount
            * @memberof serverProto.SpinResponse
            * @instance
            */

            SpinResponse.prototype.freeSpinCount = 0;
            /**
            * SpinResponse trialResp.
            * @member {serverProto.ITrialSpinResp|null|undefined} trialResp
            * @memberof serverProto.SpinResponse
            * @instance
            */

            SpinResponse.prototype.trialResp = null;
            /**
            * SpinResponse cardBookResp.
            * @member {Uint8Array} cardBookResp
            * @memberof serverProto.SpinResponse
            * @instance
            */

            SpinResponse.prototype.cardBookResp = $util.newBuffer([]);
            /**
            * Creates a new SpinResponse instance using the specified properties.
            * @function create
            * @memberof serverProto.SpinResponse
            * @static
            * @param {serverProto.ISpinResponse=} [properties] Properties to set
            * @returns {serverProto.SpinResponse} SpinResponse instance
            */

            SpinResponse.create = function create(properties) {
              return new SpinResponse(properties);
            };
            /**
            * Encodes the specified SpinResponse message. Does not implicitly {@link serverProto.SpinResponse.verify|verify} messages.
            * @function encode
            * @memberof serverProto.SpinResponse
            * @static
            * @param {serverProto.ISpinResponse} message SpinResponse message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            SpinResponse.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.allPlate != null && Object.hasOwnProperty.call(message, "allPlate")) writer.uint32(
              /* id 1, wireType 2 =*/
              10).bytes(message.allPlate);
              if (message.spinState != null && Object.hasOwnProperty.call(message, "spinState")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).uint32(message.spinState);
              if (message.totalWin != null && Object.hasOwnProperty.call(message, "totalWin")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int64(message.totalWin);
              if (message.roundIndex != null && Object.hasOwnProperty.call(message, "roundIndex")) writer.uint32(
              /* id 4, wireType 0 =*/
              32).int64(message.roundIndex);
              if (message.missionReward != null && Object.hasOwnProperty.call(message, "missionReward")) writer.uint32(
              /* id 5, wireType 0 =*/
              40).uint32(message.missionReward);
              if (message.postMoney != null && Object.hasOwnProperty.call(message, "postMoney")) writer.uint32(
              /* id 6, wireType 0 =*/
              48).int64(message.postMoney);
              if (message.preMoney != null && Object.hasOwnProperty.call(message, "preMoney")) writer.uint32(
              /* id 8, wireType 0 =*/
              64).int64(message.preMoney);
              if (message.jp != null && Object.hasOwnProperty.call(message, "jp")) $root.serverProto.JpOpen.encode(message.jp, writer.uint32(
              /* id 9, wireType 2 =*/
              74).fork()).ldelim();
              if (message.lottery != null && Object.hasOwnProperty.call(message, "lottery")) writer.uint32(
              /* id 10, wireType 2 =*/
              82).bytes(message.lottery);
              if (message.fullJpWin != null && Object.hasOwnProperty.call(message, "fullJpWin")) writer.uint32(
              /* id 11, wireType 0 =*/
              88).int64(message.fullJpWin);
              if (message.freeSpinCount != null && Object.hasOwnProperty.call(message, "freeSpinCount")) writer.uint32(
              /* id 12, wireType 0 =*/
              96).int32(message.freeSpinCount);
              if (message.trialResp != null && Object.hasOwnProperty.call(message, "trialResp")) $root.serverProto.TrialSpinResp.encode(message.trialResp, writer.uint32(
              /* id 13, wireType 2 =*/
              106).fork()).ldelim();
              if (message.cardBookResp != null && Object.hasOwnProperty.call(message, "cardBookResp")) writer.uint32(
              /* id 14, wireType 2 =*/
              114).bytes(message.cardBookResp);
              return writer;
            };
            /**
            * Encodes the specified SpinResponse message, length delimited. Does not implicitly {@link serverProto.SpinResponse.verify|verify} messages.
            * @function encodeDelimited
            * @memberof serverProto.SpinResponse
            * @static
            * @param {serverProto.ISpinResponse} message SpinResponse message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            SpinResponse.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a SpinResponse message from the specified reader or buffer.
            * @function decode
            * @memberof serverProto.SpinResponse
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {serverProto.SpinResponse} SpinResponse
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            SpinResponse.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.serverProto.SpinResponse();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      message.allPlate = reader.bytes();
                      break;
                    }

                  case 2:
                    {
                      message.spinState = reader.uint32();
                      break;
                    }

                  case 3:
                    {
                      message.totalWin = reader.int64();
                      break;
                    }

                  case 4:
                    {
                      message.roundIndex = reader.int64();
                      break;
                    }

                  case 5:
                    {
                      message.missionReward = reader.uint32();
                      break;
                    }

                  case 6:
                    {
                      message.postMoney = reader.int64();
                      break;
                    }

                  case 8:
                    {
                      message.preMoney = reader.int64();
                      break;
                    }

                  case 9:
                    {
                      message.jp = $root.serverProto.JpOpen.decode(reader, reader.uint32());
                      break;
                    }

                  case 10:
                    {
                      message.lottery = reader.bytes();
                      break;
                    }

                  case 11:
                    {
                      message.fullJpWin = reader.int64();
                      break;
                    }

                  case 12:
                    {
                      message.freeSpinCount = reader.int32();
                      break;
                    }

                  case 13:
                    {
                      message.trialResp = $root.serverProto.TrialSpinResp.decode(reader, reader.uint32());
                      break;
                    }

                  case 14:
                    {
                      message.cardBookResp = reader.bytes();
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a SpinResponse message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof serverProto.SpinResponse
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {serverProto.SpinResponse} SpinResponse
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            SpinResponse.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a SpinResponse message.
            * @function verify
            * @memberof serverProto.SpinResponse
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            SpinResponse.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.allPlate != null && message.hasOwnProperty("allPlate")) if (!(message.allPlate && typeof message.allPlate.length === "number" || $util.isString(message.allPlate))) return "allPlate: buffer expected";
              if (message.spinState != null && message.hasOwnProperty("spinState")) if (!$util.isInteger(message.spinState)) return "spinState: integer expected";
              if (message.totalWin != null && message.hasOwnProperty("totalWin")) if (!$util.isInteger(message.totalWin) && !(message.totalWin && $util.isInteger(message.totalWin.low) && $util.isInteger(message.totalWin.high))) return "totalWin: integer|Long expected";
              if (message.roundIndex != null && message.hasOwnProperty("roundIndex")) if (!$util.isInteger(message.roundIndex) && !(message.roundIndex && $util.isInteger(message.roundIndex.low) && $util.isInteger(message.roundIndex.high))) return "roundIndex: integer|Long expected";
              if (message.missionReward != null && message.hasOwnProperty("missionReward")) if (!$util.isInteger(message.missionReward)) return "missionReward: integer expected";
              if (message.postMoney != null && message.hasOwnProperty("postMoney")) if (!$util.isInteger(message.postMoney) && !(message.postMoney && $util.isInteger(message.postMoney.low) && $util.isInteger(message.postMoney.high))) return "postMoney: integer|Long expected";
              if (message.preMoney != null && message.hasOwnProperty("preMoney")) if (!$util.isInteger(message.preMoney) && !(message.preMoney && $util.isInteger(message.preMoney.low) && $util.isInteger(message.preMoney.high))) return "preMoney: integer|Long expected";

              if (message.jp != null && message.hasOwnProperty("jp")) {
                var error = $root.serverProto.JpOpen.verify(message.jp);
                if (error) return "jp." + error;
              }

              if (message.lottery != null && message.hasOwnProperty("lottery")) if (!(message.lottery && typeof message.lottery.length === "number" || $util.isString(message.lottery))) return "lottery: buffer expected";
              if (message.fullJpWin != null && message.hasOwnProperty("fullJpWin")) if (!$util.isInteger(message.fullJpWin) && !(message.fullJpWin && $util.isInteger(message.fullJpWin.low) && $util.isInteger(message.fullJpWin.high))) return "fullJpWin: integer|Long expected";
              if (message.freeSpinCount != null && message.hasOwnProperty("freeSpinCount")) if (!$util.isInteger(message.freeSpinCount)) return "freeSpinCount: integer expected";

              if (message.trialResp != null && message.hasOwnProperty("trialResp")) {
                var error = $root.serverProto.TrialSpinResp.verify(message.trialResp);
                if (error) return "trialResp." + error;
              }

              if (message.cardBookResp != null && message.hasOwnProperty("cardBookResp")) if (!(message.cardBookResp && typeof message.cardBookResp.length === "number" || $util.isString(message.cardBookResp))) return "cardBookResp: buffer expected";
              return null;
            };
            /**
            * Creates a SpinResponse message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof serverProto.SpinResponse
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {serverProto.SpinResponse} SpinResponse
            */


            SpinResponse.fromObject = function fromObject(object) {
              if (object instanceof $root.serverProto.SpinResponse) return object;
              var message = new $root.serverProto.SpinResponse();
              if (object.allPlate != null) if (typeof object.allPlate === "string") $util.base64.decode(object.allPlate, message.allPlate = $util.newBuffer($util.base64.length(object.allPlate)), 0);else if (object.allPlate.length >= 0) message.allPlate = object.allPlate;
              if (object.spinState != null) message.spinState = object.spinState >>> 0;
              if (object.totalWin != null) if ($util.Long) (message.totalWin = $util.Long.fromValue(object.totalWin)).unsigned = false;else if (typeof object.totalWin === "string") message.totalWin = parseInt(object.totalWin, 10);else if (typeof object.totalWin === "number") message.totalWin = object.totalWin;else if (typeof object.totalWin === "object") message.totalWin = new $util.LongBits(object.totalWin.low >>> 0, object.totalWin.high >>> 0).toNumber();
              if (object.roundIndex != null) if ($util.Long) (message.roundIndex = $util.Long.fromValue(object.roundIndex)).unsigned = false;else if (typeof object.roundIndex === "string") message.roundIndex = parseInt(object.roundIndex, 10);else if (typeof object.roundIndex === "number") message.roundIndex = object.roundIndex;else if (typeof object.roundIndex === "object") message.roundIndex = new $util.LongBits(object.roundIndex.low >>> 0, object.roundIndex.high >>> 0).toNumber();
              if (object.missionReward != null) message.missionReward = object.missionReward >>> 0;
              if (object.postMoney != null) if ($util.Long) (message.postMoney = $util.Long.fromValue(object.postMoney)).unsigned = false;else if (typeof object.postMoney === "string") message.postMoney = parseInt(object.postMoney, 10);else if (typeof object.postMoney === "number") message.postMoney = object.postMoney;else if (typeof object.postMoney === "object") message.postMoney = new $util.LongBits(object.postMoney.low >>> 0, object.postMoney.high >>> 0).toNumber();
              if (object.preMoney != null) if ($util.Long) (message.preMoney = $util.Long.fromValue(object.preMoney)).unsigned = false;else if (typeof object.preMoney === "string") message.preMoney = parseInt(object.preMoney, 10);else if (typeof object.preMoney === "number") message.preMoney = object.preMoney;else if (typeof object.preMoney === "object") message.preMoney = new $util.LongBits(object.preMoney.low >>> 0, object.preMoney.high >>> 0).toNumber();

              if (object.jp != null) {
                if (typeof object.jp !== "object") throw TypeError(".serverProto.SpinResponse.jp: object expected");
                message.jp = $root.serverProto.JpOpen.fromObject(object.jp);
              }

              if (object.lottery != null) if (typeof object.lottery === "string") $util.base64.decode(object.lottery, message.lottery = $util.newBuffer($util.base64.length(object.lottery)), 0);else if (object.lottery.length >= 0) message.lottery = object.lottery;
              if (object.fullJpWin != null) if ($util.Long) (message.fullJpWin = $util.Long.fromValue(object.fullJpWin)).unsigned = false;else if (typeof object.fullJpWin === "string") message.fullJpWin = parseInt(object.fullJpWin, 10);else if (typeof object.fullJpWin === "number") message.fullJpWin = object.fullJpWin;else if (typeof object.fullJpWin === "object") message.fullJpWin = new $util.LongBits(object.fullJpWin.low >>> 0, object.fullJpWin.high >>> 0).toNumber();
              if (object.freeSpinCount != null) message.freeSpinCount = object.freeSpinCount | 0;

              if (object.trialResp != null) {
                if (typeof object.trialResp !== "object") throw TypeError(".serverProto.SpinResponse.trialResp: object expected");
                message.trialResp = $root.serverProto.TrialSpinResp.fromObject(object.trialResp);
              }

              if (object.cardBookResp != null) if (typeof object.cardBookResp === "string") $util.base64.decode(object.cardBookResp, message.cardBookResp = $util.newBuffer($util.base64.length(object.cardBookResp)), 0);else if (object.cardBookResp.length >= 0) message.cardBookResp = object.cardBookResp;
              return message;
            };
            /**
            * Creates a plain object from a SpinResponse message. Also converts values to other types if specified.
            * @function toObject
            * @memberof serverProto.SpinResponse
            * @static
            * @param {serverProto.SpinResponse} message SpinResponse
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            SpinResponse.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                if (options.bytes === String) object.allPlate = "";else {
                  object.allPlate = [];
                  if (options.bytes !== Array) object.allPlate = $util.newBuffer(object.allPlate);
                }
                object.spinState = 0;

                if ($util.Long) {
                  var _long2 = new $util.Long(0, 0, false);

                  object.totalWin = options.longs === String ? _long2.toString() : options.longs === Number ? _long2.toNumber() : _long2;
                } else object.totalWin = options.longs === String ? "0" : 0;

                if ($util.Long) {
                  var _long2 = new $util.Long(0, 0, false);

                  object.roundIndex = options.longs === String ? _long2.toString() : options.longs === Number ? _long2.toNumber() : _long2;
                } else object.roundIndex = options.longs === String ? "0" : 0;

                object.missionReward = 0;

                if ($util.Long) {
                  var _long2 = new $util.Long(0, 0, false);

                  object.postMoney = options.longs === String ? _long2.toString() : options.longs === Number ? _long2.toNumber() : _long2;
                } else object.postMoney = options.longs === String ? "0" : 0;

                if ($util.Long) {
                  var _long2 = new $util.Long(0, 0, false);

                  object.preMoney = options.longs === String ? _long2.toString() : options.longs === Number ? _long2.toNumber() : _long2;
                } else object.preMoney = options.longs === String ? "0" : 0;

                object.jp = null;
                if (options.bytes === String) object.lottery = "";else {
                  object.lottery = [];
                  if (options.bytes !== Array) object.lottery = $util.newBuffer(object.lottery);
                }

                if ($util.Long) {
                  var _long2 = new $util.Long(0, 0, false);

                  object.fullJpWin = options.longs === String ? _long2.toString() : options.longs === Number ? _long2.toNumber() : _long2;
                } else object.fullJpWin = options.longs === String ? "0" : 0;

                object.freeSpinCount = 0;
                object.trialResp = null;
                if (options.bytes === String) object.cardBookResp = "";else {
                  object.cardBookResp = [];
                  if (options.bytes !== Array) object.cardBookResp = $util.newBuffer(object.cardBookResp);
                }
              }

              if (message.allPlate != null && message.hasOwnProperty("allPlate")) object.allPlate = options.bytes === String ? $util.base64.encode(message.allPlate, 0, message.allPlate.length) : options.bytes === Array ? Array.prototype.slice.call(message.allPlate) : message.allPlate;
              if (message.spinState != null && message.hasOwnProperty("spinState")) object.spinState = message.spinState;
              if (message.totalWin != null && message.hasOwnProperty("totalWin")) if (typeof message.totalWin === "number") object.totalWin = options.longs === String ? String(message.totalWin) : message.totalWin;else object.totalWin = options.longs === String ? $util.Long.prototype.toString.call(message.totalWin) : options.longs === Number ? new $util.LongBits(message.totalWin.low >>> 0, message.totalWin.high >>> 0).toNumber() : message.totalWin;
              if (message.roundIndex != null && message.hasOwnProperty("roundIndex")) if (typeof message.roundIndex === "number") object.roundIndex = options.longs === String ? String(message.roundIndex) : message.roundIndex;else object.roundIndex = options.longs === String ? $util.Long.prototype.toString.call(message.roundIndex) : options.longs === Number ? new $util.LongBits(message.roundIndex.low >>> 0, message.roundIndex.high >>> 0).toNumber() : message.roundIndex;
              if (message.missionReward != null && message.hasOwnProperty("missionReward")) object.missionReward = message.missionReward;
              if (message.postMoney != null && message.hasOwnProperty("postMoney")) if (typeof message.postMoney === "number") object.postMoney = options.longs === String ? String(message.postMoney) : message.postMoney;else object.postMoney = options.longs === String ? $util.Long.prototype.toString.call(message.postMoney) : options.longs === Number ? new $util.LongBits(message.postMoney.low >>> 0, message.postMoney.high >>> 0).toNumber() : message.postMoney;
              if (message.preMoney != null && message.hasOwnProperty("preMoney")) if (typeof message.preMoney === "number") object.preMoney = options.longs === String ? String(message.preMoney) : message.preMoney;else object.preMoney = options.longs === String ? $util.Long.prototype.toString.call(message.preMoney) : options.longs === Number ? new $util.LongBits(message.preMoney.low >>> 0, message.preMoney.high >>> 0).toNumber() : message.preMoney;
              if (message.jp != null && message.hasOwnProperty("jp")) object.jp = $root.serverProto.JpOpen.toObject(message.jp, options);
              if (message.lottery != null && message.hasOwnProperty("lottery")) object.lottery = options.bytes === String ? $util.base64.encode(message.lottery, 0, message.lottery.length) : options.bytes === Array ? Array.prototype.slice.call(message.lottery) : message.lottery;
              if (message.fullJpWin != null && message.hasOwnProperty("fullJpWin")) if (typeof message.fullJpWin === "number") object.fullJpWin = options.longs === String ? String(message.fullJpWin) : message.fullJpWin;else object.fullJpWin = options.longs === String ? $util.Long.prototype.toString.call(message.fullJpWin) : options.longs === Number ? new $util.LongBits(message.fullJpWin.low >>> 0, message.fullJpWin.high >>> 0).toNumber() : message.fullJpWin;
              if (message.freeSpinCount != null && message.hasOwnProperty("freeSpinCount")) object.freeSpinCount = message.freeSpinCount;
              if (message.trialResp != null && message.hasOwnProperty("trialResp")) object.trialResp = $root.serverProto.TrialSpinResp.toObject(message.trialResp, options);
              if (message.cardBookResp != null && message.hasOwnProperty("cardBookResp")) object.cardBookResp = options.bytes === String ? $util.base64.encode(message.cardBookResp, 0, message.cardBookResp.length) : options.bytes === Array ? Array.prototype.slice.call(message.cardBookResp) : message.cardBookResp;
              return object;
            };
            /**
            * Converts this SpinResponse to JSON.
            * @function toJSON
            * @memberof serverProto.SpinResponse
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            SpinResponse.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
            * Gets the default type url for SpinResponse
            * @function getTypeUrl
            * @memberof serverProto.SpinResponse
            * @static
            * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
            * @returns {string} The default type url
            */


            SpinResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/serverProto.SpinResponse";
            };

            return SpinResponse;
          }();

          serverProto.InfoReq = function () {
            /**
            * Properties of an InfoReq.
            * @memberof serverProto
            * @interface IInfoReq
            * @property {string|null} [os] InfoReq os
            * @property {string|null} [language] InfoReq language
            * @property {serverProto.IBrowser|null} [browser] InfoReq browser
            * @property {string|null} [version] InfoReq version
            * @property {string|null} [model] InfoReq model
            */

            /**
            * Constructs a new InfoReq.
            * @memberof serverProto
            * @classdesc Represents an InfoReq.
            * @implements IInfoReq
            * @constructor
            * @param {serverProto.IInfoReq=} [properties] Properties to set
            */
            function InfoReq(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * InfoReq os.
            * @member {string} os
            * @memberof serverProto.InfoReq
            * @instance
            */


            InfoReq.prototype.os = "";
            /**
            * InfoReq language.
            * @member {string} language
            * @memberof serverProto.InfoReq
            * @instance
            */

            InfoReq.prototype.language = "";
            /**
            * InfoReq browser.
            * @member {serverProto.IBrowser|null|undefined} browser
            * @memberof serverProto.InfoReq
            * @instance
            */

            InfoReq.prototype.browser = null;
            /**
            * InfoReq version.
            * @member {string} version
            * @memberof serverProto.InfoReq
            * @instance
            */

            InfoReq.prototype.version = "";
            /**
            * InfoReq model.
            * @member {string} model
            * @memberof serverProto.InfoReq
            * @instance
            */

            InfoReq.prototype.model = "";
            /**
            * Creates a new InfoReq instance using the specified properties.
            * @function create
            * @memberof serverProto.InfoReq
            * @static
            * @param {serverProto.IInfoReq=} [properties] Properties to set
            * @returns {serverProto.InfoReq} InfoReq instance
            */

            InfoReq.create = function create(properties) {
              return new InfoReq(properties);
            };
            /**
            * Encodes the specified InfoReq message. Does not implicitly {@link serverProto.InfoReq.verify|verify} messages.
            * @function encode
            * @memberof serverProto.InfoReq
            * @static
            * @param {serverProto.IInfoReq} message InfoReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            InfoReq.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.os != null && Object.hasOwnProperty.call(message, "os")) writer.uint32(
              /* id 1, wireType 2 =*/
              10).string(message.os);
              if (message.language != null && Object.hasOwnProperty.call(message, "language")) writer.uint32(
              /* id 2, wireType 2 =*/
              18).string(message.language);
              if (message.browser != null && Object.hasOwnProperty.call(message, "browser")) $root.serverProto.Browser.encode(message.browser, writer.uint32(
              /* id 3, wireType 2 =*/
              26).fork()).ldelim();
              if (message.version != null && Object.hasOwnProperty.call(message, "version")) writer.uint32(
              /* id 4, wireType 2 =*/
              34).string(message.version);
              if (message.model != null && Object.hasOwnProperty.call(message, "model")) writer.uint32(
              /* id 5, wireType 2 =*/
              42).string(message.model);
              return writer;
            };
            /**
            * Encodes the specified InfoReq message, length delimited. Does not implicitly {@link serverProto.InfoReq.verify|verify} messages.
            * @function encodeDelimited
            * @memberof serverProto.InfoReq
            * @static
            * @param {serverProto.IInfoReq} message InfoReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            InfoReq.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes an InfoReq message from the specified reader or buffer.
            * @function decode
            * @memberof serverProto.InfoReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {serverProto.InfoReq} InfoReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            InfoReq.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.serverProto.InfoReq();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      message.os = reader.string();
                      break;
                    }

                  case 2:
                    {
                      message.language = reader.string();
                      break;
                    }

                  case 3:
                    {
                      message.browser = $root.serverProto.Browser.decode(reader, reader.uint32());
                      break;
                    }

                  case 4:
                    {
                      message.version = reader.string();
                      break;
                    }

                  case 5:
                    {
                      message.model = reader.string();
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes an InfoReq message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof serverProto.InfoReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {serverProto.InfoReq} InfoReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            InfoReq.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies an InfoReq message.
            * @function verify
            * @memberof serverProto.InfoReq
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            InfoReq.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.os != null && message.hasOwnProperty("os")) if (!$util.isString(message.os)) return "os: string expected";
              if (message.language != null && message.hasOwnProperty("language")) if (!$util.isString(message.language)) return "language: string expected";

              if (message.browser != null && message.hasOwnProperty("browser")) {
                var error = $root.serverProto.Browser.verify(message.browser);
                if (error) return "browser." + error;
              }

              if (message.version != null && message.hasOwnProperty("version")) if (!$util.isString(message.version)) return "version: string expected";
              if (message.model != null && message.hasOwnProperty("model")) if (!$util.isString(message.model)) return "model: string expected";
              return null;
            };
            /**
            * Creates an InfoReq message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof serverProto.InfoReq
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {serverProto.InfoReq} InfoReq
            */


            InfoReq.fromObject = function fromObject(object) {
              if (object instanceof $root.serverProto.InfoReq) return object;
              var message = new $root.serverProto.InfoReq();
              if (object.os != null) message.os = String(object.os);
              if (object.language != null) message.language = String(object.language);

              if (object.browser != null) {
                if (typeof object.browser !== "object") throw TypeError(".serverProto.InfoReq.browser: object expected");
                message.browser = $root.serverProto.Browser.fromObject(object.browser);
              }

              if (object.version != null) message.version = String(object.version);
              if (object.model != null) message.model = String(object.model);
              return message;
            };
            /**
            * Creates a plain object from an InfoReq message. Also converts values to other types if specified.
            * @function toObject
            * @memberof serverProto.InfoReq
            * @static
            * @param {serverProto.InfoReq} message InfoReq
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            InfoReq.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.os = "";
                object.language = "";
                object.browser = null;
                object.version = "";
                object.model = "";
              }

              if (message.os != null && message.hasOwnProperty("os")) object.os = message.os;
              if (message.language != null && message.hasOwnProperty("language")) object.language = message.language;
              if (message.browser != null && message.hasOwnProperty("browser")) object.browser = $root.serverProto.Browser.toObject(message.browser, options);
              if (message.version != null && message.hasOwnProperty("version")) object.version = message.version;
              if (message.model != null && message.hasOwnProperty("model")) object.model = message.model;
              return object;
            };
            /**
            * Converts this InfoReq to JSON.
            * @function toJSON
            * @memberof serverProto.InfoReq
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            InfoReq.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
            * Gets the default type url for InfoReq
            * @function getTypeUrl
            * @memberof serverProto.InfoReq
            * @static
            * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
            * @returns {string} The default type url
            */


            InfoReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/serverProto.InfoReq";
            };

            return InfoReq;
          }();

          serverProto.Browser = function () {
            /**
            * Properties of a Browser.
            * @memberof serverProto
            * @interface IBrowser
            * @property {string|null} [type] Browser type
            * @property {string|null} [version] Browser version
            * @property {string|null} [language] Browser language
            * @property {number|null} [width] Browser width
            * @property {number|null} [height] Browser height
            * @property {number|null} [ratio] Browser ratio
            */

            /**
            * Constructs a new Browser.
            * @memberof serverProto
            * @classdesc Represents a Browser.
            * @implements IBrowser
            * @constructor
            * @param {serverProto.IBrowser=} [properties] Properties to set
            */
            function Browser(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * Browser type.
            * @member {string} type
            * @memberof serverProto.Browser
            * @instance
            */


            Browser.prototype.type = "";
            /**
            * Browser version.
            * @member {string} version
            * @memberof serverProto.Browser
            * @instance
            */

            Browser.prototype.version = "";
            /**
            * Browser language.
            * @member {string} language
            * @memberof serverProto.Browser
            * @instance
            */

            Browser.prototype.language = "";
            /**
            * Browser width.
            * @member {number} width
            * @memberof serverProto.Browser
            * @instance
            */

            Browser.prototype.width = 0;
            /**
            * Browser height.
            * @member {number} height
            * @memberof serverProto.Browser
            * @instance
            */

            Browser.prototype.height = 0;
            /**
            * Browser ratio.
            * @member {number} ratio
            * @memberof serverProto.Browser
            * @instance
            */

            Browser.prototype.ratio = 0;
            /**
            * Creates a new Browser instance using the specified properties.
            * @function create
            * @memberof serverProto.Browser
            * @static
            * @param {serverProto.IBrowser=} [properties] Properties to set
            * @returns {serverProto.Browser} Browser instance
            */

            Browser.create = function create(properties) {
              return new Browser(properties);
            };
            /**
            * Encodes the specified Browser message. Does not implicitly {@link serverProto.Browser.verify|verify} messages.
            * @function encode
            * @memberof serverProto.Browser
            * @static
            * @param {serverProto.IBrowser} message Browser message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            Browser.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.type != null && Object.hasOwnProperty.call(message, "type")) writer.uint32(
              /* id 1, wireType 2 =*/
              10).string(message.type);
              if (message.version != null && Object.hasOwnProperty.call(message, "version")) writer.uint32(
              /* id 2, wireType 2 =*/
              18).string(message.version);
              if (message.language != null && Object.hasOwnProperty.call(message, "language")) writer.uint32(
              /* id 3, wireType 2 =*/
              26).string(message.language);
              if (message.width != null && Object.hasOwnProperty.call(message, "width")) writer.uint32(
              /* id 4, wireType 0 =*/
              32).uint32(message.width);
              if (message.height != null && Object.hasOwnProperty.call(message, "height")) writer.uint32(
              /* id 5, wireType 0 =*/
              40).uint32(message.height);
              if (message.ratio != null && Object.hasOwnProperty.call(message, "ratio")) writer.uint32(
              /* id 6, wireType 5 =*/
              53)["float"](message.ratio);
              return writer;
            };
            /**
            * Encodes the specified Browser message, length delimited. Does not implicitly {@link serverProto.Browser.verify|verify} messages.
            * @function encodeDelimited
            * @memberof serverProto.Browser
            * @static
            * @param {serverProto.IBrowser} message Browser message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            Browser.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a Browser message from the specified reader or buffer.
            * @function decode
            * @memberof serverProto.Browser
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {serverProto.Browser} Browser
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            Browser.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.serverProto.Browser();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      message.type = reader.string();
                      break;
                    }

                  case 2:
                    {
                      message.version = reader.string();
                      break;
                    }

                  case 3:
                    {
                      message.language = reader.string();
                      break;
                    }

                  case 4:
                    {
                      message.width = reader.uint32();
                      break;
                    }

                  case 5:
                    {
                      message.height = reader.uint32();
                      break;
                    }

                  case 6:
                    {
                      message.ratio = reader["float"]();
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a Browser message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof serverProto.Browser
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {serverProto.Browser} Browser
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            Browser.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a Browser message.
            * @function verify
            * @memberof serverProto.Browser
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            Browser.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.type != null && message.hasOwnProperty("type")) if (!$util.isString(message.type)) return "type: string expected";
              if (message.version != null && message.hasOwnProperty("version")) if (!$util.isString(message.version)) return "version: string expected";
              if (message.language != null && message.hasOwnProperty("language")) if (!$util.isString(message.language)) return "language: string expected";
              if (message.width != null && message.hasOwnProperty("width")) if (!$util.isInteger(message.width)) return "width: integer expected";
              if (message.height != null && message.hasOwnProperty("height")) if (!$util.isInteger(message.height)) return "height: integer expected";
              if (message.ratio != null && message.hasOwnProperty("ratio")) if (typeof message.ratio !== "number") return "ratio: number expected";
              return null;
            };
            /**
            * Creates a Browser message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof serverProto.Browser
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {serverProto.Browser} Browser
            */


            Browser.fromObject = function fromObject(object) {
              if (object instanceof $root.serverProto.Browser) return object;
              var message = new $root.serverProto.Browser();
              if (object.type != null) message.type = String(object.type);
              if (object.version != null) message.version = String(object.version);
              if (object.language != null) message.language = String(object.language);
              if (object.width != null) message.width = object.width >>> 0;
              if (object.height != null) message.height = object.height >>> 0;
              if (object.ratio != null) message.ratio = Number(object.ratio);
              return message;
            };
            /**
            * Creates a plain object from a Browser message. Also converts values to other types if specified.
            * @function toObject
            * @memberof serverProto.Browser
            * @static
            * @param {serverProto.Browser} message Browser
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            Browser.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.type = "";
                object.version = "";
                object.language = "";
                object.width = 0;
                object.height = 0;
                object.ratio = 0;
              }

              if (message.type != null && message.hasOwnProperty("type")) object.type = message.type;
              if (message.version != null && message.hasOwnProperty("version")) object.version = message.version;
              if (message.language != null && message.hasOwnProperty("language")) object.language = message.language;
              if (message.width != null && message.hasOwnProperty("width")) object.width = message.width;
              if (message.height != null && message.hasOwnProperty("height")) object.height = message.height;
              if (message.ratio != null && message.hasOwnProperty("ratio")) object.ratio = options.json && !isFinite(message.ratio) ? String(message.ratio) : message.ratio;
              return object;
            };
            /**
            * Converts this Browser to JSON.
            * @function toJSON
            * @memberof serverProto.Browser
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            Browser.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
            * Gets the default type url for Browser
            * @function getTypeUrl
            * @memberof serverProto.Browser
            * @static
            * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
            * @returns {string} The default type url
            */


            Browser.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/serverProto.Browser";
            };

            return Browser;
          }();

          serverProto.InfoResponse = function () {
            /**
            * Properties of an InfoResponse.
            * @memberof serverProto
            * @interface IInfoResponse
            * @property {Array.<serverProto.IWallet>|null} [wallet] InfoResponse wallet
            * @property {serverProto.ISpinResponse|null} [spinResponse] InfoResponse spinResponse
            * @property {Uint8Array|null} [extraInfo] InfoResponse extraInfo
            * @property {Array.<number>|null} [jpUnlockBet] InfoResponse jpUnlockBet
            * @property {serverProto.IPreferRoundShow|null} [prefer] InfoResponse prefer
            * @property {serverProto.IMallInfo|null} [mall] InfoResponse mall
            * @property {number|null} [rtp] InfoResponse rtp
            * @property {serverProto.IFreeSpinData|null} [free] InfoResponse free
            */

            /**
            * Constructs a new InfoResponse.
            * @memberof serverProto
            * @classdesc Represents an InfoResponse.
            * @implements IInfoResponse
            * @constructor
            * @param {serverProto.IInfoResponse=} [properties] Properties to set
            */
            function InfoResponse(properties) {
              this.wallet = [];
              this.jpUnlockBet = [];
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * InfoResponse wallet.
            * @member {Array.<serverProto.IWallet>} wallet
            * @memberof serverProto.InfoResponse
            * @instance
            */


            InfoResponse.prototype.wallet = $util.emptyArray;
            /**
            * InfoResponse spinResponse.
            * @member {serverProto.ISpinResponse|null|undefined} spinResponse
            * @memberof serverProto.InfoResponse
            * @instance
            */

            InfoResponse.prototype.spinResponse = null;
            /**
            * InfoResponse extraInfo.
            * @member {Uint8Array} extraInfo
            * @memberof serverProto.InfoResponse
            * @instance
            */

            InfoResponse.prototype.extraInfo = $util.newBuffer([]);
            /**
            * InfoResponse jpUnlockBet.
            * @member {Array.<number>} jpUnlockBet
            * @memberof serverProto.InfoResponse
            * @instance
            */

            InfoResponse.prototype.jpUnlockBet = $util.emptyArray;
            /**
            * InfoResponse prefer.
            * @member {serverProto.IPreferRoundShow|null|undefined} prefer
            * @memberof serverProto.InfoResponse
            * @instance
            */

            InfoResponse.prototype.prefer = null;
            /**
            * InfoResponse mall.
            * @member {serverProto.IMallInfo|null|undefined} mall
            * @memberof serverProto.InfoResponse
            * @instance
            */

            InfoResponse.prototype.mall = null;
            /**
            * InfoResponse rtp.
            * @member {number} rtp
            * @memberof serverProto.InfoResponse
            * @instance
            */

            InfoResponse.prototype.rtp = 0;
            /**
            * InfoResponse free.
            * @member {serverProto.IFreeSpinData|null|undefined} free
            * @memberof serverProto.InfoResponse
            * @instance
            */

            InfoResponse.prototype.free = null;
            /**
            * Creates a new InfoResponse instance using the specified properties.
            * @function create
            * @memberof serverProto.InfoResponse
            * @static
            * @param {serverProto.IInfoResponse=} [properties] Properties to set
            * @returns {serverProto.InfoResponse} InfoResponse instance
            */

            InfoResponse.create = function create(properties) {
              return new InfoResponse(properties);
            };
            /**
            * Encodes the specified InfoResponse message. Does not implicitly {@link serverProto.InfoResponse.verify|verify} messages.
            * @function encode
            * @memberof serverProto.InfoResponse
            * @static
            * @param {serverProto.IInfoResponse} message InfoResponse message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            InfoResponse.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.wallet != null && message.wallet.length) for (var i = 0; i < message.wallet.length; ++i) {
                $root.serverProto.Wallet.encode(message.wallet[i], writer.uint32(
                /* id 1, wireType 2 =*/
                10).fork()).ldelim();
              }
              if (message.spinResponse != null && Object.hasOwnProperty.call(message, "spinResponse")) $root.serverProto.SpinResponse.encode(message.spinResponse, writer.uint32(
              /* id 2, wireType 2 =*/
              18).fork()).ldelim();
              if (message.extraInfo != null && Object.hasOwnProperty.call(message, "extraInfo")) writer.uint32(
              /* id 4, wireType 2 =*/
              34).bytes(message.extraInfo);

              if (message.jpUnlockBet != null && message.jpUnlockBet.length) {
                writer.uint32(
                /* id 5, wireType 2 =*/
                42).fork();

                for (var i = 0; i < message.jpUnlockBet.length; ++i) {
                  writer["double"](message.jpUnlockBet[i]);
                }

                writer.ldelim();
              }

              if (message.prefer != null && Object.hasOwnProperty.call(message, "prefer")) $root.serverProto.PreferRoundShow.encode(message.prefer, writer.uint32(
              /* id 6, wireType 2 =*/
              50).fork()).ldelim();
              if (message.mall != null && Object.hasOwnProperty.call(message, "mall")) $root.serverProto.MallInfo.encode(message.mall, writer.uint32(
              /* id 7, wireType 2 =*/
              58).fork()).ldelim();
              if (message.rtp != null && Object.hasOwnProperty.call(message, "rtp")) writer.uint32(
              /* id 8, wireType 1 =*/
              65)["double"](message.rtp);
              if (message.free != null && Object.hasOwnProperty.call(message, "free")) $root.serverProto.FreeSpinData.encode(message.free, writer.uint32(
              /* id 9, wireType 2 =*/
              74).fork()).ldelim();
              return writer;
            };
            /**
            * Encodes the specified InfoResponse message, length delimited. Does not implicitly {@link serverProto.InfoResponse.verify|verify} messages.
            * @function encodeDelimited
            * @memberof serverProto.InfoResponse
            * @static
            * @param {serverProto.IInfoResponse} message InfoResponse message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            InfoResponse.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes an InfoResponse message from the specified reader or buffer.
            * @function decode
            * @memberof serverProto.InfoResponse
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {serverProto.InfoResponse} InfoResponse
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            InfoResponse.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.serverProto.InfoResponse();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      if (!(message.wallet && message.wallet.length)) message.wallet = [];
                      message.wallet.push($root.serverProto.Wallet.decode(reader, reader.uint32()));
                      break;
                    }

                  case 2:
                    {
                      message.spinResponse = $root.serverProto.SpinResponse.decode(reader, reader.uint32());
                      break;
                    }

                  case 4:
                    {
                      message.extraInfo = reader.bytes();
                      break;
                    }

                  case 5:
                    {
                      if (!(message.jpUnlockBet && message.jpUnlockBet.length)) message.jpUnlockBet = [];

                      if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;

                        while (reader.pos < end2) {
                          message.jpUnlockBet.push(reader["double"]());
                        }
                      } else message.jpUnlockBet.push(reader["double"]());

                      break;
                    }

                  case 6:
                    {
                      message.prefer = $root.serverProto.PreferRoundShow.decode(reader, reader.uint32());
                      break;
                    }

                  case 7:
                    {
                      message.mall = $root.serverProto.MallInfo.decode(reader, reader.uint32());
                      break;
                    }

                  case 8:
                    {
                      message.rtp = reader["double"]();
                      break;
                    }

                  case 9:
                    {
                      message.free = $root.serverProto.FreeSpinData.decode(reader, reader.uint32());
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes an InfoResponse message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof serverProto.InfoResponse
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {serverProto.InfoResponse} InfoResponse
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            InfoResponse.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies an InfoResponse message.
            * @function verify
            * @memberof serverProto.InfoResponse
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            InfoResponse.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";

              if (message.wallet != null && message.hasOwnProperty("wallet")) {
                if (!Array.isArray(message.wallet)) return "wallet: array expected";

                for (var i = 0; i < message.wallet.length; ++i) {
                  var error = $root.serverProto.Wallet.verify(message.wallet[i]);
                  if (error) return "wallet." + error;
                }
              }

              if (message.spinResponse != null && message.hasOwnProperty("spinResponse")) {
                var error = $root.serverProto.SpinResponse.verify(message.spinResponse);
                if (error) return "spinResponse." + error;
              }

              if (message.extraInfo != null && message.hasOwnProperty("extraInfo")) if (!(message.extraInfo && typeof message.extraInfo.length === "number" || $util.isString(message.extraInfo))) return "extraInfo: buffer expected";

              if (message.jpUnlockBet != null && message.hasOwnProperty("jpUnlockBet")) {
                if (!Array.isArray(message.jpUnlockBet)) return "jpUnlockBet: array expected";

                for (var i = 0; i < message.jpUnlockBet.length; ++i) {
                  if (typeof message.jpUnlockBet[i] !== "number") return "jpUnlockBet: number[] expected";
                }
              }

              if (message.prefer != null && message.hasOwnProperty("prefer")) {
                var error = $root.serverProto.PreferRoundShow.verify(message.prefer);
                if (error) return "prefer." + error;
              }

              if (message.mall != null && message.hasOwnProperty("mall")) {
                var error = $root.serverProto.MallInfo.verify(message.mall);
                if (error) return "mall." + error;
              }

              if (message.rtp != null && message.hasOwnProperty("rtp")) if (typeof message.rtp !== "number") return "rtp: number expected";

              if (message.free != null && message.hasOwnProperty("free")) {
                var error = $root.serverProto.FreeSpinData.verify(message.free);
                if (error) return "free." + error;
              }

              return null;
            };
            /**
            * Creates an InfoResponse message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof serverProto.InfoResponse
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {serverProto.InfoResponse} InfoResponse
            */


            InfoResponse.fromObject = function fromObject(object) {
              if (object instanceof $root.serverProto.InfoResponse) return object;
              var message = new $root.serverProto.InfoResponse();

              if (object.wallet) {
                if (!Array.isArray(object.wallet)) throw TypeError(".serverProto.InfoResponse.wallet: array expected");
                message.wallet = [];

                for (var i = 0; i < object.wallet.length; ++i) {
                  if (typeof object.wallet[i] !== "object") throw TypeError(".serverProto.InfoResponse.wallet: object expected");
                  message.wallet[i] = $root.serverProto.Wallet.fromObject(object.wallet[i]);
                }
              }

              if (object.spinResponse != null) {
                if (typeof object.spinResponse !== "object") throw TypeError(".serverProto.InfoResponse.spinResponse: object expected");
                message.spinResponse = $root.serverProto.SpinResponse.fromObject(object.spinResponse);
              }

              if (object.extraInfo != null) if (typeof object.extraInfo === "string") $util.base64.decode(object.extraInfo, message.extraInfo = $util.newBuffer($util.base64.length(object.extraInfo)), 0);else if (object.extraInfo.length >= 0) message.extraInfo = object.extraInfo;

              if (object.jpUnlockBet) {
                if (!Array.isArray(object.jpUnlockBet)) throw TypeError(".serverProto.InfoResponse.jpUnlockBet: array expected");
                message.jpUnlockBet = [];

                for (var i = 0; i < object.jpUnlockBet.length; ++i) {
                  message.jpUnlockBet[i] = Number(object.jpUnlockBet[i]);
                }
              }

              if (object.prefer != null) {
                if (typeof object.prefer !== "object") throw TypeError(".serverProto.InfoResponse.prefer: object expected");
                message.prefer = $root.serverProto.PreferRoundShow.fromObject(object.prefer);
              }

              if (object.mall != null) {
                if (typeof object.mall !== "object") throw TypeError(".serverProto.InfoResponse.mall: object expected");
                message.mall = $root.serverProto.MallInfo.fromObject(object.mall);
              }

              if (object.rtp != null) message.rtp = Number(object.rtp);

              if (object.free != null) {
                if (typeof object.free !== "object") throw TypeError(".serverProto.InfoResponse.free: object expected");
                message.free = $root.serverProto.FreeSpinData.fromObject(object.free);
              }

              return message;
            };
            /**
            * Creates a plain object from an InfoResponse message. Also converts values to other types if specified.
            * @function toObject
            * @memberof serverProto.InfoResponse
            * @static
            * @param {serverProto.InfoResponse} message InfoResponse
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            InfoResponse.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.arrays || options.defaults) {
                object.wallet = [];
                object.jpUnlockBet = [];
              }

              if (options.defaults) {
                object.spinResponse = null;
                if (options.bytes === String) object.extraInfo = "";else {
                  object.extraInfo = [];
                  if (options.bytes !== Array) object.extraInfo = $util.newBuffer(object.extraInfo);
                }
                object.prefer = null;
                object.mall = null;
                object.rtp = 0;
                object.free = null;
              }

              if (message.wallet && message.wallet.length) {
                object.wallet = [];

                for (var j = 0; j < message.wallet.length; ++j) {
                  object.wallet[j] = $root.serverProto.Wallet.toObject(message.wallet[j], options);
                }
              }

              if (message.spinResponse != null && message.hasOwnProperty("spinResponse")) object.spinResponse = $root.serverProto.SpinResponse.toObject(message.spinResponse, options);
              if (message.extraInfo != null && message.hasOwnProperty("extraInfo")) object.extraInfo = options.bytes === String ? $util.base64.encode(message.extraInfo, 0, message.extraInfo.length) : options.bytes === Array ? Array.prototype.slice.call(message.extraInfo) : message.extraInfo;

              if (message.jpUnlockBet && message.jpUnlockBet.length) {
                object.jpUnlockBet = [];

                for (var j = 0; j < message.jpUnlockBet.length; ++j) {
                  object.jpUnlockBet[j] = options.json && !isFinite(message.jpUnlockBet[j]) ? String(message.jpUnlockBet[j]) : message.jpUnlockBet[j];
                }
              }

              if (message.prefer != null && message.hasOwnProperty("prefer")) object.prefer = $root.serverProto.PreferRoundShow.toObject(message.prefer, options);
              if (message.mall != null && message.hasOwnProperty("mall")) object.mall = $root.serverProto.MallInfo.toObject(message.mall, options);
              if (message.rtp != null && message.hasOwnProperty("rtp")) object.rtp = options.json && !isFinite(message.rtp) ? String(message.rtp) : message.rtp;
              if (message.free != null && message.hasOwnProperty("free")) object.free = $root.serverProto.FreeSpinData.toObject(message.free, options);
              return object;
            };
            /**
            * Converts this InfoResponse to JSON.
            * @function toJSON
            * @memberof serverProto.InfoResponse
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            InfoResponse.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
            * Gets the default type url for InfoResponse
            * @function getTypeUrl
            * @memberof serverProto.InfoResponse
            * @static
            * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
            * @returns {string} The default type url
            */


            InfoResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/serverProto.InfoResponse";
            };

            return InfoResponse;
          }();

          serverProto.PreferRoundShow = function () {
            /**
            * Properties of a PreferRoundShow.
            * @memberof serverProto
            * @interface IPreferRoundShow
            * @property {number|null} [BaseRound] PreferRoundShow BaseRound
            * @property {number|null} [SigmaRound] PreferRoundShow SigmaRound
            * @property {number|null} [CV] PreferRoundShow CV
            * @property {number|null} [HR] PreferRoundShow HR
            * @property {number|null} [MGR] PreferRoundShow MGR
            * @property {number|null} [Range] PreferRoundShow Range
            * @property {number|null} [Show] PreferRoundShow Show
            */

            /**
            * Constructs a new PreferRoundShow.
            * @memberof serverProto
            * @classdesc Represents a PreferRoundShow.
            * @implements IPreferRoundShow
            * @constructor
            * @param {serverProto.IPreferRoundShow=} [properties] Properties to set
            */
            function PreferRoundShow(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * PreferRoundShow BaseRound.
            * @member {number} BaseRound
            * @memberof serverProto.PreferRoundShow
            * @instance
            */


            PreferRoundShow.prototype.BaseRound = 0;
            /**
            * PreferRoundShow SigmaRound.
            * @member {number} SigmaRound
            * @memberof serverProto.PreferRoundShow
            * @instance
            */

            PreferRoundShow.prototype.SigmaRound = 0;
            /**
            * PreferRoundShow CV.
            * @member {number} CV
            * @memberof serverProto.PreferRoundShow
            * @instance
            */

            PreferRoundShow.prototype.CV = 0;
            /**
            * PreferRoundShow HR.
            * @member {number} HR
            * @memberof serverProto.PreferRoundShow
            * @instance
            */

            PreferRoundShow.prototype.HR = 0;
            /**
            * PreferRoundShow MGR.
            * @member {number} MGR
            * @memberof serverProto.PreferRoundShow
            * @instance
            */

            PreferRoundShow.prototype.MGR = 0;
            /**
            * PreferRoundShow Range.
            * @member {number} Range
            * @memberof serverProto.PreferRoundShow
            * @instance
            */

            PreferRoundShow.prototype.Range = 0;
            /**
            * PreferRoundShow Show.
            * @member {number} Show
            * @memberof serverProto.PreferRoundShow
            * @instance
            */

            PreferRoundShow.prototype.Show = 0;
            /**
            * Creates a new PreferRoundShow instance using the specified properties.
            * @function create
            * @memberof serverProto.PreferRoundShow
            * @static
            * @param {serverProto.IPreferRoundShow=} [properties] Properties to set
            * @returns {serverProto.PreferRoundShow} PreferRoundShow instance
            */

            PreferRoundShow.create = function create(properties) {
              return new PreferRoundShow(properties);
            };
            /**
            * Encodes the specified PreferRoundShow message. Does not implicitly {@link serverProto.PreferRoundShow.verify|verify} messages.
            * @function encode
            * @memberof serverProto.PreferRoundShow
            * @static
            * @param {serverProto.IPreferRoundShow} message PreferRoundShow message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            PreferRoundShow.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.BaseRound != null && Object.hasOwnProperty.call(message, "BaseRound")) writer.uint32(
              /* id 1, wireType 1 =*/
              9)["double"](message.BaseRound);
              if (message.SigmaRound != null && Object.hasOwnProperty.call(message, "SigmaRound")) writer.uint32(
              /* id 2, wireType 1 =*/
              17)["double"](message.SigmaRound);
              if (message.CV != null && Object.hasOwnProperty.call(message, "CV")) writer.uint32(
              /* id 3, wireType 1 =*/
              25)["double"](message.CV);
              if (message.HR != null && Object.hasOwnProperty.call(message, "HR")) writer.uint32(
              /* id 4, wireType 1 =*/
              33)["double"](message.HR);
              if (message.MGR != null && Object.hasOwnProperty.call(message, "MGR")) writer.uint32(
              /* id 5, wireType 1 =*/
              41)["double"](message.MGR);
              if (message.Range != null && Object.hasOwnProperty.call(message, "Range")) writer.uint32(
              /* id 6, wireType 0 =*/
              48).int32(message.Range);
              if (message.Show != null && Object.hasOwnProperty.call(message, "Show")) writer.uint32(
              /* id 7, wireType 0 =*/
              56).int32(message.Show);
              return writer;
            };
            /**
            * Encodes the specified PreferRoundShow message, length delimited. Does not implicitly {@link serverProto.PreferRoundShow.verify|verify} messages.
            * @function encodeDelimited
            * @memberof serverProto.PreferRoundShow
            * @static
            * @param {serverProto.IPreferRoundShow} message PreferRoundShow message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            PreferRoundShow.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a PreferRoundShow message from the specified reader or buffer.
            * @function decode
            * @memberof serverProto.PreferRoundShow
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {serverProto.PreferRoundShow} PreferRoundShow
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            PreferRoundShow.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.serverProto.PreferRoundShow();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      message.BaseRound = reader["double"]();
                      break;
                    }

                  case 2:
                    {
                      message.SigmaRound = reader["double"]();
                      break;
                    }

                  case 3:
                    {
                      message.CV = reader["double"]();
                      break;
                    }

                  case 4:
                    {
                      message.HR = reader["double"]();
                      break;
                    }

                  case 5:
                    {
                      message.MGR = reader["double"]();
                      break;
                    }

                  case 6:
                    {
                      message.Range = reader.int32();
                      break;
                    }

                  case 7:
                    {
                      message.Show = reader.int32();
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a PreferRoundShow message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof serverProto.PreferRoundShow
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {serverProto.PreferRoundShow} PreferRoundShow
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            PreferRoundShow.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a PreferRoundShow message.
            * @function verify
            * @memberof serverProto.PreferRoundShow
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            PreferRoundShow.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.BaseRound != null && message.hasOwnProperty("BaseRound")) if (typeof message.BaseRound !== "number") return "BaseRound: number expected";
              if (message.SigmaRound != null && message.hasOwnProperty("SigmaRound")) if (typeof message.SigmaRound !== "number") return "SigmaRound: number expected";
              if (message.CV != null && message.hasOwnProperty("CV")) if (typeof message.CV !== "number") return "CV: number expected";
              if (message.HR != null && message.hasOwnProperty("HR")) if (typeof message.HR !== "number") return "HR: number expected";
              if (message.MGR != null && message.hasOwnProperty("MGR")) if (typeof message.MGR !== "number") return "MGR: number expected";
              if (message.Range != null && message.hasOwnProperty("Range")) if (!$util.isInteger(message.Range)) return "Range: integer expected";
              if (message.Show != null && message.hasOwnProperty("Show")) if (!$util.isInteger(message.Show)) return "Show: integer expected";
              return null;
            };
            /**
            * Creates a PreferRoundShow message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof serverProto.PreferRoundShow
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {serverProto.PreferRoundShow} PreferRoundShow
            */


            PreferRoundShow.fromObject = function fromObject(object) {
              if (object instanceof $root.serverProto.PreferRoundShow) return object;
              var message = new $root.serverProto.PreferRoundShow();
              if (object.BaseRound != null) message.BaseRound = Number(object.BaseRound);
              if (object.SigmaRound != null) message.SigmaRound = Number(object.SigmaRound);
              if (object.CV != null) message.CV = Number(object.CV);
              if (object.HR != null) message.HR = Number(object.HR);
              if (object.MGR != null) message.MGR = Number(object.MGR);
              if (object.Range != null) message.Range = object.Range | 0;
              if (object.Show != null) message.Show = object.Show | 0;
              return message;
            };
            /**
            * Creates a plain object from a PreferRoundShow message. Also converts values to other types if specified.
            * @function toObject
            * @memberof serverProto.PreferRoundShow
            * @static
            * @param {serverProto.PreferRoundShow} message PreferRoundShow
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            PreferRoundShow.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.BaseRound = 0;
                object.SigmaRound = 0;
                object.CV = 0;
                object.HR = 0;
                object.MGR = 0;
                object.Range = 0;
                object.Show = 0;
              }

              if (message.BaseRound != null && message.hasOwnProperty("BaseRound")) object.BaseRound = options.json && !isFinite(message.BaseRound) ? String(message.BaseRound) : message.BaseRound;
              if (message.SigmaRound != null && message.hasOwnProperty("SigmaRound")) object.SigmaRound = options.json && !isFinite(message.SigmaRound) ? String(message.SigmaRound) : message.SigmaRound;
              if (message.CV != null && message.hasOwnProperty("CV")) object.CV = options.json && !isFinite(message.CV) ? String(message.CV) : message.CV;
              if (message.HR != null && message.hasOwnProperty("HR")) object.HR = options.json && !isFinite(message.HR) ? String(message.HR) : message.HR;
              if (message.MGR != null && message.hasOwnProperty("MGR")) object.MGR = options.json && !isFinite(message.MGR) ? String(message.MGR) : message.MGR;
              if (message.Range != null && message.hasOwnProperty("Range")) object.Range = message.Range;
              if (message.Show != null && message.hasOwnProperty("Show")) object.Show = message.Show;
              return object;
            };
            /**
            * Converts this PreferRoundShow to JSON.
            * @function toJSON
            * @memberof serverProto.PreferRoundShow
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            PreferRoundShow.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
            * Gets the default type url for PreferRoundShow
            * @function getTypeUrl
            * @memberof serverProto.PreferRoundShow
            * @static
            * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
            * @returns {string} The default type url
            */


            PreferRoundShow.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/serverProto.PreferRoundShow";
            };

            return PreferRoundShow;
          }();

          serverProto.Wallet = function () {
            /**
            * Properties of a Wallet.
            * @memberof serverProto
            * @interface IWallet
            * @property {string|null} [currencyName] Wallet currencyName
            * @property {number|null} [currencyNumber] Wallet currencyNumber
            * @property {number|Long|null} [coin] Wallet coin
            * @property {Array.<number|Long>|null} [bet] Wallet bet
            * @property {number|null} [unit] Wallet unit
            * @property {number|null} [ratio] Wallet ratio
            * @property {string|null} [currencySymbol] Wallet currencySymbol
            * @property {number|null} [rate] Wallet rate
            * @property {number|null} [cycle] Wallet cycle
            * @property {number|Long|null} [lower] Wallet lower
            * @property {number|Long|null} [upper] Wallet upper
            * @property {number|null} [decimal] Wallet decimal
            */

            /**
            * Constructs a new Wallet.
            * @memberof serverProto
            * @classdesc Represents a Wallet.
            * @implements IWallet
            * @constructor
            * @param {serverProto.IWallet=} [properties] Properties to set
            */
            function Wallet(properties) {
              this.bet = [];
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * Wallet currencyName.
            * @member {string} currencyName
            * @memberof serverProto.Wallet
            * @instance
            */


            Wallet.prototype.currencyName = "";
            /**
            * Wallet currencyNumber.
            * @member {number} currencyNumber
            * @memberof serverProto.Wallet
            * @instance
            */

            Wallet.prototype.currencyNumber = 0;
            /**
            * Wallet coin.
            * @member {number|Long} coin
            * @memberof serverProto.Wallet
            * @instance
            */

            Wallet.prototype.coin = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
            * Wallet bet.
            * @member {Array.<number|Long>} bet
            * @memberof serverProto.Wallet
            * @instance
            */

            Wallet.prototype.bet = $util.emptyArray;
            /**
            * Wallet unit.
            * @member {number} unit
            * @memberof serverProto.Wallet
            * @instance
            */

            Wallet.prototype.unit = 0;
            /**
            * Wallet ratio.
            * @member {number} ratio
            * @memberof serverProto.Wallet
            * @instance
            */

            Wallet.prototype.ratio = 0;
            /**
            * Wallet currencySymbol.
            * @member {string} currencySymbol
            * @memberof serverProto.Wallet
            * @instance
            */

            Wallet.prototype.currencySymbol = "";
            /**
            * Wallet rate.
            * @member {number} rate
            * @memberof serverProto.Wallet
            * @instance
            */

            Wallet.prototype.rate = 0;
            /**
            * Wallet cycle.
            * @member {number} cycle
            * @memberof serverProto.Wallet
            * @instance
            */

            Wallet.prototype.cycle = 0;
            /**
            * Wallet lower.
            * @member {number|Long} lower
            * @memberof serverProto.Wallet
            * @instance
            */

            Wallet.prototype.lower = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
            * Wallet upper.
            * @member {number|Long} upper
            * @memberof serverProto.Wallet
            * @instance
            */

            Wallet.prototype.upper = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
            * Wallet decimal.
            * @member {number} decimal
            * @memberof serverProto.Wallet
            * @instance
            */

            Wallet.prototype.decimal = 0;
            /**
            * Creates a new Wallet instance using the specified properties.
            * @function create
            * @memberof serverProto.Wallet
            * @static
            * @param {serverProto.IWallet=} [properties] Properties to set
            * @returns {serverProto.Wallet} Wallet instance
            */

            Wallet.create = function create(properties) {
              return new Wallet(properties);
            };
            /**
            * Encodes the specified Wallet message. Does not implicitly {@link serverProto.Wallet.verify|verify} messages.
            * @function encode
            * @memberof serverProto.Wallet
            * @static
            * @param {serverProto.IWallet} message Wallet message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            Wallet.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.currencyName != null && Object.hasOwnProperty.call(message, "currencyName")) writer.uint32(
              /* id 1, wireType 2 =*/
              10).string(message.currencyName);
              if (message.currencyNumber != null && Object.hasOwnProperty.call(message, "currencyNumber")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int32(message.currencyNumber);
              if (message.coin != null && Object.hasOwnProperty.call(message, "coin")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int64(message.coin);

              if (message.bet != null && message.bet.length) {
                writer.uint32(
                /* id 4, wireType 2 =*/
                34).fork();

                for (var i = 0; i < message.bet.length; ++i) {
                  writer.int64(message.bet[i]);
                }

                writer.ldelim();
              }

              if (message.unit != null && Object.hasOwnProperty.call(message, "unit")) writer.uint32(
              /* id 5, wireType 1 =*/
              41)["double"](message.unit);
              if (message.ratio != null && Object.hasOwnProperty.call(message, "ratio")) writer.uint32(
              /* id 6, wireType 1 =*/
              49)["double"](message.ratio);
              if (message.currencySymbol != null && Object.hasOwnProperty.call(message, "currencySymbol")) writer.uint32(
              /* id 7, wireType 2 =*/
              58).string(message.currencySymbol);
              if (message.rate != null && Object.hasOwnProperty.call(message, "rate")) writer.uint32(
              /* id 8, wireType 1 =*/
              65)["double"](message.rate);
              if (message.cycle != null && Object.hasOwnProperty.call(message, "cycle")) writer.uint32(
              /* id 9, wireType 1 =*/
              73)["double"](message.cycle);
              if (message.lower != null && Object.hasOwnProperty.call(message, "lower")) writer.uint32(
              /* id 10, wireType 0 =*/
              80).int64(message.lower);
              if (message.upper != null && Object.hasOwnProperty.call(message, "upper")) writer.uint32(
              /* id 11, wireType 0 =*/
              88).int64(message.upper);
              if (message.decimal != null && Object.hasOwnProperty.call(message, "decimal")) writer.uint32(
              /* id 12, wireType 0 =*/
              96).int32(message.decimal);
              return writer;
            };
            /**
            * Encodes the specified Wallet message, length delimited. Does not implicitly {@link serverProto.Wallet.verify|verify} messages.
            * @function encodeDelimited
            * @memberof serverProto.Wallet
            * @static
            * @param {serverProto.IWallet} message Wallet message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            Wallet.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a Wallet message from the specified reader or buffer.
            * @function decode
            * @memberof serverProto.Wallet
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {serverProto.Wallet} Wallet
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            Wallet.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.serverProto.Wallet();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      message.currencyName = reader.string();
                      break;
                    }

                  case 2:
                    {
                      message.currencyNumber = reader.int32();
                      break;
                    }

                  case 3:
                    {
                      message.coin = reader.int64();
                      break;
                    }

                  case 4:
                    {
                      if (!(message.bet && message.bet.length)) message.bet = [];

                      if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;

                        while (reader.pos < end2) {
                          message.bet.push(reader.int64());
                        }
                      } else message.bet.push(reader.int64());

                      break;
                    }

                  case 5:
                    {
                      message.unit = reader["double"]();
                      break;
                    }

                  case 6:
                    {
                      message.ratio = reader["double"]();
                      break;
                    }

                  case 7:
                    {
                      message.currencySymbol = reader.string();
                      break;
                    }

                  case 8:
                    {
                      message.rate = reader["double"]();
                      break;
                    }

                  case 9:
                    {
                      message.cycle = reader["double"]();
                      break;
                    }

                  case 10:
                    {
                      message.lower = reader.int64();
                      break;
                    }

                  case 11:
                    {
                      message.upper = reader.int64();
                      break;
                    }

                  case 12:
                    {
                      message.decimal = reader.int32();
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a Wallet message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof serverProto.Wallet
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {serverProto.Wallet} Wallet
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            Wallet.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a Wallet message.
            * @function verify
            * @memberof serverProto.Wallet
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            Wallet.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.currencyName != null && message.hasOwnProperty("currencyName")) if (!$util.isString(message.currencyName)) return "currencyName: string expected";
              if (message.currencyNumber != null && message.hasOwnProperty("currencyNumber")) if (!$util.isInteger(message.currencyNumber)) return "currencyNumber: integer expected";
              if (message.coin != null && message.hasOwnProperty("coin")) if (!$util.isInteger(message.coin) && !(message.coin && $util.isInteger(message.coin.low) && $util.isInteger(message.coin.high))) return "coin: integer|Long expected";

              if (message.bet != null && message.hasOwnProperty("bet")) {
                if (!Array.isArray(message.bet)) return "bet: array expected";

                for (var i = 0; i < message.bet.length; ++i) {
                  if (!$util.isInteger(message.bet[i]) && !(message.bet[i] && $util.isInteger(message.bet[i].low) && $util.isInteger(message.bet[i].high))) return "bet: integer|Long[] expected";
                }
              }

              if (message.unit != null && message.hasOwnProperty("unit")) if (typeof message.unit !== "number") return "unit: number expected";
              if (message.ratio != null && message.hasOwnProperty("ratio")) if (typeof message.ratio !== "number") return "ratio: number expected";
              if (message.currencySymbol != null && message.hasOwnProperty("currencySymbol")) if (!$util.isString(message.currencySymbol)) return "currencySymbol: string expected";
              if (message.rate != null && message.hasOwnProperty("rate")) if (typeof message.rate !== "number") return "rate: number expected";
              if (message.cycle != null && message.hasOwnProperty("cycle")) if (typeof message.cycle !== "number") return "cycle: number expected";
              if (message.lower != null && message.hasOwnProperty("lower")) if (!$util.isInteger(message.lower) && !(message.lower && $util.isInteger(message.lower.low) && $util.isInteger(message.lower.high))) return "lower: integer|Long expected";
              if (message.upper != null && message.hasOwnProperty("upper")) if (!$util.isInteger(message.upper) && !(message.upper && $util.isInteger(message.upper.low) && $util.isInteger(message.upper.high))) return "upper: integer|Long expected";
              if (message.decimal != null && message.hasOwnProperty("decimal")) if (!$util.isInteger(message.decimal)) return "decimal: integer expected";
              return null;
            };
            /**
            * Creates a Wallet message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof serverProto.Wallet
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {serverProto.Wallet} Wallet
            */


            Wallet.fromObject = function fromObject(object) {
              if (object instanceof $root.serverProto.Wallet) return object;
              var message = new $root.serverProto.Wallet();
              if (object.currencyName != null) message.currencyName = String(object.currencyName);
              if (object.currencyNumber != null) message.currencyNumber = object.currencyNumber | 0;
              if (object.coin != null) if ($util.Long) (message.coin = $util.Long.fromValue(object.coin)).unsigned = false;else if (typeof object.coin === "string") message.coin = parseInt(object.coin, 10);else if (typeof object.coin === "number") message.coin = object.coin;else if (typeof object.coin === "object") message.coin = new $util.LongBits(object.coin.low >>> 0, object.coin.high >>> 0).toNumber();

              if (object.bet) {
                if (!Array.isArray(object.bet)) throw TypeError(".serverProto.Wallet.bet: array expected");
                message.bet = [];

                for (var i = 0; i < object.bet.length; ++i) {
                  if ($util.Long) (message.bet[i] = $util.Long.fromValue(object.bet[i])).unsigned = false;else if (typeof object.bet[i] === "string") message.bet[i] = parseInt(object.bet[i], 10);else if (typeof object.bet[i] === "number") message.bet[i] = object.bet[i];else if (typeof object.bet[i] === "object") message.bet[i] = new $util.LongBits(object.bet[i].low >>> 0, object.bet[i].high >>> 0).toNumber();
                }
              }

              if (object.unit != null) message.unit = Number(object.unit);
              if (object.ratio != null) message.ratio = Number(object.ratio);
              if (object.currencySymbol != null) message.currencySymbol = String(object.currencySymbol);
              if (object.rate != null) message.rate = Number(object.rate);
              if (object.cycle != null) message.cycle = Number(object.cycle);
              if (object.lower != null) if ($util.Long) (message.lower = $util.Long.fromValue(object.lower)).unsigned = false;else if (typeof object.lower === "string") message.lower = parseInt(object.lower, 10);else if (typeof object.lower === "number") message.lower = object.lower;else if (typeof object.lower === "object") message.lower = new $util.LongBits(object.lower.low >>> 0, object.lower.high >>> 0).toNumber();
              if (object.upper != null) if ($util.Long) (message.upper = $util.Long.fromValue(object.upper)).unsigned = false;else if (typeof object.upper === "string") message.upper = parseInt(object.upper, 10);else if (typeof object.upper === "number") message.upper = object.upper;else if (typeof object.upper === "object") message.upper = new $util.LongBits(object.upper.low >>> 0, object.upper.high >>> 0).toNumber();
              if (object.decimal != null) message.decimal = object.decimal | 0;
              return message;
            };
            /**
            * Creates a plain object from a Wallet message. Also converts values to other types if specified.
            * @function toObject
            * @memberof serverProto.Wallet
            * @static
            * @param {serverProto.Wallet} message Wallet
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            Wallet.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};
              if (options.arrays || options.defaults) object.bet = [];

              if (options.defaults) {
                object.currencyName = "";
                object.currencyNumber = 0;

                if ($util.Long) {
                  var _long3 = new $util.Long(0, 0, false);

                  object.coin = options.longs === String ? _long3.toString() : options.longs === Number ? _long3.toNumber() : _long3;
                } else object.coin = options.longs === String ? "0" : 0;

                object.unit = 0;
                object.ratio = 0;
                object.currencySymbol = "";
                object.rate = 0;
                object.cycle = 0;

                if ($util.Long) {
                  var _long3 = new $util.Long(0, 0, false);

                  object.lower = options.longs === String ? _long3.toString() : options.longs === Number ? _long3.toNumber() : _long3;
                } else object.lower = options.longs === String ? "0" : 0;

                if ($util.Long) {
                  var _long3 = new $util.Long(0, 0, false);

                  object.upper = options.longs === String ? _long3.toString() : options.longs === Number ? _long3.toNumber() : _long3;
                } else object.upper = options.longs === String ? "0" : 0;

                object.decimal = 0;
              }

              if (message.currencyName != null && message.hasOwnProperty("currencyName")) object.currencyName = message.currencyName;
              if (message.currencyNumber != null && message.hasOwnProperty("currencyNumber")) object.currencyNumber = message.currencyNumber;
              if (message.coin != null && message.hasOwnProperty("coin")) if (typeof message.coin === "number") object.coin = options.longs === String ? String(message.coin) : message.coin;else object.coin = options.longs === String ? $util.Long.prototype.toString.call(message.coin) : options.longs === Number ? new $util.LongBits(message.coin.low >>> 0, message.coin.high >>> 0).toNumber() : message.coin;

              if (message.bet && message.bet.length) {
                object.bet = [];

                for (var j = 0; j < message.bet.length; ++j) {
                  if (typeof message.bet[j] === "number") object.bet[j] = options.longs === String ? String(message.bet[j]) : message.bet[j];else object.bet[j] = options.longs === String ? $util.Long.prototype.toString.call(message.bet[j]) : options.longs === Number ? new $util.LongBits(message.bet[j].low >>> 0, message.bet[j].high >>> 0).toNumber() : message.bet[j];
                }
              }

              if (message.unit != null && message.hasOwnProperty("unit")) object.unit = options.json && !isFinite(message.unit) ? String(message.unit) : message.unit;
              if (message.ratio != null && message.hasOwnProperty("ratio")) object.ratio = options.json && !isFinite(message.ratio) ? String(message.ratio) : message.ratio;
              if (message.currencySymbol != null && message.hasOwnProperty("currencySymbol")) object.currencySymbol = message.currencySymbol;
              if (message.rate != null && message.hasOwnProperty("rate")) object.rate = options.json && !isFinite(message.rate) ? String(message.rate) : message.rate;
              if (message.cycle != null && message.hasOwnProperty("cycle")) object.cycle = options.json && !isFinite(message.cycle) ? String(message.cycle) : message.cycle;
              if (message.lower != null && message.hasOwnProperty("lower")) if (typeof message.lower === "number") object.lower = options.longs === String ? String(message.lower) : message.lower;else object.lower = options.longs === String ? $util.Long.prototype.toString.call(message.lower) : options.longs === Number ? new $util.LongBits(message.lower.low >>> 0, message.lower.high >>> 0).toNumber() : message.lower;
              if (message.upper != null && message.hasOwnProperty("upper")) if (typeof message.upper === "number") object.upper = options.longs === String ? String(message.upper) : message.upper;else object.upper = options.longs === String ? $util.Long.prototype.toString.call(message.upper) : options.longs === Number ? new $util.LongBits(message.upper.low >>> 0, message.upper.high >>> 0).toNumber() : message.upper;
              if (message.decimal != null && message.hasOwnProperty("decimal")) object.decimal = message.decimal;
              return object;
            };
            /**
            * Converts this Wallet to JSON.
            * @function toJSON
            * @memberof serverProto.Wallet
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            Wallet.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
            * Gets the default type url for Wallet
            * @function getTypeUrl
            * @memberof serverProto.Wallet
            * @static
            * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
            * @returns {string} The default type url
            */


            Wallet.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/serverProto.Wallet";
            };

            return Wallet;
          }();

          serverProto.NoticeReq = function () {
            /**
            * Properties of a NoticeReq.
            * @memberof serverProto
            * @interface INoticeReq
            * @property {string|null} [lang] NoticeReq lang
            * @property {number|null} [currencyNumber] NoticeReq currencyNumber
            */

            /**
            * Constructs a new NoticeReq.
            * @memberof serverProto
            * @classdesc Represents a NoticeReq.
            * @implements INoticeReq
            * @constructor
            * @param {serverProto.INoticeReq=} [properties] Properties to set
            */
            function NoticeReq(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * NoticeReq lang.
            * @member {string} lang
            * @memberof serverProto.NoticeReq
            * @instance
            */


            NoticeReq.prototype.lang = "";
            /**
            * NoticeReq currencyNumber.
            * @member {number} currencyNumber
            * @memberof serverProto.NoticeReq
            * @instance
            */

            NoticeReq.prototype.currencyNumber = 0;
            /**
            * Creates a new NoticeReq instance using the specified properties.
            * @function create
            * @memberof serverProto.NoticeReq
            * @static
            * @param {serverProto.INoticeReq=} [properties] Properties to set
            * @returns {serverProto.NoticeReq} NoticeReq instance
            */

            NoticeReq.create = function create(properties) {
              return new NoticeReq(properties);
            };
            /**
            * Encodes the specified NoticeReq message. Does not implicitly {@link serverProto.NoticeReq.verify|verify} messages.
            * @function encode
            * @memberof serverProto.NoticeReq
            * @static
            * @param {serverProto.INoticeReq} message NoticeReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            NoticeReq.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.lang != null && Object.hasOwnProperty.call(message, "lang")) writer.uint32(
              /* id 1, wireType 2 =*/
              10).string(message.lang);
              if (message.currencyNumber != null && Object.hasOwnProperty.call(message, "currencyNumber")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int32(message.currencyNumber);
              return writer;
            };
            /**
            * Encodes the specified NoticeReq message, length delimited. Does not implicitly {@link serverProto.NoticeReq.verify|verify} messages.
            * @function encodeDelimited
            * @memberof serverProto.NoticeReq
            * @static
            * @param {serverProto.INoticeReq} message NoticeReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            NoticeReq.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a NoticeReq message from the specified reader or buffer.
            * @function decode
            * @memberof serverProto.NoticeReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {serverProto.NoticeReq} NoticeReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            NoticeReq.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.serverProto.NoticeReq();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      message.lang = reader.string();
                      break;
                    }

                  case 2:
                    {
                      message.currencyNumber = reader.int32();
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a NoticeReq message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof serverProto.NoticeReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {serverProto.NoticeReq} NoticeReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            NoticeReq.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a NoticeReq message.
            * @function verify
            * @memberof serverProto.NoticeReq
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            NoticeReq.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.lang != null && message.hasOwnProperty("lang")) if (!$util.isString(message.lang)) return "lang: string expected";
              if (message.currencyNumber != null && message.hasOwnProperty("currencyNumber")) if (!$util.isInteger(message.currencyNumber)) return "currencyNumber: integer expected";
              return null;
            };
            /**
            * Creates a NoticeReq message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof serverProto.NoticeReq
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {serverProto.NoticeReq} NoticeReq
            */


            NoticeReq.fromObject = function fromObject(object) {
              if (object instanceof $root.serverProto.NoticeReq) return object;
              var message = new $root.serverProto.NoticeReq();
              if (object.lang != null) message.lang = String(object.lang);
              if (object.currencyNumber != null) message.currencyNumber = object.currencyNumber | 0;
              return message;
            };
            /**
            * Creates a plain object from a NoticeReq message. Also converts values to other types if specified.
            * @function toObject
            * @memberof serverProto.NoticeReq
            * @static
            * @param {serverProto.NoticeReq} message NoticeReq
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            NoticeReq.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.lang = "";
                object.currencyNumber = 0;
              }

              if (message.lang != null && message.hasOwnProperty("lang")) object.lang = message.lang;
              if (message.currencyNumber != null && message.hasOwnProperty("currencyNumber")) object.currencyNumber = message.currencyNumber;
              return object;
            };
            /**
            * Converts this NoticeReq to JSON.
            * @function toJSON
            * @memberof serverProto.NoticeReq
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            NoticeReq.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
            * Gets the default type url for NoticeReq
            * @function getTypeUrl
            * @memberof serverProto.NoticeReq
            * @static
            * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
            * @returns {string} The default type url
            */


            NoticeReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/serverProto.NoticeReq";
            };

            return NoticeReq;
          }();
          /**
          * NoticeType enum.
          * @name serverProto.NoticeType
          * @enum {number}
          * @property {number} CoinChange=0 CoinChange value
          * @property {number} Message=1 Message value
          * @property {number} EventGift=2 EventGift value
          * @property {number} CustomType=3 CustomType value
          */


          serverProto.NoticeType = function () {
            var valuesById = {},
                values = Object.create(valuesById);
            values[valuesById[0] = "CoinChange"] = 0;
            values[valuesById[1] = "Message"] = 1;
            values[valuesById[2] = "EventGift"] = 2;
            values[valuesById[3] = "CustomType"] = 3;
            return values;
          }();

          serverProto.NoticeInfo = function () {
            /**
            * Properties of a NoticeInfo.
            * @memberof serverProto
            * @interface INoticeInfo
            * @property {serverProto.NoticeType|null} [type] NoticeInfo type
            * @property {number|Long|null} [value] NoticeInfo value
            * @property {string|null} [message] NoticeInfo message
            * @property {Uint8Array|null} [customData] NoticeInfo customData
            * @property {number|null} [currencyNumber] NoticeInfo currencyNumber
            */

            /**
            * Constructs a new NoticeInfo.
            * @memberof serverProto
            * @classdesc Represents a NoticeInfo.
            * @implements INoticeInfo
            * @constructor
            * @param {serverProto.INoticeInfo=} [properties] Properties to set
            */
            function NoticeInfo(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * NoticeInfo type.
            * @member {serverProto.NoticeType} type
            * @memberof serverProto.NoticeInfo
            * @instance
            */


            NoticeInfo.prototype.type = 0;
            /**
            * NoticeInfo value.
            * @member {number|Long} value
            * @memberof serverProto.NoticeInfo
            * @instance
            */

            NoticeInfo.prototype.value = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
            * NoticeInfo message.
            * @member {string} message
            * @memberof serverProto.NoticeInfo
            * @instance
            */

            NoticeInfo.prototype.message = "";
            /**
            * NoticeInfo customData.
            * @member {Uint8Array} customData
            * @memberof serverProto.NoticeInfo
            * @instance
            */

            NoticeInfo.prototype.customData = $util.newBuffer([]);
            /**
            * NoticeInfo currencyNumber.
            * @member {number} currencyNumber
            * @memberof serverProto.NoticeInfo
            * @instance
            */

            NoticeInfo.prototype.currencyNumber = 0;
            /**
            * Creates a new NoticeInfo instance using the specified properties.
            * @function create
            * @memberof serverProto.NoticeInfo
            * @static
            * @param {serverProto.INoticeInfo=} [properties] Properties to set
            * @returns {serverProto.NoticeInfo} NoticeInfo instance
            */

            NoticeInfo.create = function create(properties) {
              return new NoticeInfo(properties);
            };
            /**
            * Encodes the specified NoticeInfo message. Does not implicitly {@link serverProto.NoticeInfo.verify|verify} messages.
            * @function encode
            * @memberof serverProto.NoticeInfo
            * @static
            * @param {serverProto.INoticeInfo} message NoticeInfo message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            NoticeInfo.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.type != null && Object.hasOwnProperty.call(message, "type")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.type);
              if (message.value != null && Object.hasOwnProperty.call(message, "value")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int64(message.value);
              if (message.message != null && Object.hasOwnProperty.call(message, "message")) writer.uint32(
              /* id 3, wireType 2 =*/
              26).string(message.message);
              if (message.customData != null && Object.hasOwnProperty.call(message, "customData")) writer.uint32(
              /* id 4, wireType 2 =*/
              34).bytes(message.customData);
              if (message.currencyNumber != null && Object.hasOwnProperty.call(message, "currencyNumber")) writer.uint32(
              /* id 5, wireType 0 =*/
              40).int32(message.currencyNumber);
              return writer;
            };
            /**
            * Encodes the specified NoticeInfo message, length delimited. Does not implicitly {@link serverProto.NoticeInfo.verify|verify} messages.
            * @function encodeDelimited
            * @memberof serverProto.NoticeInfo
            * @static
            * @param {serverProto.INoticeInfo} message NoticeInfo message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            NoticeInfo.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a NoticeInfo message from the specified reader or buffer.
            * @function decode
            * @memberof serverProto.NoticeInfo
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {serverProto.NoticeInfo} NoticeInfo
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            NoticeInfo.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.serverProto.NoticeInfo();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      message.type = reader.int32();
                      break;
                    }

                  case 2:
                    {
                      message.value = reader.int64();
                      break;
                    }

                  case 3:
                    {
                      message.message = reader.string();
                      break;
                    }

                  case 4:
                    {
                      message.customData = reader.bytes();
                      break;
                    }

                  case 5:
                    {
                      message.currencyNumber = reader.int32();
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a NoticeInfo message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof serverProto.NoticeInfo
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {serverProto.NoticeInfo} NoticeInfo
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            NoticeInfo.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a NoticeInfo message.
            * @function verify
            * @memberof serverProto.NoticeInfo
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            NoticeInfo.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.type != null && message.hasOwnProperty("type")) switch (message.type) {
                default:
                  return "type: enum value expected";

                case 0:
                case 1:
                case 2:
                case 3:
                  break;
              }
              if (message.value != null && message.hasOwnProperty("value")) if (!$util.isInteger(message.value) && !(message.value && $util.isInteger(message.value.low) && $util.isInteger(message.value.high))) return "value: integer|Long expected";
              if (message.message != null && message.hasOwnProperty("message")) if (!$util.isString(message.message)) return "message: string expected";
              if (message.customData != null && message.hasOwnProperty("customData")) if (!(message.customData && typeof message.customData.length === "number" || $util.isString(message.customData))) return "customData: buffer expected";
              if (message.currencyNumber != null && message.hasOwnProperty("currencyNumber")) if (!$util.isInteger(message.currencyNumber)) return "currencyNumber: integer expected";
              return null;
            };
            /**
            * Creates a NoticeInfo message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof serverProto.NoticeInfo
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {serverProto.NoticeInfo} NoticeInfo
            */


            NoticeInfo.fromObject = function fromObject(object) {
              if (object instanceof $root.serverProto.NoticeInfo) return object;
              var message = new $root.serverProto.NoticeInfo();

              switch (object.type) {
                default:
                  if (typeof object.type === "number") {
                    message.type = object.type;
                    break;
                  }

                  break;

                case "CoinChange":
                case 0:
                  message.type = 0;
                  break;

                case "Message":
                case 1:
                  message.type = 1;
                  break;

                case "EventGift":
                case 2:
                  message.type = 2;
                  break;

                case "CustomType":
                case 3:
                  message.type = 3;
                  break;
              }

              if (object.value != null) if ($util.Long) (message.value = $util.Long.fromValue(object.value)).unsigned = false;else if (typeof object.value === "string") message.value = parseInt(object.value, 10);else if (typeof object.value === "number") message.value = object.value;else if (typeof object.value === "object") message.value = new $util.LongBits(object.value.low >>> 0, object.value.high >>> 0).toNumber();
              if (object.message != null) message.message = String(object.message);
              if (object.customData != null) if (typeof object.customData === "string") $util.base64.decode(object.customData, message.customData = $util.newBuffer($util.base64.length(object.customData)), 0);else if (object.customData.length >= 0) message.customData = object.customData;
              if (object.currencyNumber != null) message.currencyNumber = object.currencyNumber | 0;
              return message;
            };
            /**
            * Creates a plain object from a NoticeInfo message. Also converts values to other types if specified.
            * @function toObject
            * @memberof serverProto.NoticeInfo
            * @static
            * @param {serverProto.NoticeInfo} message NoticeInfo
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            NoticeInfo.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.type = options.enums === String ? "CoinChange" : 0;

                if ($util.Long) {
                  var _long4 = new $util.Long(0, 0, false);

                  object.value = options.longs === String ? _long4.toString() : options.longs === Number ? _long4.toNumber() : _long4;
                } else object.value = options.longs === String ? "0" : 0;

                object.message = "";
                if (options.bytes === String) object.customData = "";else {
                  object.customData = [];
                  if (options.bytes !== Array) object.customData = $util.newBuffer(object.customData);
                }
                object.currencyNumber = 0;
              }

              if (message.type != null && message.hasOwnProperty("type")) object.type = options.enums === String ? $root.serverProto.NoticeType[message.type] === undefined ? message.type : $root.serverProto.NoticeType[message.type] : message.type;
              if (message.value != null && message.hasOwnProperty("value")) if (typeof message.value === "number") object.value = options.longs === String ? String(message.value) : message.value;else object.value = options.longs === String ? $util.Long.prototype.toString.call(message.value) : options.longs === Number ? new $util.LongBits(message.value.low >>> 0, message.value.high >>> 0).toNumber() : message.value;
              if (message.message != null && message.hasOwnProperty("message")) object.message = message.message;
              if (message.customData != null && message.hasOwnProperty("customData")) object.customData = options.bytes === String ? $util.base64.encode(message.customData, 0, message.customData.length) : options.bytes === Array ? Array.prototype.slice.call(message.customData) : message.customData;
              if (message.currencyNumber != null && message.hasOwnProperty("currencyNumber")) object.currencyNumber = message.currencyNumber;
              return object;
            };
            /**
            * Converts this NoticeInfo to JSON.
            * @function toJSON
            * @memberof serverProto.NoticeInfo
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            NoticeInfo.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
            * Gets the default type url for NoticeInfo
            * @function getTypeUrl
            * @memberof serverProto.NoticeInfo
            * @static
            * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
            * @returns {string} The default type url
            */


            NoticeInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/serverProto.NoticeInfo";
            };

            return NoticeInfo;
          }();

          serverProto.NoticeResponse = function () {
            /**
            * Properties of a NoticeResponse.
            * @memberof serverProto
            * @interface INoticeResponse
            * @property {Array.<serverProto.INoticeInfo>|null} [notice] NoticeResponse notice
            */

            /**
            * Constructs a new NoticeResponse.
            * @memberof serverProto
            * @classdesc Represents a NoticeResponse.
            * @implements INoticeResponse
            * @constructor
            * @param {serverProto.INoticeResponse=} [properties] Properties to set
            */
            function NoticeResponse(properties) {
              this.notice = [];
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * NoticeResponse notice.
            * @member {Array.<serverProto.INoticeInfo>} notice
            * @memberof serverProto.NoticeResponse
            * @instance
            */


            NoticeResponse.prototype.notice = $util.emptyArray;
            /**
            * Creates a new NoticeResponse instance using the specified properties.
            * @function create
            * @memberof serverProto.NoticeResponse
            * @static
            * @param {serverProto.INoticeResponse=} [properties] Properties to set
            * @returns {serverProto.NoticeResponse} NoticeResponse instance
            */

            NoticeResponse.create = function create(properties) {
              return new NoticeResponse(properties);
            };
            /**
            * Encodes the specified NoticeResponse message. Does not implicitly {@link serverProto.NoticeResponse.verify|verify} messages.
            * @function encode
            * @memberof serverProto.NoticeResponse
            * @static
            * @param {serverProto.INoticeResponse} message NoticeResponse message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            NoticeResponse.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.notice != null && message.notice.length) for (var i = 0; i < message.notice.length; ++i) {
                $root.serverProto.NoticeInfo.encode(message.notice[i], writer.uint32(
                /* id 1, wireType 2 =*/
                10).fork()).ldelim();
              }
              return writer;
            };
            /**
            * Encodes the specified NoticeResponse message, length delimited. Does not implicitly {@link serverProto.NoticeResponse.verify|verify} messages.
            * @function encodeDelimited
            * @memberof serverProto.NoticeResponse
            * @static
            * @param {serverProto.INoticeResponse} message NoticeResponse message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            NoticeResponse.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a NoticeResponse message from the specified reader or buffer.
            * @function decode
            * @memberof serverProto.NoticeResponse
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {serverProto.NoticeResponse} NoticeResponse
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            NoticeResponse.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.serverProto.NoticeResponse();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      if (!(message.notice && message.notice.length)) message.notice = [];
                      message.notice.push($root.serverProto.NoticeInfo.decode(reader, reader.uint32()));
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a NoticeResponse message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof serverProto.NoticeResponse
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {serverProto.NoticeResponse} NoticeResponse
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            NoticeResponse.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a NoticeResponse message.
            * @function verify
            * @memberof serverProto.NoticeResponse
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            NoticeResponse.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";

              if (message.notice != null && message.hasOwnProperty("notice")) {
                if (!Array.isArray(message.notice)) return "notice: array expected";

                for (var i = 0; i < message.notice.length; ++i) {
                  var error = $root.serverProto.NoticeInfo.verify(message.notice[i]);
                  if (error) return "notice." + error;
                }
              }

              return null;
            };
            /**
            * Creates a NoticeResponse message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof serverProto.NoticeResponse
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {serverProto.NoticeResponse} NoticeResponse
            */


            NoticeResponse.fromObject = function fromObject(object) {
              if (object instanceof $root.serverProto.NoticeResponse) return object;
              var message = new $root.serverProto.NoticeResponse();

              if (object.notice) {
                if (!Array.isArray(object.notice)) throw TypeError(".serverProto.NoticeResponse.notice: array expected");
                message.notice = [];

                for (var i = 0; i < object.notice.length; ++i) {
                  if (typeof object.notice[i] !== "object") throw TypeError(".serverProto.NoticeResponse.notice: object expected");
                  message.notice[i] = $root.serverProto.NoticeInfo.fromObject(object.notice[i]);
                }
              }

              return message;
            };
            /**
            * Creates a plain object from a NoticeResponse message. Also converts values to other types if specified.
            * @function toObject
            * @memberof serverProto.NoticeResponse
            * @static
            * @param {serverProto.NoticeResponse} message NoticeResponse
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            NoticeResponse.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};
              if (options.arrays || options.defaults) object.notice = [];

              if (message.notice && message.notice.length) {
                object.notice = [];

                for (var j = 0; j < message.notice.length; ++j) {
                  object.notice[j] = $root.serverProto.NoticeInfo.toObject(message.notice[j], options);
                }
              }

              return object;
            };
            /**
            * Converts this NoticeResponse to JSON.
            * @function toJSON
            * @memberof serverProto.NoticeResponse
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            NoticeResponse.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
            * Gets the default type url for NoticeResponse
            * @function getTypeUrl
            * @memberof serverProto.NoticeResponse
            * @static
            * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
            * @returns {string} The default type url
            */


            NoticeResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/serverProto.NoticeResponse";
            };

            return NoticeResponse;
          }();

          serverProto.Itemdata = function () {
            /**
            * Properties of an Itemdata.
            * @memberof serverProto
            * @interface IItemdata
            * @property {number|null} [itemindex] Itemdata itemindex
            * @property {number|null} [itemid] Itemdata itemid
            * @property {number|null} [amount] Itemdata amount
            * @property {number|null} [gameid] Itemdata gameid
            * @property {number|null} [lvmin] Itemdata lvmin
            * @property {number|null} [lvmax] Itemdata lvmax
            * @property {number|null} [coinlimit] Itemdata coinlimit
            * @property {number|null} [dailyremaintimes] Itemdata dailyremaintimes
            * @property {string|null} [startTime] Itemdata startTime
            * @property {string|null} [expiredtime] Itemdata expiredtime
            * @property {number|null} [bet] Itemdata bet
            * @property {number|null} [spinpaytype] Itemdata spinpaytype
            * @property {number|null} [givetype] Itemdata givetype
            * @property {number|null} [wintype] Itemdata wintype
            * @property {number|null} [winmultiplier] Itemdata winmultiplier
            * @property {number|null} [winmaxmag] Itemdata winmaxmag
            * @property {number|null} [winmagset] Itemdata winmagset
            * @property {number|null} [itemvalue] Itemdata itemvalue
            * @property {string|null} [itemname] Itemdata itemname
            * @property {number|null} [icon] Itemdata icon
            * @property {number|null} [banreason] Itemdata banreason
            * @property {string|null} [itemdesc] Itemdata itemdesc
            * @property {number|null} [star] Itemdata star
            * @property {string|null} [gamename] Itemdata gamename
            * @property {number|null} [currencynumber] Itemdata currencynumber
            * @property {number|null} [source] Itemdata source
            * @property {number|null} [playvalue] Itemdata playvalue
            * @property {number|Long|null} [start] Itemdata start
            * @property {number|Long|null} [expired] Itemdata expired
            */

            /**
            * Constructs a new Itemdata.
            * @memberof serverProto
            * @classdesc Represents an Itemdata.
            * @implements IItemdata
            * @constructor
            * @param {serverProto.IItemdata=} [properties] Properties to set
            */
            function Itemdata(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * Itemdata itemindex.
            * @member {number} itemindex
            * @memberof serverProto.Itemdata
            * @instance
            */


            Itemdata.prototype.itemindex = 0;
            /**
            * Itemdata itemid.
            * @member {number} itemid
            * @memberof serverProto.Itemdata
            * @instance
            */

            Itemdata.prototype.itemid = 0;
            /**
            * Itemdata amount.
            * @member {number} amount
            * @memberof serverProto.Itemdata
            * @instance
            */

            Itemdata.prototype.amount = 0;
            /**
            * Itemdata gameid.
            * @member {number} gameid
            * @memberof serverProto.Itemdata
            * @instance
            */

            Itemdata.prototype.gameid = 0;
            /**
            * Itemdata lvmin.
            * @member {number} lvmin
            * @memberof serverProto.Itemdata
            * @instance
            */

            Itemdata.prototype.lvmin = 0;
            /**
            * Itemdata lvmax.
            * @member {number} lvmax
            * @memberof serverProto.Itemdata
            * @instance
            */

            Itemdata.prototype.lvmax = 0;
            /**
            * Itemdata coinlimit.
            * @member {number} coinlimit
            * @memberof serverProto.Itemdata
            * @instance
            */

            Itemdata.prototype.coinlimit = 0;
            /**
            * Itemdata dailyremaintimes.
            * @member {number} dailyremaintimes
            * @memberof serverProto.Itemdata
            * @instance
            */

            Itemdata.prototype.dailyremaintimes = 0;
            /**
            * Itemdata startTime.
            * @member {string} startTime
            * @memberof serverProto.Itemdata
            * @instance
            */

            Itemdata.prototype.startTime = "";
            /**
            * Itemdata expiredtime.
            * @member {string} expiredtime
            * @memberof serverProto.Itemdata
            * @instance
            */

            Itemdata.prototype.expiredtime = "";
            /**
            * Itemdata bet.
            * @member {number} bet
            * @memberof serverProto.Itemdata
            * @instance
            */

            Itemdata.prototype.bet = 0;
            /**
            * Itemdata spinpaytype.
            * @member {number} spinpaytype
            * @memberof serverProto.Itemdata
            * @instance
            */

            Itemdata.prototype.spinpaytype = 0;
            /**
            * Itemdata givetype.
            * @member {number} givetype
            * @memberof serverProto.Itemdata
            * @instance
            */

            Itemdata.prototype.givetype = 0;
            /**
            * Itemdata wintype.
            * @member {number} wintype
            * @memberof serverProto.Itemdata
            * @instance
            */

            Itemdata.prototype.wintype = 0;
            /**
            * Itemdata winmultiplier.
            * @member {number} winmultiplier
            * @memberof serverProto.Itemdata
            * @instance
            */

            Itemdata.prototype.winmultiplier = 0;
            /**
            * Itemdata winmaxmag.
            * @member {number} winmaxmag
            * @memberof serverProto.Itemdata
            * @instance
            */

            Itemdata.prototype.winmaxmag = 0;
            /**
            * Itemdata winmagset.
            * @member {number} winmagset
            * @memberof serverProto.Itemdata
            * @instance
            */

            Itemdata.prototype.winmagset = 0;
            /**
            * Itemdata itemvalue.
            * @member {number} itemvalue
            * @memberof serverProto.Itemdata
            * @instance
            */

            Itemdata.prototype.itemvalue = 0;
            /**
            * Itemdata itemname.
            * @member {string} itemname
            * @memberof serverProto.Itemdata
            * @instance
            */

            Itemdata.prototype.itemname = "";
            /**
            * Itemdata icon.
            * @member {number} icon
            * @memberof serverProto.Itemdata
            * @instance
            */

            Itemdata.prototype.icon = 0;
            /**
            * Itemdata banreason.
            * @member {number} banreason
            * @memberof serverProto.Itemdata
            * @instance
            */

            Itemdata.prototype.banreason = 0;
            /**
            * Itemdata itemdesc.
            * @member {string} itemdesc
            * @memberof serverProto.Itemdata
            * @instance
            */

            Itemdata.prototype.itemdesc = "";
            /**
            * Itemdata star.
            * @member {number} star
            * @memberof serverProto.Itemdata
            * @instance
            */

            Itemdata.prototype.star = 0;
            /**
            * Itemdata gamename.
            * @member {string} gamename
            * @memberof serverProto.Itemdata
            * @instance
            */

            Itemdata.prototype.gamename = "";
            /**
            * Itemdata currencynumber.
            * @member {number} currencynumber
            * @memberof serverProto.Itemdata
            * @instance
            */

            Itemdata.prototype.currencynumber = 0;
            /**
            * Itemdata source.
            * @member {number} source
            * @memberof serverProto.Itemdata
            * @instance
            */

            Itemdata.prototype.source = 0;
            /**
            * Itemdata playvalue.
            * @member {number} playvalue
            * @memberof serverProto.Itemdata
            * @instance
            */

            Itemdata.prototype.playvalue = 0;
            /**
            * Itemdata start.
            * @member {number|Long} start
            * @memberof serverProto.Itemdata
            * @instance
            */

            Itemdata.prototype.start = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
            * Itemdata expired.
            * @member {number|Long} expired
            * @memberof serverProto.Itemdata
            * @instance
            */

            Itemdata.prototype.expired = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
            * Creates a new Itemdata instance using the specified properties.
            * @function create
            * @memberof serverProto.Itemdata
            * @static
            * @param {serverProto.IItemdata=} [properties] Properties to set
            * @returns {serverProto.Itemdata} Itemdata instance
            */

            Itemdata.create = function create(properties) {
              return new Itemdata(properties);
            };
            /**
            * Encodes the specified Itemdata message. Does not implicitly {@link serverProto.Itemdata.verify|verify} messages.
            * @function encode
            * @memberof serverProto.Itemdata
            * @static
            * @param {serverProto.IItemdata} message Itemdata message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            Itemdata.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.itemindex != null && Object.hasOwnProperty.call(message, "itemindex")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.itemindex);
              if (message.itemid != null && Object.hasOwnProperty.call(message, "itemid")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int32(message.itemid);
              if (message.amount != null && Object.hasOwnProperty.call(message, "amount")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.amount);
              if (message.gameid != null && Object.hasOwnProperty.call(message, "gameid")) writer.uint32(
              /* id 4, wireType 0 =*/
              32).int32(message.gameid);
              if (message.lvmin != null && Object.hasOwnProperty.call(message, "lvmin")) writer.uint32(
              /* id 5, wireType 0 =*/
              40).int32(message.lvmin);
              if (message.lvmax != null && Object.hasOwnProperty.call(message, "lvmax")) writer.uint32(
              /* id 6, wireType 0 =*/
              48).int32(message.lvmax);
              if (message.coinlimit != null && Object.hasOwnProperty.call(message, "coinlimit")) writer.uint32(
              /* id 7, wireType 1 =*/
              57)["double"](message.coinlimit);
              if (message.dailyremaintimes != null && Object.hasOwnProperty.call(message, "dailyremaintimes")) writer.uint32(
              /* id 8, wireType 0 =*/
              64).int32(message.dailyremaintimes);
              if (message.startTime != null && Object.hasOwnProperty.call(message, "startTime")) writer.uint32(
              /* id 9, wireType 2 =*/
              74).string(message.startTime);
              if (message.expiredtime != null && Object.hasOwnProperty.call(message, "expiredtime")) writer.uint32(
              /* id 10, wireType 2 =*/
              82).string(message.expiredtime);
              if (message.bet != null && Object.hasOwnProperty.call(message, "bet")) writer.uint32(
              /* id 11, wireType 1 =*/
              89)["double"](message.bet);
              if (message.spinpaytype != null && Object.hasOwnProperty.call(message, "spinpaytype")) writer.uint32(
              /* id 12, wireType 0 =*/
              96).int32(message.spinpaytype);
              if (message.givetype != null && Object.hasOwnProperty.call(message, "givetype")) writer.uint32(
              /* id 13, wireType 1 =*/
              105)["double"](message.givetype);
              if (message.wintype != null && Object.hasOwnProperty.call(message, "wintype")) writer.uint32(
              /* id 14, wireType 0 =*/
              112).int32(message.wintype);
              if (message.winmultiplier != null && Object.hasOwnProperty.call(message, "winmultiplier")) writer.uint32(
              /* id 15, wireType 1 =*/
              121)["double"](message.winmultiplier);
              if (message.winmaxmag != null && Object.hasOwnProperty.call(message, "winmaxmag")) writer.uint32(
              /* id 16, wireType 1 =*/
              129)["double"](message.winmaxmag);
              if (message.winmagset != null && Object.hasOwnProperty.call(message, "winmagset")) writer.uint32(
              /* id 17, wireType 0 =*/
              136).int32(message.winmagset);
              if (message.itemvalue != null && Object.hasOwnProperty.call(message, "itemvalue")) writer.uint32(
              /* id 18, wireType 1 =*/
              145)["double"](message.itemvalue);
              if (message.itemname != null && Object.hasOwnProperty.call(message, "itemname")) writer.uint32(
              /* id 19, wireType 2 =*/
              154).string(message.itemname);
              if (message.icon != null && Object.hasOwnProperty.call(message, "icon")) writer.uint32(
              /* id 20, wireType 0 =*/
              160).int32(message.icon);
              if (message.banreason != null && Object.hasOwnProperty.call(message, "banreason")) writer.uint32(
              /* id 21, wireType 0 =*/
              168).int32(message.banreason);
              if (message.itemdesc != null && Object.hasOwnProperty.call(message, "itemdesc")) writer.uint32(
              /* id 22, wireType 2 =*/
              178).string(message.itemdesc);
              if (message.star != null && Object.hasOwnProperty.call(message, "star")) writer.uint32(
              /* id 23, wireType 0 =*/
              184).int32(message.star);
              if (message.gamename != null && Object.hasOwnProperty.call(message, "gamename")) writer.uint32(
              /* id 24, wireType 2 =*/
              194).string(message.gamename);
              if (message.currencynumber != null && Object.hasOwnProperty.call(message, "currencynumber")) writer.uint32(
              /* id 25, wireType 0 =*/
              200).int32(message.currencynumber);
              if (message.source != null && Object.hasOwnProperty.call(message, "source")) writer.uint32(
              /* id 26, wireType 0 =*/
              208).int32(message.source);
              if (message.playvalue != null && Object.hasOwnProperty.call(message, "playvalue")) writer.uint32(
              /* id 27, wireType 1 =*/
              217)["double"](message.playvalue);
              if (message.start != null && Object.hasOwnProperty.call(message, "start")) writer.uint32(
              /* id 28, wireType 0 =*/
              224).int64(message.start);
              if (message.expired != null && Object.hasOwnProperty.call(message, "expired")) writer.uint32(
              /* id 29, wireType 0 =*/
              232).int64(message.expired);
              return writer;
            };
            /**
            * Encodes the specified Itemdata message, length delimited. Does not implicitly {@link serverProto.Itemdata.verify|verify} messages.
            * @function encodeDelimited
            * @memberof serverProto.Itemdata
            * @static
            * @param {serverProto.IItemdata} message Itemdata message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            Itemdata.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes an Itemdata message from the specified reader or buffer.
            * @function decode
            * @memberof serverProto.Itemdata
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {serverProto.Itemdata} Itemdata
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            Itemdata.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.serverProto.Itemdata();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      message.itemindex = reader.int32();
                      break;
                    }

                  case 2:
                    {
                      message.itemid = reader.int32();
                      break;
                    }

                  case 3:
                    {
                      message.amount = reader.int32();
                      break;
                    }

                  case 4:
                    {
                      message.gameid = reader.int32();
                      break;
                    }

                  case 5:
                    {
                      message.lvmin = reader.int32();
                      break;
                    }

                  case 6:
                    {
                      message.lvmax = reader.int32();
                      break;
                    }

                  case 7:
                    {
                      message.coinlimit = reader["double"]();
                      break;
                    }

                  case 8:
                    {
                      message.dailyremaintimes = reader.int32();
                      break;
                    }

                  case 9:
                    {
                      message.startTime = reader.string();
                      break;
                    }

                  case 10:
                    {
                      message.expiredtime = reader.string();
                      break;
                    }

                  case 11:
                    {
                      message.bet = reader["double"]();
                      break;
                    }

                  case 12:
                    {
                      message.spinpaytype = reader.int32();
                      break;
                    }

                  case 13:
                    {
                      message.givetype = reader["double"]();
                      break;
                    }

                  case 14:
                    {
                      message.wintype = reader.int32();
                      break;
                    }

                  case 15:
                    {
                      message.winmultiplier = reader["double"]();
                      break;
                    }

                  case 16:
                    {
                      message.winmaxmag = reader["double"]();
                      break;
                    }

                  case 17:
                    {
                      message.winmagset = reader.int32();
                      break;
                    }

                  case 18:
                    {
                      message.itemvalue = reader["double"]();
                      break;
                    }

                  case 19:
                    {
                      message.itemname = reader.string();
                      break;
                    }

                  case 20:
                    {
                      message.icon = reader.int32();
                      break;
                    }

                  case 21:
                    {
                      message.banreason = reader.int32();
                      break;
                    }

                  case 22:
                    {
                      message.itemdesc = reader.string();
                      break;
                    }

                  case 23:
                    {
                      message.star = reader.int32();
                      break;
                    }

                  case 24:
                    {
                      message.gamename = reader.string();
                      break;
                    }

                  case 25:
                    {
                      message.currencynumber = reader.int32();
                      break;
                    }

                  case 26:
                    {
                      message.source = reader.int32();
                      break;
                    }

                  case 27:
                    {
                      message.playvalue = reader["double"]();
                      break;
                    }

                  case 28:
                    {
                      message.start = reader.int64();
                      break;
                    }

                  case 29:
                    {
                      message.expired = reader.int64();
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes an Itemdata message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof serverProto.Itemdata
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {serverProto.Itemdata} Itemdata
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            Itemdata.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies an Itemdata message.
            * @function verify
            * @memberof serverProto.Itemdata
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            Itemdata.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.itemindex != null && message.hasOwnProperty("itemindex")) if (!$util.isInteger(message.itemindex)) return "itemindex: integer expected";
              if (message.itemid != null && message.hasOwnProperty("itemid")) if (!$util.isInteger(message.itemid)) return "itemid: integer expected";
              if (message.amount != null && message.hasOwnProperty("amount")) if (!$util.isInteger(message.amount)) return "amount: integer expected";
              if (message.gameid != null && message.hasOwnProperty("gameid")) if (!$util.isInteger(message.gameid)) return "gameid: integer expected";
              if (message.lvmin != null && message.hasOwnProperty("lvmin")) if (!$util.isInteger(message.lvmin)) return "lvmin: integer expected";
              if (message.lvmax != null && message.hasOwnProperty("lvmax")) if (!$util.isInteger(message.lvmax)) return "lvmax: integer expected";
              if (message.coinlimit != null && message.hasOwnProperty("coinlimit")) if (typeof message.coinlimit !== "number") return "coinlimit: number expected";
              if (message.dailyremaintimes != null && message.hasOwnProperty("dailyremaintimes")) if (!$util.isInteger(message.dailyremaintimes)) return "dailyremaintimes: integer expected";
              if (message.startTime != null && message.hasOwnProperty("startTime")) if (!$util.isString(message.startTime)) return "startTime: string expected";
              if (message.expiredtime != null && message.hasOwnProperty("expiredtime")) if (!$util.isString(message.expiredtime)) return "expiredtime: string expected";
              if (message.bet != null && message.hasOwnProperty("bet")) if (typeof message.bet !== "number") return "bet: number expected";
              if (message.spinpaytype != null && message.hasOwnProperty("spinpaytype")) if (!$util.isInteger(message.spinpaytype)) return "spinpaytype: integer expected";
              if (message.givetype != null && message.hasOwnProperty("givetype")) if (typeof message.givetype !== "number") return "givetype: number expected";
              if (message.wintype != null && message.hasOwnProperty("wintype")) if (!$util.isInteger(message.wintype)) return "wintype: integer expected";
              if (message.winmultiplier != null && message.hasOwnProperty("winmultiplier")) if (typeof message.winmultiplier !== "number") return "winmultiplier: number expected";
              if (message.winmaxmag != null && message.hasOwnProperty("winmaxmag")) if (typeof message.winmaxmag !== "number") return "winmaxmag: number expected";
              if (message.winmagset != null && message.hasOwnProperty("winmagset")) if (!$util.isInteger(message.winmagset)) return "winmagset: integer expected";
              if (message.itemvalue != null && message.hasOwnProperty("itemvalue")) if (typeof message.itemvalue !== "number") return "itemvalue: number expected";
              if (message.itemname != null && message.hasOwnProperty("itemname")) if (!$util.isString(message.itemname)) return "itemname: string expected";
              if (message.icon != null && message.hasOwnProperty("icon")) if (!$util.isInteger(message.icon)) return "icon: integer expected";
              if (message.banreason != null && message.hasOwnProperty("banreason")) if (!$util.isInteger(message.banreason)) return "banreason: integer expected";
              if (message.itemdesc != null && message.hasOwnProperty("itemdesc")) if (!$util.isString(message.itemdesc)) return "itemdesc: string expected";
              if (message.star != null && message.hasOwnProperty("star")) if (!$util.isInteger(message.star)) return "star: integer expected";
              if (message.gamename != null && message.hasOwnProperty("gamename")) if (!$util.isString(message.gamename)) return "gamename: string expected";
              if (message.currencynumber != null && message.hasOwnProperty("currencynumber")) if (!$util.isInteger(message.currencynumber)) return "currencynumber: integer expected";
              if (message.source != null && message.hasOwnProperty("source")) if (!$util.isInteger(message.source)) return "source: integer expected";
              if (message.playvalue != null && message.hasOwnProperty("playvalue")) if (typeof message.playvalue !== "number") return "playvalue: number expected";
              if (message.start != null && message.hasOwnProperty("start")) if (!$util.isInteger(message.start) && !(message.start && $util.isInteger(message.start.low) && $util.isInteger(message.start.high))) return "start: integer|Long expected";
              if (message.expired != null && message.hasOwnProperty("expired")) if (!$util.isInteger(message.expired) && !(message.expired && $util.isInteger(message.expired.low) && $util.isInteger(message.expired.high))) return "expired: integer|Long expected";
              return null;
            };
            /**
            * Creates an Itemdata message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof serverProto.Itemdata
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {serverProto.Itemdata} Itemdata
            */


            Itemdata.fromObject = function fromObject(object) {
              if (object instanceof $root.serverProto.Itemdata) return object;
              var message = new $root.serverProto.Itemdata();
              if (object.itemindex != null) message.itemindex = object.itemindex | 0;
              if (object.itemid != null) message.itemid = object.itemid | 0;
              if (object.amount != null) message.amount = object.amount | 0;
              if (object.gameid != null) message.gameid = object.gameid | 0;
              if (object.lvmin != null) message.lvmin = object.lvmin | 0;
              if (object.lvmax != null) message.lvmax = object.lvmax | 0;
              if (object.coinlimit != null) message.coinlimit = Number(object.coinlimit);
              if (object.dailyremaintimes != null) message.dailyremaintimes = object.dailyremaintimes | 0;
              if (object.startTime != null) message.startTime = String(object.startTime);
              if (object.expiredtime != null) message.expiredtime = String(object.expiredtime);
              if (object.bet != null) message.bet = Number(object.bet);
              if (object.spinpaytype != null) message.spinpaytype = object.spinpaytype | 0;
              if (object.givetype != null) message.givetype = Number(object.givetype);
              if (object.wintype != null) message.wintype = object.wintype | 0;
              if (object.winmultiplier != null) message.winmultiplier = Number(object.winmultiplier);
              if (object.winmaxmag != null) message.winmaxmag = Number(object.winmaxmag);
              if (object.winmagset != null) message.winmagset = object.winmagset | 0;
              if (object.itemvalue != null) message.itemvalue = Number(object.itemvalue);
              if (object.itemname != null) message.itemname = String(object.itemname);
              if (object.icon != null) message.icon = object.icon | 0;
              if (object.banreason != null) message.banreason = object.banreason | 0;
              if (object.itemdesc != null) message.itemdesc = String(object.itemdesc);
              if (object.star != null) message.star = object.star | 0;
              if (object.gamename != null) message.gamename = String(object.gamename);
              if (object.currencynumber != null) message.currencynumber = object.currencynumber | 0;
              if (object.source != null) message.source = object.source | 0;
              if (object.playvalue != null) message.playvalue = Number(object.playvalue);
              if (object.start != null) if ($util.Long) (message.start = $util.Long.fromValue(object.start)).unsigned = false;else if (typeof object.start === "string") message.start = parseInt(object.start, 10);else if (typeof object.start === "number") message.start = object.start;else if (typeof object.start === "object") message.start = new $util.LongBits(object.start.low >>> 0, object.start.high >>> 0).toNumber();
              if (object.expired != null) if ($util.Long) (message.expired = $util.Long.fromValue(object.expired)).unsigned = false;else if (typeof object.expired === "string") message.expired = parseInt(object.expired, 10);else if (typeof object.expired === "number") message.expired = object.expired;else if (typeof object.expired === "object") message.expired = new $util.LongBits(object.expired.low >>> 0, object.expired.high >>> 0).toNumber();
              return message;
            };
            /**
            * Creates a plain object from an Itemdata message. Also converts values to other types if specified.
            * @function toObject
            * @memberof serverProto.Itemdata
            * @static
            * @param {serverProto.Itemdata} message Itemdata
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            Itemdata.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.itemindex = 0;
                object.itemid = 0;
                object.amount = 0;
                object.gameid = 0;
                object.lvmin = 0;
                object.lvmax = 0;
                object.coinlimit = 0;
                object.dailyremaintimes = 0;
                object.startTime = "";
                object.expiredtime = "";
                object.bet = 0;
                object.spinpaytype = 0;
                object.givetype = 0;
                object.wintype = 0;
                object.winmultiplier = 0;
                object.winmaxmag = 0;
                object.winmagset = 0;
                object.itemvalue = 0;
                object.itemname = "";
                object.icon = 0;
                object.banreason = 0;
                object.itemdesc = "";
                object.star = 0;
                object.gamename = "";
                object.currencynumber = 0;
                object.source = 0;
                object.playvalue = 0;

                if ($util.Long) {
                  var _long5 = new $util.Long(0, 0, false);

                  object.start = options.longs === String ? _long5.toString() : options.longs === Number ? _long5.toNumber() : _long5;
                } else object.start = options.longs === String ? "0" : 0;

                if ($util.Long) {
                  var _long5 = new $util.Long(0, 0, false);

                  object.expired = options.longs === String ? _long5.toString() : options.longs === Number ? _long5.toNumber() : _long5;
                } else object.expired = options.longs === String ? "0" : 0;
              }

              if (message.itemindex != null && message.hasOwnProperty("itemindex")) object.itemindex = message.itemindex;
              if (message.itemid != null && message.hasOwnProperty("itemid")) object.itemid = message.itemid;
              if (message.amount != null && message.hasOwnProperty("amount")) object.amount = message.amount;
              if (message.gameid != null && message.hasOwnProperty("gameid")) object.gameid = message.gameid;
              if (message.lvmin != null && message.hasOwnProperty("lvmin")) object.lvmin = message.lvmin;
              if (message.lvmax != null && message.hasOwnProperty("lvmax")) object.lvmax = message.lvmax;
              if (message.coinlimit != null && message.hasOwnProperty("coinlimit")) object.coinlimit = options.json && !isFinite(message.coinlimit) ? String(message.coinlimit) : message.coinlimit;
              if (message.dailyremaintimes != null && message.hasOwnProperty("dailyremaintimes")) object.dailyremaintimes = message.dailyremaintimes;
              if (message.startTime != null && message.hasOwnProperty("startTime")) object.startTime = message.startTime;
              if (message.expiredtime != null && message.hasOwnProperty("expiredtime")) object.expiredtime = message.expiredtime;
              if (message.bet != null && message.hasOwnProperty("bet")) object.bet = options.json && !isFinite(message.bet) ? String(message.bet) : message.bet;
              if (message.spinpaytype != null && message.hasOwnProperty("spinpaytype")) object.spinpaytype = message.spinpaytype;
              if (message.givetype != null && message.hasOwnProperty("givetype")) object.givetype = options.json && !isFinite(message.givetype) ? String(message.givetype) : message.givetype;
              if (message.wintype != null && message.hasOwnProperty("wintype")) object.wintype = message.wintype;
              if (message.winmultiplier != null && message.hasOwnProperty("winmultiplier")) object.winmultiplier = options.json && !isFinite(message.winmultiplier) ? String(message.winmultiplier) : message.winmultiplier;
              if (message.winmaxmag != null && message.hasOwnProperty("winmaxmag")) object.winmaxmag = options.json && !isFinite(message.winmaxmag) ? String(message.winmaxmag) : message.winmaxmag;
              if (message.winmagset != null && message.hasOwnProperty("winmagset")) object.winmagset = message.winmagset;
              if (message.itemvalue != null && message.hasOwnProperty("itemvalue")) object.itemvalue = options.json && !isFinite(message.itemvalue) ? String(message.itemvalue) : message.itemvalue;
              if (message.itemname != null && message.hasOwnProperty("itemname")) object.itemname = message.itemname;
              if (message.icon != null && message.hasOwnProperty("icon")) object.icon = message.icon;
              if (message.banreason != null && message.hasOwnProperty("banreason")) object.banreason = message.banreason;
              if (message.itemdesc != null && message.hasOwnProperty("itemdesc")) object.itemdesc = message.itemdesc;
              if (message.star != null && message.hasOwnProperty("star")) object.star = message.star;
              if (message.gamename != null && message.hasOwnProperty("gamename")) object.gamename = message.gamename;
              if (message.currencynumber != null && message.hasOwnProperty("currencynumber")) object.currencynumber = message.currencynumber;
              if (message.source != null && message.hasOwnProperty("source")) object.source = message.source;
              if (message.playvalue != null && message.hasOwnProperty("playvalue")) object.playvalue = options.json && !isFinite(message.playvalue) ? String(message.playvalue) : message.playvalue;
              if (message.start != null && message.hasOwnProperty("start")) if (typeof message.start === "number") object.start = options.longs === String ? String(message.start) : message.start;else object.start = options.longs === String ? $util.Long.prototype.toString.call(message.start) : options.longs === Number ? new $util.LongBits(message.start.low >>> 0, message.start.high >>> 0).toNumber() : message.start;
              if (message.expired != null && message.hasOwnProperty("expired")) if (typeof message.expired === "number") object.expired = options.longs === String ? String(message.expired) : message.expired;else object.expired = options.longs === String ? $util.Long.prototype.toString.call(message.expired) : options.longs === Number ? new $util.LongBits(message.expired.low >>> 0, message.expired.high >>> 0).toNumber() : message.expired;
              return object;
            };
            /**
            * Converts this Itemdata to JSON.
            * @function toJSON
            * @memberof serverProto.Itemdata
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            Itemdata.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
            * Gets the default type url for Itemdata
            * @function getTypeUrl
            * @memberof serverProto.Itemdata
            * @static
            * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
            * @returns {string} The default type url
            */


            Itemdata.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/serverProto.Itemdata";
            };

            return Itemdata;
          }();

          serverProto.BackPackInfo = function () {
            /**
            * Properties of a BackPackInfo.
            * @memberof serverProto
            * @interface IBackPackInfo
            * @property {number|null} [result] BackPackInfo result
            * @property {Array.<serverProto.IItemdata>|null} [playeritemdata] BackPackInfo playeritemdata
            */

            /**
            * Constructs a new BackPackInfo.
            * @memberof serverProto
            * @classdesc Represents a BackPackInfo.
            * @implements IBackPackInfo
            * @constructor
            * @param {serverProto.IBackPackInfo=} [properties] Properties to set
            */
            function BackPackInfo(properties) {
              this.playeritemdata = [];
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * BackPackInfo result.
            * @member {number} result
            * @memberof serverProto.BackPackInfo
            * @instance
            */


            BackPackInfo.prototype.result = 0;
            /**
            * BackPackInfo playeritemdata.
            * @member {Array.<serverProto.IItemdata>} playeritemdata
            * @memberof serverProto.BackPackInfo
            * @instance
            */

            BackPackInfo.prototype.playeritemdata = $util.emptyArray;
            /**
            * Creates a new BackPackInfo instance using the specified properties.
            * @function create
            * @memberof serverProto.BackPackInfo
            * @static
            * @param {serverProto.IBackPackInfo=} [properties] Properties to set
            * @returns {serverProto.BackPackInfo} BackPackInfo instance
            */

            BackPackInfo.create = function create(properties) {
              return new BackPackInfo(properties);
            };
            /**
            * Encodes the specified BackPackInfo message. Does not implicitly {@link serverProto.BackPackInfo.verify|verify} messages.
            * @function encode
            * @memberof serverProto.BackPackInfo
            * @static
            * @param {serverProto.IBackPackInfo} message BackPackInfo message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            BackPackInfo.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.result != null && Object.hasOwnProperty.call(message, "result")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.result);
              if (message.playeritemdata != null && message.playeritemdata.length) for (var i = 0; i < message.playeritemdata.length; ++i) {
                $root.serverProto.Itemdata.encode(message.playeritemdata[i], writer.uint32(
                /* id 2, wireType 2 =*/
                18).fork()).ldelim();
              }
              return writer;
            };
            /**
            * Encodes the specified BackPackInfo message, length delimited. Does not implicitly {@link serverProto.BackPackInfo.verify|verify} messages.
            * @function encodeDelimited
            * @memberof serverProto.BackPackInfo
            * @static
            * @param {serverProto.IBackPackInfo} message BackPackInfo message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            BackPackInfo.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a BackPackInfo message from the specified reader or buffer.
            * @function decode
            * @memberof serverProto.BackPackInfo
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {serverProto.BackPackInfo} BackPackInfo
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            BackPackInfo.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.serverProto.BackPackInfo();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      message.result = reader.int32();
                      break;
                    }

                  case 2:
                    {
                      if (!(message.playeritemdata && message.playeritemdata.length)) message.playeritemdata = [];
                      message.playeritemdata.push($root.serverProto.Itemdata.decode(reader, reader.uint32()));
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a BackPackInfo message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof serverProto.BackPackInfo
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {serverProto.BackPackInfo} BackPackInfo
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            BackPackInfo.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a BackPackInfo message.
            * @function verify
            * @memberof serverProto.BackPackInfo
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            BackPackInfo.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.result != null && message.hasOwnProperty("result")) if (!$util.isInteger(message.result)) return "result: integer expected";

              if (message.playeritemdata != null && message.hasOwnProperty("playeritemdata")) {
                if (!Array.isArray(message.playeritemdata)) return "playeritemdata: array expected";

                for (var i = 0; i < message.playeritemdata.length; ++i) {
                  var error = $root.serverProto.Itemdata.verify(message.playeritemdata[i]);
                  if (error) return "playeritemdata." + error;
                }
              }

              return null;
            };
            /**
            * Creates a BackPackInfo message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof serverProto.BackPackInfo
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {serverProto.BackPackInfo} BackPackInfo
            */


            BackPackInfo.fromObject = function fromObject(object) {
              if (object instanceof $root.serverProto.BackPackInfo) return object;
              var message = new $root.serverProto.BackPackInfo();
              if (object.result != null) message.result = object.result | 0;

              if (object.playeritemdata) {
                if (!Array.isArray(object.playeritemdata)) throw TypeError(".serverProto.BackPackInfo.playeritemdata: array expected");
                message.playeritemdata = [];

                for (var i = 0; i < object.playeritemdata.length; ++i) {
                  if (typeof object.playeritemdata[i] !== "object") throw TypeError(".serverProto.BackPackInfo.playeritemdata: object expected");
                  message.playeritemdata[i] = $root.serverProto.Itemdata.fromObject(object.playeritemdata[i]);
                }
              }

              return message;
            };
            /**
            * Creates a plain object from a BackPackInfo message. Also converts values to other types if specified.
            * @function toObject
            * @memberof serverProto.BackPackInfo
            * @static
            * @param {serverProto.BackPackInfo} message BackPackInfo
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            BackPackInfo.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};
              if (options.arrays || options.defaults) object.playeritemdata = [];
              if (options.defaults) object.result = 0;
              if (message.result != null && message.hasOwnProperty("result")) object.result = message.result;

              if (message.playeritemdata && message.playeritemdata.length) {
                object.playeritemdata = [];

                for (var j = 0; j < message.playeritemdata.length; ++j) {
                  object.playeritemdata[j] = $root.serverProto.Itemdata.toObject(message.playeritemdata[j], options);
                }
              }

              return object;
            };
            /**
            * Converts this BackPackInfo to JSON.
            * @function toJSON
            * @memberof serverProto.BackPackInfo
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            BackPackInfo.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
            * Gets the default type url for BackPackInfo
            * @function getTypeUrl
            * @memberof serverProto.BackPackInfo
            * @static
            * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
            * @returns {string} The default type url
            */


            BackPackInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/serverProto.BackPackInfo";
            };

            return BackPackInfo;
          }();

          serverProto.BackPack = function () {
            /**
            * Properties of a BackPack.
            * @memberof serverProto
            * @interface IBackPack
            * @property {serverProto.IBackPackInfo|null} [info] BackPack info
            * @property {number|null} [ret] BackPack ret
            */

            /**
            * Constructs a new BackPack.
            * @memberof serverProto
            * @classdesc Represents a BackPack.
            * @implements IBackPack
            * @constructor
            * @param {serverProto.IBackPack=} [properties] Properties to set
            */
            function BackPack(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * BackPack info.
            * @member {serverProto.IBackPackInfo|null|undefined} info
            * @memberof serverProto.BackPack
            * @instance
            */


            BackPack.prototype.info = null;
            /**
            * BackPack ret.
            * @member {number} ret
            * @memberof serverProto.BackPack
            * @instance
            */

            BackPack.prototype.ret = 0;
            /**
            * Creates a new BackPack instance using the specified properties.
            * @function create
            * @memberof serverProto.BackPack
            * @static
            * @param {serverProto.IBackPack=} [properties] Properties to set
            * @returns {serverProto.BackPack} BackPack instance
            */

            BackPack.create = function create(properties) {
              return new BackPack(properties);
            };
            /**
            * Encodes the specified BackPack message. Does not implicitly {@link serverProto.BackPack.verify|verify} messages.
            * @function encode
            * @memberof serverProto.BackPack
            * @static
            * @param {serverProto.IBackPack} message BackPack message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            BackPack.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.info != null && Object.hasOwnProperty.call(message, "info")) $root.serverProto.BackPackInfo.encode(message.info, writer.uint32(
              /* id 1, wireType 2 =*/
              10).fork()).ldelim();
              if (message.ret != null && Object.hasOwnProperty.call(message, "ret")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int32(message.ret);
              return writer;
            };
            /**
            * Encodes the specified BackPack message, length delimited. Does not implicitly {@link serverProto.BackPack.verify|verify} messages.
            * @function encodeDelimited
            * @memberof serverProto.BackPack
            * @static
            * @param {serverProto.IBackPack} message BackPack message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            BackPack.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a BackPack message from the specified reader or buffer.
            * @function decode
            * @memberof serverProto.BackPack
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {serverProto.BackPack} BackPack
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            BackPack.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.serverProto.BackPack();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      message.info = $root.serverProto.BackPackInfo.decode(reader, reader.uint32());
                      break;
                    }

                  case 2:
                    {
                      message.ret = reader.int32();
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a BackPack message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof serverProto.BackPack
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {serverProto.BackPack} BackPack
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            BackPack.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a BackPack message.
            * @function verify
            * @memberof serverProto.BackPack
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            BackPack.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";

              if (message.info != null && message.hasOwnProperty("info")) {
                var error = $root.serverProto.BackPackInfo.verify(message.info);
                if (error) return "info." + error;
              }

              if (message.ret != null && message.hasOwnProperty("ret")) if (!$util.isInteger(message.ret)) return "ret: integer expected";
              return null;
            };
            /**
            * Creates a BackPack message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof serverProto.BackPack
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {serverProto.BackPack} BackPack
            */


            BackPack.fromObject = function fromObject(object) {
              if (object instanceof $root.serverProto.BackPack) return object;
              var message = new $root.serverProto.BackPack();

              if (object.info != null) {
                if (typeof object.info !== "object") throw TypeError(".serverProto.BackPack.info: object expected");
                message.info = $root.serverProto.BackPackInfo.fromObject(object.info);
              }

              if (object.ret != null) message.ret = object.ret | 0;
              return message;
            };
            /**
            * Creates a plain object from a BackPack message. Also converts values to other types if specified.
            * @function toObject
            * @memberof serverProto.BackPack
            * @static
            * @param {serverProto.BackPack} message BackPack
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            BackPack.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.info = null;
                object.ret = 0;
              }

              if (message.info != null && message.hasOwnProperty("info")) object.info = $root.serverProto.BackPackInfo.toObject(message.info, options);
              if (message.ret != null && message.hasOwnProperty("ret")) object.ret = message.ret;
              return object;
            };
            /**
            * Converts this BackPack to JSON.
            * @function toJSON
            * @memberof serverProto.BackPack
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            BackPack.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
            * Gets the default type url for BackPack
            * @function getTypeUrl
            * @memberof serverProto.BackPack
            * @static
            * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
            * @returns {string} The default type url
            */


            BackPack.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/serverProto.BackPack";
            };

            return BackPack;
          }();

          serverProto.CheckUseItemReq = function () {
            /**
            * Properties of a CheckUseItemReq.
            * @memberof serverProto
            * @interface ICheckUseItemReq
            * @property {number|null} [bet] CheckUseItemReq bet
            * @property {number|null} [itemindex] CheckUseItemReq itemindex
            * @property {number|null} [itemid] CheckUseItemReq itemid
            * @property {number|null} [amount] CheckUseItemReq amount
            * @property {number|null} [currencyNumber] CheckUseItemReq currencyNumber
            */

            /**
            * Constructs a new CheckUseItemReq.
            * @memberof serverProto
            * @classdesc Represents a CheckUseItemReq.
            * @implements ICheckUseItemReq
            * @constructor
            * @param {serverProto.ICheckUseItemReq=} [properties] Properties to set
            */
            function CheckUseItemReq(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * CheckUseItemReq bet.
            * @member {number} bet
            * @memberof serverProto.CheckUseItemReq
            * @instance
            */


            CheckUseItemReq.prototype.bet = 0;
            /**
            * CheckUseItemReq itemindex.
            * @member {number} itemindex
            * @memberof serverProto.CheckUseItemReq
            * @instance
            */

            CheckUseItemReq.prototype.itemindex = 0;
            /**
            * CheckUseItemReq itemid.
            * @member {number} itemid
            * @memberof serverProto.CheckUseItemReq
            * @instance
            */

            CheckUseItemReq.prototype.itemid = 0;
            /**
            * CheckUseItemReq amount.
            * @member {number} amount
            * @memberof serverProto.CheckUseItemReq
            * @instance
            */

            CheckUseItemReq.prototype.amount = 0;
            /**
            * CheckUseItemReq currencyNumber.
            * @member {number} currencyNumber
            * @memberof serverProto.CheckUseItemReq
            * @instance
            */

            CheckUseItemReq.prototype.currencyNumber = 0;
            /**
            * Creates a new CheckUseItemReq instance using the specified properties.
            * @function create
            * @memberof serverProto.CheckUseItemReq
            * @static
            * @param {serverProto.ICheckUseItemReq=} [properties] Properties to set
            * @returns {serverProto.CheckUseItemReq} CheckUseItemReq instance
            */

            CheckUseItemReq.create = function create(properties) {
              return new CheckUseItemReq(properties);
            };
            /**
            * Encodes the specified CheckUseItemReq message. Does not implicitly {@link serverProto.CheckUseItemReq.verify|verify} messages.
            * @function encode
            * @memberof serverProto.CheckUseItemReq
            * @static
            * @param {serverProto.ICheckUseItemReq} message CheckUseItemReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            CheckUseItemReq.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.bet != null && Object.hasOwnProperty.call(message, "bet")) writer.uint32(
              /* id 1, wireType 1 =*/
              9)["double"](message.bet);
              if (message.itemindex != null && Object.hasOwnProperty.call(message, "itemindex")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int32(message.itemindex);
              if (message.itemid != null && Object.hasOwnProperty.call(message, "itemid")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.itemid);
              if (message.amount != null && Object.hasOwnProperty.call(message, "amount")) writer.uint32(
              /* id 4, wireType 0 =*/
              32).int32(message.amount);
              if (message.currencyNumber != null && Object.hasOwnProperty.call(message, "currencyNumber")) writer.uint32(
              /* id 5, wireType 0 =*/
              40).int32(message.currencyNumber);
              return writer;
            };
            /**
            * Encodes the specified CheckUseItemReq message, length delimited. Does not implicitly {@link serverProto.CheckUseItemReq.verify|verify} messages.
            * @function encodeDelimited
            * @memberof serverProto.CheckUseItemReq
            * @static
            * @param {serverProto.ICheckUseItemReq} message CheckUseItemReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            CheckUseItemReq.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a CheckUseItemReq message from the specified reader or buffer.
            * @function decode
            * @memberof serverProto.CheckUseItemReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {serverProto.CheckUseItemReq} CheckUseItemReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            CheckUseItemReq.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.serverProto.CheckUseItemReq();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      message.bet = reader["double"]();
                      break;
                    }

                  case 2:
                    {
                      message.itemindex = reader.int32();
                      break;
                    }

                  case 3:
                    {
                      message.itemid = reader.int32();
                      break;
                    }

                  case 4:
                    {
                      message.amount = reader.int32();
                      break;
                    }

                  case 5:
                    {
                      message.currencyNumber = reader.int32();
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a CheckUseItemReq message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof serverProto.CheckUseItemReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {serverProto.CheckUseItemReq} CheckUseItemReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            CheckUseItemReq.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a CheckUseItemReq message.
            * @function verify
            * @memberof serverProto.CheckUseItemReq
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            CheckUseItemReq.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.bet != null && message.hasOwnProperty("bet")) if (typeof message.bet !== "number") return "bet: number expected";
              if (message.itemindex != null && message.hasOwnProperty("itemindex")) if (!$util.isInteger(message.itemindex)) return "itemindex: integer expected";
              if (message.itemid != null && message.hasOwnProperty("itemid")) if (!$util.isInteger(message.itemid)) return "itemid: integer expected";
              if (message.amount != null && message.hasOwnProperty("amount")) if (!$util.isInteger(message.amount)) return "amount: integer expected";
              if (message.currencyNumber != null && message.hasOwnProperty("currencyNumber")) if (!$util.isInteger(message.currencyNumber)) return "currencyNumber: integer expected";
              return null;
            };
            /**
            * Creates a CheckUseItemReq message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof serverProto.CheckUseItemReq
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {serverProto.CheckUseItemReq} CheckUseItemReq
            */


            CheckUseItemReq.fromObject = function fromObject(object) {
              if (object instanceof $root.serverProto.CheckUseItemReq) return object;
              var message = new $root.serverProto.CheckUseItemReq();
              if (object.bet != null) message.bet = Number(object.bet);
              if (object.itemindex != null) message.itemindex = object.itemindex | 0;
              if (object.itemid != null) message.itemid = object.itemid | 0;
              if (object.amount != null) message.amount = object.amount | 0;
              if (object.currencyNumber != null) message.currencyNumber = object.currencyNumber | 0;
              return message;
            };
            /**
            * Creates a plain object from a CheckUseItemReq message. Also converts values to other types if specified.
            * @function toObject
            * @memberof serverProto.CheckUseItemReq
            * @static
            * @param {serverProto.CheckUseItemReq} message CheckUseItemReq
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            CheckUseItemReq.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.bet = 0;
                object.itemindex = 0;
                object.itemid = 0;
                object.amount = 0;
                object.currencyNumber = 0;
              }

              if (message.bet != null && message.hasOwnProperty("bet")) object.bet = options.json && !isFinite(message.bet) ? String(message.bet) : message.bet;
              if (message.itemindex != null && message.hasOwnProperty("itemindex")) object.itemindex = message.itemindex;
              if (message.itemid != null && message.hasOwnProperty("itemid")) object.itemid = message.itemid;
              if (message.amount != null && message.hasOwnProperty("amount")) object.amount = message.amount;
              if (message.currencyNumber != null && message.hasOwnProperty("currencyNumber")) object.currencyNumber = message.currencyNumber;
              return object;
            };
            /**
            * Converts this CheckUseItemReq to JSON.
            * @function toJSON
            * @memberof serverProto.CheckUseItemReq
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            CheckUseItemReq.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
            * Gets the default type url for CheckUseItemReq
            * @function getTypeUrl
            * @memberof serverProto.CheckUseItemReq
            * @static
            * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
            * @returns {string} The default type url
            */


            CheckUseItemReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/serverProto.CheckUseItemReq";
            };

            return CheckUseItemReq;
          }();

          serverProto.ItemInfo = function () {
            /**
            * Properties of an ItemInfo.
            * @memberof serverProto
            * @interface IItemInfo
            * @property {number|null} [result] ItemInfo result
            * @property {number|null} [bet] ItemInfo bet
            * @property {number|null} [spinpaytype] ItemInfo spinpaytype
            * @property {number|null} [givetype] ItemInfo givetype
            * @property {number|null} [wintype] ItemInfo wintype
            * @property {number|null} [winmultiplier] ItemInfo winmultiplier
            * @property {number|null} [winmaxmag] ItemInfo winmaxmag
            * @property {number|null} [winmagupperbound] ItemInfo winmagupperbound
            * @property {number|null} [winmaglowerbound] ItemInfo winmaglowerbound
            * @property {number|null} [star] ItemInfo star
            * @property {number|null} [icon] ItemInfo icon
            * @property {number|null} [alterid] ItemInfo alterid
            * @property {number|null} [coinlimit] ItemInfo coinlimit
            * @property {number|null} [source] ItemInfo source
            * @property {number|null} [playvalue] ItemInfo playvalue
            */

            /**
            * Constructs a new ItemInfo.
            * @memberof serverProto
            * @classdesc Represents an ItemInfo.
            * @implements IItemInfo
            * @constructor
            * @param {serverProto.IItemInfo=} [properties] Properties to set
            */
            function ItemInfo(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * ItemInfo result.
            * @member {number} result
            * @memberof serverProto.ItemInfo
            * @instance
            */


            ItemInfo.prototype.result = 0;
            /**
            * ItemInfo bet.
            * @member {number} bet
            * @memberof serverProto.ItemInfo
            * @instance
            */

            ItemInfo.prototype.bet = 0;
            /**
            * ItemInfo spinpaytype.
            * @member {number} spinpaytype
            * @memberof serverProto.ItemInfo
            * @instance
            */

            ItemInfo.prototype.spinpaytype = 0;
            /**
            * ItemInfo givetype.
            * @member {number} givetype
            * @memberof serverProto.ItemInfo
            * @instance
            */

            ItemInfo.prototype.givetype = 0;
            /**
            * ItemInfo wintype.
            * @member {number} wintype
            * @memberof serverProto.ItemInfo
            * @instance
            */

            ItemInfo.prototype.wintype = 0;
            /**
            * ItemInfo winmultiplier.
            * @member {number} winmultiplier
            * @memberof serverProto.ItemInfo
            * @instance
            */

            ItemInfo.prototype.winmultiplier = 0;
            /**
            * ItemInfo winmaxmag.
            * @member {number} winmaxmag
            * @memberof serverProto.ItemInfo
            * @instance
            */

            ItemInfo.prototype.winmaxmag = 0;
            /**
            * ItemInfo winmagupperbound.
            * @member {number} winmagupperbound
            * @memberof serverProto.ItemInfo
            * @instance
            */

            ItemInfo.prototype.winmagupperbound = 0;
            /**
            * ItemInfo winmaglowerbound.
            * @member {number} winmaglowerbound
            * @memberof serverProto.ItemInfo
            * @instance
            */

            ItemInfo.prototype.winmaglowerbound = 0;
            /**
            * ItemInfo star.
            * @member {number} star
            * @memberof serverProto.ItemInfo
            * @instance
            */

            ItemInfo.prototype.star = 0;
            /**
            * ItemInfo icon.
            * @member {number} icon
            * @memberof serverProto.ItemInfo
            * @instance
            */

            ItemInfo.prototype.icon = 0;
            /**
            * ItemInfo alterid.
            * @member {number} alterid
            * @memberof serverProto.ItemInfo
            * @instance
            */

            ItemInfo.prototype.alterid = 0;
            /**
            * ItemInfo coinlimit.
            * @member {number} coinlimit
            * @memberof serverProto.ItemInfo
            * @instance
            */

            ItemInfo.prototype.coinlimit = 0;
            /**
            * ItemInfo source.
            * @member {number} source
            * @memberof serverProto.ItemInfo
            * @instance
            */

            ItemInfo.prototype.source = 0;
            /**
            * ItemInfo playvalue.
            * @member {number} playvalue
            * @memberof serverProto.ItemInfo
            * @instance
            */

            ItemInfo.prototype.playvalue = 0;
            /**
            * Creates a new ItemInfo instance using the specified properties.
            * @function create
            * @memberof serverProto.ItemInfo
            * @static
            * @param {serverProto.IItemInfo=} [properties] Properties to set
            * @returns {serverProto.ItemInfo} ItemInfo instance
            */

            ItemInfo.create = function create(properties) {
              return new ItemInfo(properties);
            };
            /**
            * Encodes the specified ItemInfo message. Does not implicitly {@link serverProto.ItemInfo.verify|verify} messages.
            * @function encode
            * @memberof serverProto.ItemInfo
            * @static
            * @param {serverProto.IItemInfo} message ItemInfo message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            ItemInfo.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.result != null && Object.hasOwnProperty.call(message, "result")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.result);
              if (message.bet != null && Object.hasOwnProperty.call(message, "bet")) writer.uint32(
              /* id 2, wireType 1 =*/
              17)["double"](message.bet);
              if (message.spinpaytype != null && Object.hasOwnProperty.call(message, "spinpaytype")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.spinpaytype);
              if (message.givetype != null && Object.hasOwnProperty.call(message, "givetype")) writer.uint32(
              /* id 4, wireType 0 =*/
              32).int32(message.givetype);
              if (message.wintype != null && Object.hasOwnProperty.call(message, "wintype")) writer.uint32(
              /* id 5, wireType 0 =*/
              40).int32(message.wintype);
              if (message.winmultiplier != null && Object.hasOwnProperty.call(message, "winmultiplier")) writer.uint32(
              /* id 6, wireType 1 =*/
              49)["double"](message.winmultiplier);
              if (message.winmaxmag != null && Object.hasOwnProperty.call(message, "winmaxmag")) writer.uint32(
              /* id 7, wireType 1 =*/
              57)["double"](message.winmaxmag);
              if (message.winmagupperbound != null && Object.hasOwnProperty.call(message, "winmagupperbound")) writer.uint32(
              /* id 8, wireType 1 =*/
              65)["double"](message.winmagupperbound);
              if (message.winmaglowerbound != null && Object.hasOwnProperty.call(message, "winmaglowerbound")) writer.uint32(
              /* id 9, wireType 1 =*/
              73)["double"](message.winmaglowerbound);
              if (message.star != null && Object.hasOwnProperty.call(message, "star")) writer.uint32(
              /* id 10, wireType 0 =*/
              80).int32(message.star);
              if (message.icon != null && Object.hasOwnProperty.call(message, "icon")) writer.uint32(
              /* id 11, wireType 0 =*/
              88).int32(message.icon);
              if (message.alterid != null && Object.hasOwnProperty.call(message, "alterid")) writer.uint32(
              /* id 12, wireType 0 =*/
              96).int32(message.alterid);
              if (message.coinlimit != null && Object.hasOwnProperty.call(message, "coinlimit")) writer.uint32(
              /* id 13, wireType 1 =*/
              105)["double"](message.coinlimit);
              if (message.source != null && Object.hasOwnProperty.call(message, "source")) writer.uint32(
              /* id 14, wireType 0 =*/
              112).int32(message.source);
              if (message.playvalue != null && Object.hasOwnProperty.call(message, "playvalue")) writer.uint32(
              /* id 15, wireType 1 =*/
              121)["double"](message.playvalue);
              return writer;
            };
            /**
            * Encodes the specified ItemInfo message, length delimited. Does not implicitly {@link serverProto.ItemInfo.verify|verify} messages.
            * @function encodeDelimited
            * @memberof serverProto.ItemInfo
            * @static
            * @param {serverProto.IItemInfo} message ItemInfo message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            ItemInfo.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes an ItemInfo message from the specified reader or buffer.
            * @function decode
            * @memberof serverProto.ItemInfo
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {serverProto.ItemInfo} ItemInfo
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            ItemInfo.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.serverProto.ItemInfo();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      message.result = reader.int32();
                      break;
                    }

                  case 2:
                    {
                      message.bet = reader["double"]();
                      break;
                    }

                  case 3:
                    {
                      message.spinpaytype = reader.int32();
                      break;
                    }

                  case 4:
                    {
                      message.givetype = reader.int32();
                      break;
                    }

                  case 5:
                    {
                      message.wintype = reader.int32();
                      break;
                    }

                  case 6:
                    {
                      message.winmultiplier = reader["double"]();
                      break;
                    }

                  case 7:
                    {
                      message.winmaxmag = reader["double"]();
                      break;
                    }

                  case 8:
                    {
                      message.winmagupperbound = reader["double"]();
                      break;
                    }

                  case 9:
                    {
                      message.winmaglowerbound = reader["double"]();
                      break;
                    }

                  case 10:
                    {
                      message.star = reader.int32();
                      break;
                    }

                  case 11:
                    {
                      message.icon = reader.int32();
                      break;
                    }

                  case 12:
                    {
                      message.alterid = reader.int32();
                      break;
                    }

                  case 13:
                    {
                      message.coinlimit = reader["double"]();
                      break;
                    }

                  case 14:
                    {
                      message.source = reader.int32();
                      break;
                    }

                  case 15:
                    {
                      message.playvalue = reader["double"]();
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes an ItemInfo message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof serverProto.ItemInfo
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {serverProto.ItemInfo} ItemInfo
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            ItemInfo.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies an ItemInfo message.
            * @function verify
            * @memberof serverProto.ItemInfo
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            ItemInfo.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.result != null && message.hasOwnProperty("result")) if (!$util.isInteger(message.result)) return "result: integer expected";
              if (message.bet != null && message.hasOwnProperty("bet")) if (typeof message.bet !== "number") return "bet: number expected";
              if (message.spinpaytype != null && message.hasOwnProperty("spinpaytype")) if (!$util.isInteger(message.spinpaytype)) return "spinpaytype: integer expected";
              if (message.givetype != null && message.hasOwnProperty("givetype")) if (!$util.isInteger(message.givetype)) return "givetype: integer expected";
              if (message.wintype != null && message.hasOwnProperty("wintype")) if (!$util.isInteger(message.wintype)) return "wintype: integer expected";
              if (message.winmultiplier != null && message.hasOwnProperty("winmultiplier")) if (typeof message.winmultiplier !== "number") return "winmultiplier: number expected";
              if (message.winmaxmag != null && message.hasOwnProperty("winmaxmag")) if (typeof message.winmaxmag !== "number") return "winmaxmag: number expected";
              if (message.winmagupperbound != null && message.hasOwnProperty("winmagupperbound")) if (typeof message.winmagupperbound !== "number") return "winmagupperbound: number expected";
              if (message.winmaglowerbound != null && message.hasOwnProperty("winmaglowerbound")) if (typeof message.winmaglowerbound !== "number") return "winmaglowerbound: number expected";
              if (message.star != null && message.hasOwnProperty("star")) if (!$util.isInteger(message.star)) return "star: integer expected";
              if (message.icon != null && message.hasOwnProperty("icon")) if (!$util.isInteger(message.icon)) return "icon: integer expected";
              if (message.alterid != null && message.hasOwnProperty("alterid")) if (!$util.isInteger(message.alterid)) return "alterid: integer expected";
              if (message.coinlimit != null && message.hasOwnProperty("coinlimit")) if (typeof message.coinlimit !== "number") return "coinlimit: number expected";
              if (message.source != null && message.hasOwnProperty("source")) if (!$util.isInteger(message.source)) return "source: integer expected";
              if (message.playvalue != null && message.hasOwnProperty("playvalue")) if (typeof message.playvalue !== "number") return "playvalue: number expected";
              return null;
            };
            /**
            * Creates an ItemInfo message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof serverProto.ItemInfo
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {serverProto.ItemInfo} ItemInfo
            */


            ItemInfo.fromObject = function fromObject(object) {
              if (object instanceof $root.serverProto.ItemInfo) return object;
              var message = new $root.serverProto.ItemInfo();
              if (object.result != null) message.result = object.result | 0;
              if (object.bet != null) message.bet = Number(object.bet);
              if (object.spinpaytype != null) message.spinpaytype = object.spinpaytype | 0;
              if (object.givetype != null) message.givetype = object.givetype | 0;
              if (object.wintype != null) message.wintype = object.wintype | 0;
              if (object.winmultiplier != null) message.winmultiplier = Number(object.winmultiplier);
              if (object.winmaxmag != null) message.winmaxmag = Number(object.winmaxmag);
              if (object.winmagupperbound != null) message.winmagupperbound = Number(object.winmagupperbound);
              if (object.winmaglowerbound != null) message.winmaglowerbound = Number(object.winmaglowerbound);
              if (object.star != null) message.star = object.star | 0;
              if (object.icon != null) message.icon = object.icon | 0;
              if (object.alterid != null) message.alterid = object.alterid | 0;
              if (object.coinlimit != null) message.coinlimit = Number(object.coinlimit);
              if (object.source != null) message.source = object.source | 0;
              if (object.playvalue != null) message.playvalue = Number(object.playvalue);
              return message;
            };
            /**
            * Creates a plain object from an ItemInfo message. Also converts values to other types if specified.
            * @function toObject
            * @memberof serverProto.ItemInfo
            * @static
            * @param {serverProto.ItemInfo} message ItemInfo
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            ItemInfo.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.result = 0;
                object.bet = 0;
                object.spinpaytype = 0;
                object.givetype = 0;
                object.wintype = 0;
                object.winmultiplier = 0;
                object.winmaxmag = 0;
                object.winmagupperbound = 0;
                object.winmaglowerbound = 0;
                object.star = 0;
                object.icon = 0;
                object.alterid = 0;
                object.coinlimit = 0;
                object.source = 0;
                object.playvalue = 0;
              }

              if (message.result != null && message.hasOwnProperty("result")) object.result = message.result;
              if (message.bet != null && message.hasOwnProperty("bet")) object.bet = options.json && !isFinite(message.bet) ? String(message.bet) : message.bet;
              if (message.spinpaytype != null && message.hasOwnProperty("spinpaytype")) object.spinpaytype = message.spinpaytype;
              if (message.givetype != null && message.hasOwnProperty("givetype")) object.givetype = message.givetype;
              if (message.wintype != null && message.hasOwnProperty("wintype")) object.wintype = message.wintype;
              if (message.winmultiplier != null && message.hasOwnProperty("winmultiplier")) object.winmultiplier = options.json && !isFinite(message.winmultiplier) ? String(message.winmultiplier) : message.winmultiplier;
              if (message.winmaxmag != null && message.hasOwnProperty("winmaxmag")) object.winmaxmag = options.json && !isFinite(message.winmaxmag) ? String(message.winmaxmag) : message.winmaxmag;
              if (message.winmagupperbound != null && message.hasOwnProperty("winmagupperbound")) object.winmagupperbound = options.json && !isFinite(message.winmagupperbound) ? String(message.winmagupperbound) : message.winmagupperbound;
              if (message.winmaglowerbound != null && message.hasOwnProperty("winmaglowerbound")) object.winmaglowerbound = options.json && !isFinite(message.winmaglowerbound) ? String(message.winmaglowerbound) : message.winmaglowerbound;
              if (message.star != null && message.hasOwnProperty("star")) object.star = message.star;
              if (message.icon != null && message.hasOwnProperty("icon")) object.icon = message.icon;
              if (message.alterid != null && message.hasOwnProperty("alterid")) object.alterid = message.alterid;
              if (message.coinlimit != null && message.hasOwnProperty("coinlimit")) object.coinlimit = options.json && !isFinite(message.coinlimit) ? String(message.coinlimit) : message.coinlimit;
              if (message.source != null && message.hasOwnProperty("source")) object.source = message.source;
              if (message.playvalue != null && message.hasOwnProperty("playvalue")) object.playvalue = options.json && !isFinite(message.playvalue) ? String(message.playvalue) : message.playvalue;
              return object;
            };
            /**
            * Converts this ItemInfo to JSON.
            * @function toJSON
            * @memberof serverProto.ItemInfo
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            ItemInfo.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
            * Gets the default type url for ItemInfo
            * @function getTypeUrl
            * @memberof serverProto.ItemInfo
            * @static
            * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
            * @returns {string} The default type url
            */


            ItemInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/serverProto.ItemInfo";
            };

            return ItemInfo;
          }();

          serverProto.CheckUseItem = function () {
            /**
            * Properties of a CheckUseItem.
            * @memberof serverProto
            * @interface ICheckUseItem
            * @property {serverProto.IItemInfo|null} [info] CheckUseItem info
            * @property {number|null} [ret] CheckUseItem ret
            */

            /**
            * Constructs a new CheckUseItem.
            * @memberof serverProto
            * @classdesc Represents a CheckUseItem.
            * @implements ICheckUseItem
            * @constructor
            * @param {serverProto.ICheckUseItem=} [properties] Properties to set
            */
            function CheckUseItem(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * CheckUseItem info.
            * @member {serverProto.IItemInfo|null|undefined} info
            * @memberof serverProto.CheckUseItem
            * @instance
            */


            CheckUseItem.prototype.info = null;
            /**
            * CheckUseItem ret.
            * @member {number} ret
            * @memberof serverProto.CheckUseItem
            * @instance
            */

            CheckUseItem.prototype.ret = 0;
            /**
            * Creates a new CheckUseItem instance using the specified properties.
            * @function create
            * @memberof serverProto.CheckUseItem
            * @static
            * @param {serverProto.ICheckUseItem=} [properties] Properties to set
            * @returns {serverProto.CheckUseItem} CheckUseItem instance
            */

            CheckUseItem.create = function create(properties) {
              return new CheckUseItem(properties);
            };
            /**
            * Encodes the specified CheckUseItem message. Does not implicitly {@link serverProto.CheckUseItem.verify|verify} messages.
            * @function encode
            * @memberof serverProto.CheckUseItem
            * @static
            * @param {serverProto.ICheckUseItem} message CheckUseItem message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            CheckUseItem.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.info != null && Object.hasOwnProperty.call(message, "info")) $root.serverProto.ItemInfo.encode(message.info, writer.uint32(
              /* id 1, wireType 2 =*/
              10).fork()).ldelim();
              if (message.ret != null && Object.hasOwnProperty.call(message, "ret")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int32(message.ret);
              return writer;
            };
            /**
            * Encodes the specified CheckUseItem message, length delimited. Does not implicitly {@link serverProto.CheckUseItem.verify|verify} messages.
            * @function encodeDelimited
            * @memberof serverProto.CheckUseItem
            * @static
            * @param {serverProto.ICheckUseItem} message CheckUseItem message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            CheckUseItem.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a CheckUseItem message from the specified reader or buffer.
            * @function decode
            * @memberof serverProto.CheckUseItem
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {serverProto.CheckUseItem} CheckUseItem
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            CheckUseItem.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.serverProto.CheckUseItem();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      message.info = $root.serverProto.ItemInfo.decode(reader, reader.uint32());
                      break;
                    }

                  case 2:
                    {
                      message.ret = reader.int32();
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a CheckUseItem message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof serverProto.CheckUseItem
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {serverProto.CheckUseItem} CheckUseItem
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            CheckUseItem.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a CheckUseItem message.
            * @function verify
            * @memberof serverProto.CheckUseItem
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            CheckUseItem.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";

              if (message.info != null && message.hasOwnProperty("info")) {
                var error = $root.serverProto.ItemInfo.verify(message.info);
                if (error) return "info." + error;
              }

              if (message.ret != null && message.hasOwnProperty("ret")) if (!$util.isInteger(message.ret)) return "ret: integer expected";
              return null;
            };
            /**
            * Creates a CheckUseItem message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof serverProto.CheckUseItem
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {serverProto.CheckUseItem} CheckUseItem
            */


            CheckUseItem.fromObject = function fromObject(object) {
              if (object instanceof $root.serverProto.CheckUseItem) return object;
              var message = new $root.serverProto.CheckUseItem();

              if (object.info != null) {
                if (typeof object.info !== "object") throw TypeError(".serverProto.CheckUseItem.info: object expected");
                message.info = $root.serverProto.ItemInfo.fromObject(object.info);
              }

              if (object.ret != null) message.ret = object.ret | 0;
              return message;
            };
            /**
            * Creates a plain object from a CheckUseItem message. Also converts values to other types if specified.
            * @function toObject
            * @memberof serverProto.CheckUseItem
            * @static
            * @param {serverProto.CheckUseItem} message CheckUseItem
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            CheckUseItem.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.info = null;
                object.ret = 0;
              }

              if (message.info != null && message.hasOwnProperty("info")) object.info = $root.serverProto.ItemInfo.toObject(message.info, options);
              if (message.ret != null && message.hasOwnProperty("ret")) object.ret = message.ret;
              return object;
            };
            /**
            * Converts this CheckUseItem to JSON.
            * @function toJSON
            * @memberof serverProto.CheckUseItem
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            CheckUseItem.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
            * Gets the default type url for CheckUseItem
            * @function getTypeUrl
            * @memberof serverProto.CheckUseItem
            * @static
            * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
            * @returns {string} The default type url
            */


            CheckUseItem.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/serverProto.CheckUseItem";
            };

            return CheckUseItem;
          }();

          serverProto.ListAllGameInfo = function () {
            /**
            * Properties of a ListAllGameInfo.
            * @memberof serverProto
            * @interface IListAllGameInfo
            * @property {number|null} [result] ListAllGameInfo result
            * @property {Array.<serverProto.IItemListData>|null} [canuseitem] ListAllGameInfo canuseitem
            */

            /**
            * Constructs a new ListAllGameInfo.
            * @memberof serverProto
            * @classdesc Represents a ListAllGameInfo.
            * @implements IListAllGameInfo
            * @constructor
            * @param {serverProto.IListAllGameInfo=} [properties] Properties to set
            */
            function ListAllGameInfo(properties) {
              this.canuseitem = [];
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * ListAllGameInfo result.
            * @member {number} result
            * @memberof serverProto.ListAllGameInfo
            * @instance
            */


            ListAllGameInfo.prototype.result = 0;
            /**
            * ListAllGameInfo canuseitem.
            * @member {Array.<serverProto.IItemListData>} canuseitem
            * @memberof serverProto.ListAllGameInfo
            * @instance
            */

            ListAllGameInfo.prototype.canuseitem = $util.emptyArray;
            /**
            * Creates a new ListAllGameInfo instance using the specified properties.
            * @function create
            * @memberof serverProto.ListAllGameInfo
            * @static
            * @param {serverProto.IListAllGameInfo=} [properties] Properties to set
            * @returns {serverProto.ListAllGameInfo} ListAllGameInfo instance
            */

            ListAllGameInfo.create = function create(properties) {
              return new ListAllGameInfo(properties);
            };
            /**
            * Encodes the specified ListAllGameInfo message. Does not implicitly {@link serverProto.ListAllGameInfo.verify|verify} messages.
            * @function encode
            * @memberof serverProto.ListAllGameInfo
            * @static
            * @param {serverProto.IListAllGameInfo} message ListAllGameInfo message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            ListAllGameInfo.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.result != null && Object.hasOwnProperty.call(message, "result")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.result);
              if (message.canuseitem != null && message.canuseitem.length) for (var i = 0; i < message.canuseitem.length; ++i) {
                $root.serverProto.ItemListData.encode(message.canuseitem[i], writer.uint32(
                /* id 2, wireType 2 =*/
                18).fork()).ldelim();
              }
              return writer;
            };
            /**
            * Encodes the specified ListAllGameInfo message, length delimited. Does not implicitly {@link serverProto.ListAllGameInfo.verify|verify} messages.
            * @function encodeDelimited
            * @memberof serverProto.ListAllGameInfo
            * @static
            * @param {serverProto.IListAllGameInfo} message ListAllGameInfo message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            ListAllGameInfo.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a ListAllGameInfo message from the specified reader or buffer.
            * @function decode
            * @memberof serverProto.ListAllGameInfo
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {serverProto.ListAllGameInfo} ListAllGameInfo
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            ListAllGameInfo.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.serverProto.ListAllGameInfo();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      message.result = reader.int32();
                      break;
                    }

                  case 2:
                    {
                      if (!(message.canuseitem && message.canuseitem.length)) message.canuseitem = [];
                      message.canuseitem.push($root.serverProto.ItemListData.decode(reader, reader.uint32()));
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a ListAllGameInfo message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof serverProto.ListAllGameInfo
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {serverProto.ListAllGameInfo} ListAllGameInfo
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            ListAllGameInfo.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a ListAllGameInfo message.
            * @function verify
            * @memberof serverProto.ListAllGameInfo
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            ListAllGameInfo.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.result != null && message.hasOwnProperty("result")) if (!$util.isInteger(message.result)) return "result: integer expected";

              if (message.canuseitem != null && message.hasOwnProperty("canuseitem")) {
                if (!Array.isArray(message.canuseitem)) return "canuseitem: array expected";

                for (var i = 0; i < message.canuseitem.length; ++i) {
                  var error = $root.serverProto.ItemListData.verify(message.canuseitem[i]);
                  if (error) return "canuseitem." + error;
                }
              }

              return null;
            };
            /**
            * Creates a ListAllGameInfo message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof serverProto.ListAllGameInfo
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {serverProto.ListAllGameInfo} ListAllGameInfo
            */


            ListAllGameInfo.fromObject = function fromObject(object) {
              if (object instanceof $root.serverProto.ListAllGameInfo) return object;
              var message = new $root.serverProto.ListAllGameInfo();
              if (object.result != null) message.result = object.result | 0;

              if (object.canuseitem) {
                if (!Array.isArray(object.canuseitem)) throw TypeError(".serverProto.ListAllGameInfo.canuseitem: array expected");
                message.canuseitem = [];

                for (var i = 0; i < object.canuseitem.length; ++i) {
                  if (typeof object.canuseitem[i] !== "object") throw TypeError(".serverProto.ListAllGameInfo.canuseitem: object expected");
                  message.canuseitem[i] = $root.serverProto.ItemListData.fromObject(object.canuseitem[i]);
                }
              }

              return message;
            };
            /**
            * Creates a plain object from a ListAllGameInfo message. Also converts values to other types if specified.
            * @function toObject
            * @memberof serverProto.ListAllGameInfo
            * @static
            * @param {serverProto.ListAllGameInfo} message ListAllGameInfo
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            ListAllGameInfo.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};
              if (options.arrays || options.defaults) object.canuseitem = [];
              if (options.defaults) object.result = 0;
              if (message.result != null && message.hasOwnProperty("result")) object.result = message.result;

              if (message.canuseitem && message.canuseitem.length) {
                object.canuseitem = [];

                for (var j = 0; j < message.canuseitem.length; ++j) {
                  object.canuseitem[j] = $root.serverProto.ItemListData.toObject(message.canuseitem[j], options);
                }
              }

              return object;
            };
            /**
            * Converts this ListAllGameInfo to JSON.
            * @function toJSON
            * @memberof serverProto.ListAllGameInfo
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            ListAllGameInfo.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
            * Gets the default type url for ListAllGameInfo
            * @function getTypeUrl
            * @memberof serverProto.ListAllGameInfo
            * @static
            * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
            * @returns {string} The default type url
            */


            ListAllGameInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/serverProto.ListAllGameInfo";
            };

            return ListAllGameInfo;
          }();

          serverProto.ItemListData = function () {
            /**
            * Properties of an ItemListData.
            * @memberof serverProto
            * @interface IItemListData
            * @property {number|null} [gameid] ItemListData gameid
            * @property {number|null} [ownamount] ItemListData ownamount
            * @property {number|null} [canamount] ItemListData canamount
            * @property {number|null} [minitemindex] ItemListData minitemindex
            */

            /**
            * Constructs a new ItemListData.
            * @memberof serverProto
            * @classdesc Represents an ItemListData.
            * @implements IItemListData
            * @constructor
            * @param {serverProto.IItemListData=} [properties] Properties to set
            */
            function ItemListData(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * ItemListData gameid.
            * @member {number} gameid
            * @memberof serverProto.ItemListData
            * @instance
            */


            ItemListData.prototype.gameid = 0;
            /**
            * ItemListData ownamount.
            * @member {number} ownamount
            * @memberof serverProto.ItemListData
            * @instance
            */

            ItemListData.prototype.ownamount = 0;
            /**
            * ItemListData canamount.
            * @member {number} canamount
            * @memberof serverProto.ItemListData
            * @instance
            */

            ItemListData.prototype.canamount = 0;
            /**
            * ItemListData minitemindex.
            * @member {number} minitemindex
            * @memberof serverProto.ItemListData
            * @instance
            */

            ItemListData.prototype.minitemindex = 0;
            /**
            * Creates a new ItemListData instance using the specified properties.
            * @function create
            * @memberof serverProto.ItemListData
            * @static
            * @param {serverProto.IItemListData=} [properties] Properties to set
            * @returns {serverProto.ItemListData} ItemListData instance
            */

            ItemListData.create = function create(properties) {
              return new ItemListData(properties);
            };
            /**
            * Encodes the specified ItemListData message. Does not implicitly {@link serverProto.ItemListData.verify|verify} messages.
            * @function encode
            * @memberof serverProto.ItemListData
            * @static
            * @param {serverProto.IItemListData} message ItemListData message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            ItemListData.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.gameid != null && Object.hasOwnProperty.call(message, "gameid")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.gameid);
              if (message.ownamount != null && Object.hasOwnProperty.call(message, "ownamount")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int32(message.ownamount);
              if (message.canamount != null && Object.hasOwnProperty.call(message, "canamount")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.canamount);
              if (message.minitemindex != null && Object.hasOwnProperty.call(message, "minitemindex")) writer.uint32(
              /* id 4, wireType 0 =*/
              32).int32(message.minitemindex);
              return writer;
            };
            /**
            * Encodes the specified ItemListData message, length delimited. Does not implicitly {@link serverProto.ItemListData.verify|verify} messages.
            * @function encodeDelimited
            * @memberof serverProto.ItemListData
            * @static
            * @param {serverProto.IItemListData} message ItemListData message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            ItemListData.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes an ItemListData message from the specified reader or buffer.
            * @function decode
            * @memberof serverProto.ItemListData
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {serverProto.ItemListData} ItemListData
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            ItemListData.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.serverProto.ItemListData();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      message.gameid = reader.int32();
                      break;
                    }

                  case 2:
                    {
                      message.ownamount = reader.int32();
                      break;
                    }

                  case 3:
                    {
                      message.canamount = reader.int32();
                      break;
                    }

                  case 4:
                    {
                      message.minitemindex = reader.int32();
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes an ItemListData message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof serverProto.ItemListData
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {serverProto.ItemListData} ItemListData
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            ItemListData.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies an ItemListData message.
            * @function verify
            * @memberof serverProto.ItemListData
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            ItemListData.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.gameid != null && message.hasOwnProperty("gameid")) if (!$util.isInteger(message.gameid)) return "gameid: integer expected";
              if (message.ownamount != null && message.hasOwnProperty("ownamount")) if (!$util.isInteger(message.ownamount)) return "ownamount: integer expected";
              if (message.canamount != null && message.hasOwnProperty("canamount")) if (!$util.isInteger(message.canamount)) return "canamount: integer expected";
              if (message.minitemindex != null && message.hasOwnProperty("minitemindex")) if (!$util.isInteger(message.minitemindex)) return "minitemindex: integer expected";
              return null;
            };
            /**
            * Creates an ItemListData message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof serverProto.ItemListData
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {serverProto.ItemListData} ItemListData
            */


            ItemListData.fromObject = function fromObject(object) {
              if (object instanceof $root.serverProto.ItemListData) return object;
              var message = new $root.serverProto.ItemListData();
              if (object.gameid != null) message.gameid = object.gameid | 0;
              if (object.ownamount != null) message.ownamount = object.ownamount | 0;
              if (object.canamount != null) message.canamount = object.canamount | 0;
              if (object.minitemindex != null) message.minitemindex = object.minitemindex | 0;
              return message;
            };
            /**
            * Creates a plain object from an ItemListData message. Also converts values to other types if specified.
            * @function toObject
            * @memberof serverProto.ItemListData
            * @static
            * @param {serverProto.ItemListData} message ItemListData
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            ItemListData.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.gameid = 0;
                object.ownamount = 0;
                object.canamount = 0;
                object.minitemindex = 0;
              }

              if (message.gameid != null && message.hasOwnProperty("gameid")) object.gameid = message.gameid;
              if (message.ownamount != null && message.hasOwnProperty("ownamount")) object.ownamount = message.ownamount;
              if (message.canamount != null && message.hasOwnProperty("canamount")) object.canamount = message.canamount;
              if (message.minitemindex != null && message.hasOwnProperty("minitemindex")) object.minitemindex = message.minitemindex;
              return object;
            };
            /**
            * Converts this ItemListData to JSON.
            * @function toJSON
            * @memberof serverProto.ItemListData
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            ItemListData.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
            * Gets the default type url for ItemListData
            * @function getTypeUrl
            * @memberof serverProto.ItemListData
            * @static
            * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
            * @returns {string} The default type url
            */


            ItemListData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/serverProto.ItemListData";
            };

            return ItemListData;
          }();

          serverProto.MailInfo = function () {
            /**
            * Properties of a MailInfo.
            * @memberof serverProto
            * @interface IMailInfo
            * @property {number|null} [result] MailInfo result
            * @property {Array.<serverProto.IMaildata>|null} [usermailackdata] MailInfo usermailackdata
            * @property {number|null} [isread] MailInfo isread
            */

            /**
            * Constructs a new MailInfo.
            * @memberof serverProto
            * @classdesc Represents a MailInfo.
            * @implements IMailInfo
            * @constructor
            * @param {serverProto.IMailInfo=} [properties] Properties to set
            */
            function MailInfo(properties) {
              this.usermailackdata = [];
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * MailInfo result.
            * @member {number} result
            * @memberof serverProto.MailInfo
            * @instance
            */


            MailInfo.prototype.result = 0;
            /**
            * MailInfo usermailackdata.
            * @member {Array.<serverProto.IMaildata>} usermailackdata
            * @memberof serverProto.MailInfo
            * @instance
            */

            MailInfo.prototype.usermailackdata = $util.emptyArray;
            /**
            * MailInfo isread.
            * @member {number} isread
            * @memberof serverProto.MailInfo
            * @instance
            */

            MailInfo.prototype.isread = 0;
            /**
            * Creates a new MailInfo instance using the specified properties.
            * @function create
            * @memberof serverProto.MailInfo
            * @static
            * @param {serverProto.IMailInfo=} [properties] Properties to set
            * @returns {serverProto.MailInfo} MailInfo instance
            */

            MailInfo.create = function create(properties) {
              return new MailInfo(properties);
            };
            /**
            * Encodes the specified MailInfo message. Does not implicitly {@link serverProto.MailInfo.verify|verify} messages.
            * @function encode
            * @memberof serverProto.MailInfo
            * @static
            * @param {serverProto.IMailInfo} message MailInfo message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            MailInfo.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.result != null && Object.hasOwnProperty.call(message, "result")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.result);
              if (message.usermailackdata != null && message.usermailackdata.length) for (var i = 0; i < message.usermailackdata.length; ++i) {
                $root.serverProto.Maildata.encode(message.usermailackdata[i], writer.uint32(
                /* id 2, wireType 2 =*/
                18).fork()).ldelim();
              }
              if (message.isread != null && Object.hasOwnProperty.call(message, "isread")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.isread);
              return writer;
            };
            /**
            * Encodes the specified MailInfo message, length delimited. Does not implicitly {@link serverProto.MailInfo.verify|verify} messages.
            * @function encodeDelimited
            * @memberof serverProto.MailInfo
            * @static
            * @param {serverProto.IMailInfo} message MailInfo message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            MailInfo.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a MailInfo message from the specified reader or buffer.
            * @function decode
            * @memberof serverProto.MailInfo
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {serverProto.MailInfo} MailInfo
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            MailInfo.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.serverProto.MailInfo();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      message.result = reader.int32();
                      break;
                    }

                  case 2:
                    {
                      if (!(message.usermailackdata && message.usermailackdata.length)) message.usermailackdata = [];
                      message.usermailackdata.push($root.serverProto.Maildata.decode(reader, reader.uint32()));
                      break;
                    }

                  case 3:
                    {
                      message.isread = reader.int32();
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a MailInfo message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof serverProto.MailInfo
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {serverProto.MailInfo} MailInfo
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            MailInfo.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a MailInfo message.
            * @function verify
            * @memberof serverProto.MailInfo
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            MailInfo.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.result != null && message.hasOwnProperty("result")) if (!$util.isInteger(message.result)) return "result: integer expected";

              if (message.usermailackdata != null && message.hasOwnProperty("usermailackdata")) {
                if (!Array.isArray(message.usermailackdata)) return "usermailackdata: array expected";

                for (var i = 0; i < message.usermailackdata.length; ++i) {
                  var error = $root.serverProto.Maildata.verify(message.usermailackdata[i]);
                  if (error) return "usermailackdata." + error;
                }
              }

              if (message.isread != null && message.hasOwnProperty("isread")) if (!$util.isInteger(message.isread)) return "isread: integer expected";
              return null;
            };
            /**
            * Creates a MailInfo message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof serverProto.MailInfo
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {serverProto.MailInfo} MailInfo
            */


            MailInfo.fromObject = function fromObject(object) {
              if (object instanceof $root.serverProto.MailInfo) return object;
              var message = new $root.serverProto.MailInfo();
              if (object.result != null) message.result = object.result | 0;

              if (object.usermailackdata) {
                if (!Array.isArray(object.usermailackdata)) throw TypeError(".serverProto.MailInfo.usermailackdata: array expected");
                message.usermailackdata = [];

                for (var i = 0; i < object.usermailackdata.length; ++i) {
                  if (typeof object.usermailackdata[i] !== "object") throw TypeError(".serverProto.MailInfo.usermailackdata: object expected");
                  message.usermailackdata[i] = $root.serverProto.Maildata.fromObject(object.usermailackdata[i]);
                }
              }

              if (object.isread != null) message.isread = object.isread | 0;
              return message;
            };
            /**
            * Creates a plain object from a MailInfo message. Also converts values to other types if specified.
            * @function toObject
            * @memberof serverProto.MailInfo
            * @static
            * @param {serverProto.MailInfo} message MailInfo
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            MailInfo.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};
              if (options.arrays || options.defaults) object.usermailackdata = [];

              if (options.defaults) {
                object.result = 0;
                object.isread = 0;
              }

              if (message.result != null && message.hasOwnProperty("result")) object.result = message.result;

              if (message.usermailackdata && message.usermailackdata.length) {
                object.usermailackdata = [];

                for (var j = 0; j < message.usermailackdata.length; ++j) {
                  object.usermailackdata[j] = $root.serverProto.Maildata.toObject(message.usermailackdata[j], options);
                }
              }

              if (message.isread != null && message.hasOwnProperty("isread")) object.isread = message.isread;
              return object;
            };
            /**
            * Converts this MailInfo to JSON.
            * @function toJSON
            * @memberof serverProto.MailInfo
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            MailInfo.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
            * Gets the default type url for MailInfo
            * @function getTypeUrl
            * @memberof serverProto.MailInfo
            * @static
            * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
            * @returns {string} The default type url
            */


            MailInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/serverProto.MailInfo";
            };

            return MailInfo;
          }();

          serverProto.Maildata = function () {
            /**
            * Properties of a Maildata.
            * @memberof serverProto
            * @interface IMaildata
            * @property {number|null} [idx] Maildata idx
            * @property {number|null} [accountid] Maildata accountid
            * @property {number|null} [source] Maildata source
            * @property {serverProto.IContent|null} [content] Maildata content
            * @property {number|null} [isread] Maildata isread
            * @property {string|null} [createtime] Maildata createtime
            * @property {number|Long|null} [created] Maildata created
            */

            /**
            * Constructs a new Maildata.
            * @memberof serverProto
            * @classdesc Represents a Maildata.
            * @implements IMaildata
            * @constructor
            * @param {serverProto.IMaildata=} [properties] Properties to set
            */
            function Maildata(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * Maildata idx.
            * @member {number} idx
            * @memberof serverProto.Maildata
            * @instance
            */


            Maildata.prototype.idx = 0;
            /**
            * Maildata accountid.
            * @member {number} accountid
            * @memberof serverProto.Maildata
            * @instance
            */

            Maildata.prototype.accountid = 0;
            /**
            * Maildata source.
            * @member {number} source
            * @memberof serverProto.Maildata
            * @instance
            */

            Maildata.prototype.source = 0;
            /**
            * Maildata content.
            * @member {serverProto.IContent|null|undefined} content
            * @memberof serverProto.Maildata
            * @instance
            */

            Maildata.prototype.content = null;
            /**
            * Maildata isread.
            * @member {number} isread
            * @memberof serverProto.Maildata
            * @instance
            */

            Maildata.prototype.isread = 0;
            /**
            * Maildata createtime.
            * @member {string} createtime
            * @memberof serverProto.Maildata
            * @instance
            */

            Maildata.prototype.createtime = "";
            /**
            * Maildata created.
            * @member {number|Long} created
            * @memberof serverProto.Maildata
            * @instance
            */

            Maildata.prototype.created = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
            * Creates a new Maildata instance using the specified properties.
            * @function create
            * @memberof serverProto.Maildata
            * @static
            * @param {serverProto.IMaildata=} [properties] Properties to set
            * @returns {serverProto.Maildata} Maildata instance
            */

            Maildata.create = function create(properties) {
              return new Maildata(properties);
            };
            /**
            * Encodes the specified Maildata message. Does not implicitly {@link serverProto.Maildata.verify|verify} messages.
            * @function encode
            * @memberof serverProto.Maildata
            * @static
            * @param {serverProto.IMaildata} message Maildata message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            Maildata.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.idx != null && Object.hasOwnProperty.call(message, "idx")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.idx);
              if (message.accountid != null && Object.hasOwnProperty.call(message, "accountid")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int32(message.accountid);
              if (message.source != null && Object.hasOwnProperty.call(message, "source")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.source);
              if (message.content != null && Object.hasOwnProperty.call(message, "content")) $root.serverProto.Content.encode(message.content, writer.uint32(
              /* id 4, wireType 2 =*/
              34).fork()).ldelim();
              if (message.isread != null && Object.hasOwnProperty.call(message, "isread")) writer.uint32(
              /* id 5, wireType 0 =*/
              40).int32(message.isread);
              if (message.createtime != null && Object.hasOwnProperty.call(message, "createtime")) writer.uint32(
              /* id 6, wireType 2 =*/
              50).string(message.createtime);
              if (message.created != null && Object.hasOwnProperty.call(message, "created")) writer.uint32(
              /* id 7, wireType 0 =*/
              56).int64(message.created);
              return writer;
            };
            /**
            * Encodes the specified Maildata message, length delimited. Does not implicitly {@link serverProto.Maildata.verify|verify} messages.
            * @function encodeDelimited
            * @memberof serverProto.Maildata
            * @static
            * @param {serverProto.IMaildata} message Maildata message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            Maildata.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a Maildata message from the specified reader or buffer.
            * @function decode
            * @memberof serverProto.Maildata
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {serverProto.Maildata} Maildata
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            Maildata.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.serverProto.Maildata();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      message.idx = reader.int32();
                      break;
                    }

                  case 2:
                    {
                      message.accountid = reader.int32();
                      break;
                    }

                  case 3:
                    {
                      message.source = reader.int32();
                      break;
                    }

                  case 4:
                    {
                      message.content = $root.serverProto.Content.decode(reader, reader.uint32());
                      break;
                    }

                  case 5:
                    {
                      message.isread = reader.int32();
                      break;
                    }

                  case 6:
                    {
                      message.createtime = reader.string();
                      break;
                    }

                  case 7:
                    {
                      message.created = reader.int64();
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a Maildata message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof serverProto.Maildata
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {serverProto.Maildata} Maildata
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            Maildata.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a Maildata message.
            * @function verify
            * @memberof serverProto.Maildata
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            Maildata.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.idx != null && message.hasOwnProperty("idx")) if (!$util.isInteger(message.idx)) return "idx: integer expected";
              if (message.accountid != null && message.hasOwnProperty("accountid")) if (!$util.isInteger(message.accountid)) return "accountid: integer expected";
              if (message.source != null && message.hasOwnProperty("source")) if (!$util.isInteger(message.source)) return "source: integer expected";

              if (message.content != null && message.hasOwnProperty("content")) {
                var error = $root.serverProto.Content.verify(message.content);
                if (error) return "content." + error;
              }

              if (message.isread != null && message.hasOwnProperty("isread")) if (!$util.isInteger(message.isread)) return "isread: integer expected";
              if (message.createtime != null && message.hasOwnProperty("createtime")) if (!$util.isString(message.createtime)) return "createtime: string expected";
              if (message.created != null && message.hasOwnProperty("created")) if (!$util.isInteger(message.created) && !(message.created && $util.isInteger(message.created.low) && $util.isInteger(message.created.high))) return "created: integer|Long expected";
              return null;
            };
            /**
            * Creates a Maildata message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof serverProto.Maildata
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {serverProto.Maildata} Maildata
            */


            Maildata.fromObject = function fromObject(object) {
              if (object instanceof $root.serverProto.Maildata) return object;
              var message = new $root.serverProto.Maildata();
              if (object.idx != null) message.idx = object.idx | 0;
              if (object.accountid != null) message.accountid = object.accountid | 0;
              if (object.source != null) message.source = object.source | 0;

              if (object.content != null) {
                if (typeof object.content !== "object") throw TypeError(".serverProto.Maildata.content: object expected");
                message.content = $root.serverProto.Content.fromObject(object.content);
              }

              if (object.isread != null) message.isread = object.isread | 0;
              if (object.createtime != null) message.createtime = String(object.createtime);
              if (object.created != null) if ($util.Long) (message.created = $util.Long.fromValue(object.created)).unsigned = false;else if (typeof object.created === "string") message.created = parseInt(object.created, 10);else if (typeof object.created === "number") message.created = object.created;else if (typeof object.created === "object") message.created = new $util.LongBits(object.created.low >>> 0, object.created.high >>> 0).toNumber();
              return message;
            };
            /**
            * Creates a plain object from a Maildata message. Also converts values to other types if specified.
            * @function toObject
            * @memberof serverProto.Maildata
            * @static
            * @param {serverProto.Maildata} message Maildata
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            Maildata.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.idx = 0;
                object.accountid = 0;
                object.source = 0;
                object.content = null;
                object.isread = 0;
                object.createtime = "";

                if ($util.Long) {
                  var _long6 = new $util.Long(0, 0, false);

                  object.created = options.longs === String ? _long6.toString() : options.longs === Number ? _long6.toNumber() : _long6;
                } else object.created = options.longs === String ? "0" : 0;
              }

              if (message.idx != null && message.hasOwnProperty("idx")) object.idx = message.idx;
              if (message.accountid != null && message.hasOwnProperty("accountid")) object.accountid = message.accountid;
              if (message.source != null && message.hasOwnProperty("source")) object.source = message.source;
              if (message.content != null && message.hasOwnProperty("content")) object.content = $root.serverProto.Content.toObject(message.content, options);
              if (message.isread != null && message.hasOwnProperty("isread")) object.isread = message.isread;
              if (message.createtime != null && message.hasOwnProperty("createtime")) object.createtime = message.createtime;
              if (message.created != null && message.hasOwnProperty("created")) if (typeof message.created === "number") object.created = options.longs === String ? String(message.created) : message.created;else object.created = options.longs === String ? $util.Long.prototype.toString.call(message.created) : options.longs === Number ? new $util.LongBits(message.created.low >>> 0, message.created.high >>> 0).toNumber() : message.created;
              return object;
            };
            /**
            * Converts this Maildata to JSON.
            * @function toJSON
            * @memberof serverProto.Maildata
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            Maildata.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
            * Gets the default type url for Maildata
            * @function getTypeUrl
            * @memberof serverProto.Maildata
            * @static
            * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
            * @returns {string} The default type url
            */


            Maildata.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/serverProto.Maildata";
            };

            return Maildata;
          }();

          serverProto.Content = function () {
            /**
            * Properties of a Content.
            * @memberof serverProto
            * @interface IContent
            * @property {number|null} [action] Content action
            * @property {number|null} [gameid] Content gameid
            * @property {number|null} [itemid] Content itemid
            * @property {number|null} [amount] Content amount
            * @property {string|null} [createtime] Content createtime
            * @property {number|null} [wintype] Content wintype
            * @property {string|null} [msg] Content msg
            * @property {number|null} [star] Content star
            */

            /**
            * Constructs a new Content.
            * @memberof serverProto
            * @classdesc Represents a Content.
            * @implements IContent
            * @constructor
            * @param {serverProto.IContent=} [properties] Properties to set
            */
            function Content(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * Content action.
            * @member {number} action
            * @memberof serverProto.Content
            * @instance
            */


            Content.prototype.action = 0;
            /**
            * Content gameid.
            * @member {number} gameid
            * @memberof serverProto.Content
            * @instance
            */

            Content.prototype.gameid = 0;
            /**
            * Content itemid.
            * @member {number} itemid
            * @memberof serverProto.Content
            * @instance
            */

            Content.prototype.itemid = 0;
            /**
            * Content amount.
            * @member {number} amount
            * @memberof serverProto.Content
            * @instance
            */

            Content.prototype.amount = 0;
            /**
            * Content createtime.
            * @member {string} createtime
            * @memberof serverProto.Content
            * @instance
            */

            Content.prototype.createtime = "";
            /**
            * Content wintype.
            * @member {number} wintype
            * @memberof serverProto.Content
            * @instance
            */

            Content.prototype.wintype = 0;
            /**
            * Content msg.
            * @member {string} msg
            * @memberof serverProto.Content
            * @instance
            */

            Content.prototype.msg = "";
            /**
            * Content star.
            * @member {number} star
            * @memberof serverProto.Content
            * @instance
            */

            Content.prototype.star = 0;
            /**
            * Creates a new Content instance using the specified properties.
            * @function create
            * @memberof serverProto.Content
            * @static
            * @param {serverProto.IContent=} [properties] Properties to set
            * @returns {serverProto.Content} Content instance
            */

            Content.create = function create(properties) {
              return new Content(properties);
            };
            /**
            * Encodes the specified Content message. Does not implicitly {@link serverProto.Content.verify|verify} messages.
            * @function encode
            * @memberof serverProto.Content
            * @static
            * @param {serverProto.IContent} message Content message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            Content.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.action != null && Object.hasOwnProperty.call(message, "action")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.action);
              if (message.gameid != null && Object.hasOwnProperty.call(message, "gameid")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int32(message.gameid);
              if (message.itemid != null && Object.hasOwnProperty.call(message, "itemid")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.itemid);
              if (message.amount != null && Object.hasOwnProperty.call(message, "amount")) writer.uint32(
              /* id 4, wireType 1 =*/
              33)["double"](message.amount);
              if (message.createtime != null && Object.hasOwnProperty.call(message, "createtime")) writer.uint32(
              /* id 5, wireType 2 =*/
              42).string(message.createtime);
              if (message.wintype != null && Object.hasOwnProperty.call(message, "wintype")) writer.uint32(
              /* id 6, wireType 0 =*/
              48).int32(message.wintype);
              if (message.msg != null && Object.hasOwnProperty.call(message, "msg")) writer.uint32(
              /* id 7, wireType 2 =*/
              58).string(message.msg);
              if (message.star != null && Object.hasOwnProperty.call(message, "star")) writer.uint32(
              /* id 8, wireType 0 =*/
              64).int32(message.star);
              return writer;
            };
            /**
            * Encodes the specified Content message, length delimited. Does not implicitly {@link serverProto.Content.verify|verify} messages.
            * @function encodeDelimited
            * @memberof serverProto.Content
            * @static
            * @param {serverProto.IContent} message Content message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            Content.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a Content message from the specified reader or buffer.
            * @function decode
            * @memberof serverProto.Content
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {serverProto.Content} Content
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            Content.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.serverProto.Content();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      message.action = reader.int32();
                      break;
                    }

                  case 2:
                    {
                      message.gameid = reader.int32();
                      break;
                    }

                  case 3:
                    {
                      message.itemid = reader.int32();
                      break;
                    }

                  case 4:
                    {
                      message.amount = reader["double"]();
                      break;
                    }

                  case 5:
                    {
                      message.createtime = reader.string();
                      break;
                    }

                  case 6:
                    {
                      message.wintype = reader.int32();
                      break;
                    }

                  case 7:
                    {
                      message.msg = reader.string();
                      break;
                    }

                  case 8:
                    {
                      message.star = reader.int32();
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a Content message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof serverProto.Content
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {serverProto.Content} Content
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            Content.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a Content message.
            * @function verify
            * @memberof serverProto.Content
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            Content.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.action != null && message.hasOwnProperty("action")) if (!$util.isInteger(message.action)) return "action: integer expected";
              if (message.gameid != null && message.hasOwnProperty("gameid")) if (!$util.isInteger(message.gameid)) return "gameid: integer expected";
              if (message.itemid != null && message.hasOwnProperty("itemid")) if (!$util.isInteger(message.itemid)) return "itemid: integer expected";
              if (message.amount != null && message.hasOwnProperty("amount")) if (typeof message.amount !== "number") return "amount: number expected";
              if (message.createtime != null && message.hasOwnProperty("createtime")) if (!$util.isString(message.createtime)) return "createtime: string expected";
              if (message.wintype != null && message.hasOwnProperty("wintype")) if (!$util.isInteger(message.wintype)) return "wintype: integer expected";
              if (message.msg != null && message.hasOwnProperty("msg")) if (!$util.isString(message.msg)) return "msg: string expected";
              if (message.star != null && message.hasOwnProperty("star")) if (!$util.isInteger(message.star)) return "star: integer expected";
              return null;
            };
            /**
            * Creates a Content message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof serverProto.Content
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {serverProto.Content} Content
            */


            Content.fromObject = function fromObject(object) {
              if (object instanceof $root.serverProto.Content) return object;
              var message = new $root.serverProto.Content();
              if (object.action != null) message.action = object.action | 0;
              if (object.gameid != null) message.gameid = object.gameid | 0;
              if (object.itemid != null) message.itemid = object.itemid | 0;
              if (object.amount != null) message.amount = Number(object.amount);
              if (object.createtime != null) message.createtime = String(object.createtime);
              if (object.wintype != null) message.wintype = object.wintype | 0;
              if (object.msg != null) message.msg = String(object.msg);
              if (object.star != null) message.star = object.star | 0;
              return message;
            };
            /**
            * Creates a plain object from a Content message. Also converts values to other types if specified.
            * @function toObject
            * @memberof serverProto.Content
            * @static
            * @param {serverProto.Content} message Content
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            Content.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.action = 0;
                object.gameid = 0;
                object.itemid = 0;
                object.amount = 0;
                object.createtime = "";
                object.wintype = 0;
                object.msg = "";
                object.star = 0;
              }

              if (message.action != null && message.hasOwnProperty("action")) object.action = message.action;
              if (message.gameid != null && message.hasOwnProperty("gameid")) object.gameid = message.gameid;
              if (message.itemid != null && message.hasOwnProperty("itemid")) object.itemid = message.itemid;
              if (message.amount != null && message.hasOwnProperty("amount")) object.amount = options.json && !isFinite(message.amount) ? String(message.amount) : message.amount;
              if (message.createtime != null && message.hasOwnProperty("createtime")) object.createtime = message.createtime;
              if (message.wintype != null && message.hasOwnProperty("wintype")) object.wintype = message.wintype;
              if (message.msg != null && message.hasOwnProperty("msg")) object.msg = message.msg;
              if (message.star != null && message.hasOwnProperty("star")) object.star = message.star;
              return object;
            };
            /**
            * Converts this Content to JSON.
            * @function toJSON
            * @memberof serverProto.Content
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            Content.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
            * Gets the default type url for Content
            * @function getTypeUrl
            * @memberof serverProto.Content
            * @static
            * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
            * @returns {string} The default type url
            */


            Content.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/serverProto.Content";
            };

            return Content;
          }();

          serverProto.GetUserMail = function () {
            /**
            * Properties of a GetUserMail.
            * @memberof serverProto
            * @interface IGetUserMail
            * @property {serverProto.IMailInfo|null} [info] GetUserMail info
            * @property {number|null} [ret] GetUserMail ret
            */

            /**
            * Constructs a new GetUserMail.
            * @memberof serverProto
            * @classdesc Represents a GetUserMail.
            * @implements IGetUserMail
            * @constructor
            * @param {serverProto.IGetUserMail=} [properties] Properties to set
            */
            function GetUserMail(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * GetUserMail info.
            * @member {serverProto.IMailInfo|null|undefined} info
            * @memberof serverProto.GetUserMail
            * @instance
            */


            GetUserMail.prototype.info = null;
            /**
            * GetUserMail ret.
            * @member {number} ret
            * @memberof serverProto.GetUserMail
            * @instance
            */

            GetUserMail.prototype.ret = 0;
            /**
            * Creates a new GetUserMail instance using the specified properties.
            * @function create
            * @memberof serverProto.GetUserMail
            * @static
            * @param {serverProto.IGetUserMail=} [properties] Properties to set
            * @returns {serverProto.GetUserMail} GetUserMail instance
            */

            GetUserMail.create = function create(properties) {
              return new GetUserMail(properties);
            };
            /**
            * Encodes the specified GetUserMail message. Does not implicitly {@link serverProto.GetUserMail.verify|verify} messages.
            * @function encode
            * @memberof serverProto.GetUserMail
            * @static
            * @param {serverProto.IGetUserMail} message GetUserMail message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            GetUserMail.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.info != null && Object.hasOwnProperty.call(message, "info")) $root.serverProto.MailInfo.encode(message.info, writer.uint32(
              /* id 1, wireType 2 =*/
              10).fork()).ldelim();
              if (message.ret != null && Object.hasOwnProperty.call(message, "ret")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int32(message.ret);
              return writer;
            };
            /**
            * Encodes the specified GetUserMail message, length delimited. Does not implicitly {@link serverProto.GetUserMail.verify|verify} messages.
            * @function encodeDelimited
            * @memberof serverProto.GetUserMail
            * @static
            * @param {serverProto.IGetUserMail} message GetUserMail message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            GetUserMail.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a GetUserMail message from the specified reader or buffer.
            * @function decode
            * @memberof serverProto.GetUserMail
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {serverProto.GetUserMail} GetUserMail
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            GetUserMail.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.serverProto.GetUserMail();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      message.info = $root.serverProto.MailInfo.decode(reader, reader.uint32());
                      break;
                    }

                  case 2:
                    {
                      message.ret = reader.int32();
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a GetUserMail message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof serverProto.GetUserMail
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {serverProto.GetUserMail} GetUserMail
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            GetUserMail.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a GetUserMail message.
            * @function verify
            * @memberof serverProto.GetUserMail
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            GetUserMail.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";

              if (message.info != null && message.hasOwnProperty("info")) {
                var error = $root.serverProto.MailInfo.verify(message.info);
                if (error) return "info." + error;
              }

              if (message.ret != null && message.hasOwnProperty("ret")) if (!$util.isInteger(message.ret)) return "ret: integer expected";
              return null;
            };
            /**
            * Creates a GetUserMail message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof serverProto.GetUserMail
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {serverProto.GetUserMail} GetUserMail
            */


            GetUserMail.fromObject = function fromObject(object) {
              if (object instanceof $root.serverProto.GetUserMail) return object;
              var message = new $root.serverProto.GetUserMail();

              if (object.info != null) {
                if (typeof object.info !== "object") throw TypeError(".serverProto.GetUserMail.info: object expected");
                message.info = $root.serverProto.MailInfo.fromObject(object.info);
              }

              if (object.ret != null) message.ret = object.ret | 0;
              return message;
            };
            /**
            * Creates a plain object from a GetUserMail message. Also converts values to other types if specified.
            * @function toObject
            * @memberof serverProto.GetUserMail
            * @static
            * @param {serverProto.GetUserMail} message GetUserMail
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            GetUserMail.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.info = null;
                object.ret = 0;
              }

              if (message.info != null && message.hasOwnProperty("info")) object.info = $root.serverProto.MailInfo.toObject(message.info, options);
              if (message.ret != null && message.hasOwnProperty("ret")) object.ret = message.ret;
              return object;
            };
            /**
            * Converts this GetUserMail to JSON.
            * @function toJSON
            * @memberof serverProto.GetUserMail
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            GetUserMail.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
            * Gets the default type url for GetUserMail
            * @function getTypeUrl
            * @memberof serverProto.GetUserMail
            * @static
            * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
            * @returns {string} The default type url
            */


            GetUserMail.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/serverProto.GetUserMail";
            };

            return GetUserMail;
          }();

          serverProto.ReadMailResp = function () {
            /**
            * Properties of a ReadMailResp.
            * @memberof serverProto
            * @interface IReadMailResp
            * @property {serverProto.IReadMailInfo|null} [info] ReadMailResp info
            * @property {number|null} [ret] ReadMailResp ret
            */

            /**
            * Constructs a new ReadMailResp.
            * @memberof serverProto
            * @classdesc Represents a ReadMailResp.
            * @implements IReadMailResp
            * @constructor
            * @param {serverProto.IReadMailResp=} [properties] Properties to set
            */
            function ReadMailResp(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * ReadMailResp info.
            * @member {serverProto.IReadMailInfo|null|undefined} info
            * @memberof serverProto.ReadMailResp
            * @instance
            */


            ReadMailResp.prototype.info = null;
            /**
            * ReadMailResp ret.
            * @member {number} ret
            * @memberof serverProto.ReadMailResp
            * @instance
            */

            ReadMailResp.prototype.ret = 0;
            /**
            * Creates a new ReadMailResp instance using the specified properties.
            * @function create
            * @memberof serverProto.ReadMailResp
            * @static
            * @param {serverProto.IReadMailResp=} [properties] Properties to set
            * @returns {serverProto.ReadMailResp} ReadMailResp instance
            */

            ReadMailResp.create = function create(properties) {
              return new ReadMailResp(properties);
            };
            /**
            * Encodes the specified ReadMailResp message. Does not implicitly {@link serverProto.ReadMailResp.verify|verify} messages.
            * @function encode
            * @memberof serverProto.ReadMailResp
            * @static
            * @param {serverProto.IReadMailResp} message ReadMailResp message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            ReadMailResp.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.info != null && Object.hasOwnProperty.call(message, "info")) $root.serverProto.ReadMailInfo.encode(message.info, writer.uint32(
              /* id 1, wireType 2 =*/
              10).fork()).ldelim();
              if (message.ret != null && Object.hasOwnProperty.call(message, "ret")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int32(message.ret);
              return writer;
            };
            /**
            * Encodes the specified ReadMailResp message, length delimited. Does not implicitly {@link serverProto.ReadMailResp.verify|verify} messages.
            * @function encodeDelimited
            * @memberof serverProto.ReadMailResp
            * @static
            * @param {serverProto.IReadMailResp} message ReadMailResp message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            ReadMailResp.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a ReadMailResp message from the specified reader or buffer.
            * @function decode
            * @memberof serverProto.ReadMailResp
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {serverProto.ReadMailResp} ReadMailResp
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            ReadMailResp.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.serverProto.ReadMailResp();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      message.info = $root.serverProto.ReadMailInfo.decode(reader, reader.uint32());
                      break;
                    }

                  case 2:
                    {
                      message.ret = reader.int32();
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a ReadMailResp message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof serverProto.ReadMailResp
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {serverProto.ReadMailResp} ReadMailResp
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            ReadMailResp.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a ReadMailResp message.
            * @function verify
            * @memberof serverProto.ReadMailResp
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            ReadMailResp.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";

              if (message.info != null && message.hasOwnProperty("info")) {
                var error = $root.serverProto.ReadMailInfo.verify(message.info);
                if (error) return "info." + error;
              }

              if (message.ret != null && message.hasOwnProperty("ret")) if (!$util.isInteger(message.ret)) return "ret: integer expected";
              return null;
            };
            /**
            * Creates a ReadMailResp message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof serverProto.ReadMailResp
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {serverProto.ReadMailResp} ReadMailResp
            */


            ReadMailResp.fromObject = function fromObject(object) {
              if (object instanceof $root.serverProto.ReadMailResp) return object;
              var message = new $root.serverProto.ReadMailResp();

              if (object.info != null) {
                if (typeof object.info !== "object") throw TypeError(".serverProto.ReadMailResp.info: object expected");
                message.info = $root.serverProto.ReadMailInfo.fromObject(object.info);
              }

              if (object.ret != null) message.ret = object.ret | 0;
              return message;
            };
            /**
            * Creates a plain object from a ReadMailResp message. Also converts values to other types if specified.
            * @function toObject
            * @memberof serverProto.ReadMailResp
            * @static
            * @param {serverProto.ReadMailResp} message ReadMailResp
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            ReadMailResp.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.info = null;
                object.ret = 0;
              }

              if (message.info != null && message.hasOwnProperty("info")) object.info = $root.serverProto.ReadMailInfo.toObject(message.info, options);
              if (message.ret != null && message.hasOwnProperty("ret")) object.ret = message.ret;
              return object;
            };
            /**
            * Converts this ReadMailResp to JSON.
            * @function toJSON
            * @memberof serverProto.ReadMailResp
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            ReadMailResp.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
            * Gets the default type url for ReadMailResp
            * @function getTypeUrl
            * @memberof serverProto.ReadMailResp
            * @static
            * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
            * @returns {string} The default type url
            */


            ReadMailResp.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/serverProto.ReadMailResp";
            };

            return ReadMailResp;
          }();

          serverProto.ReadMailInfo = function () {
            /**
            * Properties of a ReadMailInfo.
            * @memberof serverProto
            * @interface IReadMailInfo
            * @property {number|null} [result] ReadMailInfo result
            */

            /**
            * Constructs a new ReadMailInfo.
            * @memberof serverProto
            * @classdesc Represents a ReadMailInfo.
            * @implements IReadMailInfo
            * @constructor
            * @param {serverProto.IReadMailInfo=} [properties] Properties to set
            */
            function ReadMailInfo(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * ReadMailInfo result.
            * @member {number} result
            * @memberof serverProto.ReadMailInfo
            * @instance
            */


            ReadMailInfo.prototype.result = 0;
            /**
            * Creates a new ReadMailInfo instance using the specified properties.
            * @function create
            * @memberof serverProto.ReadMailInfo
            * @static
            * @param {serverProto.IReadMailInfo=} [properties] Properties to set
            * @returns {serverProto.ReadMailInfo} ReadMailInfo instance
            */

            ReadMailInfo.create = function create(properties) {
              return new ReadMailInfo(properties);
            };
            /**
            * Encodes the specified ReadMailInfo message. Does not implicitly {@link serverProto.ReadMailInfo.verify|verify} messages.
            * @function encode
            * @memberof serverProto.ReadMailInfo
            * @static
            * @param {serverProto.IReadMailInfo} message ReadMailInfo message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            ReadMailInfo.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.result != null && Object.hasOwnProperty.call(message, "result")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.result);
              return writer;
            };
            /**
            * Encodes the specified ReadMailInfo message, length delimited. Does not implicitly {@link serverProto.ReadMailInfo.verify|verify} messages.
            * @function encodeDelimited
            * @memberof serverProto.ReadMailInfo
            * @static
            * @param {serverProto.IReadMailInfo} message ReadMailInfo message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            ReadMailInfo.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a ReadMailInfo message from the specified reader or buffer.
            * @function decode
            * @memberof serverProto.ReadMailInfo
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {serverProto.ReadMailInfo} ReadMailInfo
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            ReadMailInfo.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.serverProto.ReadMailInfo();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      message.result = reader.int32();
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a ReadMailInfo message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof serverProto.ReadMailInfo
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {serverProto.ReadMailInfo} ReadMailInfo
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            ReadMailInfo.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a ReadMailInfo message.
            * @function verify
            * @memberof serverProto.ReadMailInfo
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            ReadMailInfo.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.result != null && message.hasOwnProperty("result")) if (!$util.isInteger(message.result)) return "result: integer expected";
              return null;
            };
            /**
            * Creates a ReadMailInfo message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof serverProto.ReadMailInfo
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {serverProto.ReadMailInfo} ReadMailInfo
            */


            ReadMailInfo.fromObject = function fromObject(object) {
              if (object instanceof $root.serverProto.ReadMailInfo) return object;
              var message = new $root.serverProto.ReadMailInfo();
              if (object.result != null) message.result = object.result | 0;
              return message;
            };
            /**
            * Creates a plain object from a ReadMailInfo message. Also converts values to other types if specified.
            * @function toObject
            * @memberof serverProto.ReadMailInfo
            * @static
            * @param {serverProto.ReadMailInfo} message ReadMailInfo
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            ReadMailInfo.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};
              if (options.defaults) object.result = 0;
              if (message.result != null && message.hasOwnProperty("result")) object.result = message.result;
              return object;
            };
            /**
            * Converts this ReadMailInfo to JSON.
            * @function toJSON
            * @memberof serverProto.ReadMailInfo
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            ReadMailInfo.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
            * Gets the default type url for ReadMailInfo
            * @function getTypeUrl
            * @memberof serverProto.ReadMailInfo
            * @static
            * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
            * @returns {string} The default type url
            */


            ReadMailInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/serverProto.ReadMailInfo";
            };

            return ReadMailInfo;
          }();

          serverProto.doubleArray = function () {
            /**
            * Properties of a doubleArray.
            * @memberof serverProto
            * @interface IdoubleArray
            * @property {Array.<number>|null} [value] doubleArray value
            */

            /**
            * Constructs a new doubleArray.
            * @memberof serverProto
            * @classdesc Represents a doubleArray.
            * @implements IdoubleArray
            * @constructor
            * @param {serverProto.IdoubleArray=} [properties] Properties to set
            */
            function doubleArray(properties) {
              this.value = [];
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * doubleArray value.
            * @member {Array.<number>} value
            * @memberof serverProto.doubleArray
            * @instance
            */


            doubleArray.prototype.value = $util.emptyArray;
            /**
            * Creates a new doubleArray instance using the specified properties.
            * @function create
            * @memberof serverProto.doubleArray
            * @static
            * @param {serverProto.IdoubleArray=} [properties] Properties to set
            * @returns {serverProto.doubleArray} doubleArray instance
            */

            doubleArray.create = function create(properties) {
              return new doubleArray(properties);
            };
            /**
            * Encodes the specified doubleArray message. Does not implicitly {@link serverProto.doubleArray.verify|verify} messages.
            * @function encode
            * @memberof serverProto.doubleArray
            * @static
            * @param {serverProto.IdoubleArray} message doubleArray message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            doubleArray.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();

              if (message.value != null && message.value.length) {
                writer.uint32(
                /* id 1, wireType 2 =*/
                10).fork();

                for (var i = 0; i < message.value.length; ++i) {
                  writer["double"](message.value[i]);
                }

                writer.ldelim();
              }

              return writer;
            };
            /**
            * Encodes the specified doubleArray message, length delimited. Does not implicitly {@link serverProto.doubleArray.verify|verify} messages.
            * @function encodeDelimited
            * @memberof serverProto.doubleArray
            * @static
            * @param {serverProto.IdoubleArray} message doubleArray message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            doubleArray.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a doubleArray message from the specified reader or buffer.
            * @function decode
            * @memberof serverProto.doubleArray
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {serverProto.doubleArray} doubleArray
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            doubleArray.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.serverProto.doubleArray();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      if (!(message.value && message.value.length)) message.value = [];

                      if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;

                        while (reader.pos < end2) {
                          message.value.push(reader["double"]());
                        }
                      } else message.value.push(reader["double"]());

                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a doubleArray message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof serverProto.doubleArray
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {serverProto.doubleArray} doubleArray
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            doubleArray.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a doubleArray message.
            * @function verify
            * @memberof serverProto.doubleArray
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            doubleArray.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";

              if (message.value != null && message.hasOwnProperty("value")) {
                if (!Array.isArray(message.value)) return "value: array expected";

                for (var i = 0; i < message.value.length; ++i) {
                  if (typeof message.value[i] !== "number") return "value: number[] expected";
                }
              }

              return null;
            };
            /**
            * Creates a doubleArray message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof serverProto.doubleArray
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {serverProto.doubleArray} doubleArray
            */


            doubleArray.fromObject = function fromObject(object) {
              if (object instanceof $root.serverProto.doubleArray) return object;
              var message = new $root.serverProto.doubleArray();

              if (object.value) {
                if (!Array.isArray(object.value)) throw TypeError(".serverProto.doubleArray.value: array expected");
                message.value = [];

                for (var i = 0; i < object.value.length; ++i) {
                  message.value[i] = Number(object.value[i]);
                }
              }

              return message;
            };
            /**
            * Creates a plain object from a doubleArray message. Also converts values to other types if specified.
            * @function toObject
            * @memberof serverProto.doubleArray
            * @static
            * @param {serverProto.doubleArray} message doubleArray
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            doubleArray.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};
              if (options.arrays || options.defaults) object.value = [];

              if (message.value && message.value.length) {
                object.value = [];

                for (var j = 0; j < message.value.length; ++j) {
                  object.value[j] = options.json && !isFinite(message.value[j]) ? String(message.value[j]) : message.value[j];
                }
              }

              return object;
            };
            /**
            * Converts this doubleArray to JSON.
            * @function toJSON
            * @memberof serverProto.doubleArray
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            doubleArray.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
            * Gets the default type url for doubleArray
            * @function getTypeUrl
            * @memberof serverProto.doubleArray
            * @static
            * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
            * @returns {string} The default type url
            */


            doubleArray.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/serverProto.doubleArray";
            };

            return doubleArray;
          }();

          serverProto.uint32Array = function () {
            /**
            * Properties of an uint32Array.
            * @memberof serverProto
            * @interface Iuint32Array
            * @property {Array.<number>|null} [value] uint32Array value
            */

            /**
            * Constructs a new uint32Array.
            * @memberof serverProto
            * @classdesc Represents an uint32Array.
            * @implements Iuint32Array
            * @constructor
            * @param {serverProto.Iuint32Array=} [properties] Properties to set
            */
            function uint32Array(properties) {
              this.value = [];
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * uint32Array value.
            * @member {Array.<number>} value
            * @memberof serverProto.uint32Array
            * @instance
            */


            uint32Array.prototype.value = $util.emptyArray;
            /**
            * Creates a new uint32Array instance using the specified properties.
            * @function create
            * @memberof serverProto.uint32Array
            * @static
            * @param {serverProto.Iuint32Array=} [properties] Properties to set
            * @returns {serverProto.uint32Array} uint32Array instance
            */

            uint32Array.create = function create(properties) {
              return new uint32Array(properties);
            };
            /**
            * Encodes the specified uint32Array message. Does not implicitly {@link serverProto.uint32Array.verify|verify} messages.
            * @function encode
            * @memberof serverProto.uint32Array
            * @static
            * @param {serverProto.Iuint32Array} message uint32Array message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            uint32Array.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();

              if (message.value != null && message.value.length) {
                writer.uint32(
                /* id 1, wireType 2 =*/
                10).fork();

                for (var i = 0; i < message.value.length; ++i) {
                  writer.uint32(message.value[i]);
                }

                writer.ldelim();
              }

              return writer;
            };
            /**
            * Encodes the specified uint32Array message, length delimited. Does not implicitly {@link serverProto.uint32Array.verify|verify} messages.
            * @function encodeDelimited
            * @memberof serverProto.uint32Array
            * @static
            * @param {serverProto.Iuint32Array} message uint32Array message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            uint32Array.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes an uint32Array message from the specified reader or buffer.
            * @function decode
            * @memberof serverProto.uint32Array
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {serverProto.uint32Array} uint32Array
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            uint32Array.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.serverProto.uint32Array();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      if (!(message.value && message.value.length)) message.value = [];

                      if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;

                        while (reader.pos < end2) {
                          message.value.push(reader.uint32());
                        }
                      } else message.value.push(reader.uint32());

                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes an uint32Array message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof serverProto.uint32Array
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {serverProto.uint32Array} uint32Array
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            uint32Array.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies an uint32Array message.
            * @function verify
            * @memberof serverProto.uint32Array
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            uint32Array.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";

              if (message.value != null && message.hasOwnProperty("value")) {
                if (!Array.isArray(message.value)) return "value: array expected";

                for (var i = 0; i < message.value.length; ++i) {
                  if (!$util.isInteger(message.value[i])) return "value: integer[] expected";
                }
              }

              return null;
            };
            /**
            * Creates an uint32Array message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof serverProto.uint32Array
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {serverProto.uint32Array} uint32Array
            */


            uint32Array.fromObject = function fromObject(object) {
              if (object instanceof $root.serverProto.uint32Array) return object;
              var message = new $root.serverProto.uint32Array();

              if (object.value) {
                if (!Array.isArray(object.value)) throw TypeError(".serverProto.uint32Array.value: array expected");
                message.value = [];

                for (var i = 0; i < object.value.length; ++i) {
                  message.value[i] = object.value[i] >>> 0;
                }
              }

              return message;
            };
            /**
            * Creates a plain object from an uint32Array message. Also converts values to other types if specified.
            * @function toObject
            * @memberof serverProto.uint32Array
            * @static
            * @param {serverProto.uint32Array} message uint32Array
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            uint32Array.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};
              if (options.arrays || options.defaults) object.value = [];

              if (message.value && message.value.length) {
                object.value = [];

                for (var j = 0; j < message.value.length; ++j) {
                  object.value[j] = message.value[j];
                }
              }

              return object;
            };
            /**
            * Converts this uint32Array to JSON.
            * @function toJSON
            * @memberof serverProto.uint32Array
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            uint32Array.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
            * Gets the default type url for uint32Array
            * @function getTypeUrl
            * @memberof serverProto.uint32Array
            * @static
            * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
            * @returns {string} The default type url
            */


            uint32Array.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/serverProto.uint32Array";
            };

            return uint32Array;
          }();

          serverProto.DailyMissionInfo = function () {
            /**
            * Properties of a DailyMissionInfo.
            * @memberof serverProto
            * @interface IDailyMissionInfo
            * @property {string|null} [message] DailyMissionInfo message
            */

            /**
            * Constructs a new DailyMissionInfo.
            * @memberof serverProto
            * @classdesc Represents a DailyMissionInfo.
            * @implements IDailyMissionInfo
            * @constructor
            * @param {serverProto.IDailyMissionInfo=} [properties] Properties to set
            */
            function DailyMissionInfo(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * DailyMissionInfo message.
            * @member {string} message
            * @memberof serverProto.DailyMissionInfo
            * @instance
            */


            DailyMissionInfo.prototype.message = "";
            /**
            * Creates a new DailyMissionInfo instance using the specified properties.
            * @function create
            * @memberof serverProto.DailyMissionInfo
            * @static
            * @param {serverProto.IDailyMissionInfo=} [properties] Properties to set
            * @returns {serverProto.DailyMissionInfo} DailyMissionInfo instance
            */

            DailyMissionInfo.create = function create(properties) {
              return new DailyMissionInfo(properties);
            };
            /**
            * Encodes the specified DailyMissionInfo message. Does not implicitly {@link serverProto.DailyMissionInfo.verify|verify} messages.
            * @function encode
            * @memberof serverProto.DailyMissionInfo
            * @static
            * @param {serverProto.IDailyMissionInfo} message DailyMissionInfo message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            DailyMissionInfo.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.message != null && Object.hasOwnProperty.call(message, "message")) writer.uint32(
              /* id 1, wireType 2 =*/
              10).string(message.message);
              return writer;
            };
            /**
            * Encodes the specified DailyMissionInfo message, length delimited. Does not implicitly {@link serverProto.DailyMissionInfo.verify|verify} messages.
            * @function encodeDelimited
            * @memberof serverProto.DailyMissionInfo
            * @static
            * @param {serverProto.IDailyMissionInfo} message DailyMissionInfo message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            DailyMissionInfo.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a DailyMissionInfo message from the specified reader or buffer.
            * @function decode
            * @memberof serverProto.DailyMissionInfo
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {serverProto.DailyMissionInfo} DailyMissionInfo
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            DailyMissionInfo.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.serverProto.DailyMissionInfo();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      message.message = reader.string();
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a DailyMissionInfo message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof serverProto.DailyMissionInfo
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {serverProto.DailyMissionInfo} DailyMissionInfo
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            DailyMissionInfo.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a DailyMissionInfo message.
            * @function verify
            * @memberof serverProto.DailyMissionInfo
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            DailyMissionInfo.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.message != null && message.hasOwnProperty("message")) if (!$util.isString(message.message)) return "message: string expected";
              return null;
            };
            /**
            * Creates a DailyMissionInfo message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof serverProto.DailyMissionInfo
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {serverProto.DailyMissionInfo} DailyMissionInfo
            */


            DailyMissionInfo.fromObject = function fromObject(object) {
              if (object instanceof $root.serverProto.DailyMissionInfo) return object;
              var message = new $root.serverProto.DailyMissionInfo();
              if (object.message != null) message.message = String(object.message);
              return message;
            };
            /**
            * Creates a plain object from a DailyMissionInfo message. Also converts values to other types if specified.
            * @function toObject
            * @memberof serverProto.DailyMissionInfo
            * @static
            * @param {serverProto.DailyMissionInfo} message DailyMissionInfo
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            DailyMissionInfo.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};
              if (options.defaults) object.message = "";
              if (message.message != null && message.hasOwnProperty("message")) object.message = message.message;
              return object;
            };
            /**
            * Converts this DailyMissionInfo to JSON.
            * @function toJSON
            * @memberof serverProto.DailyMissionInfo
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            DailyMissionInfo.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
            * Gets the default type url for DailyMissionInfo
            * @function getTypeUrl
            * @memberof serverProto.DailyMissionInfo
            * @static
            * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
            * @returns {string} The default type url
            */


            DailyMissionInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/serverProto.DailyMissionInfo";
            };

            return DailyMissionInfo;
          }();

          serverProto.TrialBet = function () {
            /**
            * Properties of a TrialBet.
            * @memberof serverProto
            * @interface ITrialBet
            * @property {number|Long|null} [bet] TrialBet bet
            * @property {number|null} [actno] TrialBet actno
            * @property {number|null} [currencyNumber] TrialBet currencyNumber
            * @property {number|null} [vip] TrialBet vip
            * @property {Uint8Array|null} [customReq] TrialBet customReq
            */

            /**
            * Constructs a new TrialBet.
            * @memberof serverProto
            * @classdesc Represents a TrialBet.
            * @implements ITrialBet
            * @constructor
            * @param {serverProto.ITrialBet=} [properties] Properties to set
            */
            function TrialBet(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * TrialBet bet.
            * @member {number|Long} bet
            * @memberof serverProto.TrialBet
            * @instance
            */


            TrialBet.prototype.bet = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
            * TrialBet actno.
            * @member {number} actno
            * @memberof serverProto.TrialBet
            * @instance
            */

            TrialBet.prototype.actno = 0;
            /**
            * TrialBet currencyNumber.
            * @member {number} currencyNumber
            * @memberof serverProto.TrialBet
            * @instance
            */

            TrialBet.prototype.currencyNumber = 0;
            /**
            * TrialBet vip.
            * @member {number} vip
            * @memberof serverProto.TrialBet
            * @instance
            */

            TrialBet.prototype.vip = 0;
            /**
            * TrialBet customReq.
            * @member {Uint8Array} customReq
            * @memberof serverProto.TrialBet
            * @instance
            */

            TrialBet.prototype.customReq = $util.newBuffer([]);
            /**
            * Creates a new TrialBet instance using the specified properties.
            * @function create
            * @memberof serverProto.TrialBet
            * @static
            * @param {serverProto.ITrialBet=} [properties] Properties to set
            * @returns {serverProto.TrialBet} TrialBet instance
            */

            TrialBet.create = function create(properties) {
              return new TrialBet(properties);
            };
            /**
            * Encodes the specified TrialBet message. Does not implicitly {@link serverProto.TrialBet.verify|verify} messages.
            * @function encode
            * @memberof serverProto.TrialBet
            * @static
            * @param {serverProto.ITrialBet} message TrialBet message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            TrialBet.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.bet != null && Object.hasOwnProperty.call(message, "bet")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int64(message.bet);
              if (message.actno != null && Object.hasOwnProperty.call(message, "actno")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int32(message.actno);
              if (message.currencyNumber != null && Object.hasOwnProperty.call(message, "currencyNumber")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.currencyNumber);
              if (message.vip != null && Object.hasOwnProperty.call(message, "vip")) writer.uint32(
              /* id 4, wireType 0 =*/
              32).uint32(message.vip);
              if (message.customReq != null && Object.hasOwnProperty.call(message, "customReq")) writer.uint32(
              /* id 5, wireType 2 =*/
              42).bytes(message.customReq);
              return writer;
            };
            /**
            * Encodes the specified TrialBet message, length delimited. Does not implicitly {@link serverProto.TrialBet.verify|verify} messages.
            * @function encodeDelimited
            * @memberof serverProto.TrialBet
            * @static
            * @param {serverProto.ITrialBet} message TrialBet message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            TrialBet.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a TrialBet message from the specified reader or buffer.
            * @function decode
            * @memberof serverProto.TrialBet
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {serverProto.TrialBet} TrialBet
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            TrialBet.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.serverProto.TrialBet();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      message.bet = reader.int64();
                      break;
                    }

                  case 2:
                    {
                      message.actno = reader.int32();
                      break;
                    }

                  case 3:
                    {
                      message.currencyNumber = reader.int32();
                      break;
                    }

                  case 4:
                    {
                      message.vip = reader.uint32();
                      break;
                    }

                  case 5:
                    {
                      message.customReq = reader.bytes();
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a TrialBet message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof serverProto.TrialBet
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {serverProto.TrialBet} TrialBet
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            TrialBet.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a TrialBet message.
            * @function verify
            * @memberof serverProto.TrialBet
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            TrialBet.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.bet != null && message.hasOwnProperty("bet")) if (!$util.isInteger(message.bet) && !(message.bet && $util.isInteger(message.bet.low) && $util.isInteger(message.bet.high))) return "bet: integer|Long expected";
              if (message.actno != null && message.hasOwnProperty("actno")) if (!$util.isInteger(message.actno)) return "actno: integer expected";
              if (message.currencyNumber != null && message.hasOwnProperty("currencyNumber")) if (!$util.isInteger(message.currencyNumber)) return "currencyNumber: integer expected";
              if (message.vip != null && message.hasOwnProperty("vip")) if (!$util.isInteger(message.vip)) return "vip: integer expected";
              if (message.customReq != null && message.hasOwnProperty("customReq")) if (!(message.customReq && typeof message.customReq.length === "number" || $util.isString(message.customReq))) return "customReq: buffer expected";
              return null;
            };
            /**
            * Creates a TrialBet message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof serverProto.TrialBet
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {serverProto.TrialBet} TrialBet
            */


            TrialBet.fromObject = function fromObject(object) {
              if (object instanceof $root.serverProto.TrialBet) return object;
              var message = new $root.serverProto.TrialBet();
              if (object.bet != null) if ($util.Long) (message.bet = $util.Long.fromValue(object.bet)).unsigned = false;else if (typeof object.bet === "string") message.bet = parseInt(object.bet, 10);else if (typeof object.bet === "number") message.bet = object.bet;else if (typeof object.bet === "object") message.bet = new $util.LongBits(object.bet.low >>> 0, object.bet.high >>> 0).toNumber();
              if (object.actno != null) message.actno = object.actno | 0;
              if (object.currencyNumber != null) message.currencyNumber = object.currencyNumber | 0;
              if (object.vip != null) message.vip = object.vip >>> 0;
              if (object.customReq != null) if (typeof object.customReq === "string") $util.base64.decode(object.customReq, message.customReq = $util.newBuffer($util.base64.length(object.customReq)), 0);else if (object.customReq.length >= 0) message.customReq = object.customReq;
              return message;
            };
            /**
            * Creates a plain object from a TrialBet message. Also converts values to other types if specified.
            * @function toObject
            * @memberof serverProto.TrialBet
            * @static
            * @param {serverProto.TrialBet} message TrialBet
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            TrialBet.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                if ($util.Long) {
                  var _long7 = new $util.Long(0, 0, false);

                  object.bet = options.longs === String ? _long7.toString() : options.longs === Number ? _long7.toNumber() : _long7;
                } else object.bet = options.longs === String ? "0" : 0;

                object.actno = 0;
                object.currencyNumber = 0;
                object.vip = 0;
                if (options.bytes === String) object.customReq = "";else {
                  object.customReq = [];
                  if (options.bytes !== Array) object.customReq = $util.newBuffer(object.customReq);
                }
              }

              if (message.bet != null && message.hasOwnProperty("bet")) if (typeof message.bet === "number") object.bet = options.longs === String ? String(message.bet) : message.bet;else object.bet = options.longs === String ? $util.Long.prototype.toString.call(message.bet) : options.longs === Number ? new $util.LongBits(message.bet.low >>> 0, message.bet.high >>> 0).toNumber() : message.bet;
              if (message.actno != null && message.hasOwnProperty("actno")) object.actno = message.actno;
              if (message.currencyNumber != null && message.hasOwnProperty("currencyNumber")) object.currencyNumber = message.currencyNumber;
              if (message.vip != null && message.hasOwnProperty("vip")) object.vip = message.vip;
              if (message.customReq != null && message.hasOwnProperty("customReq")) object.customReq = options.bytes === String ? $util.base64.encode(message.customReq, 0, message.customReq.length) : options.bytes === Array ? Array.prototype.slice.call(message.customReq) : message.customReq;
              return object;
            };
            /**
            * Converts this TrialBet to JSON.
            * @function toJSON
            * @memberof serverProto.TrialBet
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            TrialBet.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
            * Gets the default type url for TrialBet
            * @function getTypeUrl
            * @memberof serverProto.TrialBet
            * @static
            * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
            * @returns {string} The default type url
            */


            TrialBet.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/serverProto.TrialBet";
            };

            return TrialBet;
          }();

          serverProto.TrialInfo = function () {
            /**
            * Properties of a TrialInfo.
            * @memberof serverProto
            * @interface ITrialInfo
            * @property {number|null} [acktype] TrialInfo acktype
            * @property {number|null} [nowactno] TrialInfo nowactno
            * @property {number|null} [targettype] TrialInfo targettype
            * @property {Array.<serverProto.ITrialAwardData>|null} [awarddesc] TrialInfo awarddesc
            * @property {number|null} [pstate] TrialInfo pstate
            * @property {serverProto.ITrialPlayer|null} [trialinfo] TrialInfo trialinfo
            * @property {Array.<number>|null} [bet] TrialInfo bet
            * @property {boolean|null} [remind] TrialInfo remind
            * @property {serverProto.ITrialAwardData|null} [remindinfo] TrialInfo remindinfo
            * @property {Array.<number>|null} [rtags] TrialInfo rtags
            * @property {number|Long|null} [start] TrialInfo start
            * @property {number|Long|null} [end] TrialInfo end
            */

            /**
            * Constructs a new TrialInfo.
            * @memberof serverProto
            * @classdesc Represents a TrialInfo.
            * @implements ITrialInfo
            * @constructor
            * @param {serverProto.ITrialInfo=} [properties] Properties to set
            */
            function TrialInfo(properties) {
              this.awarddesc = [];
              this.bet = [];
              this.rtags = [];
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * TrialInfo acktype.
            * @member {number} acktype
            * @memberof serverProto.TrialInfo
            * @instance
            */


            TrialInfo.prototype.acktype = 0;
            /**
            * TrialInfo nowactno.
            * @member {number} nowactno
            * @memberof serverProto.TrialInfo
            * @instance
            */

            TrialInfo.prototype.nowactno = 0;
            /**
            * TrialInfo targettype.
            * @member {number} targettype
            * @memberof serverProto.TrialInfo
            * @instance
            */

            TrialInfo.prototype.targettype = 0;
            /**
            * TrialInfo awarddesc.
            * @member {Array.<serverProto.ITrialAwardData>} awarddesc
            * @memberof serverProto.TrialInfo
            * @instance
            */

            TrialInfo.prototype.awarddesc = $util.emptyArray;
            /**
            * TrialInfo pstate.
            * @member {number} pstate
            * @memberof serverProto.TrialInfo
            * @instance
            */

            TrialInfo.prototype.pstate = 0;
            /**
            * TrialInfo trialinfo.
            * @member {serverProto.ITrialPlayer|null|undefined} trialinfo
            * @memberof serverProto.TrialInfo
            * @instance
            */

            TrialInfo.prototype.trialinfo = null;
            /**
            * TrialInfo bet.
            * @member {Array.<number>} bet
            * @memberof serverProto.TrialInfo
            * @instance
            */

            TrialInfo.prototype.bet = $util.emptyArray;
            /**
            * TrialInfo remind.
            * @member {boolean} remind
            * @memberof serverProto.TrialInfo
            * @instance
            */

            TrialInfo.prototype.remind = false;
            /**
            * TrialInfo remindinfo.
            * @member {serverProto.ITrialAwardData|null|undefined} remindinfo
            * @memberof serverProto.TrialInfo
            * @instance
            */

            TrialInfo.prototype.remindinfo = null;
            /**
            * TrialInfo rtags.
            * @member {Array.<number>} rtags
            * @memberof serverProto.TrialInfo
            * @instance
            */

            TrialInfo.prototype.rtags = $util.emptyArray;
            /**
            * TrialInfo start.
            * @member {number|Long} start
            * @memberof serverProto.TrialInfo
            * @instance
            */

            TrialInfo.prototype.start = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
            * TrialInfo end.
            * @member {number|Long} end
            * @memberof serverProto.TrialInfo
            * @instance
            */

            TrialInfo.prototype.end = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
            * Creates a new TrialInfo instance using the specified properties.
            * @function create
            * @memberof serverProto.TrialInfo
            * @static
            * @param {serverProto.ITrialInfo=} [properties] Properties to set
            * @returns {serverProto.TrialInfo} TrialInfo instance
            */

            TrialInfo.create = function create(properties) {
              return new TrialInfo(properties);
            };
            /**
            * Encodes the specified TrialInfo message. Does not implicitly {@link serverProto.TrialInfo.verify|verify} messages.
            * @function encode
            * @memberof serverProto.TrialInfo
            * @static
            * @param {serverProto.ITrialInfo} message TrialInfo message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            TrialInfo.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.acktype != null && Object.hasOwnProperty.call(message, "acktype")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.acktype);
              if (message.nowactno != null && Object.hasOwnProperty.call(message, "nowactno")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int32(message.nowactno);
              if (message.targettype != null && Object.hasOwnProperty.call(message, "targettype")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.targettype);
              if (message.awarddesc != null && message.awarddesc.length) for (var i = 0; i < message.awarddesc.length; ++i) {
                $root.serverProto.TrialAwardData.encode(message.awarddesc[i], writer.uint32(
                /* id 4, wireType 2 =*/
                34).fork()).ldelim();
              }
              if (message.pstate != null && Object.hasOwnProperty.call(message, "pstate")) writer.uint32(
              /* id 5, wireType 0 =*/
              40).int32(message.pstate);
              if (message.trialinfo != null && Object.hasOwnProperty.call(message, "trialinfo")) $root.serverProto.TrialPlayer.encode(message.trialinfo, writer.uint32(
              /* id 6, wireType 2 =*/
              50).fork()).ldelim();

              if (message.bet != null && message.bet.length) {
                writer.uint32(
                /* id 7, wireType 2 =*/
                58).fork();

                for (var i = 0; i < message.bet.length; ++i) {
                  writer["double"](message.bet[i]);
                }

                writer.ldelim();
              }

              if (message.remind != null && Object.hasOwnProperty.call(message, "remind")) writer.uint32(
              /* id 8, wireType 0 =*/
              64).bool(message.remind);
              if (message.remindinfo != null && Object.hasOwnProperty.call(message, "remindinfo")) $root.serverProto.TrialAwardData.encode(message.remindinfo, writer.uint32(
              /* id 9, wireType 2 =*/
              74).fork()).ldelim();

              if (message.rtags != null && message.rtags.length) {
                writer.uint32(
                /* id 10, wireType 2 =*/
                82).fork();

                for (var i = 0; i < message.rtags.length; ++i) {
                  writer.int32(message.rtags[i]);
                }

                writer.ldelim();
              }

              if (message.start != null && Object.hasOwnProperty.call(message, "start")) writer.uint32(
              /* id 11, wireType 0 =*/
              88).int64(message.start);
              if (message.end != null && Object.hasOwnProperty.call(message, "end")) writer.uint32(
              /* id 12, wireType 0 =*/
              96).int64(message.end);
              return writer;
            };
            /**
            * Encodes the specified TrialInfo message, length delimited. Does not implicitly {@link serverProto.TrialInfo.verify|verify} messages.
            * @function encodeDelimited
            * @memberof serverProto.TrialInfo
            * @static
            * @param {serverProto.ITrialInfo} message TrialInfo message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            TrialInfo.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a TrialInfo message from the specified reader or buffer.
            * @function decode
            * @memberof serverProto.TrialInfo
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {serverProto.TrialInfo} TrialInfo
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            TrialInfo.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.serverProto.TrialInfo();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      message.acktype = reader.int32();
                      break;
                    }

                  case 2:
                    {
                      message.nowactno = reader.int32();
                      break;
                    }

                  case 3:
                    {
                      message.targettype = reader.int32();
                      break;
                    }

                  case 4:
                    {
                      if (!(message.awarddesc && message.awarddesc.length)) message.awarddesc = [];
                      message.awarddesc.push($root.serverProto.TrialAwardData.decode(reader, reader.uint32()));
                      break;
                    }

                  case 5:
                    {
                      message.pstate = reader.int32();
                      break;
                    }

                  case 6:
                    {
                      message.trialinfo = $root.serverProto.TrialPlayer.decode(reader, reader.uint32());
                      break;
                    }

                  case 7:
                    {
                      if (!(message.bet && message.bet.length)) message.bet = [];

                      if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;

                        while (reader.pos < end2) {
                          message.bet.push(reader["double"]());
                        }
                      } else message.bet.push(reader["double"]());

                      break;
                    }

                  case 8:
                    {
                      message.remind = reader.bool();
                      break;
                    }

                  case 9:
                    {
                      message.remindinfo = $root.serverProto.TrialAwardData.decode(reader, reader.uint32());
                      break;
                    }

                  case 10:
                    {
                      if (!(message.rtags && message.rtags.length)) message.rtags = [];

                      if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;

                        while (reader.pos < end2) {
                          message.rtags.push(reader.int32());
                        }
                      } else message.rtags.push(reader.int32());

                      break;
                    }

                  case 11:
                    {
                      message.start = reader.int64();
                      break;
                    }

                  case 12:
                    {
                      message.end = reader.int64();
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a TrialInfo message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof serverProto.TrialInfo
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {serverProto.TrialInfo} TrialInfo
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            TrialInfo.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a TrialInfo message.
            * @function verify
            * @memberof serverProto.TrialInfo
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            TrialInfo.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.acktype != null && message.hasOwnProperty("acktype")) if (!$util.isInteger(message.acktype)) return "acktype: integer expected";
              if (message.nowactno != null && message.hasOwnProperty("nowactno")) if (!$util.isInteger(message.nowactno)) return "nowactno: integer expected";
              if (message.targettype != null && message.hasOwnProperty("targettype")) if (!$util.isInteger(message.targettype)) return "targettype: integer expected";

              if (message.awarddesc != null && message.hasOwnProperty("awarddesc")) {
                if (!Array.isArray(message.awarddesc)) return "awarddesc: array expected";

                for (var i = 0; i < message.awarddesc.length; ++i) {
                  var error = $root.serverProto.TrialAwardData.verify(message.awarddesc[i]);
                  if (error) return "awarddesc." + error;
                }
              }

              if (message.pstate != null && message.hasOwnProperty("pstate")) if (!$util.isInteger(message.pstate)) return "pstate: integer expected";

              if (message.trialinfo != null && message.hasOwnProperty("trialinfo")) {
                var error = $root.serverProto.TrialPlayer.verify(message.trialinfo);
                if (error) return "trialinfo." + error;
              }

              if (message.bet != null && message.hasOwnProperty("bet")) {
                if (!Array.isArray(message.bet)) return "bet: array expected";

                for (var i = 0; i < message.bet.length; ++i) {
                  if (typeof message.bet[i] !== "number") return "bet: number[] expected";
                }
              }

              if (message.remind != null && message.hasOwnProperty("remind")) if (typeof message.remind !== "boolean") return "remind: boolean expected";

              if (message.remindinfo != null && message.hasOwnProperty("remindinfo")) {
                var error = $root.serverProto.TrialAwardData.verify(message.remindinfo);
                if (error) return "remindinfo." + error;
              }

              if (message.rtags != null && message.hasOwnProperty("rtags")) {
                if (!Array.isArray(message.rtags)) return "rtags: array expected";

                for (var i = 0; i < message.rtags.length; ++i) {
                  if (!$util.isInteger(message.rtags[i])) return "rtags: integer[] expected";
                }
              }

              if (message.start != null && message.hasOwnProperty("start")) if (!$util.isInteger(message.start) && !(message.start && $util.isInteger(message.start.low) && $util.isInteger(message.start.high))) return "start: integer|Long expected";
              if (message.end != null && message.hasOwnProperty("end")) if (!$util.isInteger(message.end) && !(message.end && $util.isInteger(message.end.low) && $util.isInteger(message.end.high))) return "end: integer|Long expected";
              return null;
            };
            /**
            * Creates a TrialInfo message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof serverProto.TrialInfo
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {serverProto.TrialInfo} TrialInfo
            */


            TrialInfo.fromObject = function fromObject(object) {
              if (object instanceof $root.serverProto.TrialInfo) return object;
              var message = new $root.serverProto.TrialInfo();
              if (object.acktype != null) message.acktype = object.acktype | 0;
              if (object.nowactno != null) message.nowactno = object.nowactno | 0;
              if (object.targettype != null) message.targettype = object.targettype | 0;

              if (object.awarddesc) {
                if (!Array.isArray(object.awarddesc)) throw TypeError(".serverProto.TrialInfo.awarddesc: array expected");
                message.awarddesc = [];

                for (var i = 0; i < object.awarddesc.length; ++i) {
                  if (typeof object.awarddesc[i] !== "object") throw TypeError(".serverProto.TrialInfo.awarddesc: object expected");
                  message.awarddesc[i] = $root.serverProto.TrialAwardData.fromObject(object.awarddesc[i]);
                }
              }

              if (object.pstate != null) message.pstate = object.pstate | 0;

              if (object.trialinfo != null) {
                if (typeof object.trialinfo !== "object") throw TypeError(".serverProto.TrialInfo.trialinfo: object expected");
                message.trialinfo = $root.serverProto.TrialPlayer.fromObject(object.trialinfo);
              }

              if (object.bet) {
                if (!Array.isArray(object.bet)) throw TypeError(".serverProto.TrialInfo.bet: array expected");
                message.bet = [];

                for (var i = 0; i < object.bet.length; ++i) {
                  message.bet[i] = Number(object.bet[i]);
                }
              }

              if (object.remind != null) message.remind = Boolean(object.remind);

              if (object.remindinfo != null) {
                if (typeof object.remindinfo !== "object") throw TypeError(".serverProto.TrialInfo.remindinfo: object expected");
                message.remindinfo = $root.serverProto.TrialAwardData.fromObject(object.remindinfo);
              }

              if (object.rtags) {
                if (!Array.isArray(object.rtags)) throw TypeError(".serverProto.TrialInfo.rtags: array expected");
                message.rtags = [];

                for (var i = 0; i < object.rtags.length; ++i) {
                  message.rtags[i] = object.rtags[i] | 0;
                }
              }

              if (object.start != null) if ($util.Long) (message.start = $util.Long.fromValue(object.start)).unsigned = false;else if (typeof object.start === "string") message.start = parseInt(object.start, 10);else if (typeof object.start === "number") message.start = object.start;else if (typeof object.start === "object") message.start = new $util.LongBits(object.start.low >>> 0, object.start.high >>> 0).toNumber();
              if (object.end != null) if ($util.Long) (message.end = $util.Long.fromValue(object.end)).unsigned = false;else if (typeof object.end === "string") message.end = parseInt(object.end, 10);else if (typeof object.end === "number") message.end = object.end;else if (typeof object.end === "object") message.end = new $util.LongBits(object.end.low >>> 0, object.end.high >>> 0).toNumber();
              return message;
            };
            /**
            * Creates a plain object from a TrialInfo message. Also converts values to other types if specified.
            * @function toObject
            * @memberof serverProto.TrialInfo
            * @static
            * @param {serverProto.TrialInfo} message TrialInfo
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            TrialInfo.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.arrays || options.defaults) {
                object.awarddesc = [];
                object.bet = [];
                object.rtags = [];
              }

              if (options.defaults) {
                object.acktype = 0;
                object.nowactno = 0;
                object.targettype = 0;
                object.pstate = 0;
                object.trialinfo = null;
                object.remind = false;
                object.remindinfo = null;

                if ($util.Long) {
                  var _long8 = new $util.Long(0, 0, false);

                  object.start = options.longs === String ? _long8.toString() : options.longs === Number ? _long8.toNumber() : _long8;
                } else object.start = options.longs === String ? "0" : 0;

                if ($util.Long) {
                  var _long8 = new $util.Long(0, 0, false);

                  object.end = options.longs === String ? _long8.toString() : options.longs === Number ? _long8.toNumber() : _long8;
                } else object.end = options.longs === String ? "0" : 0;
              }

              if (message.acktype != null && message.hasOwnProperty("acktype")) object.acktype = message.acktype;
              if (message.nowactno != null && message.hasOwnProperty("nowactno")) object.nowactno = message.nowactno;
              if (message.targettype != null && message.hasOwnProperty("targettype")) object.targettype = message.targettype;

              if (message.awarddesc && message.awarddesc.length) {
                object.awarddesc = [];

                for (var j = 0; j < message.awarddesc.length; ++j) {
                  object.awarddesc[j] = $root.serverProto.TrialAwardData.toObject(message.awarddesc[j], options);
                }
              }

              if (message.pstate != null && message.hasOwnProperty("pstate")) object.pstate = message.pstate;
              if (message.trialinfo != null && message.hasOwnProperty("trialinfo")) object.trialinfo = $root.serverProto.TrialPlayer.toObject(message.trialinfo, options);

              if (message.bet && message.bet.length) {
                object.bet = [];

                for (var j = 0; j < message.bet.length; ++j) {
                  object.bet[j] = options.json && !isFinite(message.bet[j]) ? String(message.bet[j]) : message.bet[j];
                }
              }

              if (message.remind != null && message.hasOwnProperty("remind")) object.remind = message.remind;
              if (message.remindinfo != null && message.hasOwnProperty("remindinfo")) object.remindinfo = $root.serverProto.TrialAwardData.toObject(message.remindinfo, options);

              if (message.rtags && message.rtags.length) {
                object.rtags = [];

                for (var j = 0; j < message.rtags.length; ++j) {
                  object.rtags[j] = message.rtags[j];
                }
              }

              if (message.start != null && message.hasOwnProperty("start")) if (typeof message.start === "number") object.start = options.longs === String ? String(message.start) : message.start;else object.start = options.longs === String ? $util.Long.prototype.toString.call(message.start) : options.longs === Number ? new $util.LongBits(message.start.low >>> 0, message.start.high >>> 0).toNumber() : message.start;
              if (message.end != null && message.hasOwnProperty("end")) if (typeof message.end === "number") object.end = options.longs === String ? String(message.end) : message.end;else object.end = options.longs === String ? $util.Long.prototype.toString.call(message.end) : options.longs === Number ? new $util.LongBits(message.end.low >>> 0, message.end.high >>> 0).toNumber() : message.end;
              return object;
            };
            /**
            * Converts this TrialInfo to JSON.
            * @function toJSON
            * @memberof serverProto.TrialInfo
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            TrialInfo.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
            * Gets the default type url for TrialInfo
            * @function getTypeUrl
            * @memberof serverProto.TrialInfo
            * @static
            * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
            * @returns {string} The default type url
            */


            TrialInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/serverProto.TrialInfo";
            };

            return TrialInfo;
          }();

          serverProto.TrialPlayer = function () {
            /**
            * Properties of a TrialPlayer.
            * @memberof serverProto
            * @interface ITrialPlayer
            * @property {number|null} [apiid] TrialPlayer apiid
            * @property {number|null} [gameid] TrialPlayer gameid
            * @property {number|null} [sac] TrialPlayer sac
            * @property {number|null} [activityno] TrialPlayer activityno
            * @property {number|null} [totalbet] TrialPlayer totalbet
            * @property {number|null} [totalwin] TrialPlayer totalwin
            * @property {number|null} [property] TrialPlayer property
            */

            /**
            * Constructs a new TrialPlayer.
            * @memberof serverProto
            * @classdesc Represents a TrialPlayer.
            * @implements ITrialPlayer
            * @constructor
            * @param {serverProto.ITrialPlayer=} [properties] Properties to set
            */
            function TrialPlayer(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * TrialPlayer apiid.
            * @member {number} apiid
            * @memberof serverProto.TrialPlayer
            * @instance
            */


            TrialPlayer.prototype.apiid = 0;
            /**
            * TrialPlayer gameid.
            * @member {number} gameid
            * @memberof serverProto.TrialPlayer
            * @instance
            */

            TrialPlayer.prototype.gameid = 0;
            /**
            * TrialPlayer sac.
            * @member {number} sac
            * @memberof serverProto.TrialPlayer
            * @instance
            */

            TrialPlayer.prototype.sac = 0;
            /**
            * TrialPlayer activityno.
            * @member {number} activityno
            * @memberof serverProto.TrialPlayer
            * @instance
            */

            TrialPlayer.prototype.activityno = 0;
            /**
            * TrialPlayer totalbet.
            * @member {number} totalbet
            * @memberof serverProto.TrialPlayer
            * @instance
            */

            TrialPlayer.prototype.totalbet = 0;
            /**
            * TrialPlayer totalwin.
            * @member {number} totalwin
            * @memberof serverProto.TrialPlayer
            * @instance
            */

            TrialPlayer.prototype.totalwin = 0;
            /**
            * TrialPlayer property.
            * @member {number} property
            * @memberof serverProto.TrialPlayer
            * @instance
            */

            TrialPlayer.prototype.property = 0;
            /**
            * Creates a new TrialPlayer instance using the specified properties.
            * @function create
            * @memberof serverProto.TrialPlayer
            * @static
            * @param {serverProto.ITrialPlayer=} [properties] Properties to set
            * @returns {serverProto.TrialPlayer} TrialPlayer instance
            */

            TrialPlayer.create = function create(properties) {
              return new TrialPlayer(properties);
            };
            /**
            * Encodes the specified TrialPlayer message. Does not implicitly {@link serverProto.TrialPlayer.verify|verify} messages.
            * @function encode
            * @memberof serverProto.TrialPlayer
            * @static
            * @param {serverProto.ITrialPlayer} message TrialPlayer message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            TrialPlayer.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.apiid != null && Object.hasOwnProperty.call(message, "apiid")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.apiid);
              if (message.gameid != null && Object.hasOwnProperty.call(message, "gameid")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int32(message.gameid);
              if (message.sac != null && Object.hasOwnProperty.call(message, "sac")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.sac);
              if (message.activityno != null && Object.hasOwnProperty.call(message, "activityno")) writer.uint32(
              /* id 4, wireType 0 =*/
              32).int32(message.activityno);
              if (message.totalbet != null && Object.hasOwnProperty.call(message, "totalbet")) writer.uint32(
              /* id 5, wireType 1 =*/
              41)["double"](message.totalbet);
              if (message.totalwin != null && Object.hasOwnProperty.call(message, "totalwin")) writer.uint32(
              /* id 6, wireType 1 =*/
              49)["double"](message.totalwin);
              if (message.property != null && Object.hasOwnProperty.call(message, "property")) writer.uint32(
              /* id 7, wireType 1 =*/
              57)["double"](message.property);
              return writer;
            };
            /**
            * Encodes the specified TrialPlayer message, length delimited. Does not implicitly {@link serverProto.TrialPlayer.verify|verify} messages.
            * @function encodeDelimited
            * @memberof serverProto.TrialPlayer
            * @static
            * @param {serverProto.ITrialPlayer} message TrialPlayer message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            TrialPlayer.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a TrialPlayer message from the specified reader or buffer.
            * @function decode
            * @memberof serverProto.TrialPlayer
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {serverProto.TrialPlayer} TrialPlayer
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            TrialPlayer.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.serverProto.TrialPlayer();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      message.apiid = reader.int32();
                      break;
                    }

                  case 2:
                    {
                      message.gameid = reader.int32();
                      break;
                    }

                  case 3:
                    {
                      message.sac = reader.int32();
                      break;
                    }

                  case 4:
                    {
                      message.activityno = reader.int32();
                      break;
                    }

                  case 5:
                    {
                      message.totalbet = reader["double"]();
                      break;
                    }

                  case 6:
                    {
                      message.totalwin = reader["double"]();
                      break;
                    }

                  case 7:
                    {
                      message.property = reader["double"]();
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a TrialPlayer message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof serverProto.TrialPlayer
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {serverProto.TrialPlayer} TrialPlayer
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            TrialPlayer.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a TrialPlayer message.
            * @function verify
            * @memberof serverProto.TrialPlayer
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            TrialPlayer.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.apiid != null && message.hasOwnProperty("apiid")) if (!$util.isInteger(message.apiid)) return "apiid: integer expected";
              if (message.gameid != null && message.hasOwnProperty("gameid")) if (!$util.isInteger(message.gameid)) return "gameid: integer expected";
              if (message.sac != null && message.hasOwnProperty("sac")) if (!$util.isInteger(message.sac)) return "sac: integer expected";
              if (message.activityno != null && message.hasOwnProperty("activityno")) if (!$util.isInteger(message.activityno)) return "activityno: integer expected";
              if (message.totalbet != null && message.hasOwnProperty("totalbet")) if (typeof message.totalbet !== "number") return "totalbet: number expected";
              if (message.totalwin != null && message.hasOwnProperty("totalwin")) if (typeof message.totalwin !== "number") return "totalwin: number expected";
              if (message.property != null && message.hasOwnProperty("property")) if (typeof message.property !== "number") return "property: number expected";
              return null;
            };
            /**
            * Creates a TrialPlayer message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof serverProto.TrialPlayer
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {serverProto.TrialPlayer} TrialPlayer
            */


            TrialPlayer.fromObject = function fromObject(object) {
              if (object instanceof $root.serverProto.TrialPlayer) return object;
              var message = new $root.serverProto.TrialPlayer();
              if (object.apiid != null) message.apiid = object.apiid | 0;
              if (object.gameid != null) message.gameid = object.gameid | 0;
              if (object.sac != null) message.sac = object.sac | 0;
              if (object.activityno != null) message.activityno = object.activityno | 0;
              if (object.totalbet != null) message.totalbet = Number(object.totalbet);
              if (object.totalwin != null) message.totalwin = Number(object.totalwin);
              if (object.property != null) message.property = Number(object.property);
              return message;
            };
            /**
            * Creates a plain object from a TrialPlayer message. Also converts values to other types if specified.
            * @function toObject
            * @memberof serverProto.TrialPlayer
            * @static
            * @param {serverProto.TrialPlayer} message TrialPlayer
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            TrialPlayer.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.apiid = 0;
                object.gameid = 0;
                object.sac = 0;
                object.activityno = 0;
                object.totalbet = 0;
                object.totalwin = 0;
                object.property = 0;
              }

              if (message.apiid != null && message.hasOwnProperty("apiid")) object.apiid = message.apiid;
              if (message.gameid != null && message.hasOwnProperty("gameid")) object.gameid = message.gameid;
              if (message.sac != null && message.hasOwnProperty("sac")) object.sac = message.sac;
              if (message.activityno != null && message.hasOwnProperty("activityno")) object.activityno = message.activityno;
              if (message.totalbet != null && message.hasOwnProperty("totalbet")) object.totalbet = options.json && !isFinite(message.totalbet) ? String(message.totalbet) : message.totalbet;
              if (message.totalwin != null && message.hasOwnProperty("totalwin")) object.totalwin = options.json && !isFinite(message.totalwin) ? String(message.totalwin) : message.totalwin;
              if (message.property != null && message.hasOwnProperty("property")) object.property = options.json && !isFinite(message.property) ? String(message.property) : message.property;
              return object;
            };
            /**
            * Converts this TrialPlayer to JSON.
            * @function toJSON
            * @memberof serverProto.TrialPlayer
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            TrialPlayer.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
            * Gets the default type url for TrialPlayer
            * @function getTypeUrl
            * @memberof serverProto.TrialPlayer
            * @static
            * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
            * @returns {string} The default type url
            */


            TrialPlayer.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/serverProto.TrialPlayer";
            };

            return TrialPlayer;
          }();

          serverProto.TrialAwardData = function () {
            /**
            * Properties of a TrialAwardData.
            * @memberof serverProto
            * @interface ITrialAwardData
            * @property {number|null} [award] TrialAwardData award
            * @property {number|null} [type] TrialAwardData type
            * @property {number|null} [gate] TrialAwardData gate
            * @property {number|null} [gameid] TrialAwardData gameid
            * @property {number|null} [itemid] TrialAwardData itemid
            * @property {number|null} [amount] TrialAwardData amount
            * @property {serverProto.ITrialItemData|null} [data] TrialAwardData data
            * @property {number|null} [money] TrialAwardData money
            */

            /**
            * Constructs a new TrialAwardData.
            * @memberof serverProto
            * @classdesc Represents a TrialAwardData.
            * @implements ITrialAwardData
            * @constructor
            * @param {serverProto.ITrialAwardData=} [properties] Properties to set
            */
            function TrialAwardData(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * TrialAwardData award.
            * @member {number} award
            * @memberof serverProto.TrialAwardData
            * @instance
            */


            TrialAwardData.prototype.award = 0;
            /**
            * TrialAwardData type.
            * @member {number} type
            * @memberof serverProto.TrialAwardData
            * @instance
            */

            TrialAwardData.prototype.type = 0;
            /**
            * TrialAwardData gate.
            * @member {number} gate
            * @memberof serverProto.TrialAwardData
            * @instance
            */

            TrialAwardData.prototype.gate = 0;
            /**
            * TrialAwardData gameid.
            * @member {number} gameid
            * @memberof serverProto.TrialAwardData
            * @instance
            */

            TrialAwardData.prototype.gameid = 0;
            /**
            * TrialAwardData itemid.
            * @member {number} itemid
            * @memberof serverProto.TrialAwardData
            * @instance
            */

            TrialAwardData.prototype.itemid = 0;
            /**
            * TrialAwardData amount.
            * @member {number} amount
            * @memberof serverProto.TrialAwardData
            * @instance
            */

            TrialAwardData.prototype.amount = 0;
            /**
            * TrialAwardData data.
            * @member {serverProto.ITrialItemData|null|undefined} data
            * @memberof serverProto.TrialAwardData
            * @instance
            */

            TrialAwardData.prototype.data = null;
            /**
            * TrialAwardData money.
            * @member {number} money
            * @memberof serverProto.TrialAwardData
            * @instance
            */

            TrialAwardData.prototype.money = 0;
            /**
            * Creates a new TrialAwardData instance using the specified properties.
            * @function create
            * @memberof serverProto.TrialAwardData
            * @static
            * @param {serverProto.ITrialAwardData=} [properties] Properties to set
            * @returns {serverProto.TrialAwardData} TrialAwardData instance
            */

            TrialAwardData.create = function create(properties) {
              return new TrialAwardData(properties);
            };
            /**
            * Encodes the specified TrialAwardData message. Does not implicitly {@link serverProto.TrialAwardData.verify|verify} messages.
            * @function encode
            * @memberof serverProto.TrialAwardData
            * @static
            * @param {serverProto.ITrialAwardData} message TrialAwardData message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            TrialAwardData.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.award != null && Object.hasOwnProperty.call(message, "award")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.award);
              if (message.type != null && Object.hasOwnProperty.call(message, "type")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int32(message.type);
              if (message.gate != null && Object.hasOwnProperty.call(message, "gate")) writer.uint32(
              /* id 3, wireType 1 =*/
              25)["double"](message.gate);
              if (message.gameid != null && Object.hasOwnProperty.call(message, "gameid")) writer.uint32(
              /* id 4, wireType 0 =*/
              32).int32(message.gameid);
              if (message.itemid != null && Object.hasOwnProperty.call(message, "itemid")) writer.uint32(
              /* id 5, wireType 0 =*/
              40).int32(message.itemid);
              if (message.amount != null && Object.hasOwnProperty.call(message, "amount")) writer.uint32(
              /* id 6, wireType 0 =*/
              48).int32(message.amount);
              if (message.data != null && Object.hasOwnProperty.call(message, "data")) $root.serverProto.TrialItemData.encode(message.data, writer.uint32(
              /* id 7, wireType 2 =*/
              58).fork()).ldelim();
              if (message.money != null && Object.hasOwnProperty.call(message, "money")) writer.uint32(
              /* id 8, wireType 1 =*/
              65)["double"](message.money);
              return writer;
            };
            /**
            * Encodes the specified TrialAwardData message, length delimited. Does not implicitly {@link serverProto.TrialAwardData.verify|verify} messages.
            * @function encodeDelimited
            * @memberof serverProto.TrialAwardData
            * @static
            * @param {serverProto.ITrialAwardData} message TrialAwardData message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            TrialAwardData.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a TrialAwardData message from the specified reader or buffer.
            * @function decode
            * @memberof serverProto.TrialAwardData
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {serverProto.TrialAwardData} TrialAwardData
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            TrialAwardData.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.serverProto.TrialAwardData();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      message.award = reader.int32();
                      break;
                    }

                  case 2:
                    {
                      message.type = reader.int32();
                      break;
                    }

                  case 3:
                    {
                      message.gate = reader["double"]();
                      break;
                    }

                  case 4:
                    {
                      message.gameid = reader.int32();
                      break;
                    }

                  case 5:
                    {
                      message.itemid = reader.int32();
                      break;
                    }

                  case 6:
                    {
                      message.amount = reader.int32();
                      break;
                    }

                  case 7:
                    {
                      message.data = $root.serverProto.TrialItemData.decode(reader, reader.uint32());
                      break;
                    }

                  case 8:
                    {
                      message.money = reader["double"]();
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a TrialAwardData message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof serverProto.TrialAwardData
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {serverProto.TrialAwardData} TrialAwardData
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            TrialAwardData.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a TrialAwardData message.
            * @function verify
            * @memberof serverProto.TrialAwardData
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            TrialAwardData.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.award != null && message.hasOwnProperty("award")) if (!$util.isInteger(message.award)) return "award: integer expected";
              if (message.type != null && message.hasOwnProperty("type")) if (!$util.isInteger(message.type)) return "type: integer expected";
              if (message.gate != null && message.hasOwnProperty("gate")) if (typeof message.gate !== "number") return "gate: number expected";
              if (message.gameid != null && message.hasOwnProperty("gameid")) if (!$util.isInteger(message.gameid)) return "gameid: integer expected";
              if (message.itemid != null && message.hasOwnProperty("itemid")) if (!$util.isInteger(message.itemid)) return "itemid: integer expected";
              if (message.amount != null && message.hasOwnProperty("amount")) if (!$util.isInteger(message.amount)) return "amount: integer expected";

              if (message.data != null && message.hasOwnProperty("data")) {
                var error = $root.serverProto.TrialItemData.verify(message.data);
                if (error) return "data." + error;
              }

              if (message.money != null && message.hasOwnProperty("money")) if (typeof message.money !== "number") return "money: number expected";
              return null;
            };
            /**
            * Creates a TrialAwardData message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof serverProto.TrialAwardData
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {serverProto.TrialAwardData} TrialAwardData
            */


            TrialAwardData.fromObject = function fromObject(object) {
              if (object instanceof $root.serverProto.TrialAwardData) return object;
              var message = new $root.serverProto.TrialAwardData();
              if (object.award != null) message.award = object.award | 0;
              if (object.type != null) message.type = object.type | 0;
              if (object.gate != null) message.gate = Number(object.gate);
              if (object.gameid != null) message.gameid = object.gameid | 0;
              if (object.itemid != null) message.itemid = object.itemid | 0;
              if (object.amount != null) message.amount = object.amount | 0;

              if (object.data != null) {
                if (typeof object.data !== "object") throw TypeError(".serverProto.TrialAwardData.data: object expected");
                message.data = $root.serverProto.TrialItemData.fromObject(object.data);
              }

              if (object.money != null) message.money = Number(object.money);
              return message;
            };
            /**
            * Creates a plain object from a TrialAwardData message. Also converts values to other types if specified.
            * @function toObject
            * @memberof serverProto.TrialAwardData
            * @static
            * @param {serverProto.TrialAwardData} message TrialAwardData
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            TrialAwardData.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.award = 0;
                object.type = 0;
                object.gate = 0;
                object.gameid = 0;
                object.itemid = 0;
                object.amount = 0;
                object.data = null;
                object.money = 0;
              }

              if (message.award != null && message.hasOwnProperty("award")) object.award = message.award;
              if (message.type != null && message.hasOwnProperty("type")) object.type = message.type;
              if (message.gate != null && message.hasOwnProperty("gate")) object.gate = options.json && !isFinite(message.gate) ? String(message.gate) : message.gate;
              if (message.gameid != null && message.hasOwnProperty("gameid")) object.gameid = message.gameid;
              if (message.itemid != null && message.hasOwnProperty("itemid")) object.itemid = message.itemid;
              if (message.amount != null && message.hasOwnProperty("amount")) object.amount = message.amount;
              if (message.data != null && message.hasOwnProperty("data")) object.data = $root.serverProto.TrialItemData.toObject(message.data, options);
              if (message.money != null && message.hasOwnProperty("money")) object.money = options.json && !isFinite(message.money) ? String(message.money) : message.money;
              return object;
            };
            /**
            * Converts this TrialAwardData to JSON.
            * @function toJSON
            * @memberof serverProto.TrialAwardData
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            TrialAwardData.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
            * Gets the default type url for TrialAwardData
            * @function getTypeUrl
            * @memberof serverProto.TrialAwardData
            * @static
            * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
            * @returns {string} The default type url
            */


            TrialAwardData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/serverProto.TrialAwardData";
            };

            return TrialAwardData;
          }();

          serverProto.TrialItemData = function () {
            /**
            * Properties of a TrialItemData.
            * @memberof serverProto
            * @interface ITrialItemData
            * @property {number|null} [star] TrialItemData star
            * @property {number|null} [icon] TrialItemData icon
            * @property {number|null} [type] TrialItemData type
            * @property {number|null} [bet] TrialItemData bet
            * @property {string|null} [gamename] TrialItemData gamename
            */

            /**
            * Constructs a new TrialItemData.
            * @memberof serverProto
            * @classdesc Represents a TrialItemData.
            * @implements ITrialItemData
            * @constructor
            * @param {serverProto.ITrialItemData=} [properties] Properties to set
            */
            function TrialItemData(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * TrialItemData star.
            * @member {number} star
            * @memberof serverProto.TrialItemData
            * @instance
            */


            TrialItemData.prototype.star = 0;
            /**
            * TrialItemData icon.
            * @member {number} icon
            * @memberof serverProto.TrialItemData
            * @instance
            */

            TrialItemData.prototype.icon = 0;
            /**
            * TrialItemData type.
            * @member {number} type
            * @memberof serverProto.TrialItemData
            * @instance
            */

            TrialItemData.prototype.type = 0;
            /**
            * TrialItemData bet.
            * @member {number} bet
            * @memberof serverProto.TrialItemData
            * @instance
            */

            TrialItemData.prototype.bet = 0;
            /**
            * TrialItemData gamename.
            * @member {string} gamename
            * @memberof serverProto.TrialItemData
            * @instance
            */

            TrialItemData.prototype.gamename = "";
            /**
            * Creates a new TrialItemData instance using the specified properties.
            * @function create
            * @memberof serverProto.TrialItemData
            * @static
            * @param {serverProto.ITrialItemData=} [properties] Properties to set
            * @returns {serverProto.TrialItemData} TrialItemData instance
            */

            TrialItemData.create = function create(properties) {
              return new TrialItemData(properties);
            };
            /**
            * Encodes the specified TrialItemData message. Does not implicitly {@link serverProto.TrialItemData.verify|verify} messages.
            * @function encode
            * @memberof serverProto.TrialItemData
            * @static
            * @param {serverProto.ITrialItemData} message TrialItemData message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            TrialItemData.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.star != null && Object.hasOwnProperty.call(message, "star")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.star);
              if (message.icon != null && Object.hasOwnProperty.call(message, "icon")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int32(message.icon);
              if (message.type != null && Object.hasOwnProperty.call(message, "type")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.type);
              if (message.bet != null && Object.hasOwnProperty.call(message, "bet")) writer.uint32(
              /* id 4, wireType 1 =*/
              33)["double"](message.bet);
              if (message.gamename != null && Object.hasOwnProperty.call(message, "gamename")) writer.uint32(
              /* id 5, wireType 2 =*/
              42).string(message.gamename);
              return writer;
            };
            /**
            * Encodes the specified TrialItemData message, length delimited. Does not implicitly {@link serverProto.TrialItemData.verify|verify} messages.
            * @function encodeDelimited
            * @memberof serverProto.TrialItemData
            * @static
            * @param {serverProto.ITrialItemData} message TrialItemData message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            TrialItemData.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a TrialItemData message from the specified reader or buffer.
            * @function decode
            * @memberof serverProto.TrialItemData
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {serverProto.TrialItemData} TrialItemData
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            TrialItemData.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.serverProto.TrialItemData();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      message.star = reader.int32();
                      break;
                    }

                  case 2:
                    {
                      message.icon = reader.int32();
                      break;
                    }

                  case 3:
                    {
                      message.type = reader.int32();
                      break;
                    }

                  case 4:
                    {
                      message.bet = reader["double"]();
                      break;
                    }

                  case 5:
                    {
                      message.gamename = reader.string();
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a TrialItemData message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof serverProto.TrialItemData
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {serverProto.TrialItemData} TrialItemData
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            TrialItemData.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a TrialItemData message.
            * @function verify
            * @memberof serverProto.TrialItemData
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            TrialItemData.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.star != null && message.hasOwnProperty("star")) if (!$util.isInteger(message.star)) return "star: integer expected";
              if (message.icon != null && message.hasOwnProperty("icon")) if (!$util.isInteger(message.icon)) return "icon: integer expected";
              if (message.type != null && message.hasOwnProperty("type")) if (!$util.isInteger(message.type)) return "type: integer expected";
              if (message.bet != null && message.hasOwnProperty("bet")) if (typeof message.bet !== "number") return "bet: number expected";
              if (message.gamename != null && message.hasOwnProperty("gamename")) if (!$util.isString(message.gamename)) return "gamename: string expected";
              return null;
            };
            /**
            * Creates a TrialItemData message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof serverProto.TrialItemData
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {serverProto.TrialItemData} TrialItemData
            */


            TrialItemData.fromObject = function fromObject(object) {
              if (object instanceof $root.serverProto.TrialItemData) return object;
              var message = new $root.serverProto.TrialItemData();
              if (object.star != null) message.star = object.star | 0;
              if (object.icon != null) message.icon = object.icon | 0;
              if (object.type != null) message.type = object.type | 0;
              if (object.bet != null) message.bet = Number(object.bet);
              if (object.gamename != null) message.gamename = String(object.gamename);
              return message;
            };
            /**
            * Creates a plain object from a TrialItemData message. Also converts values to other types if specified.
            * @function toObject
            * @memberof serverProto.TrialItemData
            * @static
            * @param {serverProto.TrialItemData} message TrialItemData
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            TrialItemData.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.star = 0;
                object.icon = 0;
                object.type = 0;
                object.bet = 0;
                object.gamename = "";
              }

              if (message.star != null && message.hasOwnProperty("star")) object.star = message.star;
              if (message.icon != null && message.hasOwnProperty("icon")) object.icon = message.icon;
              if (message.type != null && message.hasOwnProperty("type")) object.type = message.type;
              if (message.bet != null && message.hasOwnProperty("bet")) object.bet = options.json && !isFinite(message.bet) ? String(message.bet) : message.bet;
              if (message.gamename != null && message.hasOwnProperty("gamename")) object.gamename = message.gamename;
              return object;
            };
            /**
            * Converts this TrialItemData to JSON.
            * @function toJSON
            * @memberof serverProto.TrialItemData
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            TrialItemData.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
            * Gets the default type url for TrialItemData
            * @function getTypeUrl
            * @memberof serverProto.TrialItemData
            * @static
            * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
            * @returns {string} The default type url
            */


            TrialItemData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/serverProto.TrialItemData";
            };

            return TrialItemData;
          }();

          serverProto.TrialSignUp = function () {
            /**
            * Properties of a TrialSignUp.
            * @memberof serverProto
            * @interface ITrialSignUp
            * @property {number|null} [acktype] TrialSignUp acktype
            * @property {serverProto.ITrialPlayer|null} [trialinfo] TrialSignUp trialinfo
            */

            /**
            * Constructs a new TrialSignUp.
            * @memberof serverProto
            * @classdesc Represents a TrialSignUp.
            * @implements ITrialSignUp
            * @constructor
            * @param {serverProto.ITrialSignUp=} [properties] Properties to set
            */
            function TrialSignUp(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * TrialSignUp acktype.
            * @member {number} acktype
            * @memberof serverProto.TrialSignUp
            * @instance
            */


            TrialSignUp.prototype.acktype = 0;
            /**
            * TrialSignUp trialinfo.
            * @member {serverProto.ITrialPlayer|null|undefined} trialinfo
            * @memberof serverProto.TrialSignUp
            * @instance
            */

            TrialSignUp.prototype.trialinfo = null;
            /**
            * Creates a new TrialSignUp instance using the specified properties.
            * @function create
            * @memberof serverProto.TrialSignUp
            * @static
            * @param {serverProto.ITrialSignUp=} [properties] Properties to set
            * @returns {serverProto.TrialSignUp} TrialSignUp instance
            */

            TrialSignUp.create = function create(properties) {
              return new TrialSignUp(properties);
            };
            /**
            * Encodes the specified TrialSignUp message. Does not implicitly {@link serverProto.TrialSignUp.verify|verify} messages.
            * @function encode
            * @memberof serverProto.TrialSignUp
            * @static
            * @param {serverProto.ITrialSignUp} message TrialSignUp message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            TrialSignUp.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.acktype != null && Object.hasOwnProperty.call(message, "acktype")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.acktype);
              if (message.trialinfo != null && Object.hasOwnProperty.call(message, "trialinfo")) $root.serverProto.TrialPlayer.encode(message.trialinfo, writer.uint32(
              /* id 2, wireType 2 =*/
              18).fork()).ldelim();
              return writer;
            };
            /**
            * Encodes the specified TrialSignUp message, length delimited. Does not implicitly {@link serverProto.TrialSignUp.verify|verify} messages.
            * @function encodeDelimited
            * @memberof serverProto.TrialSignUp
            * @static
            * @param {serverProto.ITrialSignUp} message TrialSignUp message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            TrialSignUp.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a TrialSignUp message from the specified reader or buffer.
            * @function decode
            * @memberof serverProto.TrialSignUp
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {serverProto.TrialSignUp} TrialSignUp
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            TrialSignUp.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.serverProto.TrialSignUp();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      message.acktype = reader.int32();
                      break;
                    }

                  case 2:
                    {
                      message.trialinfo = $root.serverProto.TrialPlayer.decode(reader, reader.uint32());
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a TrialSignUp message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof serverProto.TrialSignUp
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {serverProto.TrialSignUp} TrialSignUp
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            TrialSignUp.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a TrialSignUp message.
            * @function verify
            * @memberof serverProto.TrialSignUp
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            TrialSignUp.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.acktype != null && message.hasOwnProperty("acktype")) if (!$util.isInteger(message.acktype)) return "acktype: integer expected";

              if (message.trialinfo != null && message.hasOwnProperty("trialinfo")) {
                var error = $root.serverProto.TrialPlayer.verify(message.trialinfo);
                if (error) return "trialinfo." + error;
              }

              return null;
            };
            /**
            * Creates a TrialSignUp message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof serverProto.TrialSignUp
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {serverProto.TrialSignUp} TrialSignUp
            */


            TrialSignUp.fromObject = function fromObject(object) {
              if (object instanceof $root.serverProto.TrialSignUp) return object;
              var message = new $root.serverProto.TrialSignUp();
              if (object.acktype != null) message.acktype = object.acktype | 0;

              if (object.trialinfo != null) {
                if (typeof object.trialinfo !== "object") throw TypeError(".serverProto.TrialSignUp.trialinfo: object expected");
                message.trialinfo = $root.serverProto.TrialPlayer.fromObject(object.trialinfo);
              }

              return message;
            };
            /**
            * Creates a plain object from a TrialSignUp message. Also converts values to other types if specified.
            * @function toObject
            * @memberof serverProto.TrialSignUp
            * @static
            * @param {serverProto.TrialSignUp} message TrialSignUp
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            TrialSignUp.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.acktype = 0;
                object.trialinfo = null;
              }

              if (message.acktype != null && message.hasOwnProperty("acktype")) object.acktype = message.acktype;
              if (message.trialinfo != null && message.hasOwnProperty("trialinfo")) object.trialinfo = $root.serverProto.TrialPlayer.toObject(message.trialinfo, options);
              return object;
            };
            /**
            * Converts this TrialSignUp to JSON.
            * @function toJSON
            * @memberof serverProto.TrialSignUp
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            TrialSignUp.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
            * Gets the default type url for TrialSignUp
            * @function getTypeUrl
            * @memberof serverProto.TrialSignUp
            * @static
            * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
            * @returns {string} The default type url
            */


            TrialSignUp.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/serverProto.TrialSignUp";
            };

            return TrialSignUp;
          }();

          serverProto.TrialGiveUp = function () {
            /**
            * Properties of a TrialGiveUp.
            * @memberof serverProto
            * @interface ITrialGiveUp
            * @property {number|null} [acktype] TrialGiveUp acktype
            * @property {number|null} [award] TrialGiveUp award
            * @property {serverProto.ITrialMoneyLog|null} [gamelog] TrialGiveUp gamelog
            */

            /**
            * Constructs a new TrialGiveUp.
            * @memberof serverProto
            * @classdesc Represents a TrialGiveUp.
            * @implements ITrialGiveUp
            * @constructor
            * @param {serverProto.ITrialGiveUp=} [properties] Properties to set
            */
            function TrialGiveUp(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * TrialGiveUp acktype.
            * @member {number} acktype
            * @memberof serverProto.TrialGiveUp
            * @instance
            */


            TrialGiveUp.prototype.acktype = 0;
            /**
            * TrialGiveUp award.
            * @member {number} award
            * @memberof serverProto.TrialGiveUp
            * @instance
            */

            TrialGiveUp.prototype.award = 0;
            /**
            * TrialGiveUp gamelog.
            * @member {serverProto.ITrialMoneyLog|null|undefined} gamelog
            * @memberof serverProto.TrialGiveUp
            * @instance
            */

            TrialGiveUp.prototype.gamelog = null;
            /**
            * Creates a new TrialGiveUp instance using the specified properties.
            * @function create
            * @memberof serverProto.TrialGiveUp
            * @static
            * @param {serverProto.ITrialGiveUp=} [properties] Properties to set
            * @returns {serverProto.TrialGiveUp} TrialGiveUp instance
            */

            TrialGiveUp.create = function create(properties) {
              return new TrialGiveUp(properties);
            };
            /**
            * Encodes the specified TrialGiveUp message. Does not implicitly {@link serverProto.TrialGiveUp.verify|verify} messages.
            * @function encode
            * @memberof serverProto.TrialGiveUp
            * @static
            * @param {serverProto.ITrialGiveUp} message TrialGiveUp message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            TrialGiveUp.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.acktype != null && Object.hasOwnProperty.call(message, "acktype")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.acktype);
              if (message.award != null && Object.hasOwnProperty.call(message, "award")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int32(message.award);
              if (message.gamelog != null && Object.hasOwnProperty.call(message, "gamelog")) $root.serverProto.TrialMoneyLog.encode(message.gamelog, writer.uint32(
              /* id 3, wireType 2 =*/
              26).fork()).ldelim();
              return writer;
            };
            /**
            * Encodes the specified TrialGiveUp message, length delimited. Does not implicitly {@link serverProto.TrialGiveUp.verify|verify} messages.
            * @function encodeDelimited
            * @memberof serverProto.TrialGiveUp
            * @static
            * @param {serverProto.ITrialGiveUp} message TrialGiveUp message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            TrialGiveUp.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a TrialGiveUp message from the specified reader or buffer.
            * @function decode
            * @memberof serverProto.TrialGiveUp
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {serverProto.TrialGiveUp} TrialGiveUp
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            TrialGiveUp.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.serverProto.TrialGiveUp();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      message.acktype = reader.int32();
                      break;
                    }

                  case 2:
                    {
                      message.award = reader.int32();
                      break;
                    }

                  case 3:
                    {
                      message.gamelog = $root.serverProto.TrialMoneyLog.decode(reader, reader.uint32());
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a TrialGiveUp message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof serverProto.TrialGiveUp
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {serverProto.TrialGiveUp} TrialGiveUp
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            TrialGiveUp.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a TrialGiveUp message.
            * @function verify
            * @memberof serverProto.TrialGiveUp
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            TrialGiveUp.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.acktype != null && message.hasOwnProperty("acktype")) if (!$util.isInteger(message.acktype)) return "acktype: integer expected";
              if (message.award != null && message.hasOwnProperty("award")) if (!$util.isInteger(message.award)) return "award: integer expected";

              if (message.gamelog != null && message.hasOwnProperty("gamelog")) {
                var error = $root.serverProto.TrialMoneyLog.verify(message.gamelog);
                if (error) return "gamelog." + error;
              }

              return null;
            };
            /**
            * Creates a TrialGiveUp message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof serverProto.TrialGiveUp
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {serverProto.TrialGiveUp} TrialGiveUp
            */


            TrialGiveUp.fromObject = function fromObject(object) {
              if (object instanceof $root.serverProto.TrialGiveUp) return object;
              var message = new $root.serverProto.TrialGiveUp();
              if (object.acktype != null) message.acktype = object.acktype | 0;
              if (object.award != null) message.award = object.award | 0;

              if (object.gamelog != null) {
                if (typeof object.gamelog !== "object") throw TypeError(".serverProto.TrialGiveUp.gamelog: object expected");
                message.gamelog = $root.serverProto.TrialMoneyLog.fromObject(object.gamelog);
              }

              return message;
            };
            /**
            * Creates a plain object from a TrialGiveUp message. Also converts values to other types if specified.
            * @function toObject
            * @memberof serverProto.TrialGiveUp
            * @static
            * @param {serverProto.TrialGiveUp} message TrialGiveUp
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            TrialGiveUp.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.acktype = 0;
                object.award = 0;
                object.gamelog = null;
              }

              if (message.acktype != null && message.hasOwnProperty("acktype")) object.acktype = message.acktype;
              if (message.award != null && message.hasOwnProperty("award")) object.award = message.award;
              if (message.gamelog != null && message.hasOwnProperty("gamelog")) object.gamelog = $root.serverProto.TrialMoneyLog.toObject(message.gamelog, options);
              return object;
            };
            /**
            * Converts this TrialGiveUp to JSON.
            * @function toJSON
            * @memberof serverProto.TrialGiveUp
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            TrialGiveUp.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
            * Gets the default type url for TrialGiveUp
            * @function getTypeUrl
            * @memberof serverProto.TrialGiveUp
            * @static
            * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
            * @returns {string} The default type url
            */


            TrialGiveUp.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/serverProto.TrialGiveUp";
            };

            return TrialGiveUp;
          }();

          serverProto.TrialMoneyLog = function () {
            /**
            * Properties of a TrialMoneyLog.
            * @memberof serverProto
            * @interface ITrialMoneyLog
            * @property {number|null} [AccountID] TrialMoneyLog AccountID
            * @property {number|Long|null} [RoundIndex] TrialMoneyLog RoundIndex
            * @property {number|null} [RatedWin] TrialMoneyLog RatedWin
            * @property {number|null} [NowProperty] TrialMoneyLog NowProperty
            * @property {string|null} [LogTime] TrialMoneyLog LogTime
            */

            /**
            * Constructs a new TrialMoneyLog.
            * @memberof serverProto
            * @classdesc Represents a TrialMoneyLog.
            * @implements ITrialMoneyLog
            * @constructor
            * @param {serverProto.ITrialMoneyLog=} [properties] Properties to set
            */
            function TrialMoneyLog(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * TrialMoneyLog AccountID.
            * @member {number} AccountID
            * @memberof serverProto.TrialMoneyLog
            * @instance
            */


            TrialMoneyLog.prototype.AccountID = 0;
            /**
            * TrialMoneyLog RoundIndex.
            * @member {number|Long} RoundIndex
            * @memberof serverProto.TrialMoneyLog
            * @instance
            */

            TrialMoneyLog.prototype.RoundIndex = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
            * TrialMoneyLog RatedWin.
            * @member {number} RatedWin
            * @memberof serverProto.TrialMoneyLog
            * @instance
            */

            TrialMoneyLog.prototype.RatedWin = 0;
            /**
            * TrialMoneyLog NowProperty.
            * @member {number} NowProperty
            * @memberof serverProto.TrialMoneyLog
            * @instance
            */

            TrialMoneyLog.prototype.NowProperty = 0;
            /**
            * TrialMoneyLog LogTime.
            * @member {string} LogTime
            * @memberof serverProto.TrialMoneyLog
            * @instance
            */

            TrialMoneyLog.prototype.LogTime = "";
            /**
            * Creates a new TrialMoneyLog instance using the specified properties.
            * @function create
            * @memberof serverProto.TrialMoneyLog
            * @static
            * @param {serverProto.ITrialMoneyLog=} [properties] Properties to set
            * @returns {serverProto.TrialMoneyLog} TrialMoneyLog instance
            */

            TrialMoneyLog.create = function create(properties) {
              return new TrialMoneyLog(properties);
            };
            /**
            * Encodes the specified TrialMoneyLog message. Does not implicitly {@link serverProto.TrialMoneyLog.verify|verify} messages.
            * @function encode
            * @memberof serverProto.TrialMoneyLog
            * @static
            * @param {serverProto.ITrialMoneyLog} message TrialMoneyLog message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            TrialMoneyLog.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.AccountID != null && Object.hasOwnProperty.call(message, "AccountID")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.AccountID);
              if (message.RoundIndex != null && Object.hasOwnProperty.call(message, "RoundIndex")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int64(message.RoundIndex);
              if (message.RatedWin != null && Object.hasOwnProperty.call(message, "RatedWin")) writer.uint32(
              /* id 3, wireType 1 =*/
              25)["double"](message.RatedWin);
              if (message.NowProperty != null && Object.hasOwnProperty.call(message, "NowProperty")) writer.uint32(
              /* id 4, wireType 1 =*/
              33)["double"](message.NowProperty);
              if (message.LogTime != null && Object.hasOwnProperty.call(message, "LogTime")) writer.uint32(
              /* id 5, wireType 2 =*/
              42).string(message.LogTime);
              return writer;
            };
            /**
            * Encodes the specified TrialMoneyLog message, length delimited. Does not implicitly {@link serverProto.TrialMoneyLog.verify|verify} messages.
            * @function encodeDelimited
            * @memberof serverProto.TrialMoneyLog
            * @static
            * @param {serverProto.ITrialMoneyLog} message TrialMoneyLog message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            TrialMoneyLog.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a TrialMoneyLog message from the specified reader or buffer.
            * @function decode
            * @memberof serverProto.TrialMoneyLog
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {serverProto.TrialMoneyLog} TrialMoneyLog
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            TrialMoneyLog.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.serverProto.TrialMoneyLog();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      message.AccountID = reader.int32();
                      break;
                    }

                  case 2:
                    {
                      message.RoundIndex = reader.int64();
                      break;
                    }

                  case 3:
                    {
                      message.RatedWin = reader["double"]();
                      break;
                    }

                  case 4:
                    {
                      message.NowProperty = reader["double"]();
                      break;
                    }

                  case 5:
                    {
                      message.LogTime = reader.string();
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a TrialMoneyLog message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof serverProto.TrialMoneyLog
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {serverProto.TrialMoneyLog} TrialMoneyLog
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            TrialMoneyLog.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a TrialMoneyLog message.
            * @function verify
            * @memberof serverProto.TrialMoneyLog
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            TrialMoneyLog.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.AccountID != null && message.hasOwnProperty("AccountID")) if (!$util.isInteger(message.AccountID)) return "AccountID: integer expected";
              if (message.RoundIndex != null && message.hasOwnProperty("RoundIndex")) if (!$util.isInteger(message.RoundIndex) && !(message.RoundIndex && $util.isInteger(message.RoundIndex.low) && $util.isInteger(message.RoundIndex.high))) return "RoundIndex: integer|Long expected";
              if (message.RatedWin != null && message.hasOwnProperty("RatedWin")) if (typeof message.RatedWin !== "number") return "RatedWin: number expected";
              if (message.NowProperty != null && message.hasOwnProperty("NowProperty")) if (typeof message.NowProperty !== "number") return "NowProperty: number expected";
              if (message.LogTime != null && message.hasOwnProperty("LogTime")) if (!$util.isString(message.LogTime)) return "LogTime: string expected";
              return null;
            };
            /**
            * Creates a TrialMoneyLog message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof serverProto.TrialMoneyLog
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {serverProto.TrialMoneyLog} TrialMoneyLog
            */


            TrialMoneyLog.fromObject = function fromObject(object) {
              if (object instanceof $root.serverProto.TrialMoneyLog) return object;
              var message = new $root.serverProto.TrialMoneyLog();
              if (object.AccountID != null) message.AccountID = object.AccountID | 0;
              if (object.RoundIndex != null) if ($util.Long) (message.RoundIndex = $util.Long.fromValue(object.RoundIndex)).unsigned = false;else if (typeof object.RoundIndex === "string") message.RoundIndex = parseInt(object.RoundIndex, 10);else if (typeof object.RoundIndex === "number") message.RoundIndex = object.RoundIndex;else if (typeof object.RoundIndex === "object") message.RoundIndex = new $util.LongBits(object.RoundIndex.low >>> 0, object.RoundIndex.high >>> 0).toNumber();
              if (object.RatedWin != null) message.RatedWin = Number(object.RatedWin);
              if (object.NowProperty != null) message.NowProperty = Number(object.NowProperty);
              if (object.LogTime != null) message.LogTime = String(object.LogTime);
              return message;
            };
            /**
            * Creates a plain object from a TrialMoneyLog message. Also converts values to other types if specified.
            * @function toObject
            * @memberof serverProto.TrialMoneyLog
            * @static
            * @param {serverProto.TrialMoneyLog} message TrialMoneyLog
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            TrialMoneyLog.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.AccountID = 0;

                if ($util.Long) {
                  var _long9 = new $util.Long(0, 0, false);

                  object.RoundIndex = options.longs === String ? _long9.toString() : options.longs === Number ? _long9.toNumber() : _long9;
                } else object.RoundIndex = options.longs === String ? "0" : 0;

                object.RatedWin = 0;
                object.NowProperty = 0;
                object.LogTime = "";
              }

              if (message.AccountID != null && message.hasOwnProperty("AccountID")) object.AccountID = message.AccountID;
              if (message.RoundIndex != null && message.hasOwnProperty("RoundIndex")) if (typeof message.RoundIndex === "number") object.RoundIndex = options.longs === String ? String(message.RoundIndex) : message.RoundIndex;else object.RoundIndex = options.longs === String ? $util.Long.prototype.toString.call(message.RoundIndex) : options.longs === Number ? new $util.LongBits(message.RoundIndex.low >>> 0, message.RoundIndex.high >>> 0).toNumber() : message.RoundIndex;
              if (message.RatedWin != null && message.hasOwnProperty("RatedWin")) object.RatedWin = options.json && !isFinite(message.RatedWin) ? String(message.RatedWin) : message.RatedWin;
              if (message.NowProperty != null && message.hasOwnProperty("NowProperty")) object.NowProperty = options.json && !isFinite(message.NowProperty) ? String(message.NowProperty) : message.NowProperty;
              if (message.LogTime != null && message.hasOwnProperty("LogTime")) object.LogTime = message.LogTime;
              return object;
            };
            /**
            * Converts this TrialMoneyLog to JSON.
            * @function toJSON
            * @memberof serverProto.TrialMoneyLog
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            TrialMoneyLog.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
            * Gets the default type url for TrialMoneyLog
            * @function getTypeUrl
            * @memberof serverProto.TrialMoneyLog
            * @static
            * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
            * @returns {string} The default type url
            */


            TrialMoneyLog.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/serverProto.TrialMoneyLog";
            };

            return TrialMoneyLog;
          }();

          serverProto.TrialInfoReq = function () {
            /**
            * Properties of a TrialInfoReq.
            * @memberof serverProto
            * @interface ITrialInfoReq
            * @property {number|null} [vip] TrialInfoReq vip
            * @property {number|null} [lang] TrialInfoReq lang
            * @property {number|null} [actno] TrialInfoReq actno
            */

            /**
            * Constructs a new TrialInfoReq.
            * @memberof serverProto
            * @classdesc Represents a TrialInfoReq.
            * @implements ITrialInfoReq
            * @constructor
            * @param {serverProto.ITrialInfoReq=} [properties] Properties to set
            */
            function TrialInfoReq(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * TrialInfoReq vip.
            * @member {number} vip
            * @memberof serverProto.TrialInfoReq
            * @instance
            */


            TrialInfoReq.prototype.vip = 0;
            /**
            * TrialInfoReq lang.
            * @member {number} lang
            * @memberof serverProto.TrialInfoReq
            * @instance
            */

            TrialInfoReq.prototype.lang = 0;
            /**
            * TrialInfoReq actno.
            * @member {number} actno
            * @memberof serverProto.TrialInfoReq
            * @instance
            */

            TrialInfoReq.prototype.actno = 0;
            /**
            * Creates a new TrialInfoReq instance using the specified properties.
            * @function create
            * @memberof serverProto.TrialInfoReq
            * @static
            * @param {serverProto.ITrialInfoReq=} [properties] Properties to set
            * @returns {serverProto.TrialInfoReq} TrialInfoReq instance
            */

            TrialInfoReq.create = function create(properties) {
              return new TrialInfoReq(properties);
            };
            /**
            * Encodes the specified TrialInfoReq message. Does not implicitly {@link serverProto.TrialInfoReq.verify|verify} messages.
            * @function encode
            * @memberof serverProto.TrialInfoReq
            * @static
            * @param {serverProto.ITrialInfoReq} message TrialInfoReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            TrialInfoReq.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.vip != null && Object.hasOwnProperty.call(message, "vip")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.vip);
              if (message.lang != null && Object.hasOwnProperty.call(message, "lang")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int32(message.lang);
              if (message.actno != null && Object.hasOwnProperty.call(message, "actno")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.actno);
              return writer;
            };
            /**
            * Encodes the specified TrialInfoReq message, length delimited. Does not implicitly {@link serverProto.TrialInfoReq.verify|verify} messages.
            * @function encodeDelimited
            * @memberof serverProto.TrialInfoReq
            * @static
            * @param {serverProto.ITrialInfoReq} message TrialInfoReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            TrialInfoReq.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a TrialInfoReq message from the specified reader or buffer.
            * @function decode
            * @memberof serverProto.TrialInfoReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {serverProto.TrialInfoReq} TrialInfoReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            TrialInfoReq.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.serverProto.TrialInfoReq();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      message.vip = reader.int32();
                      break;
                    }

                  case 2:
                    {
                      message.lang = reader.int32();
                      break;
                    }

                  case 3:
                    {
                      message.actno = reader.int32();
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a TrialInfoReq message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof serverProto.TrialInfoReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {serverProto.TrialInfoReq} TrialInfoReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            TrialInfoReq.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a TrialInfoReq message.
            * @function verify
            * @memberof serverProto.TrialInfoReq
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            TrialInfoReq.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.vip != null && message.hasOwnProperty("vip")) if (!$util.isInteger(message.vip)) return "vip: integer expected";
              if (message.lang != null && message.hasOwnProperty("lang")) if (!$util.isInteger(message.lang)) return "lang: integer expected";
              if (message.actno != null && message.hasOwnProperty("actno")) if (!$util.isInteger(message.actno)) return "actno: integer expected";
              return null;
            };
            /**
            * Creates a TrialInfoReq message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof serverProto.TrialInfoReq
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {serverProto.TrialInfoReq} TrialInfoReq
            */


            TrialInfoReq.fromObject = function fromObject(object) {
              if (object instanceof $root.serverProto.TrialInfoReq) return object;
              var message = new $root.serverProto.TrialInfoReq();
              if (object.vip != null) message.vip = object.vip | 0;
              if (object.lang != null) message.lang = object.lang | 0;
              if (object.actno != null) message.actno = object.actno | 0;
              return message;
            };
            /**
            * Creates a plain object from a TrialInfoReq message. Also converts values to other types if specified.
            * @function toObject
            * @memberof serverProto.TrialInfoReq
            * @static
            * @param {serverProto.TrialInfoReq} message TrialInfoReq
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            TrialInfoReq.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.vip = 0;
                object.lang = 0;
                object.actno = 0;
              }

              if (message.vip != null && message.hasOwnProperty("vip")) object.vip = message.vip;
              if (message.lang != null && message.hasOwnProperty("lang")) object.lang = message.lang;
              if (message.actno != null && message.hasOwnProperty("actno")) object.actno = message.actno;
              return object;
            };
            /**
            * Converts this TrialInfoReq to JSON.
            * @function toJSON
            * @memberof serverProto.TrialInfoReq
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            TrialInfoReq.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
            * Gets the default type url for TrialInfoReq
            * @function getTypeUrl
            * @memberof serverProto.TrialInfoReq
            * @static
            * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
            * @returns {string} The default type url
            */


            TrialInfoReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/serverProto.TrialInfoReq";
            };

            return TrialInfoReq;
          }();

          serverProto.TrialSpinResp = function () {
            /**
            * Properties of a TrialSpinResp.
            * @memberof serverProto
            * @interface ITrialSpinResp
            * @property {number|null} [finish] TrialSpinResp finish
            * @property {number|null} [award] TrialSpinResp award
            */

            /**
            * Constructs a new TrialSpinResp.
            * @memberof serverProto
            * @classdesc Represents a TrialSpinResp.
            * @implements ITrialSpinResp
            * @constructor
            * @param {serverProto.ITrialSpinResp=} [properties] Properties to set
            */
            function TrialSpinResp(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * TrialSpinResp finish.
            * @member {number} finish
            * @memberof serverProto.TrialSpinResp
            * @instance
            */


            TrialSpinResp.prototype.finish = 0;
            /**
            * TrialSpinResp award.
            * @member {number} award
            * @memberof serverProto.TrialSpinResp
            * @instance
            */

            TrialSpinResp.prototype.award = 0;
            /**
            * Creates a new TrialSpinResp instance using the specified properties.
            * @function create
            * @memberof serverProto.TrialSpinResp
            * @static
            * @param {serverProto.ITrialSpinResp=} [properties] Properties to set
            * @returns {serverProto.TrialSpinResp} TrialSpinResp instance
            */

            TrialSpinResp.create = function create(properties) {
              return new TrialSpinResp(properties);
            };
            /**
            * Encodes the specified TrialSpinResp message. Does not implicitly {@link serverProto.TrialSpinResp.verify|verify} messages.
            * @function encode
            * @memberof serverProto.TrialSpinResp
            * @static
            * @param {serverProto.ITrialSpinResp} message TrialSpinResp message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            TrialSpinResp.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.finish != null && Object.hasOwnProperty.call(message, "finish")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.finish);
              if (message.award != null && Object.hasOwnProperty.call(message, "award")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int32(message.award);
              return writer;
            };
            /**
            * Encodes the specified TrialSpinResp message, length delimited. Does not implicitly {@link serverProto.TrialSpinResp.verify|verify} messages.
            * @function encodeDelimited
            * @memberof serverProto.TrialSpinResp
            * @static
            * @param {serverProto.ITrialSpinResp} message TrialSpinResp message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            TrialSpinResp.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a TrialSpinResp message from the specified reader or buffer.
            * @function decode
            * @memberof serverProto.TrialSpinResp
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {serverProto.TrialSpinResp} TrialSpinResp
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            TrialSpinResp.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.serverProto.TrialSpinResp();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      message.finish = reader.int32();
                      break;
                    }

                  case 2:
                    {
                      message.award = reader.int32();
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a TrialSpinResp message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof serverProto.TrialSpinResp
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {serverProto.TrialSpinResp} TrialSpinResp
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            TrialSpinResp.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a TrialSpinResp message.
            * @function verify
            * @memberof serverProto.TrialSpinResp
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            TrialSpinResp.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.finish != null && message.hasOwnProperty("finish")) if (!$util.isInteger(message.finish)) return "finish: integer expected";
              if (message.award != null && message.hasOwnProperty("award")) if (!$util.isInteger(message.award)) return "award: integer expected";
              return null;
            };
            /**
            * Creates a TrialSpinResp message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof serverProto.TrialSpinResp
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {serverProto.TrialSpinResp} TrialSpinResp
            */


            TrialSpinResp.fromObject = function fromObject(object) {
              if (object instanceof $root.serverProto.TrialSpinResp) return object;
              var message = new $root.serverProto.TrialSpinResp();
              if (object.finish != null) message.finish = object.finish | 0;
              if (object.award != null) message.award = object.award | 0;
              return message;
            };
            /**
            * Creates a plain object from a TrialSpinResp message. Also converts values to other types if specified.
            * @function toObject
            * @memberof serverProto.TrialSpinResp
            * @static
            * @param {serverProto.TrialSpinResp} message TrialSpinResp
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            TrialSpinResp.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.finish = 0;
                object.award = 0;
              }

              if (message.finish != null && message.hasOwnProperty("finish")) object.finish = message.finish;
              if (message.award != null && message.hasOwnProperty("award")) object.award = message.award;
              return object;
            };
            /**
            * Converts this TrialSpinResp to JSON.
            * @function toJSON
            * @memberof serverProto.TrialSpinResp
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            TrialSpinResp.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
            * Gets the default type url for TrialSpinResp
            * @function getTypeUrl
            * @memberof serverProto.TrialSpinResp
            * @static
            * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
            * @returns {string} The default type url
            */


            TrialSpinResp.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/serverProto.TrialSpinResp";
            };

            return TrialSpinResp;
          }();
          /**
          * VipError enum.
          * @name serverProto.VipError
          * @enum {number}
          * @property {number} VipSuccess=0 VipSuccess value
          * @property {number} Unavailable=1 Unavailable value
          * @property {number} ParameterError=2 ParameterError value
          * @property {number} Reject=3 Reject value
          */


          serverProto.VipError = function () {
            var valuesById = {},
                values = Object.create(valuesById);
            values[valuesById[0] = "VipSuccess"] = 0;
            values[valuesById[1] = "Unavailable"] = 1;
            values[valuesById[2] = "ParameterError"] = 2;
            values[valuesById[3] = "Reject"] = 3;
            return values;
          }();

          serverProto.VipSignInfoReq = function () {
            /**
            * Properties of a VipSignInfoReq.
            * @memberof serverProto
            * @interface IVipSignInfoReq
            * @property {number|null} [currency] VipSignInfoReq currency
            */

            /**
            * Constructs a new VipSignInfoReq.
            * @memberof serverProto
            * @classdesc Represents a VipSignInfoReq.
            * @implements IVipSignInfoReq
            * @constructor
            * @param {serverProto.IVipSignInfoReq=} [properties] Properties to set
            */
            function VipSignInfoReq(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * VipSignInfoReq currency.
            * @member {number} currency
            * @memberof serverProto.VipSignInfoReq
            * @instance
            */


            VipSignInfoReq.prototype.currency = 0;
            /**
            * Creates a new VipSignInfoReq instance using the specified properties.
            * @function create
            * @memberof serverProto.VipSignInfoReq
            * @static
            * @param {serverProto.IVipSignInfoReq=} [properties] Properties to set
            * @returns {serverProto.VipSignInfoReq} VipSignInfoReq instance
            */

            VipSignInfoReq.create = function create(properties) {
              return new VipSignInfoReq(properties);
            };
            /**
            * Encodes the specified VipSignInfoReq message. Does not implicitly {@link serverProto.VipSignInfoReq.verify|verify} messages.
            * @function encode
            * @memberof serverProto.VipSignInfoReq
            * @static
            * @param {serverProto.IVipSignInfoReq} message VipSignInfoReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            VipSignInfoReq.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.currency != null && Object.hasOwnProperty.call(message, "currency")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.currency);
              return writer;
            };
            /**
            * Encodes the specified VipSignInfoReq message, length delimited. Does not implicitly {@link serverProto.VipSignInfoReq.verify|verify} messages.
            * @function encodeDelimited
            * @memberof serverProto.VipSignInfoReq
            * @static
            * @param {serverProto.IVipSignInfoReq} message VipSignInfoReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            VipSignInfoReq.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a VipSignInfoReq message from the specified reader or buffer.
            * @function decode
            * @memberof serverProto.VipSignInfoReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {serverProto.VipSignInfoReq} VipSignInfoReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            VipSignInfoReq.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.serverProto.VipSignInfoReq();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      message.currency = reader.int32();
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a VipSignInfoReq message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof serverProto.VipSignInfoReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {serverProto.VipSignInfoReq} VipSignInfoReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            VipSignInfoReq.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a VipSignInfoReq message.
            * @function verify
            * @memberof serverProto.VipSignInfoReq
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            VipSignInfoReq.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.currency != null && message.hasOwnProperty("currency")) if (!$util.isInteger(message.currency)) return "currency: integer expected";
              return null;
            };
            /**
            * Creates a VipSignInfoReq message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof serverProto.VipSignInfoReq
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {serverProto.VipSignInfoReq} VipSignInfoReq
            */


            VipSignInfoReq.fromObject = function fromObject(object) {
              if (object instanceof $root.serverProto.VipSignInfoReq) return object;
              var message = new $root.serverProto.VipSignInfoReq();
              if (object.currency != null) message.currency = object.currency | 0;
              return message;
            };
            /**
            * Creates a plain object from a VipSignInfoReq message. Also converts values to other types if specified.
            * @function toObject
            * @memberof serverProto.VipSignInfoReq
            * @static
            * @param {serverProto.VipSignInfoReq} message VipSignInfoReq
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            VipSignInfoReq.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};
              if (options.defaults) object.currency = 0;
              if (message.currency != null && message.hasOwnProperty("currency")) object.currency = message.currency;
              return object;
            };
            /**
            * Converts this VipSignInfoReq to JSON.
            * @function toJSON
            * @memberof serverProto.VipSignInfoReq
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            VipSignInfoReq.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
            * Gets the default type url for VipSignInfoReq
            * @function getTypeUrl
            * @memberof serverProto.VipSignInfoReq
            * @static
            * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
            * @returns {string} The default type url
            */


            VipSignInfoReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/serverProto.VipSignInfoReq";
            };

            return VipSignInfoReq;
          }();

          serverProto.VipSignInfoResp = function () {
            /**
            * Properties of a VipSignInfoResp.
            * @memberof serverProto
            * @interface IVipSignInfoResp
            * @property {Array.<serverProto.ITreasure>|null} [TreasureList] VipSignInfoResp TreasureList
            * @property {google.protobuf.ITimestamp|null} [ExpiredTime] VipSignInfoResp ExpiredTime
            * @property {serverProto.VipError|null} [Error] VipSignInfoResp Error
            */

            /**
            * Constructs a new VipSignInfoResp.
            * @memberof serverProto
            * @classdesc Represents a VipSignInfoResp.
            * @implements IVipSignInfoResp
            * @constructor
            * @param {serverProto.IVipSignInfoResp=} [properties] Properties to set
            */
            function VipSignInfoResp(properties) {
              this.TreasureList = [];
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * VipSignInfoResp TreasureList.
            * @member {Array.<serverProto.ITreasure>} TreasureList
            * @memberof serverProto.VipSignInfoResp
            * @instance
            */


            VipSignInfoResp.prototype.TreasureList = $util.emptyArray;
            /**
            * VipSignInfoResp ExpiredTime.
            * @member {google.protobuf.ITimestamp|null|undefined} ExpiredTime
            * @memberof serverProto.VipSignInfoResp
            * @instance
            */

            VipSignInfoResp.prototype.ExpiredTime = null;
            /**
            * VipSignInfoResp Error.
            * @member {serverProto.VipError} Error
            * @memberof serverProto.VipSignInfoResp
            * @instance
            */

            VipSignInfoResp.prototype.Error = 0;
            /**
            * Creates a new VipSignInfoResp instance using the specified properties.
            * @function create
            * @memberof serverProto.VipSignInfoResp
            * @static
            * @param {serverProto.IVipSignInfoResp=} [properties] Properties to set
            * @returns {serverProto.VipSignInfoResp} VipSignInfoResp instance
            */

            VipSignInfoResp.create = function create(properties) {
              return new VipSignInfoResp(properties);
            };
            /**
            * Encodes the specified VipSignInfoResp message. Does not implicitly {@link serverProto.VipSignInfoResp.verify|verify} messages.
            * @function encode
            * @memberof serverProto.VipSignInfoResp
            * @static
            * @param {serverProto.IVipSignInfoResp} message VipSignInfoResp message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            VipSignInfoResp.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.TreasureList != null && message.TreasureList.length) for (var i = 0; i < message.TreasureList.length; ++i) {
                $root.serverProto.Treasure.encode(message.TreasureList[i], writer.uint32(
                /* id 1, wireType 2 =*/
                10).fork()).ldelim();
              }
              if (message.ExpiredTime != null && Object.hasOwnProperty.call(message, "ExpiredTime")) $root.google.protobuf.Timestamp.encode(message.ExpiredTime, writer.uint32(
              /* id 2, wireType 2 =*/
              18).fork()).ldelim();
              if (message.Error != null && Object.hasOwnProperty.call(message, "Error")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.Error);
              return writer;
            };
            /**
            * Encodes the specified VipSignInfoResp message, length delimited. Does not implicitly {@link serverProto.VipSignInfoResp.verify|verify} messages.
            * @function encodeDelimited
            * @memberof serverProto.VipSignInfoResp
            * @static
            * @param {serverProto.IVipSignInfoResp} message VipSignInfoResp message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            VipSignInfoResp.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a VipSignInfoResp message from the specified reader or buffer.
            * @function decode
            * @memberof serverProto.VipSignInfoResp
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {serverProto.VipSignInfoResp} VipSignInfoResp
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            VipSignInfoResp.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.serverProto.VipSignInfoResp();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      if (!(message.TreasureList && message.TreasureList.length)) message.TreasureList = [];
                      message.TreasureList.push($root.serverProto.Treasure.decode(reader, reader.uint32()));
                      break;
                    }

                  case 2:
                    {
                      message.ExpiredTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                      break;
                    }

                  case 3:
                    {
                      message.Error = reader.int32();
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a VipSignInfoResp message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof serverProto.VipSignInfoResp
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {serverProto.VipSignInfoResp} VipSignInfoResp
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            VipSignInfoResp.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a VipSignInfoResp message.
            * @function verify
            * @memberof serverProto.VipSignInfoResp
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            VipSignInfoResp.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";

              if (message.TreasureList != null && message.hasOwnProperty("TreasureList")) {
                if (!Array.isArray(message.TreasureList)) return "TreasureList: array expected";

                for (var i = 0; i < message.TreasureList.length; ++i) {
                  var error = $root.serverProto.Treasure.verify(message.TreasureList[i]);
                  if (error) return "TreasureList." + error;
                }
              }

              if (message.ExpiredTime != null && message.hasOwnProperty("ExpiredTime")) {
                var error = $root.google.protobuf.Timestamp.verify(message.ExpiredTime);
                if (error) return "ExpiredTime." + error;
              }

              if (message.Error != null && message.hasOwnProperty("Error")) switch (message.Error) {
                default:
                  return "Error: enum value expected";

                case 0:
                case 1:
                case 2:
                case 3:
                  break;
              }
              return null;
            };
            /**
            * Creates a VipSignInfoResp message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof serverProto.VipSignInfoResp
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {serverProto.VipSignInfoResp} VipSignInfoResp
            */


            VipSignInfoResp.fromObject = function fromObject(object) {
              if (object instanceof $root.serverProto.VipSignInfoResp) return object;
              var message = new $root.serverProto.VipSignInfoResp();

              if (object.TreasureList) {
                if (!Array.isArray(object.TreasureList)) throw TypeError(".serverProto.VipSignInfoResp.TreasureList: array expected");
                message.TreasureList = [];

                for (var i = 0; i < object.TreasureList.length; ++i) {
                  if (typeof object.TreasureList[i] !== "object") throw TypeError(".serverProto.VipSignInfoResp.TreasureList: object expected");
                  message.TreasureList[i] = $root.serverProto.Treasure.fromObject(object.TreasureList[i]);
                }
              }

              if (object.ExpiredTime != null) {
                if (typeof object.ExpiredTime !== "object") throw TypeError(".serverProto.VipSignInfoResp.ExpiredTime: object expected");
                message.ExpiredTime = $root.google.protobuf.Timestamp.fromObject(object.ExpiredTime);
              }

              switch (object.Error) {
                default:
                  if (typeof object.Error === "number") {
                    message.Error = object.Error;
                    break;
                  }

                  break;

                case "VipSuccess":
                case 0:
                  message.Error = 0;
                  break;

                case "Unavailable":
                case 1:
                  message.Error = 1;
                  break;

                case "ParameterError":
                case 2:
                  message.Error = 2;
                  break;

                case "Reject":
                case 3:
                  message.Error = 3;
                  break;
              }

              return message;
            };
            /**
            * Creates a plain object from a VipSignInfoResp message. Also converts values to other types if specified.
            * @function toObject
            * @memberof serverProto.VipSignInfoResp
            * @static
            * @param {serverProto.VipSignInfoResp} message VipSignInfoResp
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            VipSignInfoResp.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};
              if (options.arrays || options.defaults) object.TreasureList = [];

              if (options.defaults) {
                object.ExpiredTime = null;
                object.Error = options.enums === String ? "VipSuccess" : 0;
              }

              if (message.TreasureList && message.TreasureList.length) {
                object.TreasureList = [];

                for (var j = 0; j < message.TreasureList.length; ++j) {
                  object.TreasureList[j] = $root.serverProto.Treasure.toObject(message.TreasureList[j], options);
                }
              }

              if (message.ExpiredTime != null && message.hasOwnProperty("ExpiredTime")) object.ExpiredTime = $root.google.protobuf.Timestamp.toObject(message.ExpiredTime, options);
              if (message.Error != null && message.hasOwnProperty("Error")) object.Error = options.enums === String ? $root.serverProto.VipError[message.Error] === undefined ? message.Error : $root.serverProto.VipError[message.Error] : message.Error;
              return object;
            };
            /**
            * Converts this VipSignInfoResp to JSON.
            * @function toJSON
            * @memberof serverProto.VipSignInfoResp
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            VipSignInfoResp.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
            * Gets the default type url for VipSignInfoResp
            * @function getTypeUrl
            * @memberof serverProto.VipSignInfoResp
            * @static
            * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
            * @returns {string} The default type url
            */


            VipSignInfoResp.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/serverProto.VipSignInfoResp";
            };

            return VipSignInfoResp;
          }();

          serverProto.Treasure = function () {
            /**
            * Properties of a Treasure.
            * @memberof serverProto
            * @interface ITreasure
            * @property {string|null} [Index] Treasure Index
            * @property {number|null} [MinVip] Treasure MinVip
            * @property {number|null} [Exp] Treasure Exp
            * @property {boolean|null} [IsOpen] Treasure IsOpen
            */

            /**
            * Constructs a new Treasure.
            * @memberof serverProto
            * @classdesc Represents a Treasure.
            * @implements ITreasure
            * @constructor
            * @param {serverProto.ITreasure=} [properties] Properties to set
            */
            function Treasure(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * Treasure Index.
            * @member {string} Index
            * @memberof serverProto.Treasure
            * @instance
            */


            Treasure.prototype.Index = "";
            /**
            * Treasure MinVip.
            * @member {number} MinVip
            * @memberof serverProto.Treasure
            * @instance
            */

            Treasure.prototype.MinVip = 0;
            /**
            * Treasure Exp.
            * @member {number} Exp
            * @memberof serverProto.Treasure
            * @instance
            */

            Treasure.prototype.Exp = 0;
            /**
            * Treasure IsOpen.
            * @member {boolean} IsOpen
            * @memberof serverProto.Treasure
            * @instance
            */

            Treasure.prototype.IsOpen = false;
            /**
            * Creates a new Treasure instance using the specified properties.
            * @function create
            * @memberof serverProto.Treasure
            * @static
            * @param {serverProto.ITreasure=} [properties] Properties to set
            * @returns {serverProto.Treasure} Treasure instance
            */

            Treasure.create = function create(properties) {
              return new Treasure(properties);
            };
            /**
            * Encodes the specified Treasure message. Does not implicitly {@link serverProto.Treasure.verify|verify} messages.
            * @function encode
            * @memberof serverProto.Treasure
            * @static
            * @param {serverProto.ITreasure} message Treasure message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            Treasure.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.Index != null && Object.hasOwnProperty.call(message, "Index")) writer.uint32(
              /* id 1, wireType 2 =*/
              10).string(message.Index);
              if (message.MinVip != null && Object.hasOwnProperty.call(message, "MinVip")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int32(message.MinVip);
              if (message.Exp != null && Object.hasOwnProperty.call(message, "Exp")) writer.uint32(
              /* id 3, wireType 1 =*/
              25)["double"](message.Exp);
              if (message.IsOpen != null && Object.hasOwnProperty.call(message, "IsOpen")) writer.uint32(
              /* id 4, wireType 0 =*/
              32).bool(message.IsOpen);
              return writer;
            };
            /**
            * Encodes the specified Treasure message, length delimited. Does not implicitly {@link serverProto.Treasure.verify|verify} messages.
            * @function encodeDelimited
            * @memberof serverProto.Treasure
            * @static
            * @param {serverProto.ITreasure} message Treasure message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            Treasure.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a Treasure message from the specified reader or buffer.
            * @function decode
            * @memberof serverProto.Treasure
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {serverProto.Treasure} Treasure
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            Treasure.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.serverProto.Treasure();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      message.Index = reader.string();
                      break;
                    }

                  case 2:
                    {
                      message.MinVip = reader.int32();
                      break;
                    }

                  case 3:
                    {
                      message.Exp = reader["double"]();
                      break;
                    }

                  case 4:
                    {
                      message.IsOpen = reader.bool();
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a Treasure message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof serverProto.Treasure
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {serverProto.Treasure} Treasure
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            Treasure.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a Treasure message.
            * @function verify
            * @memberof serverProto.Treasure
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            Treasure.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.Index != null && message.hasOwnProperty("Index")) if (!$util.isString(message.Index)) return "Index: string expected";
              if (message.MinVip != null && message.hasOwnProperty("MinVip")) if (!$util.isInteger(message.MinVip)) return "MinVip: integer expected";
              if (message.Exp != null && message.hasOwnProperty("Exp")) if (typeof message.Exp !== "number") return "Exp: number expected";
              if (message.IsOpen != null && message.hasOwnProperty("IsOpen")) if (typeof message.IsOpen !== "boolean") return "IsOpen: boolean expected";
              return null;
            };
            /**
            * Creates a Treasure message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof serverProto.Treasure
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {serverProto.Treasure} Treasure
            */


            Treasure.fromObject = function fromObject(object) {
              if (object instanceof $root.serverProto.Treasure) return object;
              var message = new $root.serverProto.Treasure();
              if (object.Index != null) message.Index = String(object.Index);
              if (object.MinVip != null) message.MinVip = object.MinVip | 0;
              if (object.Exp != null) message.Exp = Number(object.Exp);
              if (object.IsOpen != null) message.IsOpen = Boolean(object.IsOpen);
              return message;
            };
            /**
            * Creates a plain object from a Treasure message. Also converts values to other types if specified.
            * @function toObject
            * @memberof serverProto.Treasure
            * @static
            * @param {serverProto.Treasure} message Treasure
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            Treasure.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.Index = "";
                object.MinVip = 0;
                object.Exp = 0;
                object.IsOpen = false;
              }

              if (message.Index != null && message.hasOwnProperty("Index")) object.Index = message.Index;
              if (message.MinVip != null && message.hasOwnProperty("MinVip")) object.MinVip = message.MinVip;
              if (message.Exp != null && message.hasOwnProperty("Exp")) object.Exp = options.json && !isFinite(message.Exp) ? String(message.Exp) : message.Exp;
              if (message.IsOpen != null && message.hasOwnProperty("IsOpen")) object.IsOpen = message.IsOpen;
              return object;
            };
            /**
            * Converts this Treasure to JSON.
            * @function toJSON
            * @memberof serverProto.Treasure
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            Treasure.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
            * Gets the default type url for Treasure
            * @function getTypeUrl
            * @memberof serverProto.Treasure
            * @static
            * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
            * @returns {string} The default type url
            */


            Treasure.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/serverProto.Treasure";
            };

            return Treasure;
          }();

          serverProto.VipSignRewardReq = function () {
            /**
            * Properties of a VipSignRewardReq.
            * @memberof serverProto
            * @interface IVipSignRewardReq
            * @property {number|null} [currency] VipSignRewardReq currency
            * @property {string|null} [treasureIndex] VipSignRewardReq treasureIndex
            */

            /**
            * Constructs a new VipSignRewardReq.
            * @memberof serverProto
            * @classdesc Represents a VipSignRewardReq.
            * @implements IVipSignRewardReq
            * @constructor
            * @param {serverProto.IVipSignRewardReq=} [properties] Properties to set
            */
            function VipSignRewardReq(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * VipSignRewardReq currency.
            * @member {number} currency
            * @memberof serverProto.VipSignRewardReq
            * @instance
            */


            VipSignRewardReq.prototype.currency = 0;
            /**
            * VipSignRewardReq treasureIndex.
            * @member {string} treasureIndex
            * @memberof serverProto.VipSignRewardReq
            * @instance
            */

            VipSignRewardReq.prototype.treasureIndex = "";
            /**
            * Creates a new VipSignRewardReq instance using the specified properties.
            * @function create
            * @memberof serverProto.VipSignRewardReq
            * @static
            * @param {serverProto.IVipSignRewardReq=} [properties] Properties to set
            * @returns {serverProto.VipSignRewardReq} VipSignRewardReq instance
            */

            VipSignRewardReq.create = function create(properties) {
              return new VipSignRewardReq(properties);
            };
            /**
            * Encodes the specified VipSignRewardReq message. Does not implicitly {@link serverProto.VipSignRewardReq.verify|verify} messages.
            * @function encode
            * @memberof serverProto.VipSignRewardReq
            * @static
            * @param {serverProto.IVipSignRewardReq} message VipSignRewardReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            VipSignRewardReq.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.currency != null && Object.hasOwnProperty.call(message, "currency")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.currency);
              if (message.treasureIndex != null && Object.hasOwnProperty.call(message, "treasureIndex")) writer.uint32(
              /* id 2, wireType 2 =*/
              18).string(message.treasureIndex);
              return writer;
            };
            /**
            * Encodes the specified VipSignRewardReq message, length delimited. Does not implicitly {@link serverProto.VipSignRewardReq.verify|verify} messages.
            * @function encodeDelimited
            * @memberof serverProto.VipSignRewardReq
            * @static
            * @param {serverProto.IVipSignRewardReq} message VipSignRewardReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            VipSignRewardReq.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a VipSignRewardReq message from the specified reader or buffer.
            * @function decode
            * @memberof serverProto.VipSignRewardReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {serverProto.VipSignRewardReq} VipSignRewardReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            VipSignRewardReq.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.serverProto.VipSignRewardReq();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      message.currency = reader.int32();
                      break;
                    }

                  case 2:
                    {
                      message.treasureIndex = reader.string();
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a VipSignRewardReq message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof serverProto.VipSignRewardReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {serverProto.VipSignRewardReq} VipSignRewardReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            VipSignRewardReq.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a VipSignRewardReq message.
            * @function verify
            * @memberof serverProto.VipSignRewardReq
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            VipSignRewardReq.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.currency != null && message.hasOwnProperty("currency")) if (!$util.isInteger(message.currency)) return "currency: integer expected";
              if (message.treasureIndex != null && message.hasOwnProperty("treasureIndex")) if (!$util.isString(message.treasureIndex)) return "treasureIndex: string expected";
              return null;
            };
            /**
            * Creates a VipSignRewardReq message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof serverProto.VipSignRewardReq
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {serverProto.VipSignRewardReq} VipSignRewardReq
            */


            VipSignRewardReq.fromObject = function fromObject(object) {
              if (object instanceof $root.serverProto.VipSignRewardReq) return object;
              var message = new $root.serverProto.VipSignRewardReq();
              if (object.currency != null) message.currency = object.currency | 0;
              if (object.treasureIndex != null) message.treasureIndex = String(object.treasureIndex);
              return message;
            };
            /**
            * Creates a plain object from a VipSignRewardReq message. Also converts values to other types if specified.
            * @function toObject
            * @memberof serverProto.VipSignRewardReq
            * @static
            * @param {serverProto.VipSignRewardReq} message VipSignRewardReq
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            VipSignRewardReq.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.currency = 0;
                object.treasureIndex = "";
              }

              if (message.currency != null && message.hasOwnProperty("currency")) object.currency = message.currency;
              if (message.treasureIndex != null && message.hasOwnProperty("treasureIndex")) object.treasureIndex = message.treasureIndex;
              return object;
            };
            /**
            * Converts this VipSignRewardReq to JSON.
            * @function toJSON
            * @memberof serverProto.VipSignRewardReq
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            VipSignRewardReq.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
            * Gets the default type url for VipSignRewardReq
            * @function getTypeUrl
            * @memberof serverProto.VipSignRewardReq
            * @static
            * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
            * @returns {string} The default type url
            */


            VipSignRewardReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/serverProto.VipSignRewardReq";
            };

            return VipSignRewardReq;
          }();

          serverProto.VipSignRewardResp = function () {
            /**
            * Properties of a VipSignRewardResp.
            * @memberof serverProto
            * @interface IVipSignRewardResp
            * @property {number|null} [ItemID] VipSignRewardResp ItemID
            * @property {number|null} [Count] VipSignRewardResp Count
            * @property {serverProto.Error|null} [Error] VipSignRewardResp Error
            * @property {number|null} [Icon] VipSignRewardResp Icon
            */

            /**
            * Constructs a new VipSignRewardResp.
            * @memberof serverProto
            * @classdesc Represents a VipSignRewardResp.
            * @implements IVipSignRewardResp
            * @constructor
            * @param {serverProto.IVipSignRewardResp=} [properties] Properties to set
            */
            function VipSignRewardResp(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * VipSignRewardResp ItemID.
            * @member {number} ItemID
            * @memberof serverProto.VipSignRewardResp
            * @instance
            */


            VipSignRewardResp.prototype.ItemID = 0;
            /**
            * VipSignRewardResp Count.
            * @member {number} Count
            * @memberof serverProto.VipSignRewardResp
            * @instance
            */

            VipSignRewardResp.prototype.Count = 0;
            /**
            * VipSignRewardResp Error.
            * @member {serverProto.Error} Error
            * @memberof serverProto.VipSignRewardResp
            * @instance
            */

            VipSignRewardResp.prototype.Error = 0;
            /**
            * VipSignRewardResp Icon.
            * @member {number} Icon
            * @memberof serverProto.VipSignRewardResp
            * @instance
            */

            VipSignRewardResp.prototype.Icon = 0;
            /**
            * Creates a new VipSignRewardResp instance using the specified properties.
            * @function create
            * @memberof serverProto.VipSignRewardResp
            * @static
            * @param {serverProto.IVipSignRewardResp=} [properties] Properties to set
            * @returns {serverProto.VipSignRewardResp} VipSignRewardResp instance
            */

            VipSignRewardResp.create = function create(properties) {
              return new VipSignRewardResp(properties);
            };
            /**
            * Encodes the specified VipSignRewardResp message. Does not implicitly {@link serverProto.VipSignRewardResp.verify|verify} messages.
            * @function encode
            * @memberof serverProto.VipSignRewardResp
            * @static
            * @param {serverProto.IVipSignRewardResp} message VipSignRewardResp message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            VipSignRewardResp.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.ItemID != null && Object.hasOwnProperty.call(message, "ItemID")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.ItemID);
              if (message.Count != null && Object.hasOwnProperty.call(message, "Count")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int32(message.Count);
              if (message.Error != null && Object.hasOwnProperty.call(message, "Error")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.Error);
              if (message.Icon != null && Object.hasOwnProperty.call(message, "Icon")) writer.uint32(
              /* id 4, wireType 0 =*/
              32).int32(message.Icon);
              return writer;
            };
            /**
            * Encodes the specified VipSignRewardResp message, length delimited. Does not implicitly {@link serverProto.VipSignRewardResp.verify|verify} messages.
            * @function encodeDelimited
            * @memberof serverProto.VipSignRewardResp
            * @static
            * @param {serverProto.IVipSignRewardResp} message VipSignRewardResp message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            VipSignRewardResp.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a VipSignRewardResp message from the specified reader or buffer.
            * @function decode
            * @memberof serverProto.VipSignRewardResp
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {serverProto.VipSignRewardResp} VipSignRewardResp
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            VipSignRewardResp.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.serverProto.VipSignRewardResp();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      message.ItemID = reader.int32();
                      break;
                    }

                  case 2:
                    {
                      message.Count = reader.int32();
                      break;
                    }

                  case 3:
                    {
                      message.Error = reader.int32();
                      break;
                    }

                  case 4:
                    {
                      message.Icon = reader.int32();
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a VipSignRewardResp message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof serverProto.VipSignRewardResp
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {serverProto.VipSignRewardResp} VipSignRewardResp
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            VipSignRewardResp.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a VipSignRewardResp message.
            * @function verify
            * @memberof serverProto.VipSignRewardResp
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            VipSignRewardResp.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.ItemID != null && message.hasOwnProperty("ItemID")) if (!$util.isInteger(message.ItemID)) return "ItemID: integer expected";
              if (message.Count != null && message.hasOwnProperty("Count")) if (!$util.isInteger(message.Count)) return "Count: integer expected";
              if (message.Error != null && message.hasOwnProperty("Error")) switch (message.Error) {
                default:
                  return "Error: enum value expected";

                case 0:
                case 123:
                case 211:
                case 241:
                case 251:
                case 252:
                case 253:
                case 301:
                case 303:
                case 304:
                case 305:
                case 311:
                case 400:
                case 500:
                case 600:
                case 700:
                case 701:
                case 800:
                case 801:
                case 802:
                case 803:
                case 9999:
                  break;
              }
              if (message.Icon != null && message.hasOwnProperty("Icon")) if (!$util.isInteger(message.Icon)) return "Icon: integer expected";
              return null;
            };
            /**
            * Creates a VipSignRewardResp message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof serverProto.VipSignRewardResp
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {serverProto.VipSignRewardResp} VipSignRewardResp
            */


            VipSignRewardResp.fromObject = function fromObject(object) {
              if (object instanceof $root.serverProto.VipSignRewardResp) return object;
              var message = new $root.serverProto.VipSignRewardResp();
              if (object.ItemID != null) message.ItemID = object.ItemID | 0;
              if (object.Count != null) message.Count = object.Count | 0;

              switch (object.Error) {
                default:
                  if (typeof object.Error === "number") {
                    message.Error = object.Error;
                    break;
                  }

                  break;

                case "success":
                case 0:
                  message.Error = 0;
                  break;

                case "SpecialError":
                case 123:
                  message.Error = 123;
                  break;

                case "plateInvalid":
                case 211:
                  message.Error = 211;
                  break;

                case "gameInvalid":
                case 241:
                  message.Error = 241;
                  break;

                case "paramter":
                case 251:
                  message.Error = 251;
                  break;

                case "ackType":
                case 252:
                  message.Error = 252;
                  break;

                case "reLogin":
                case 253:
                  message.Error = 253;
                  break;

                case "spinBet":
                case 301:
                  message.Error = 301;
                  break;

                case "spinRetry":
                case 303:
                  message.Error = 303;
                  break;

                case "spinReject":
                case 304:
                  message.Error = 304;
                  break;

                case "spinCoinError":
                case 305:
                  message.Error = 305;
                  break;

                case "spinCurrecny":
                case 311:
                  message.Error = 311;
                  break;

                case "missionUnavailable":
                case 400:
                  message.Error = 400;
                  break;

                case "itemUnavailable":
                case 500:
                  message.Error = 500;
                  break;

                case "signUnavailable":
                case 600:
                  message.Error = 600;
                  break;

                case "trialUnavailable":
                case 700:
                  message.Error = 700;
                  break;

                case "trialIsEnd":
                case 701:
                  message.Error = 701;
                  break;

                case "vipSignUnavailable":
                case 800:
                  message.Error = 800;
                  break;

                case "DebrisUnavailable":
                case 801:
                  message.Error = 801;
                  break;

                case "DebrisError":
                case 802:
                  message.Error = 802;
                  break;

                case "GiftCodeEror":
                case 803:
                  message.Error = 803;
                  break;

                case "unknow":
                case 9999:
                  message.Error = 9999;
                  break;
              }

              if (object.Icon != null) message.Icon = object.Icon | 0;
              return message;
            };
            /**
            * Creates a plain object from a VipSignRewardResp message. Also converts values to other types if specified.
            * @function toObject
            * @memberof serverProto.VipSignRewardResp
            * @static
            * @param {serverProto.VipSignRewardResp} message VipSignRewardResp
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            VipSignRewardResp.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.ItemID = 0;
                object.Count = 0;
                object.Error = options.enums === String ? "success" : 0;
                object.Icon = 0;
              }

              if (message.ItemID != null && message.hasOwnProperty("ItemID")) object.ItemID = message.ItemID;
              if (message.Count != null && message.hasOwnProperty("Count")) object.Count = message.Count;
              if (message.Error != null && message.hasOwnProperty("Error")) object.Error = options.enums === String ? $root.serverProto.Error[message.Error] === undefined ? message.Error : $root.serverProto.Error[message.Error] : message.Error;
              if (message.Icon != null && message.hasOwnProperty("Icon")) object.Icon = message.Icon;
              return object;
            };
            /**
            * Converts this VipSignRewardResp to JSON.
            * @function toJSON
            * @memberof serverProto.VipSignRewardResp
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            VipSignRewardResp.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
            * Gets the default type url for VipSignRewardResp
            * @function getTypeUrl
            * @memberof serverProto.VipSignRewardResp
            * @static
            * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
            * @returns {string} The default type url
            */


            VipSignRewardResp.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/serverProto.VipSignRewardResp";
            };

            return VipSignRewardResp;
          }();

          serverProto.MallInfo = function () {
            /**
            * Properties of a MallInfo.
            * @memberof serverProto
            * @interface IMallInfo
            * @property {number|null} [PriceOdd] MallInfo PriceOdd
            * @property {number|null} [DescType] MallInfo DescType
            * @property {number|Long|null} [MaxBet] MallInfo MaxBet
            * @property {number|null} [AlterID] MallInfo AlterID
            * @property {number|null} [Show] MallInfo Show
            */

            /**
            * Constructs a new MallInfo.
            * @memberof serverProto
            * @classdesc Represents a MallInfo.
            * @implements IMallInfo
            * @constructor
            * @param {serverProto.IMallInfo=} [properties] Properties to set
            */
            function MallInfo(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * MallInfo PriceOdd.
            * @member {number} PriceOdd
            * @memberof serverProto.MallInfo
            * @instance
            */


            MallInfo.prototype.PriceOdd = 0;
            /**
            * MallInfo DescType.
            * @member {number} DescType
            * @memberof serverProto.MallInfo
            * @instance
            */

            MallInfo.prototype.DescType = 0;
            /**
            * MallInfo MaxBet.
            * @member {number|Long} MaxBet
            * @memberof serverProto.MallInfo
            * @instance
            */

            MallInfo.prototype.MaxBet = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
            * MallInfo AlterID.
            * @member {number} AlterID
            * @memberof serverProto.MallInfo
            * @instance
            */

            MallInfo.prototype.AlterID = 0;
            /**
            * MallInfo Show.
            * @member {number} Show
            * @memberof serverProto.MallInfo
            * @instance
            */

            MallInfo.prototype.Show = 0;
            /**
            * Creates a new MallInfo instance using the specified properties.
            * @function create
            * @memberof serverProto.MallInfo
            * @static
            * @param {serverProto.IMallInfo=} [properties] Properties to set
            * @returns {serverProto.MallInfo} MallInfo instance
            */

            MallInfo.create = function create(properties) {
              return new MallInfo(properties);
            };
            /**
            * Encodes the specified MallInfo message. Does not implicitly {@link serverProto.MallInfo.verify|verify} messages.
            * @function encode
            * @memberof serverProto.MallInfo
            * @static
            * @param {serverProto.IMallInfo} message MallInfo message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            MallInfo.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.PriceOdd != null && Object.hasOwnProperty.call(message, "PriceOdd")) writer.uint32(
              /* id 1, wireType 1 =*/
              9)["double"](message.PriceOdd);
              if (message.DescType != null && Object.hasOwnProperty.call(message, "DescType")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int32(message.DescType);
              if (message.MaxBet != null && Object.hasOwnProperty.call(message, "MaxBet")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int64(message.MaxBet);
              if (message.AlterID != null && Object.hasOwnProperty.call(message, "AlterID")) writer.uint32(
              /* id 4, wireType 0 =*/
              32).int32(message.AlterID);
              if (message.Show != null && Object.hasOwnProperty.call(message, "Show")) writer.uint32(
              /* id 5, wireType 0 =*/
              40).int32(message.Show);
              return writer;
            };
            /**
            * Encodes the specified MallInfo message, length delimited. Does not implicitly {@link serverProto.MallInfo.verify|verify} messages.
            * @function encodeDelimited
            * @memberof serverProto.MallInfo
            * @static
            * @param {serverProto.IMallInfo} message MallInfo message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            MallInfo.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a MallInfo message from the specified reader or buffer.
            * @function decode
            * @memberof serverProto.MallInfo
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {serverProto.MallInfo} MallInfo
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            MallInfo.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.serverProto.MallInfo();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      message.PriceOdd = reader["double"]();
                      break;
                    }

                  case 2:
                    {
                      message.DescType = reader.int32();
                      break;
                    }

                  case 3:
                    {
                      message.MaxBet = reader.int64();
                      break;
                    }

                  case 4:
                    {
                      message.AlterID = reader.int32();
                      break;
                    }

                  case 5:
                    {
                      message.Show = reader.int32();
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a MallInfo message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof serverProto.MallInfo
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {serverProto.MallInfo} MallInfo
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            MallInfo.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a MallInfo message.
            * @function verify
            * @memberof serverProto.MallInfo
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            MallInfo.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.PriceOdd != null && message.hasOwnProperty("PriceOdd")) if (typeof message.PriceOdd !== "number") return "PriceOdd: number expected";
              if (message.DescType != null && message.hasOwnProperty("DescType")) if (!$util.isInteger(message.DescType)) return "DescType: integer expected";
              if (message.MaxBet != null && message.hasOwnProperty("MaxBet")) if (!$util.isInteger(message.MaxBet) && !(message.MaxBet && $util.isInteger(message.MaxBet.low) && $util.isInteger(message.MaxBet.high))) return "MaxBet: integer|Long expected";
              if (message.AlterID != null && message.hasOwnProperty("AlterID")) if (!$util.isInteger(message.AlterID)) return "AlterID: integer expected";
              if (message.Show != null && message.hasOwnProperty("Show")) if (!$util.isInteger(message.Show)) return "Show: integer expected";
              return null;
            };
            /**
            * Creates a MallInfo message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof serverProto.MallInfo
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {serverProto.MallInfo} MallInfo
            */


            MallInfo.fromObject = function fromObject(object) {
              if (object instanceof $root.serverProto.MallInfo) return object;
              var message = new $root.serverProto.MallInfo();
              if (object.PriceOdd != null) message.PriceOdd = Number(object.PriceOdd);
              if (object.DescType != null) message.DescType = object.DescType | 0;
              if (object.MaxBet != null) if ($util.Long) (message.MaxBet = $util.Long.fromValue(object.MaxBet)).unsigned = false;else if (typeof object.MaxBet === "string") message.MaxBet = parseInt(object.MaxBet, 10);else if (typeof object.MaxBet === "number") message.MaxBet = object.MaxBet;else if (typeof object.MaxBet === "object") message.MaxBet = new $util.LongBits(object.MaxBet.low >>> 0, object.MaxBet.high >>> 0).toNumber();
              if (object.AlterID != null) message.AlterID = object.AlterID | 0;
              if (object.Show != null) message.Show = object.Show | 0;
              return message;
            };
            /**
            * Creates a plain object from a MallInfo message. Also converts values to other types if specified.
            * @function toObject
            * @memberof serverProto.MallInfo
            * @static
            * @param {serverProto.MallInfo} message MallInfo
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            MallInfo.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.PriceOdd = 0;
                object.DescType = 0;

                if ($util.Long) {
                  var _long10 = new $util.Long(0, 0, false);

                  object.MaxBet = options.longs === String ? _long10.toString() : options.longs === Number ? _long10.toNumber() : _long10;
                } else object.MaxBet = options.longs === String ? "0" : 0;

                object.AlterID = 0;
                object.Show = 0;
              }

              if (message.PriceOdd != null && message.hasOwnProperty("PriceOdd")) object.PriceOdd = options.json && !isFinite(message.PriceOdd) ? String(message.PriceOdd) : message.PriceOdd;
              if (message.DescType != null && message.hasOwnProperty("DescType")) object.DescType = message.DescType;
              if (message.MaxBet != null && message.hasOwnProperty("MaxBet")) if (typeof message.MaxBet === "number") object.MaxBet = options.longs === String ? String(message.MaxBet) : message.MaxBet;else object.MaxBet = options.longs === String ? $util.Long.prototype.toString.call(message.MaxBet) : options.longs === Number ? new $util.LongBits(message.MaxBet.low >>> 0, message.MaxBet.high >>> 0).toNumber() : message.MaxBet;
              if (message.AlterID != null && message.hasOwnProperty("AlterID")) object.AlterID = message.AlterID;
              if (message.Show != null && message.hasOwnProperty("Show")) object.Show = message.Show;
              return object;
            };
            /**
            * Converts this MallInfo to JSON.
            * @function toJSON
            * @memberof serverProto.MallInfo
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            MallInfo.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
            * Gets the default type url for MallInfo
            * @function getTypeUrl
            * @memberof serverProto.MallInfo
            * @static
            * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
            * @returns {string} The default type url
            */


            MallInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/serverProto.MallInfo";
            };

            return MallInfo;
          }();

          serverProto.ExtraSpinReq = function () {
            /**
            * Properties of an ExtraSpinReq.
            * @memberof serverProto
            * @interface IExtraSpinReq
            * @property {number|Long|null} [bet] ExtraSpinReq bet
            * @property {number|null} [currencyNumber] ExtraSpinReq currencyNumber
            * @property {number|null} [vip] ExtraSpinReq vip
            */

            /**
            * Constructs a new ExtraSpinReq.
            * @memberof serverProto
            * @classdesc Represents an ExtraSpinReq.
            * @implements IExtraSpinReq
            * @constructor
            * @param {serverProto.IExtraSpinReq=} [properties] Properties to set
            */
            function ExtraSpinReq(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * ExtraSpinReq bet.
            * @member {number|Long} bet
            * @memberof serverProto.ExtraSpinReq
            * @instance
            */


            ExtraSpinReq.prototype.bet = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
            * ExtraSpinReq currencyNumber.
            * @member {number} currencyNumber
            * @memberof serverProto.ExtraSpinReq
            * @instance
            */

            ExtraSpinReq.prototype.currencyNumber = 0;
            /**
            * ExtraSpinReq vip.
            * @member {number} vip
            * @memberof serverProto.ExtraSpinReq
            * @instance
            */

            ExtraSpinReq.prototype.vip = 0;
            /**
            * Creates a new ExtraSpinReq instance using the specified properties.
            * @function create
            * @memberof serverProto.ExtraSpinReq
            * @static
            * @param {serverProto.IExtraSpinReq=} [properties] Properties to set
            * @returns {serverProto.ExtraSpinReq} ExtraSpinReq instance
            */

            ExtraSpinReq.create = function create(properties) {
              return new ExtraSpinReq(properties);
            };
            /**
            * Encodes the specified ExtraSpinReq message. Does not implicitly {@link serverProto.ExtraSpinReq.verify|verify} messages.
            * @function encode
            * @memberof serverProto.ExtraSpinReq
            * @static
            * @param {serverProto.IExtraSpinReq} message ExtraSpinReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            ExtraSpinReq.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.bet != null && Object.hasOwnProperty.call(message, "bet")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int64(message.bet);
              if (message.currencyNumber != null && Object.hasOwnProperty.call(message, "currencyNumber")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int32(message.currencyNumber);
              if (message.vip != null && Object.hasOwnProperty.call(message, "vip")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).uint32(message.vip);
              return writer;
            };
            /**
            * Encodes the specified ExtraSpinReq message, length delimited. Does not implicitly {@link serverProto.ExtraSpinReq.verify|verify} messages.
            * @function encodeDelimited
            * @memberof serverProto.ExtraSpinReq
            * @static
            * @param {serverProto.IExtraSpinReq} message ExtraSpinReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            ExtraSpinReq.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes an ExtraSpinReq message from the specified reader or buffer.
            * @function decode
            * @memberof serverProto.ExtraSpinReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {serverProto.ExtraSpinReq} ExtraSpinReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            ExtraSpinReq.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.serverProto.ExtraSpinReq();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      message.bet = reader.int64();
                      break;
                    }

                  case 2:
                    {
                      message.currencyNumber = reader.int32();
                      break;
                    }

                  case 3:
                    {
                      message.vip = reader.uint32();
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes an ExtraSpinReq message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof serverProto.ExtraSpinReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {serverProto.ExtraSpinReq} ExtraSpinReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            ExtraSpinReq.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies an ExtraSpinReq message.
            * @function verify
            * @memberof serverProto.ExtraSpinReq
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            ExtraSpinReq.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.bet != null && message.hasOwnProperty("bet")) if (!$util.isInteger(message.bet) && !(message.bet && $util.isInteger(message.bet.low) && $util.isInteger(message.bet.high))) return "bet: integer|Long expected";
              if (message.currencyNumber != null && message.hasOwnProperty("currencyNumber")) if (!$util.isInteger(message.currencyNumber)) return "currencyNumber: integer expected";
              if (message.vip != null && message.hasOwnProperty("vip")) if (!$util.isInteger(message.vip)) return "vip: integer expected";
              return null;
            };
            /**
            * Creates an ExtraSpinReq message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof serverProto.ExtraSpinReq
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {serverProto.ExtraSpinReq} ExtraSpinReq
            */


            ExtraSpinReq.fromObject = function fromObject(object) {
              if (object instanceof $root.serverProto.ExtraSpinReq) return object;
              var message = new $root.serverProto.ExtraSpinReq();
              if (object.bet != null) if ($util.Long) (message.bet = $util.Long.fromValue(object.bet)).unsigned = false;else if (typeof object.bet === "string") message.bet = parseInt(object.bet, 10);else if (typeof object.bet === "number") message.bet = object.bet;else if (typeof object.bet === "object") message.bet = new $util.LongBits(object.bet.low >>> 0, object.bet.high >>> 0).toNumber();
              if (object.currencyNumber != null) message.currencyNumber = object.currencyNumber | 0;
              if (object.vip != null) message.vip = object.vip >>> 0;
              return message;
            };
            /**
            * Creates a plain object from an ExtraSpinReq message. Also converts values to other types if specified.
            * @function toObject
            * @memberof serverProto.ExtraSpinReq
            * @static
            * @param {serverProto.ExtraSpinReq} message ExtraSpinReq
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            ExtraSpinReq.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                if ($util.Long) {
                  var _long11 = new $util.Long(0, 0, false);

                  object.bet = options.longs === String ? _long11.toString() : options.longs === Number ? _long11.toNumber() : _long11;
                } else object.bet = options.longs === String ? "0" : 0;

                object.currencyNumber = 0;
                object.vip = 0;
              }

              if (message.bet != null && message.hasOwnProperty("bet")) if (typeof message.bet === "number") object.bet = options.longs === String ? String(message.bet) : message.bet;else object.bet = options.longs === String ? $util.Long.prototype.toString.call(message.bet) : options.longs === Number ? new $util.LongBits(message.bet.low >>> 0, message.bet.high >>> 0).toNumber() : message.bet;
              if (message.currencyNumber != null && message.hasOwnProperty("currencyNumber")) object.currencyNumber = message.currencyNumber;
              if (message.vip != null && message.hasOwnProperty("vip")) object.vip = message.vip;
              return object;
            };
            /**
            * Converts this ExtraSpinReq to JSON.
            * @function toJSON
            * @memberof serverProto.ExtraSpinReq
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            ExtraSpinReq.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
            * Gets the default type url for ExtraSpinReq
            * @function getTypeUrl
            * @memberof serverProto.ExtraSpinReq
            * @static
            * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
            * @returns {string} The default type url
            */


            ExtraSpinReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/serverProto.ExtraSpinReq";
            };

            return ExtraSpinReq;
          }();

          serverProto.DebrisReq = function () {
            /**
            * Properties of a DebrisReq.
            * @memberof serverProto
            * @interface IDebrisReq
            * @property {number|null} [no] DebrisReq no
            * @property {number|null} [formula] DebrisReq formula
            * @property {number|null} [amount] DebrisReq amount
            * @property {number|null} [currencynumber] DebrisReq currencynumber
            */

            /**
            * Constructs a new DebrisReq.
            * @memberof serverProto
            * @classdesc Represents a DebrisReq.
            * @implements IDebrisReq
            * @constructor
            * @param {serverProto.IDebrisReq=} [properties] Properties to set
            */
            function DebrisReq(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * DebrisReq no.
            * @member {number} no
            * @memberof serverProto.DebrisReq
            * @instance
            */


            DebrisReq.prototype.no = 0;
            /**
            * DebrisReq formula.
            * @member {number} formula
            * @memberof serverProto.DebrisReq
            * @instance
            */

            DebrisReq.prototype.formula = 0;
            /**
            * DebrisReq amount.
            * @member {number} amount
            * @memberof serverProto.DebrisReq
            * @instance
            */

            DebrisReq.prototype.amount = 0;
            /**
            * DebrisReq currencynumber.
            * @member {number} currencynumber
            * @memberof serverProto.DebrisReq
            * @instance
            */

            DebrisReq.prototype.currencynumber = 0;
            /**
            * Creates a new DebrisReq instance using the specified properties.
            * @function create
            * @memberof serverProto.DebrisReq
            * @static
            * @param {serverProto.IDebrisReq=} [properties] Properties to set
            * @returns {serverProto.DebrisReq} DebrisReq instance
            */

            DebrisReq.create = function create(properties) {
              return new DebrisReq(properties);
            };
            /**
            * Encodes the specified DebrisReq message. Does not implicitly {@link serverProto.DebrisReq.verify|verify} messages.
            * @function encode
            * @memberof serverProto.DebrisReq
            * @static
            * @param {serverProto.IDebrisReq} message DebrisReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            DebrisReq.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.no != null && Object.hasOwnProperty.call(message, "no")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).uint32(message.no);
              if (message.formula != null && Object.hasOwnProperty.call(message, "formula")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).uint32(message.formula);
              if (message.amount != null && Object.hasOwnProperty.call(message, "amount")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).uint32(message.amount);
              if (message.currencynumber != null && Object.hasOwnProperty.call(message, "currencynumber")) writer.uint32(
              /* id 4, wireType 0 =*/
              32).uint32(message.currencynumber);
              return writer;
            };
            /**
            * Encodes the specified DebrisReq message, length delimited. Does not implicitly {@link serverProto.DebrisReq.verify|verify} messages.
            * @function encodeDelimited
            * @memberof serverProto.DebrisReq
            * @static
            * @param {serverProto.IDebrisReq} message DebrisReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            DebrisReq.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a DebrisReq message from the specified reader or buffer.
            * @function decode
            * @memberof serverProto.DebrisReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {serverProto.DebrisReq} DebrisReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            DebrisReq.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.serverProto.DebrisReq();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      message.no = reader.uint32();
                      break;
                    }

                  case 2:
                    {
                      message.formula = reader.uint32();
                      break;
                    }

                  case 3:
                    {
                      message.amount = reader.uint32();
                      break;
                    }

                  case 4:
                    {
                      message.currencynumber = reader.uint32();
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a DebrisReq message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof serverProto.DebrisReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {serverProto.DebrisReq} DebrisReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            DebrisReq.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a DebrisReq message.
            * @function verify
            * @memberof serverProto.DebrisReq
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            DebrisReq.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.no != null && message.hasOwnProperty("no")) if (!$util.isInteger(message.no)) return "no: integer expected";
              if (message.formula != null && message.hasOwnProperty("formula")) if (!$util.isInteger(message.formula)) return "formula: integer expected";
              if (message.amount != null && message.hasOwnProperty("amount")) if (!$util.isInteger(message.amount)) return "amount: integer expected";
              if (message.currencynumber != null && message.hasOwnProperty("currencynumber")) if (!$util.isInteger(message.currencynumber)) return "currencynumber: integer expected";
              return null;
            };
            /**
            * Creates a DebrisReq message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof serverProto.DebrisReq
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {serverProto.DebrisReq} DebrisReq
            */


            DebrisReq.fromObject = function fromObject(object) {
              if (object instanceof $root.serverProto.DebrisReq) return object;
              var message = new $root.serverProto.DebrisReq();
              if (object.no != null) message.no = object.no >>> 0;
              if (object.formula != null) message.formula = object.formula >>> 0;
              if (object.amount != null) message.amount = object.amount >>> 0;
              if (object.currencynumber != null) message.currencynumber = object.currencynumber >>> 0;
              return message;
            };
            /**
            * Creates a plain object from a DebrisReq message. Also converts values to other types if specified.
            * @function toObject
            * @memberof serverProto.DebrisReq
            * @static
            * @param {serverProto.DebrisReq} message DebrisReq
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            DebrisReq.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.no = 0;
                object.formula = 0;
                object.amount = 0;
                object.currencynumber = 0;
              }

              if (message.no != null && message.hasOwnProperty("no")) object.no = message.no;
              if (message.formula != null && message.hasOwnProperty("formula")) object.formula = message.formula;
              if (message.amount != null && message.hasOwnProperty("amount")) object.amount = message.amount;
              if (message.currencynumber != null && message.hasOwnProperty("currencynumber")) object.currencynumber = message.currencynumber;
              return object;
            };
            /**
            * Converts this DebrisReq to JSON.
            * @function toJSON
            * @memberof serverProto.DebrisReq
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            DebrisReq.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
            * Gets the default type url for DebrisReq
            * @function getTypeUrl
            * @memberof serverProto.DebrisReq
            * @static
            * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
            * @returns {string} The default type url
            */


            DebrisReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/serverProto.DebrisReq";
            };

            return DebrisReq;
          }();

          serverProto.FreeSpinData = function () {
            /**
            * Properties of a FreeSpinData.
            * @memberof serverProto
            * @interface IFreeSpinData
            * @property {number|null} [Remain] FreeSpinData Remain
            * @property {number|null} [bet] FreeSpinData bet
            */

            /**
            * Constructs a new FreeSpinData.
            * @memberof serverProto
            * @classdesc Represents a FreeSpinData.
            * @implements IFreeSpinData
            * @constructor
            * @param {serverProto.IFreeSpinData=} [properties] Properties to set
            */
            function FreeSpinData(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * FreeSpinData Remain.
            * @member {number} Remain
            * @memberof serverProto.FreeSpinData
            * @instance
            */


            FreeSpinData.prototype.Remain = 0;
            /**
            * FreeSpinData bet.
            * @member {number} bet
            * @memberof serverProto.FreeSpinData
            * @instance
            */

            FreeSpinData.prototype.bet = 0;
            /**
            * Creates a new FreeSpinData instance using the specified properties.
            * @function create
            * @memberof serverProto.FreeSpinData
            * @static
            * @param {serverProto.IFreeSpinData=} [properties] Properties to set
            * @returns {serverProto.FreeSpinData} FreeSpinData instance
            */

            FreeSpinData.create = function create(properties) {
              return new FreeSpinData(properties);
            };
            /**
            * Encodes the specified FreeSpinData message. Does not implicitly {@link serverProto.FreeSpinData.verify|verify} messages.
            * @function encode
            * @memberof serverProto.FreeSpinData
            * @static
            * @param {serverProto.IFreeSpinData} message FreeSpinData message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            FreeSpinData.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.Remain != null && Object.hasOwnProperty.call(message, "Remain")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.Remain);
              if (message.bet != null && Object.hasOwnProperty.call(message, "bet")) writer.uint32(
              /* id 2, wireType 1 =*/
              17)["double"](message.bet);
              return writer;
            };
            /**
            * Encodes the specified FreeSpinData message, length delimited. Does not implicitly {@link serverProto.FreeSpinData.verify|verify} messages.
            * @function encodeDelimited
            * @memberof serverProto.FreeSpinData
            * @static
            * @param {serverProto.IFreeSpinData} message FreeSpinData message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            FreeSpinData.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a FreeSpinData message from the specified reader or buffer.
            * @function decode
            * @memberof serverProto.FreeSpinData
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {serverProto.FreeSpinData} FreeSpinData
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            FreeSpinData.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.serverProto.FreeSpinData();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      message.Remain = reader.int32();
                      break;
                    }

                  case 2:
                    {
                      message.bet = reader["double"]();
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a FreeSpinData message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof serverProto.FreeSpinData
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {serverProto.FreeSpinData} FreeSpinData
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            FreeSpinData.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a FreeSpinData message.
            * @function verify
            * @memberof serverProto.FreeSpinData
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            FreeSpinData.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.Remain != null && message.hasOwnProperty("Remain")) if (!$util.isInteger(message.Remain)) return "Remain: integer expected";
              if (message.bet != null && message.hasOwnProperty("bet")) if (typeof message.bet !== "number") return "bet: number expected";
              return null;
            };
            /**
            * Creates a FreeSpinData message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof serverProto.FreeSpinData
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {serverProto.FreeSpinData} FreeSpinData
            */


            FreeSpinData.fromObject = function fromObject(object) {
              if (object instanceof $root.serverProto.FreeSpinData) return object;
              var message = new $root.serverProto.FreeSpinData();
              if (object.Remain != null) message.Remain = object.Remain | 0;
              if (object.bet != null) message.bet = Number(object.bet);
              return message;
            };
            /**
            * Creates a plain object from a FreeSpinData message. Also converts values to other types if specified.
            * @function toObject
            * @memberof serverProto.FreeSpinData
            * @static
            * @param {serverProto.FreeSpinData} message FreeSpinData
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            FreeSpinData.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.Remain = 0;
                object.bet = 0;
              }

              if (message.Remain != null && message.hasOwnProperty("Remain")) object.Remain = message.Remain;
              if (message.bet != null && message.hasOwnProperty("bet")) object.bet = options.json && !isFinite(message.bet) ? String(message.bet) : message.bet;
              return object;
            };
            /**
            * Converts this FreeSpinData to JSON.
            * @function toJSON
            * @memberof serverProto.FreeSpinData
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            FreeSpinData.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
            * Gets the default type url for FreeSpinData
            * @function getTypeUrl
            * @memberof serverProto.FreeSpinData
            * @static
            * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
            * @returns {string} The default type url
            */


            FreeSpinData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/serverProto.FreeSpinData";
            };

            return FreeSpinData;
          }();

          serverProto.VerifyGiftCodeRequest = function () {
            /**
            * Properties of a VerifyGiftCodeRequest.
            * @memberof serverProto
            * @interface IVerifyGiftCodeRequest
            * @property {string|null} [giftcode] VerifyGiftCodeRequest giftcode
            */

            /**
            * Constructs a new VerifyGiftCodeRequest.
            * @memberof serverProto
            * @classdesc Represents a VerifyGiftCodeRequest.
            * @implements IVerifyGiftCodeRequest
            * @constructor
            * @param {serverProto.IVerifyGiftCodeRequest=} [properties] Properties to set
            */
            function VerifyGiftCodeRequest(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * VerifyGiftCodeRequest giftcode.
            * @member {string} giftcode
            * @memberof serverProto.VerifyGiftCodeRequest
            * @instance
            */


            VerifyGiftCodeRequest.prototype.giftcode = "";
            /**
            * Creates a new VerifyGiftCodeRequest instance using the specified properties.
            * @function create
            * @memberof serverProto.VerifyGiftCodeRequest
            * @static
            * @param {serverProto.IVerifyGiftCodeRequest=} [properties] Properties to set
            * @returns {serverProto.VerifyGiftCodeRequest} VerifyGiftCodeRequest instance
            */

            VerifyGiftCodeRequest.create = function create(properties) {
              return new VerifyGiftCodeRequest(properties);
            };
            /**
            * Encodes the specified VerifyGiftCodeRequest message. Does not implicitly {@link serverProto.VerifyGiftCodeRequest.verify|verify} messages.
            * @function encode
            * @memberof serverProto.VerifyGiftCodeRequest
            * @static
            * @param {serverProto.IVerifyGiftCodeRequest} message VerifyGiftCodeRequest message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            VerifyGiftCodeRequest.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.giftcode != null && Object.hasOwnProperty.call(message, "giftcode")) writer.uint32(
              /* id 1, wireType 2 =*/
              10).string(message.giftcode);
              return writer;
            };
            /**
            * Encodes the specified VerifyGiftCodeRequest message, length delimited. Does not implicitly {@link serverProto.VerifyGiftCodeRequest.verify|verify} messages.
            * @function encodeDelimited
            * @memberof serverProto.VerifyGiftCodeRequest
            * @static
            * @param {serverProto.IVerifyGiftCodeRequest} message VerifyGiftCodeRequest message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            VerifyGiftCodeRequest.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a VerifyGiftCodeRequest message from the specified reader or buffer.
            * @function decode
            * @memberof serverProto.VerifyGiftCodeRequest
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {serverProto.VerifyGiftCodeRequest} VerifyGiftCodeRequest
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            VerifyGiftCodeRequest.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.serverProto.VerifyGiftCodeRequest();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      message.giftcode = reader.string();
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a VerifyGiftCodeRequest message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof serverProto.VerifyGiftCodeRequest
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {serverProto.VerifyGiftCodeRequest} VerifyGiftCodeRequest
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            VerifyGiftCodeRequest.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a VerifyGiftCodeRequest message.
            * @function verify
            * @memberof serverProto.VerifyGiftCodeRequest
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            VerifyGiftCodeRequest.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.giftcode != null && message.hasOwnProperty("giftcode")) if (!$util.isString(message.giftcode)) return "giftcode: string expected";
              return null;
            };
            /**
            * Creates a VerifyGiftCodeRequest message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof serverProto.VerifyGiftCodeRequest
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {serverProto.VerifyGiftCodeRequest} VerifyGiftCodeRequest
            */


            VerifyGiftCodeRequest.fromObject = function fromObject(object) {
              if (object instanceof $root.serverProto.VerifyGiftCodeRequest) return object;
              var message = new $root.serverProto.VerifyGiftCodeRequest();
              if (object.giftcode != null) message.giftcode = String(object.giftcode);
              return message;
            };
            /**
            * Creates a plain object from a VerifyGiftCodeRequest message. Also converts values to other types if specified.
            * @function toObject
            * @memberof serverProto.VerifyGiftCodeRequest
            * @static
            * @param {serverProto.VerifyGiftCodeRequest} message VerifyGiftCodeRequest
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            VerifyGiftCodeRequest.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};
              if (options.defaults) object.giftcode = "";
              if (message.giftcode != null && message.hasOwnProperty("giftcode")) object.giftcode = message.giftcode;
              return object;
            };
            /**
            * Converts this VerifyGiftCodeRequest to JSON.
            * @function toJSON
            * @memberof serverProto.VerifyGiftCodeRequest
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            VerifyGiftCodeRequest.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
            * Gets the default type url for VerifyGiftCodeRequest
            * @function getTypeUrl
            * @memberof serverProto.VerifyGiftCodeRequest
            * @static
            * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
            * @returns {string} The default type url
            */


            VerifyGiftCodeRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/serverProto.VerifyGiftCodeRequest";
            };

            return VerifyGiftCodeRequest;
          }();

          serverProto.VerifyGiftCodeResponse = function () {
            /**
            * Properties of a VerifyGiftCodeResponse.
            * @memberof serverProto
            * @interface IVerifyGiftCodeResponse
            * @property {number|null} [Code] VerifyGiftCodeResponse Code
            * @property {number|null} [Round] VerifyGiftCodeResponse Round
            * @property {number|null} [Type] VerifyGiftCodeResponse Type
            */

            /**
            * Constructs a new VerifyGiftCodeResponse.
            * @memberof serverProto
            * @classdesc Represents a VerifyGiftCodeResponse.
            * @implements IVerifyGiftCodeResponse
            * @constructor
            * @param {serverProto.IVerifyGiftCodeResponse=} [properties] Properties to set
            */
            function VerifyGiftCodeResponse(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * VerifyGiftCodeResponse Code.
            * @member {number} Code
            * @memberof serverProto.VerifyGiftCodeResponse
            * @instance
            */


            VerifyGiftCodeResponse.prototype.Code = 0;
            /**
            * VerifyGiftCodeResponse Round.
            * @member {number} Round
            * @memberof serverProto.VerifyGiftCodeResponse
            * @instance
            */

            VerifyGiftCodeResponse.prototype.Round = 0;
            /**
            * VerifyGiftCodeResponse Type.
            * @member {number} Type
            * @memberof serverProto.VerifyGiftCodeResponse
            * @instance
            */

            VerifyGiftCodeResponse.prototype.Type = 0;
            /**
            * Creates a new VerifyGiftCodeResponse instance using the specified properties.
            * @function create
            * @memberof serverProto.VerifyGiftCodeResponse
            * @static
            * @param {serverProto.IVerifyGiftCodeResponse=} [properties] Properties to set
            * @returns {serverProto.VerifyGiftCodeResponse} VerifyGiftCodeResponse instance
            */

            VerifyGiftCodeResponse.create = function create(properties) {
              return new VerifyGiftCodeResponse(properties);
            };
            /**
            * Encodes the specified VerifyGiftCodeResponse message. Does not implicitly {@link serverProto.VerifyGiftCodeResponse.verify|verify} messages.
            * @function encode
            * @memberof serverProto.VerifyGiftCodeResponse
            * @static
            * @param {serverProto.IVerifyGiftCodeResponse} message VerifyGiftCodeResponse message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            VerifyGiftCodeResponse.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.Code != null && Object.hasOwnProperty.call(message, "Code")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.Code);
              if (message.Round != null && Object.hasOwnProperty.call(message, "Round")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int32(message.Round);
              if (message.Type != null && Object.hasOwnProperty.call(message, "Type")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.Type);
              return writer;
            };
            /**
            * Encodes the specified VerifyGiftCodeResponse message, length delimited. Does not implicitly {@link serverProto.VerifyGiftCodeResponse.verify|verify} messages.
            * @function encodeDelimited
            * @memberof serverProto.VerifyGiftCodeResponse
            * @static
            * @param {serverProto.IVerifyGiftCodeResponse} message VerifyGiftCodeResponse message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            VerifyGiftCodeResponse.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a VerifyGiftCodeResponse message from the specified reader or buffer.
            * @function decode
            * @memberof serverProto.VerifyGiftCodeResponse
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {serverProto.VerifyGiftCodeResponse} VerifyGiftCodeResponse
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            VerifyGiftCodeResponse.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.serverProto.VerifyGiftCodeResponse();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      message.Code = reader.int32();
                      break;
                    }

                  case 2:
                    {
                      message.Round = reader.int32();
                      break;
                    }

                  case 3:
                    {
                      message.Type = reader.int32();
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a VerifyGiftCodeResponse message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof serverProto.VerifyGiftCodeResponse
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {serverProto.VerifyGiftCodeResponse} VerifyGiftCodeResponse
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            VerifyGiftCodeResponse.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a VerifyGiftCodeResponse message.
            * @function verify
            * @memberof serverProto.VerifyGiftCodeResponse
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            VerifyGiftCodeResponse.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.Code != null && message.hasOwnProperty("Code")) if (!$util.isInteger(message.Code)) return "Code: integer expected";
              if (message.Round != null && message.hasOwnProperty("Round")) if (!$util.isInteger(message.Round)) return "Round: integer expected";
              if (message.Type != null && message.hasOwnProperty("Type")) if (!$util.isInteger(message.Type)) return "Type: integer expected";
              return null;
            };
            /**
            * Creates a VerifyGiftCodeResponse message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof serverProto.VerifyGiftCodeResponse
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {serverProto.VerifyGiftCodeResponse} VerifyGiftCodeResponse
            */


            VerifyGiftCodeResponse.fromObject = function fromObject(object) {
              if (object instanceof $root.serverProto.VerifyGiftCodeResponse) return object;
              var message = new $root.serverProto.VerifyGiftCodeResponse();
              if (object.Code != null) message.Code = object.Code | 0;
              if (object.Round != null) message.Round = object.Round | 0;
              if (object.Type != null) message.Type = object.Type | 0;
              return message;
            };
            /**
            * Creates a plain object from a VerifyGiftCodeResponse message. Also converts values to other types if specified.
            * @function toObject
            * @memberof serverProto.VerifyGiftCodeResponse
            * @static
            * @param {serverProto.VerifyGiftCodeResponse} message VerifyGiftCodeResponse
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            VerifyGiftCodeResponse.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.Code = 0;
                object.Round = 0;
                object.Type = 0;
              }

              if (message.Code != null && message.hasOwnProperty("Code")) object.Code = message.Code;
              if (message.Round != null && message.hasOwnProperty("Round")) object.Round = message.Round;
              if (message.Type != null && message.hasOwnProperty("Type")) object.Type = message.Type;
              return object;
            };
            /**
            * Converts this VerifyGiftCodeResponse to JSON.
            * @function toJSON
            * @memberof serverProto.VerifyGiftCodeResponse
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            VerifyGiftCodeResponse.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
            * Gets the default type url for VerifyGiftCodeResponse
            * @function getTypeUrl
            * @memberof serverProto.VerifyGiftCodeResponse
            * @static
            * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
            * @returns {string} The default type url
            */


            VerifyGiftCodeResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/serverProto.VerifyGiftCodeResponse";
            };

            return VerifyGiftCodeResponse;
          }();

          serverProto.JpListResp = function () {
            /**
            * Properties of a JpListResp.
            * @memberof serverProto
            * @interface IJpListResp
            * @property {Array.<serverProto.IJpInfo>|null} [info] JpListResp info
            */

            /**
            * Constructs a new JpListResp.
            * @memberof serverProto
            * @classdesc Represents a JpListResp.
            * @implements IJpListResp
            * @constructor
            * @param {serverProto.IJpListResp=} [properties] Properties to set
            */
            function JpListResp(properties) {
              this.info = [];
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * JpListResp info.
            * @member {Array.<serverProto.IJpInfo>} info
            * @memberof serverProto.JpListResp
            * @instance
            */


            JpListResp.prototype.info = $util.emptyArray;
            /**
            * Creates a new JpListResp instance using the specified properties.
            * @function create
            * @memberof serverProto.JpListResp
            * @static
            * @param {serverProto.IJpListResp=} [properties] Properties to set
            * @returns {serverProto.JpListResp} JpListResp instance
            */

            JpListResp.create = function create(properties) {
              return new JpListResp(properties);
            };
            /**
            * Encodes the specified JpListResp message. Does not implicitly {@link serverProto.JpListResp.verify|verify} messages.
            * @function encode
            * @memberof serverProto.JpListResp
            * @static
            * @param {serverProto.IJpListResp} message JpListResp message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            JpListResp.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.info != null && message.info.length) for (var i = 0; i < message.info.length; ++i) {
                $root.serverProto.JpInfo.encode(message.info[i], writer.uint32(
                /* id 1, wireType 2 =*/
                10).fork()).ldelim();
              }
              return writer;
            };
            /**
            * Encodes the specified JpListResp message, length delimited. Does not implicitly {@link serverProto.JpListResp.verify|verify} messages.
            * @function encodeDelimited
            * @memberof serverProto.JpListResp
            * @static
            * @param {serverProto.IJpListResp} message JpListResp message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            JpListResp.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a JpListResp message from the specified reader or buffer.
            * @function decode
            * @memberof serverProto.JpListResp
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {serverProto.JpListResp} JpListResp
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            JpListResp.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.serverProto.JpListResp();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      if (!(message.info && message.info.length)) message.info = [];
                      message.info.push($root.serverProto.JpInfo.decode(reader, reader.uint32()));
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a JpListResp message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof serverProto.JpListResp
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {serverProto.JpListResp} JpListResp
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            JpListResp.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a JpListResp message.
            * @function verify
            * @memberof serverProto.JpListResp
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            JpListResp.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";

              if (message.info != null && message.hasOwnProperty("info")) {
                if (!Array.isArray(message.info)) return "info: array expected";

                for (var i = 0; i < message.info.length; ++i) {
                  var error = $root.serverProto.JpInfo.verify(message.info[i]);
                  if (error) return "info." + error;
                }
              }

              return null;
            };
            /**
            * Creates a JpListResp message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof serverProto.JpListResp
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {serverProto.JpListResp} JpListResp
            */


            JpListResp.fromObject = function fromObject(object) {
              if (object instanceof $root.serverProto.JpListResp) return object;
              var message = new $root.serverProto.JpListResp();

              if (object.info) {
                if (!Array.isArray(object.info)) throw TypeError(".serverProto.JpListResp.info: array expected");
                message.info = [];

                for (var i = 0; i < object.info.length; ++i) {
                  if (typeof object.info[i] !== "object") throw TypeError(".serverProto.JpListResp.info: object expected");
                  message.info[i] = $root.serverProto.JpInfo.fromObject(object.info[i]);
                }
              }

              return message;
            };
            /**
            * Creates a plain object from a JpListResp message. Also converts values to other types if specified.
            * @function toObject
            * @memberof serverProto.JpListResp
            * @static
            * @param {serverProto.JpListResp} message JpListResp
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            JpListResp.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};
              if (options.arrays || options.defaults) object.info = [];

              if (message.info && message.info.length) {
                object.info = [];

                for (var j = 0; j < message.info.length; ++j) {
                  object.info[j] = $root.serverProto.JpInfo.toObject(message.info[j], options);
                }
              }

              return object;
            };
            /**
            * Converts this JpListResp to JSON.
            * @function toJSON
            * @memberof serverProto.JpListResp
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            JpListResp.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
            * Gets the default type url for JpListResp
            * @function getTypeUrl
            * @memberof serverProto.JpListResp
            * @static
            * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
            * @returns {string} The default type url
            */


            JpListResp.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/serverProto.JpListResp";
            };

            return JpListResp;
          }();

          serverProto.JpHistoryReq = function () {
            /**
            * Properties of a JpHistoryReq.
            * @memberof serverProto
            * @interface IJpHistoryReq
            * @property {google.protobuf.ITimestamp|null} [startTime] JpHistoryReq startTime
            * @property {google.protobuf.ITimestamp|null} [endTime] JpHistoryReq endTime
            */

            /**
            * Constructs a new JpHistoryReq.
            * @memberof serverProto
            * @classdesc Represents a JpHistoryReq.
            * @implements IJpHistoryReq
            * @constructor
            * @param {serverProto.IJpHistoryReq=} [properties] Properties to set
            */
            function JpHistoryReq(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * JpHistoryReq startTime.
            * @member {google.protobuf.ITimestamp|null|undefined} startTime
            * @memberof serverProto.JpHistoryReq
            * @instance
            */


            JpHistoryReq.prototype.startTime = null;
            /**
            * JpHistoryReq endTime.
            * @member {google.protobuf.ITimestamp|null|undefined} endTime
            * @memberof serverProto.JpHistoryReq
            * @instance
            */

            JpHistoryReq.prototype.endTime = null;
            /**
            * Creates a new JpHistoryReq instance using the specified properties.
            * @function create
            * @memberof serverProto.JpHistoryReq
            * @static
            * @param {serverProto.IJpHistoryReq=} [properties] Properties to set
            * @returns {serverProto.JpHistoryReq} JpHistoryReq instance
            */

            JpHistoryReq.create = function create(properties) {
              return new JpHistoryReq(properties);
            };
            /**
            * Encodes the specified JpHistoryReq message. Does not implicitly {@link serverProto.JpHistoryReq.verify|verify} messages.
            * @function encode
            * @memberof serverProto.JpHistoryReq
            * @static
            * @param {serverProto.IJpHistoryReq} message JpHistoryReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            JpHistoryReq.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.startTime != null && Object.hasOwnProperty.call(message, "startTime")) $root.google.protobuf.Timestamp.encode(message.startTime, writer.uint32(
              /* id 1, wireType 2 =*/
              10).fork()).ldelim();
              if (message.endTime != null && Object.hasOwnProperty.call(message, "endTime")) $root.google.protobuf.Timestamp.encode(message.endTime, writer.uint32(
              /* id 2, wireType 2 =*/
              18).fork()).ldelim();
              return writer;
            };
            /**
            * Encodes the specified JpHistoryReq message, length delimited. Does not implicitly {@link serverProto.JpHistoryReq.verify|verify} messages.
            * @function encodeDelimited
            * @memberof serverProto.JpHistoryReq
            * @static
            * @param {serverProto.IJpHistoryReq} message JpHistoryReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            JpHistoryReq.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a JpHistoryReq message from the specified reader or buffer.
            * @function decode
            * @memberof serverProto.JpHistoryReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {serverProto.JpHistoryReq} JpHistoryReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            JpHistoryReq.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.serverProto.JpHistoryReq();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      message.startTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                      break;
                    }

                  case 2:
                    {
                      message.endTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a JpHistoryReq message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof serverProto.JpHistoryReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {serverProto.JpHistoryReq} JpHistoryReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            JpHistoryReq.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a JpHistoryReq message.
            * @function verify
            * @memberof serverProto.JpHistoryReq
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            JpHistoryReq.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";

              if (message.startTime != null && message.hasOwnProperty("startTime")) {
                var error = $root.google.protobuf.Timestamp.verify(message.startTime);
                if (error) return "startTime." + error;
              }

              if (message.endTime != null && message.hasOwnProperty("endTime")) {
                var error = $root.google.protobuf.Timestamp.verify(message.endTime);
                if (error) return "endTime." + error;
              }

              return null;
            };
            /**
            * Creates a JpHistoryReq message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof serverProto.JpHistoryReq
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {serverProto.JpHistoryReq} JpHistoryReq
            */


            JpHistoryReq.fromObject = function fromObject(object) {
              if (object instanceof $root.serverProto.JpHistoryReq) return object;
              var message = new $root.serverProto.JpHistoryReq();

              if (object.startTime != null) {
                if (typeof object.startTime !== "object") throw TypeError(".serverProto.JpHistoryReq.startTime: object expected");
                message.startTime = $root.google.protobuf.Timestamp.fromObject(object.startTime);
              }

              if (object.endTime != null) {
                if (typeof object.endTime !== "object") throw TypeError(".serverProto.JpHistoryReq.endTime: object expected");
                message.endTime = $root.google.protobuf.Timestamp.fromObject(object.endTime);
              }

              return message;
            };
            /**
            * Creates a plain object from a JpHistoryReq message. Also converts values to other types if specified.
            * @function toObject
            * @memberof serverProto.JpHistoryReq
            * @static
            * @param {serverProto.JpHistoryReq} message JpHistoryReq
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            JpHistoryReq.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.startTime = null;
                object.endTime = null;
              }

              if (message.startTime != null && message.hasOwnProperty("startTime")) object.startTime = $root.google.protobuf.Timestamp.toObject(message.startTime, options);
              if (message.endTime != null && message.hasOwnProperty("endTime")) object.endTime = $root.google.protobuf.Timestamp.toObject(message.endTime, options);
              return object;
            };
            /**
            * Converts this JpHistoryReq to JSON.
            * @function toJSON
            * @memberof serverProto.JpHistoryReq
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            JpHistoryReq.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
            * Gets the default type url for JpHistoryReq
            * @function getTypeUrl
            * @memberof serverProto.JpHistoryReq
            * @static
            * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
            * @returns {string} The default type url
            */


            JpHistoryReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/serverProto.JpHistoryReq";
            };

            return JpHistoryReq;
          }();

          serverProto.JpHistoryResp = function () {
            /**
            * Properties of a JpHistoryResp.
            * @memberof serverProto
            * @interface IJpHistoryResp
            * @property {Array.<serverProto.IJpHistoryInfo>|null} [list] JpHistoryResp list
            */

            /**
            * Constructs a new JpHistoryResp.
            * @memberof serverProto
            * @classdesc Represents a JpHistoryResp.
            * @implements IJpHistoryResp
            * @constructor
            * @param {serverProto.IJpHistoryResp=} [properties] Properties to set
            */
            function JpHistoryResp(properties) {
              this.list = [];
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * JpHistoryResp list.
            * @member {Array.<serverProto.IJpHistoryInfo>} list
            * @memberof serverProto.JpHistoryResp
            * @instance
            */


            JpHistoryResp.prototype.list = $util.emptyArray;
            /**
            * Creates a new JpHistoryResp instance using the specified properties.
            * @function create
            * @memberof serverProto.JpHistoryResp
            * @static
            * @param {serverProto.IJpHistoryResp=} [properties] Properties to set
            * @returns {serverProto.JpHistoryResp} JpHistoryResp instance
            */

            JpHistoryResp.create = function create(properties) {
              return new JpHistoryResp(properties);
            };
            /**
            * Encodes the specified JpHistoryResp message. Does not implicitly {@link serverProto.JpHistoryResp.verify|verify} messages.
            * @function encode
            * @memberof serverProto.JpHistoryResp
            * @static
            * @param {serverProto.IJpHistoryResp} message JpHistoryResp message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            JpHistoryResp.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.list != null && message.list.length) for (var i = 0; i < message.list.length; ++i) {
                $root.serverProto.JpHistoryInfo.encode(message.list[i], writer.uint32(
                /* id 1, wireType 2 =*/
                10).fork()).ldelim();
              }
              return writer;
            };
            /**
            * Encodes the specified JpHistoryResp message, length delimited. Does not implicitly {@link serverProto.JpHistoryResp.verify|verify} messages.
            * @function encodeDelimited
            * @memberof serverProto.JpHistoryResp
            * @static
            * @param {serverProto.IJpHistoryResp} message JpHistoryResp message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            JpHistoryResp.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a JpHistoryResp message from the specified reader or buffer.
            * @function decode
            * @memberof serverProto.JpHistoryResp
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {serverProto.JpHistoryResp} JpHistoryResp
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            JpHistoryResp.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.serverProto.JpHistoryResp();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      if (!(message.list && message.list.length)) message.list = [];
                      message.list.push($root.serverProto.JpHistoryInfo.decode(reader, reader.uint32()));
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a JpHistoryResp message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof serverProto.JpHistoryResp
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {serverProto.JpHistoryResp} JpHistoryResp
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            JpHistoryResp.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a JpHistoryResp message.
            * @function verify
            * @memberof serverProto.JpHistoryResp
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            JpHistoryResp.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";

              if (message.list != null && message.hasOwnProperty("list")) {
                if (!Array.isArray(message.list)) return "list: array expected";

                for (var i = 0; i < message.list.length; ++i) {
                  var error = $root.serverProto.JpHistoryInfo.verify(message.list[i]);
                  if (error) return "list." + error;
                }
              }

              return null;
            };
            /**
            * Creates a JpHistoryResp message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof serverProto.JpHistoryResp
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {serverProto.JpHistoryResp} JpHistoryResp
            */


            JpHistoryResp.fromObject = function fromObject(object) {
              if (object instanceof $root.serverProto.JpHistoryResp) return object;
              var message = new $root.serverProto.JpHistoryResp();

              if (object.list) {
                if (!Array.isArray(object.list)) throw TypeError(".serverProto.JpHistoryResp.list: array expected");
                message.list = [];

                for (var i = 0; i < object.list.length; ++i) {
                  if (typeof object.list[i] !== "object") throw TypeError(".serverProto.JpHistoryResp.list: object expected");
                  message.list[i] = $root.serverProto.JpHistoryInfo.fromObject(object.list[i]);
                }
              }

              return message;
            };
            /**
            * Creates a plain object from a JpHistoryResp message. Also converts values to other types if specified.
            * @function toObject
            * @memberof serverProto.JpHistoryResp
            * @static
            * @param {serverProto.JpHistoryResp} message JpHistoryResp
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            JpHistoryResp.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};
              if (options.arrays || options.defaults) object.list = [];

              if (message.list && message.list.length) {
                object.list = [];

                for (var j = 0; j < message.list.length; ++j) {
                  object.list[j] = $root.serverProto.JpHistoryInfo.toObject(message.list[j], options);
                }
              }

              return object;
            };
            /**
            * Converts this JpHistoryResp to JSON.
            * @function toJSON
            * @memberof serverProto.JpHistoryResp
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            JpHistoryResp.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
            * Gets the default type url for JpHistoryResp
            * @function getTypeUrl
            * @memberof serverProto.JpHistoryResp
            * @static
            * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
            * @returns {string} The default type url
            */


            JpHistoryResp.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/serverProto.JpHistoryResp";
            };

            return JpHistoryResp;
          }();
          /**
          * JpType enum.
          * @name serverProto.JpType
          * @enum {number}
          * @property {number} None=0 None value
          * @property {number} Mini=1 Mini value
          * @property {number} Major=2 Major value
          * @property {number} Grand=3 Grand value
          */


          serverProto.JpType = function () {
            var valuesById = {},
                values = Object.create(valuesById);
            values[valuesById[0] = "None"] = 0;
            values[valuesById[1] = "Mini"] = 1;
            values[valuesById[2] = "Major"] = 2;
            values[valuesById[3] = "Grand"] = 3;
            return values;
          }();

          serverProto.JpInfo = function () {
            /**
            * Properties of a JpInfo.
            * @memberof serverProto
            * @interface IJpInfo
            * @property {serverProto.JpType|null} [type] JpInfo type
            * @property {number|null} [value] JpInfo value
            */

            /**
            * Constructs a new JpInfo.
            * @memberof serverProto
            * @classdesc Represents a JpInfo.
            * @implements IJpInfo
            * @constructor
            * @param {serverProto.IJpInfo=} [properties] Properties to set
            */
            function JpInfo(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * JpInfo type.
            * @member {serverProto.JpType} type
            * @memberof serverProto.JpInfo
            * @instance
            */


            JpInfo.prototype.type = 0;
            /**
            * JpInfo value.
            * @member {number} value
            * @memberof serverProto.JpInfo
            * @instance
            */

            JpInfo.prototype.value = 0;
            /**
            * Creates a new JpInfo instance using the specified properties.
            * @function create
            * @memberof serverProto.JpInfo
            * @static
            * @param {serverProto.IJpInfo=} [properties] Properties to set
            * @returns {serverProto.JpInfo} JpInfo instance
            */

            JpInfo.create = function create(properties) {
              return new JpInfo(properties);
            };
            /**
            * Encodes the specified JpInfo message. Does not implicitly {@link serverProto.JpInfo.verify|verify} messages.
            * @function encode
            * @memberof serverProto.JpInfo
            * @static
            * @param {serverProto.IJpInfo} message JpInfo message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            JpInfo.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.type != null && Object.hasOwnProperty.call(message, "type")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.type);
              if (message.value != null && Object.hasOwnProperty.call(message, "value")) writer.uint32(
              /* id 2, wireType 1 =*/
              17)["double"](message.value);
              return writer;
            };
            /**
            * Encodes the specified JpInfo message, length delimited. Does not implicitly {@link serverProto.JpInfo.verify|verify} messages.
            * @function encodeDelimited
            * @memberof serverProto.JpInfo
            * @static
            * @param {serverProto.IJpInfo} message JpInfo message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            JpInfo.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a JpInfo message from the specified reader or buffer.
            * @function decode
            * @memberof serverProto.JpInfo
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {serverProto.JpInfo} JpInfo
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            JpInfo.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.serverProto.JpInfo();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      message.type = reader.int32();
                      break;
                    }

                  case 2:
                    {
                      message.value = reader["double"]();
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a JpInfo message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof serverProto.JpInfo
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {serverProto.JpInfo} JpInfo
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            JpInfo.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a JpInfo message.
            * @function verify
            * @memberof serverProto.JpInfo
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            JpInfo.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.type != null && message.hasOwnProperty("type")) switch (message.type) {
                default:
                  return "type: enum value expected";

                case 0:
                case 1:
                case 2:
                case 3:
                  break;
              }
              if (message.value != null && message.hasOwnProperty("value")) if (typeof message.value !== "number") return "value: number expected";
              return null;
            };
            /**
            * Creates a JpInfo message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof serverProto.JpInfo
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {serverProto.JpInfo} JpInfo
            */


            JpInfo.fromObject = function fromObject(object) {
              if (object instanceof $root.serverProto.JpInfo) return object;
              var message = new $root.serverProto.JpInfo();

              switch (object.type) {
                default:
                  if (typeof object.type === "number") {
                    message.type = object.type;
                    break;
                  }

                  break;

                case "None":
                case 0:
                  message.type = 0;
                  break;

                case "Mini":
                case 1:
                  message.type = 1;
                  break;

                case "Major":
                case 2:
                  message.type = 2;
                  break;

                case "Grand":
                case 3:
                  message.type = 3;
                  break;
              }

              if (object.value != null) message.value = Number(object.value);
              return message;
            };
            /**
            * Creates a plain object from a JpInfo message. Also converts values to other types if specified.
            * @function toObject
            * @memberof serverProto.JpInfo
            * @static
            * @param {serverProto.JpInfo} message JpInfo
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            JpInfo.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.type = options.enums === String ? "None" : 0;
                object.value = 0;
              }

              if (message.type != null && message.hasOwnProperty("type")) object.type = options.enums === String ? $root.serverProto.JpType[message.type] === undefined ? message.type : $root.serverProto.JpType[message.type] : message.type;
              if (message.value != null && message.hasOwnProperty("value")) object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
              return object;
            };
            /**
            * Converts this JpInfo to JSON.
            * @function toJSON
            * @memberof serverProto.JpInfo
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            JpInfo.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
            * Gets the default type url for JpInfo
            * @function getTypeUrl
            * @memberof serverProto.JpInfo
            * @static
            * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
            * @returns {string} The default type url
            */


            JpInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/serverProto.JpInfo";
            };

            return JpInfo;
          }();

          serverProto.JpHistoryInfo = function () {
            /**
            * Properties of a JpHistoryInfo.
            * @memberof serverProto
            * @interface IJpHistoryInfo
            * @property {serverProto.JpType|null} [type] JpHistoryInfo type
            * @property {string|null} [winner] JpHistoryInfo winner
            * @property {number|null} [win] JpHistoryInfo win
            * @property {number|null} [gameID] JpHistoryInfo gameID
            * @property {string|null} [nickname] JpHistoryInfo nickname
            */

            /**
            * Constructs a new JpHistoryInfo.
            * @memberof serverProto
            * @classdesc Represents a JpHistoryInfo.
            * @implements IJpHistoryInfo
            * @constructor
            * @param {serverProto.IJpHistoryInfo=} [properties] Properties to set
            */
            function JpHistoryInfo(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * JpHistoryInfo type.
            * @member {serverProto.JpType} type
            * @memberof serverProto.JpHistoryInfo
            * @instance
            */


            JpHistoryInfo.prototype.type = 0;
            /**
            * JpHistoryInfo winner.
            * @member {string} winner
            * @memberof serverProto.JpHistoryInfo
            * @instance
            */

            JpHistoryInfo.prototype.winner = "";
            /**
            * JpHistoryInfo win.
            * @member {number} win
            * @memberof serverProto.JpHistoryInfo
            * @instance
            */

            JpHistoryInfo.prototype.win = 0;
            /**
            * JpHistoryInfo gameID.
            * @member {number} gameID
            * @memberof serverProto.JpHistoryInfo
            * @instance
            */

            JpHistoryInfo.prototype.gameID = 0;
            /**
            * JpHistoryInfo nickname.
            * @member {string} nickname
            * @memberof serverProto.JpHistoryInfo
            * @instance
            */

            JpHistoryInfo.prototype.nickname = "";
            /**
            * Creates a new JpHistoryInfo instance using the specified properties.
            * @function create
            * @memberof serverProto.JpHistoryInfo
            * @static
            * @param {serverProto.IJpHistoryInfo=} [properties] Properties to set
            * @returns {serverProto.JpHistoryInfo} JpHistoryInfo instance
            */

            JpHistoryInfo.create = function create(properties) {
              return new JpHistoryInfo(properties);
            };
            /**
            * Encodes the specified JpHistoryInfo message. Does not implicitly {@link serverProto.JpHistoryInfo.verify|verify} messages.
            * @function encode
            * @memberof serverProto.JpHistoryInfo
            * @static
            * @param {serverProto.IJpHistoryInfo} message JpHistoryInfo message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            JpHistoryInfo.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.type != null && Object.hasOwnProperty.call(message, "type")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.type);
              if (message.winner != null && Object.hasOwnProperty.call(message, "winner")) writer.uint32(
              /* id 2, wireType 2 =*/
              18).string(message.winner);
              if (message.win != null && Object.hasOwnProperty.call(message, "win")) writer.uint32(
              /* id 3, wireType 1 =*/
              25)["double"](message.win);
              if (message.gameID != null && Object.hasOwnProperty.call(message, "gameID")) writer.uint32(
              /* id 4, wireType 0 =*/
              32).int32(message.gameID);
              if (message.nickname != null && Object.hasOwnProperty.call(message, "nickname")) writer.uint32(
              /* id 5, wireType 2 =*/
              42).string(message.nickname);
              return writer;
            };
            /**
            * Encodes the specified JpHistoryInfo message, length delimited. Does not implicitly {@link serverProto.JpHistoryInfo.verify|verify} messages.
            * @function encodeDelimited
            * @memberof serverProto.JpHistoryInfo
            * @static
            * @param {serverProto.IJpHistoryInfo} message JpHistoryInfo message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            JpHistoryInfo.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a JpHistoryInfo message from the specified reader or buffer.
            * @function decode
            * @memberof serverProto.JpHistoryInfo
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {serverProto.JpHistoryInfo} JpHistoryInfo
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            JpHistoryInfo.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.serverProto.JpHistoryInfo();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      message.type = reader.int32();
                      break;
                    }

                  case 2:
                    {
                      message.winner = reader.string();
                      break;
                    }

                  case 3:
                    {
                      message.win = reader["double"]();
                      break;
                    }

                  case 4:
                    {
                      message.gameID = reader.int32();
                      break;
                    }

                  case 5:
                    {
                      message.nickname = reader.string();
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a JpHistoryInfo message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof serverProto.JpHistoryInfo
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {serverProto.JpHistoryInfo} JpHistoryInfo
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            JpHistoryInfo.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a JpHistoryInfo message.
            * @function verify
            * @memberof serverProto.JpHistoryInfo
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            JpHistoryInfo.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.type != null && message.hasOwnProperty("type")) switch (message.type) {
                default:
                  return "type: enum value expected";

                case 0:
                case 1:
                case 2:
                case 3:
                  break;
              }
              if (message.winner != null && message.hasOwnProperty("winner")) if (!$util.isString(message.winner)) return "winner: string expected";
              if (message.win != null && message.hasOwnProperty("win")) if (typeof message.win !== "number") return "win: number expected";
              if (message.gameID != null && message.hasOwnProperty("gameID")) if (!$util.isInteger(message.gameID)) return "gameID: integer expected";
              if (message.nickname != null && message.hasOwnProperty("nickname")) if (!$util.isString(message.nickname)) return "nickname: string expected";
              return null;
            };
            /**
            * Creates a JpHistoryInfo message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof serverProto.JpHistoryInfo
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {serverProto.JpHistoryInfo} JpHistoryInfo
            */


            JpHistoryInfo.fromObject = function fromObject(object) {
              if (object instanceof $root.serverProto.JpHistoryInfo) return object;
              var message = new $root.serverProto.JpHistoryInfo();

              switch (object.type) {
                default:
                  if (typeof object.type === "number") {
                    message.type = object.type;
                    break;
                  }

                  break;

                case "None":
                case 0:
                  message.type = 0;
                  break;

                case "Mini":
                case 1:
                  message.type = 1;
                  break;

                case "Major":
                case 2:
                  message.type = 2;
                  break;

                case "Grand":
                case 3:
                  message.type = 3;
                  break;
              }

              if (object.winner != null) message.winner = String(object.winner);
              if (object.win != null) message.win = Number(object.win);
              if (object.gameID != null) message.gameID = object.gameID | 0;
              if (object.nickname != null) message.nickname = String(object.nickname);
              return message;
            };
            /**
            * Creates a plain object from a JpHistoryInfo message. Also converts values to other types if specified.
            * @function toObject
            * @memberof serverProto.JpHistoryInfo
            * @static
            * @param {serverProto.JpHistoryInfo} message JpHistoryInfo
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            JpHistoryInfo.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.type = options.enums === String ? "None" : 0;
                object.winner = "";
                object.win = 0;
                object.gameID = 0;
                object.nickname = "";
              }

              if (message.type != null && message.hasOwnProperty("type")) object.type = options.enums === String ? $root.serverProto.JpType[message.type] === undefined ? message.type : $root.serverProto.JpType[message.type] : message.type;
              if (message.winner != null && message.hasOwnProperty("winner")) object.winner = message.winner;
              if (message.win != null && message.hasOwnProperty("win")) object.win = options.json && !isFinite(message.win) ? String(message.win) : message.win;
              if (message.gameID != null && message.hasOwnProperty("gameID")) object.gameID = message.gameID;
              if (message.nickname != null && message.hasOwnProperty("nickname")) object.nickname = message.nickname;
              return object;
            };
            /**
            * Converts this JpHistoryInfo to JSON.
            * @function toJSON
            * @memberof serverProto.JpHistoryInfo
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            JpHistoryInfo.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
            * Gets the default type url for JpHistoryInfo
            * @function getTypeUrl
            * @memberof serverProto.JpHistoryInfo
            * @static
            * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
            * @returns {string} The default type url
            */


            JpHistoryInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/serverProto.JpHistoryInfo";
            };

            return JpHistoryInfo;
          }();

          serverProto.JpMarqueeInfo = function () {
            /**
            * Properties of a JpMarqueeInfo.
            * @memberof serverProto
            * @interface IJpMarqueeInfo
            * @property {number|null} [aID] JpMarqueeInfo aID
            * @property {number|null} [gameID] JpMarqueeInfo gameID
            * @property {serverProto.JpType|null} [type] JpMarqueeInfo type
            * @property {string|null} [winner] JpMarqueeInfo winner
            * @property {number|null} [win] JpMarqueeInfo win
            * @property {string|null} [winnerNickname] JpMarqueeInfo winnerNickname
            */

            /**
            * Constructs a new JpMarqueeInfo.
            * @memberof serverProto
            * @classdesc Represents a JpMarqueeInfo.
            * @implements IJpMarqueeInfo
            * @constructor
            * @param {serverProto.IJpMarqueeInfo=} [properties] Properties to set
            */
            function JpMarqueeInfo(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * JpMarqueeInfo aID.
            * @member {number} aID
            * @memberof serverProto.JpMarqueeInfo
            * @instance
            */


            JpMarqueeInfo.prototype.aID = 0;
            /**
            * JpMarqueeInfo gameID.
            * @member {number} gameID
            * @memberof serverProto.JpMarqueeInfo
            * @instance
            */

            JpMarqueeInfo.prototype.gameID = 0;
            /**
            * JpMarqueeInfo type.
            * @member {serverProto.JpType} type
            * @memberof serverProto.JpMarqueeInfo
            * @instance
            */

            JpMarqueeInfo.prototype.type = 0;
            /**
            * JpMarqueeInfo winner.
            * @member {string} winner
            * @memberof serverProto.JpMarqueeInfo
            * @instance
            */

            JpMarqueeInfo.prototype.winner = "";
            /**
            * JpMarqueeInfo win.
            * @member {number} win
            * @memberof serverProto.JpMarqueeInfo
            * @instance
            */

            JpMarqueeInfo.prototype.win = 0;
            /**
            * JpMarqueeInfo winnerNickname.
            * @member {string} winnerNickname
            * @memberof serverProto.JpMarqueeInfo
            * @instance
            */

            JpMarqueeInfo.prototype.winnerNickname = "";
            /**
            * Creates a new JpMarqueeInfo instance using the specified properties.
            * @function create
            * @memberof serverProto.JpMarqueeInfo
            * @static
            * @param {serverProto.IJpMarqueeInfo=} [properties] Properties to set
            * @returns {serverProto.JpMarqueeInfo} JpMarqueeInfo instance
            */

            JpMarqueeInfo.create = function create(properties) {
              return new JpMarqueeInfo(properties);
            };
            /**
            * Encodes the specified JpMarqueeInfo message. Does not implicitly {@link serverProto.JpMarqueeInfo.verify|verify} messages.
            * @function encode
            * @memberof serverProto.JpMarqueeInfo
            * @static
            * @param {serverProto.IJpMarqueeInfo} message JpMarqueeInfo message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            JpMarqueeInfo.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.aID != null && Object.hasOwnProperty.call(message, "aID")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).uint32(message.aID);
              if (message.gameID != null && Object.hasOwnProperty.call(message, "gameID")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).uint32(message.gameID);
              if (message.type != null && Object.hasOwnProperty.call(message, "type")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.type);
              if (message.winner != null && Object.hasOwnProperty.call(message, "winner")) writer.uint32(
              /* id 4, wireType 2 =*/
              34).string(message.winner);
              if (message.win != null && Object.hasOwnProperty.call(message, "win")) writer.uint32(
              /* id 5, wireType 1 =*/
              41)["double"](message.win);
              if (message.winnerNickname != null && Object.hasOwnProperty.call(message, "winnerNickname")) writer.uint32(
              /* id 6, wireType 2 =*/
              50).string(message.winnerNickname);
              return writer;
            };
            /**
            * Encodes the specified JpMarqueeInfo message, length delimited. Does not implicitly {@link serverProto.JpMarqueeInfo.verify|verify} messages.
            * @function encodeDelimited
            * @memberof serverProto.JpMarqueeInfo
            * @static
            * @param {serverProto.IJpMarqueeInfo} message JpMarqueeInfo message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            JpMarqueeInfo.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a JpMarqueeInfo message from the specified reader or buffer.
            * @function decode
            * @memberof serverProto.JpMarqueeInfo
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {serverProto.JpMarqueeInfo} JpMarqueeInfo
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            JpMarqueeInfo.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.serverProto.JpMarqueeInfo();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      message.aID = reader.uint32();
                      break;
                    }

                  case 2:
                    {
                      message.gameID = reader.uint32();
                      break;
                    }

                  case 3:
                    {
                      message.type = reader.int32();
                      break;
                    }

                  case 4:
                    {
                      message.winner = reader.string();
                      break;
                    }

                  case 5:
                    {
                      message.win = reader["double"]();
                      break;
                    }

                  case 6:
                    {
                      message.winnerNickname = reader.string();
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a JpMarqueeInfo message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof serverProto.JpMarqueeInfo
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {serverProto.JpMarqueeInfo} JpMarqueeInfo
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            JpMarqueeInfo.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a JpMarqueeInfo message.
            * @function verify
            * @memberof serverProto.JpMarqueeInfo
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            JpMarqueeInfo.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.aID != null && message.hasOwnProperty("aID")) if (!$util.isInteger(message.aID)) return "aID: integer expected";
              if (message.gameID != null && message.hasOwnProperty("gameID")) if (!$util.isInteger(message.gameID)) return "gameID: integer expected";
              if (message.type != null && message.hasOwnProperty("type")) switch (message.type) {
                default:
                  return "type: enum value expected";

                case 0:
                case 1:
                case 2:
                case 3:
                  break;
              }
              if (message.winner != null && message.hasOwnProperty("winner")) if (!$util.isString(message.winner)) return "winner: string expected";
              if (message.win != null && message.hasOwnProperty("win")) if (typeof message.win !== "number") return "win: number expected";
              if (message.winnerNickname != null && message.hasOwnProperty("winnerNickname")) if (!$util.isString(message.winnerNickname)) return "winnerNickname: string expected";
              return null;
            };
            /**
            * Creates a JpMarqueeInfo message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof serverProto.JpMarqueeInfo
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {serverProto.JpMarqueeInfo} JpMarqueeInfo
            */


            JpMarqueeInfo.fromObject = function fromObject(object) {
              if (object instanceof $root.serverProto.JpMarqueeInfo) return object;
              var message = new $root.serverProto.JpMarqueeInfo();
              if (object.aID != null) message.aID = object.aID >>> 0;
              if (object.gameID != null) message.gameID = object.gameID >>> 0;

              switch (object.type) {
                default:
                  if (typeof object.type === "number") {
                    message.type = object.type;
                    break;
                  }

                  break;

                case "None":
                case 0:
                  message.type = 0;
                  break;

                case "Mini":
                case 1:
                  message.type = 1;
                  break;

                case "Major":
                case 2:
                  message.type = 2;
                  break;

                case "Grand":
                case 3:
                  message.type = 3;
                  break;
              }

              if (object.winner != null) message.winner = String(object.winner);
              if (object.win != null) message.win = Number(object.win);
              if (object.winnerNickname != null) message.winnerNickname = String(object.winnerNickname);
              return message;
            };
            /**
            * Creates a plain object from a JpMarqueeInfo message. Also converts values to other types if specified.
            * @function toObject
            * @memberof serverProto.JpMarqueeInfo
            * @static
            * @param {serverProto.JpMarqueeInfo} message JpMarqueeInfo
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            JpMarqueeInfo.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.aID = 0;
                object.gameID = 0;
                object.type = options.enums === String ? "None" : 0;
                object.winner = "";
                object.win = 0;
                object.winnerNickname = "";
              }

              if (message.aID != null && message.hasOwnProperty("aID")) object.aID = message.aID;
              if (message.gameID != null && message.hasOwnProperty("gameID")) object.gameID = message.gameID;
              if (message.type != null && message.hasOwnProperty("type")) object.type = options.enums === String ? $root.serverProto.JpType[message.type] === undefined ? message.type : $root.serverProto.JpType[message.type] : message.type;
              if (message.winner != null && message.hasOwnProperty("winner")) object.winner = message.winner;
              if (message.win != null && message.hasOwnProperty("win")) object.win = options.json && !isFinite(message.win) ? String(message.win) : message.win;
              if (message.winnerNickname != null && message.hasOwnProperty("winnerNickname")) object.winnerNickname = message.winnerNickname;
              return object;
            };
            /**
            * Converts this JpMarqueeInfo to JSON.
            * @function toJSON
            * @memberof serverProto.JpMarqueeInfo
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            JpMarqueeInfo.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
            * Gets the default type url for JpMarqueeInfo
            * @function getTypeUrl
            * @memberof serverProto.JpMarqueeInfo
            * @static
            * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
            * @returns {string} The default type url
            */


            JpMarqueeInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/serverProto.JpMarqueeInfo";
            };

            return JpMarqueeInfo;
          }();

          serverProto.JpOpen = function () {
            /**
            * Properties of a JpOpen.
            * @memberof serverProto
            * @interface IJpOpen
            * @property {serverProto.JpType|null} [type] JpOpen type
            * @property {number|null} [win] JpOpen win
            */

            /**
            * Constructs a new JpOpen.
            * @memberof serverProto
            * @classdesc Represents a JpOpen.
            * @implements IJpOpen
            * @constructor
            * @param {serverProto.IJpOpen=} [properties] Properties to set
            */
            function JpOpen(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * JpOpen type.
            * @member {serverProto.JpType} type
            * @memberof serverProto.JpOpen
            * @instance
            */


            JpOpen.prototype.type = 0;
            /**
            * JpOpen win.
            * @member {number} win
            * @memberof serverProto.JpOpen
            * @instance
            */

            JpOpen.prototype.win = 0;
            /**
            * Creates a new JpOpen instance using the specified properties.
            * @function create
            * @memberof serverProto.JpOpen
            * @static
            * @param {serverProto.IJpOpen=} [properties] Properties to set
            * @returns {serverProto.JpOpen} JpOpen instance
            */

            JpOpen.create = function create(properties) {
              return new JpOpen(properties);
            };
            /**
            * Encodes the specified JpOpen message. Does not implicitly {@link serverProto.JpOpen.verify|verify} messages.
            * @function encode
            * @memberof serverProto.JpOpen
            * @static
            * @param {serverProto.IJpOpen} message JpOpen message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            JpOpen.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.type != null && Object.hasOwnProperty.call(message, "type")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.type);
              if (message.win != null && Object.hasOwnProperty.call(message, "win")) writer.uint32(
              /* id 2, wireType 1 =*/
              17)["double"](message.win);
              return writer;
            };
            /**
            * Encodes the specified JpOpen message, length delimited. Does not implicitly {@link serverProto.JpOpen.verify|verify} messages.
            * @function encodeDelimited
            * @memberof serverProto.JpOpen
            * @static
            * @param {serverProto.IJpOpen} message JpOpen message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            JpOpen.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a JpOpen message from the specified reader or buffer.
            * @function decode
            * @memberof serverProto.JpOpen
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {serverProto.JpOpen} JpOpen
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            JpOpen.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.serverProto.JpOpen();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      message.type = reader.int32();
                      break;
                    }

                  case 2:
                    {
                      message.win = reader["double"]();
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a JpOpen message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof serverProto.JpOpen
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {serverProto.JpOpen} JpOpen
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            JpOpen.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a JpOpen message.
            * @function verify
            * @memberof serverProto.JpOpen
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            JpOpen.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.type != null && message.hasOwnProperty("type")) switch (message.type) {
                default:
                  return "type: enum value expected";

                case 0:
                case 1:
                case 2:
                case 3:
                  break;
              }
              if (message.win != null && message.hasOwnProperty("win")) if (typeof message.win !== "number") return "win: number expected";
              return null;
            };
            /**
            * Creates a JpOpen message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof serverProto.JpOpen
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {serverProto.JpOpen} JpOpen
            */


            JpOpen.fromObject = function fromObject(object) {
              if (object instanceof $root.serverProto.JpOpen) return object;
              var message = new $root.serverProto.JpOpen();

              switch (object.type) {
                default:
                  if (typeof object.type === "number") {
                    message.type = object.type;
                    break;
                  }

                  break;

                case "None":
                case 0:
                  message.type = 0;
                  break;

                case "Mini":
                case 1:
                  message.type = 1;
                  break;

                case "Major":
                case 2:
                  message.type = 2;
                  break;

                case "Grand":
                case 3:
                  message.type = 3;
                  break;
              }

              if (object.win != null) message.win = Number(object.win);
              return message;
            };
            /**
            * Creates a plain object from a JpOpen message. Also converts values to other types if specified.
            * @function toObject
            * @memberof serverProto.JpOpen
            * @static
            * @param {serverProto.JpOpen} message JpOpen
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            JpOpen.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.type = options.enums === String ? "None" : 0;
                object.win = 0;
              }

              if (message.type != null && message.hasOwnProperty("type")) object.type = options.enums === String ? $root.serverProto.JpType[message.type] === undefined ? message.type : $root.serverProto.JpType[message.type] : message.type;
              if (message.win != null && message.hasOwnProperty("win")) object.win = options.json && !isFinite(message.win) ? String(message.win) : message.win;
              return object;
            };
            /**
            * Converts this JpOpen to JSON.
            * @function toJSON
            * @memberof serverProto.JpOpen
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            JpOpen.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
            * Gets the default type url for JpOpen
            * @function getTypeUrl
            * @memberof serverProto.JpOpen
            * @static
            * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
            * @returns {string} The default type url
            */


            JpOpen.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/serverProto.JpOpen";
            };

            return JpOpen;
          }();

          serverProto.JpShowData = function () {
            /**
            * Properties of a JpShowData.
            * @memberof serverProto
            * @interface IJpShowData
            * @property {Array.<serverProto.IJpInfo>|null} [info] JpShowData info
            * @property {Array.<number>|null} [game] JpShowData game
            */

            /**
            * Constructs a new JpShowData.
            * @memberof serverProto
            * @classdesc Represents a JpShowData.
            * @implements IJpShowData
            * @constructor
            * @param {serverProto.IJpShowData=} [properties] Properties to set
            */
            function JpShowData(properties) {
              this.info = [];
              this.game = [];
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * JpShowData info.
            * @member {Array.<serverProto.IJpInfo>} info
            * @memberof serverProto.JpShowData
            * @instance
            */


            JpShowData.prototype.info = $util.emptyArray;
            /**
            * JpShowData game.
            * @member {Array.<number>} game
            * @memberof serverProto.JpShowData
            * @instance
            */

            JpShowData.prototype.game = $util.emptyArray;
            /**
            * Creates a new JpShowData instance using the specified properties.
            * @function create
            * @memberof serverProto.JpShowData
            * @static
            * @param {serverProto.IJpShowData=} [properties] Properties to set
            * @returns {serverProto.JpShowData} JpShowData instance
            */

            JpShowData.create = function create(properties) {
              return new JpShowData(properties);
            };
            /**
            * Encodes the specified JpShowData message. Does not implicitly {@link serverProto.JpShowData.verify|verify} messages.
            * @function encode
            * @memberof serverProto.JpShowData
            * @static
            * @param {serverProto.IJpShowData} message JpShowData message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            JpShowData.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.info != null && message.info.length) for (var i = 0; i < message.info.length; ++i) {
                $root.serverProto.JpInfo.encode(message.info[i], writer.uint32(
                /* id 1, wireType 2 =*/
                10).fork()).ldelim();
              }

              if (message.game != null && message.game.length) {
                writer.uint32(
                /* id 2, wireType 2 =*/
                18).fork();

                for (var i = 0; i < message.game.length; ++i) {
                  writer.int32(message.game[i]);
                }

                writer.ldelim();
              }

              return writer;
            };
            /**
            * Encodes the specified JpShowData message, length delimited. Does not implicitly {@link serverProto.JpShowData.verify|verify} messages.
            * @function encodeDelimited
            * @memberof serverProto.JpShowData
            * @static
            * @param {serverProto.IJpShowData} message JpShowData message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            JpShowData.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a JpShowData message from the specified reader or buffer.
            * @function decode
            * @memberof serverProto.JpShowData
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {serverProto.JpShowData} JpShowData
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            JpShowData.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.serverProto.JpShowData();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      if (!(message.info && message.info.length)) message.info = [];
                      message.info.push($root.serverProto.JpInfo.decode(reader, reader.uint32()));
                      break;
                    }

                  case 2:
                    {
                      if (!(message.game && message.game.length)) message.game = [];

                      if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;

                        while (reader.pos < end2) {
                          message.game.push(reader.int32());
                        }
                      } else message.game.push(reader.int32());

                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a JpShowData message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof serverProto.JpShowData
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {serverProto.JpShowData} JpShowData
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            JpShowData.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a JpShowData message.
            * @function verify
            * @memberof serverProto.JpShowData
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            JpShowData.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";

              if (message.info != null && message.hasOwnProperty("info")) {
                if (!Array.isArray(message.info)) return "info: array expected";

                for (var i = 0; i < message.info.length; ++i) {
                  var error = $root.serverProto.JpInfo.verify(message.info[i]);
                  if (error) return "info." + error;
                }
              }

              if (message.game != null && message.hasOwnProperty("game")) {
                if (!Array.isArray(message.game)) return "game: array expected";

                for (var i = 0; i < message.game.length; ++i) {
                  if (!$util.isInteger(message.game[i])) return "game: integer[] expected";
                }
              }

              return null;
            };
            /**
            * Creates a JpShowData message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof serverProto.JpShowData
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {serverProto.JpShowData} JpShowData
            */


            JpShowData.fromObject = function fromObject(object) {
              if (object instanceof $root.serverProto.JpShowData) return object;
              var message = new $root.serverProto.JpShowData();

              if (object.info) {
                if (!Array.isArray(object.info)) throw TypeError(".serverProto.JpShowData.info: array expected");
                message.info = [];

                for (var i = 0; i < object.info.length; ++i) {
                  if (typeof object.info[i] !== "object") throw TypeError(".serverProto.JpShowData.info: object expected");
                  message.info[i] = $root.serverProto.JpInfo.fromObject(object.info[i]);
                }
              }

              if (object.game) {
                if (!Array.isArray(object.game)) throw TypeError(".serverProto.JpShowData.game: array expected");
                message.game = [];

                for (var i = 0; i < object.game.length; ++i) {
                  message.game[i] = object.game[i] | 0;
                }
              }

              return message;
            };
            /**
            * Creates a plain object from a JpShowData message. Also converts values to other types if specified.
            * @function toObject
            * @memberof serverProto.JpShowData
            * @static
            * @param {serverProto.JpShowData} message JpShowData
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            JpShowData.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.arrays || options.defaults) {
                object.info = [];
                object.game = [];
              }

              if (message.info && message.info.length) {
                object.info = [];

                for (var j = 0; j < message.info.length; ++j) {
                  object.info[j] = $root.serverProto.JpInfo.toObject(message.info[j], options);
                }
              }

              if (message.game && message.game.length) {
                object.game = [];

                for (var j = 0; j < message.game.length; ++j) {
                  object.game[j] = message.game[j];
                }
              }

              return object;
            };
            /**
            * Converts this JpShowData to JSON.
            * @function toJSON
            * @memberof serverProto.JpShowData
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            JpShowData.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
            * Gets the default type url for JpShowData
            * @function getTypeUrl
            * @memberof serverProto.JpShowData
            * @static
            * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
            * @returns {string} The default type url
            */


            JpShowData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/serverProto.JpShowData";
            };

            return JpShowData;
          }();

          serverProto.FullJpListResp = function () {
            /**
            * Properties of a FullJpListResp.
            * @memberof serverProto
            * @interface IFullJpListResp
            * @property {number|null} [value] FullJpListResp value
            * @property {number|null} [full] FullJpListResp full
            * @property {number|null} [minVip] FullJpListResp minVip
            * @property {number|null} [minBet] FullJpListResp minBet
            */

            /**
            * Constructs a new FullJpListResp.
            * @memberof serverProto
            * @classdesc Represents a FullJpListResp.
            * @implements IFullJpListResp
            * @constructor
            * @param {serverProto.IFullJpListResp=} [properties] Properties to set
            */
            function FullJpListResp(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * FullJpListResp value.
            * @member {number} value
            * @memberof serverProto.FullJpListResp
            * @instance
            */


            FullJpListResp.prototype.value = 0;
            /**
            * FullJpListResp full.
            * @member {number} full
            * @memberof serverProto.FullJpListResp
            * @instance
            */

            FullJpListResp.prototype.full = 0;
            /**
            * FullJpListResp minVip.
            * @member {number} minVip
            * @memberof serverProto.FullJpListResp
            * @instance
            */

            FullJpListResp.prototype.minVip = 0;
            /**
            * FullJpListResp minBet.
            * @member {number} minBet
            * @memberof serverProto.FullJpListResp
            * @instance
            */

            FullJpListResp.prototype.minBet = 0;
            /**
            * Creates a new FullJpListResp instance using the specified properties.
            * @function create
            * @memberof serverProto.FullJpListResp
            * @static
            * @param {serverProto.IFullJpListResp=} [properties] Properties to set
            * @returns {serverProto.FullJpListResp} FullJpListResp instance
            */

            FullJpListResp.create = function create(properties) {
              return new FullJpListResp(properties);
            };
            /**
            * Encodes the specified FullJpListResp message. Does not implicitly {@link serverProto.FullJpListResp.verify|verify} messages.
            * @function encode
            * @memberof serverProto.FullJpListResp
            * @static
            * @param {serverProto.IFullJpListResp} message FullJpListResp message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            FullJpListResp.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.value != null && Object.hasOwnProperty.call(message, "value")) writer.uint32(
              /* id 1, wireType 1 =*/
              9)["double"](message.value);
              if (message.full != null && Object.hasOwnProperty.call(message, "full")) writer.uint32(
              /* id 2, wireType 1 =*/
              17)["double"](message.full);
              if (message.minVip != null && Object.hasOwnProperty.call(message, "minVip")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).uint32(message.minVip);
              if (message.minBet != null && Object.hasOwnProperty.call(message, "minBet")) writer.uint32(
              /* id 4, wireType 1 =*/
              33)["double"](message.minBet);
              return writer;
            };
            /**
            * Encodes the specified FullJpListResp message, length delimited. Does not implicitly {@link serverProto.FullJpListResp.verify|verify} messages.
            * @function encodeDelimited
            * @memberof serverProto.FullJpListResp
            * @static
            * @param {serverProto.IFullJpListResp} message FullJpListResp message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            FullJpListResp.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a FullJpListResp message from the specified reader or buffer.
            * @function decode
            * @memberof serverProto.FullJpListResp
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {serverProto.FullJpListResp} FullJpListResp
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            FullJpListResp.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.serverProto.FullJpListResp();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      message.value = reader["double"]();
                      break;
                    }

                  case 2:
                    {
                      message.full = reader["double"]();
                      break;
                    }

                  case 3:
                    {
                      message.minVip = reader.uint32();
                      break;
                    }

                  case 4:
                    {
                      message.minBet = reader["double"]();
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a FullJpListResp message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof serverProto.FullJpListResp
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {serverProto.FullJpListResp} FullJpListResp
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            FullJpListResp.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a FullJpListResp message.
            * @function verify
            * @memberof serverProto.FullJpListResp
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            FullJpListResp.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.value != null && message.hasOwnProperty("value")) if (typeof message.value !== "number") return "value: number expected";
              if (message.full != null && message.hasOwnProperty("full")) if (typeof message.full !== "number") return "full: number expected";
              if (message.minVip != null && message.hasOwnProperty("minVip")) if (!$util.isInteger(message.minVip)) return "minVip: integer expected";
              if (message.minBet != null && message.hasOwnProperty("minBet")) if (typeof message.minBet !== "number") return "minBet: number expected";
              return null;
            };
            /**
            * Creates a FullJpListResp message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof serverProto.FullJpListResp
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {serverProto.FullJpListResp} FullJpListResp
            */


            FullJpListResp.fromObject = function fromObject(object) {
              if (object instanceof $root.serverProto.FullJpListResp) return object;
              var message = new $root.serverProto.FullJpListResp();
              if (object.value != null) message.value = Number(object.value);
              if (object.full != null) message.full = Number(object.full);
              if (object.minVip != null) message.minVip = object.minVip >>> 0;
              if (object.minBet != null) message.minBet = Number(object.minBet);
              return message;
            };
            /**
            * Creates a plain object from a FullJpListResp message. Also converts values to other types if specified.
            * @function toObject
            * @memberof serverProto.FullJpListResp
            * @static
            * @param {serverProto.FullJpListResp} message FullJpListResp
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            FullJpListResp.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.value = 0;
                object.full = 0;
                object.minVip = 0;
                object.minBet = 0;
              }

              if (message.value != null && message.hasOwnProperty("value")) object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
              if (message.full != null && message.hasOwnProperty("full")) object.full = options.json && !isFinite(message.full) ? String(message.full) : message.full;
              if (message.minVip != null && message.hasOwnProperty("minVip")) object.minVip = message.minVip;
              if (message.minBet != null && message.hasOwnProperty("minBet")) object.minBet = options.json && !isFinite(message.minBet) ? String(message.minBet) : message.minBet;
              return object;
            };
            /**
            * Converts this FullJpListResp to JSON.
            * @function toJSON
            * @memberof serverProto.FullJpListResp
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            FullJpListResp.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
            * Gets the default type url for FullJpListResp
            * @function getTypeUrl
            * @memberof serverProto.FullJpListResp
            * @static
            * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
            * @returns {string} The default type url
            */


            FullJpListResp.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/serverProto.FullJpListResp";
            };

            return FullJpListResp;
          }();

          serverProto.FullJpHistoryReq = function () {
            /**
            * Properties of a FullJpHistoryReq.
            * @memberof serverProto
            * @interface IFullJpHistoryReq
            * @property {google.protobuf.ITimestamp|null} [startTime] FullJpHistoryReq startTime
            * @property {google.protobuf.ITimestamp|null} [endTime] FullJpHistoryReq endTime
            */

            /**
            * Constructs a new FullJpHistoryReq.
            * @memberof serverProto
            * @classdesc Represents a FullJpHistoryReq.
            * @implements IFullJpHistoryReq
            * @constructor
            * @param {serverProto.IFullJpHistoryReq=} [properties] Properties to set
            */
            function FullJpHistoryReq(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * FullJpHistoryReq startTime.
            * @member {google.protobuf.ITimestamp|null|undefined} startTime
            * @memberof serverProto.FullJpHistoryReq
            * @instance
            */


            FullJpHistoryReq.prototype.startTime = null;
            /**
            * FullJpHistoryReq endTime.
            * @member {google.protobuf.ITimestamp|null|undefined} endTime
            * @memberof serverProto.FullJpHistoryReq
            * @instance
            */

            FullJpHistoryReq.prototype.endTime = null;
            /**
            * Creates a new FullJpHistoryReq instance using the specified properties.
            * @function create
            * @memberof serverProto.FullJpHistoryReq
            * @static
            * @param {serverProto.IFullJpHistoryReq=} [properties] Properties to set
            * @returns {serverProto.FullJpHistoryReq} FullJpHistoryReq instance
            */

            FullJpHistoryReq.create = function create(properties) {
              return new FullJpHistoryReq(properties);
            };
            /**
            * Encodes the specified FullJpHistoryReq message. Does not implicitly {@link serverProto.FullJpHistoryReq.verify|verify} messages.
            * @function encode
            * @memberof serverProto.FullJpHistoryReq
            * @static
            * @param {serverProto.IFullJpHistoryReq} message FullJpHistoryReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            FullJpHistoryReq.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.startTime != null && Object.hasOwnProperty.call(message, "startTime")) $root.google.protobuf.Timestamp.encode(message.startTime, writer.uint32(
              /* id 1, wireType 2 =*/
              10).fork()).ldelim();
              if (message.endTime != null && Object.hasOwnProperty.call(message, "endTime")) $root.google.protobuf.Timestamp.encode(message.endTime, writer.uint32(
              /* id 2, wireType 2 =*/
              18).fork()).ldelim();
              return writer;
            };
            /**
            * Encodes the specified FullJpHistoryReq message, length delimited. Does not implicitly {@link serverProto.FullJpHistoryReq.verify|verify} messages.
            * @function encodeDelimited
            * @memberof serverProto.FullJpHistoryReq
            * @static
            * @param {serverProto.IFullJpHistoryReq} message FullJpHistoryReq message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            FullJpHistoryReq.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a FullJpHistoryReq message from the specified reader or buffer.
            * @function decode
            * @memberof serverProto.FullJpHistoryReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {serverProto.FullJpHistoryReq} FullJpHistoryReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            FullJpHistoryReq.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.serverProto.FullJpHistoryReq();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      message.startTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                      break;
                    }

                  case 2:
                    {
                      message.endTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a FullJpHistoryReq message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof serverProto.FullJpHistoryReq
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {serverProto.FullJpHistoryReq} FullJpHistoryReq
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            FullJpHistoryReq.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a FullJpHistoryReq message.
            * @function verify
            * @memberof serverProto.FullJpHistoryReq
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            FullJpHistoryReq.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";

              if (message.startTime != null && message.hasOwnProperty("startTime")) {
                var error = $root.google.protobuf.Timestamp.verify(message.startTime);
                if (error) return "startTime." + error;
              }

              if (message.endTime != null && message.hasOwnProperty("endTime")) {
                var error = $root.google.protobuf.Timestamp.verify(message.endTime);
                if (error) return "endTime." + error;
              }

              return null;
            };
            /**
            * Creates a FullJpHistoryReq message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof serverProto.FullJpHistoryReq
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {serverProto.FullJpHistoryReq} FullJpHistoryReq
            */


            FullJpHistoryReq.fromObject = function fromObject(object) {
              if (object instanceof $root.serverProto.FullJpHistoryReq) return object;
              var message = new $root.serverProto.FullJpHistoryReq();

              if (object.startTime != null) {
                if (typeof object.startTime !== "object") throw TypeError(".serverProto.FullJpHistoryReq.startTime: object expected");
                message.startTime = $root.google.protobuf.Timestamp.fromObject(object.startTime);
              }

              if (object.endTime != null) {
                if (typeof object.endTime !== "object") throw TypeError(".serverProto.FullJpHistoryReq.endTime: object expected");
                message.endTime = $root.google.protobuf.Timestamp.fromObject(object.endTime);
              }

              return message;
            };
            /**
            * Creates a plain object from a FullJpHistoryReq message. Also converts values to other types if specified.
            * @function toObject
            * @memberof serverProto.FullJpHistoryReq
            * @static
            * @param {serverProto.FullJpHistoryReq} message FullJpHistoryReq
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            FullJpHistoryReq.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.startTime = null;
                object.endTime = null;
              }

              if (message.startTime != null && message.hasOwnProperty("startTime")) object.startTime = $root.google.protobuf.Timestamp.toObject(message.startTime, options);
              if (message.endTime != null && message.hasOwnProperty("endTime")) object.endTime = $root.google.protobuf.Timestamp.toObject(message.endTime, options);
              return object;
            };
            /**
            * Converts this FullJpHistoryReq to JSON.
            * @function toJSON
            * @memberof serverProto.FullJpHistoryReq
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            FullJpHistoryReq.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
            * Gets the default type url for FullJpHistoryReq
            * @function getTypeUrl
            * @memberof serverProto.FullJpHistoryReq
            * @static
            * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
            * @returns {string} The default type url
            */


            FullJpHistoryReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/serverProto.FullJpHistoryReq";
            };

            return FullJpHistoryReq;
          }();

          serverProto.FullJpHistoryResp = function () {
            /**
            * Properties of a FullJpHistoryResp.
            * @memberof serverProto
            * @interface IFullJpHistoryResp
            * @property {Array.<serverProto.IFullJpHistoryInfo>|null} [list] FullJpHistoryResp list
            */

            /**
            * Constructs a new FullJpHistoryResp.
            * @memberof serverProto
            * @classdesc Represents a FullJpHistoryResp.
            * @implements IFullJpHistoryResp
            * @constructor
            * @param {serverProto.IFullJpHistoryResp=} [properties] Properties to set
            */
            function FullJpHistoryResp(properties) {
              this.list = [];
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * FullJpHistoryResp list.
            * @member {Array.<serverProto.IFullJpHistoryInfo>} list
            * @memberof serverProto.FullJpHistoryResp
            * @instance
            */


            FullJpHistoryResp.prototype.list = $util.emptyArray;
            /**
            * Creates a new FullJpHistoryResp instance using the specified properties.
            * @function create
            * @memberof serverProto.FullJpHistoryResp
            * @static
            * @param {serverProto.IFullJpHistoryResp=} [properties] Properties to set
            * @returns {serverProto.FullJpHistoryResp} FullJpHistoryResp instance
            */

            FullJpHistoryResp.create = function create(properties) {
              return new FullJpHistoryResp(properties);
            };
            /**
            * Encodes the specified FullJpHistoryResp message. Does not implicitly {@link serverProto.FullJpHistoryResp.verify|verify} messages.
            * @function encode
            * @memberof serverProto.FullJpHistoryResp
            * @static
            * @param {serverProto.IFullJpHistoryResp} message FullJpHistoryResp message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            FullJpHistoryResp.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.list != null && message.list.length) for (var i = 0; i < message.list.length; ++i) {
                $root.serverProto.FullJpHistoryInfo.encode(message.list[i], writer.uint32(
                /* id 1, wireType 2 =*/
                10).fork()).ldelim();
              }
              return writer;
            };
            /**
            * Encodes the specified FullJpHistoryResp message, length delimited. Does not implicitly {@link serverProto.FullJpHistoryResp.verify|verify} messages.
            * @function encodeDelimited
            * @memberof serverProto.FullJpHistoryResp
            * @static
            * @param {serverProto.IFullJpHistoryResp} message FullJpHistoryResp message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            FullJpHistoryResp.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a FullJpHistoryResp message from the specified reader or buffer.
            * @function decode
            * @memberof serverProto.FullJpHistoryResp
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {serverProto.FullJpHistoryResp} FullJpHistoryResp
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            FullJpHistoryResp.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.serverProto.FullJpHistoryResp();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      if (!(message.list && message.list.length)) message.list = [];
                      message.list.push($root.serverProto.FullJpHistoryInfo.decode(reader, reader.uint32()));
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a FullJpHistoryResp message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof serverProto.FullJpHistoryResp
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {serverProto.FullJpHistoryResp} FullJpHistoryResp
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            FullJpHistoryResp.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a FullJpHistoryResp message.
            * @function verify
            * @memberof serverProto.FullJpHistoryResp
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            FullJpHistoryResp.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";

              if (message.list != null && message.hasOwnProperty("list")) {
                if (!Array.isArray(message.list)) return "list: array expected";

                for (var i = 0; i < message.list.length; ++i) {
                  var error = $root.serverProto.FullJpHistoryInfo.verify(message.list[i]);
                  if (error) return "list." + error;
                }
              }

              return null;
            };
            /**
            * Creates a FullJpHistoryResp message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof serverProto.FullJpHistoryResp
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {serverProto.FullJpHistoryResp} FullJpHistoryResp
            */


            FullJpHistoryResp.fromObject = function fromObject(object) {
              if (object instanceof $root.serverProto.FullJpHistoryResp) return object;
              var message = new $root.serverProto.FullJpHistoryResp();

              if (object.list) {
                if (!Array.isArray(object.list)) throw TypeError(".serverProto.FullJpHistoryResp.list: array expected");
                message.list = [];

                for (var i = 0; i < object.list.length; ++i) {
                  if (typeof object.list[i] !== "object") throw TypeError(".serverProto.FullJpHistoryResp.list: object expected");
                  message.list[i] = $root.serverProto.FullJpHistoryInfo.fromObject(object.list[i]);
                }
              }

              return message;
            };
            /**
            * Creates a plain object from a FullJpHistoryResp message. Also converts values to other types if specified.
            * @function toObject
            * @memberof serverProto.FullJpHistoryResp
            * @static
            * @param {serverProto.FullJpHistoryResp} message FullJpHistoryResp
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            FullJpHistoryResp.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};
              if (options.arrays || options.defaults) object.list = [];

              if (message.list && message.list.length) {
                object.list = [];

                for (var j = 0; j < message.list.length; ++j) {
                  object.list[j] = $root.serverProto.FullJpHistoryInfo.toObject(message.list[j], options);
                }
              }

              return object;
            };
            /**
            * Converts this FullJpHistoryResp to JSON.
            * @function toJSON
            * @memberof serverProto.FullJpHistoryResp
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            FullJpHistoryResp.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
            * Gets the default type url for FullJpHistoryResp
            * @function getTypeUrl
            * @memberof serverProto.FullJpHistoryResp
            * @static
            * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
            * @returns {string} The default type url
            */


            FullJpHistoryResp.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/serverProto.FullJpHistoryResp";
            };

            return FullJpHistoryResp;
          }();

          serverProto.FullJpAllResp = function () {
            /**
            * Properties of a FullJpAllResp.
            * @memberof serverProto
            * @interface IFullJpAllResp
            * @property {Array.<serverProto.IFullJp>|null} [list] FullJpAllResp list
            */

            /**
            * Constructs a new FullJpAllResp.
            * @memberof serverProto
            * @classdesc Represents a FullJpAllResp.
            * @implements IFullJpAllResp
            * @constructor
            * @param {serverProto.IFullJpAllResp=} [properties] Properties to set
            */
            function FullJpAllResp(properties) {
              this.list = [];
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * FullJpAllResp list.
            * @member {Array.<serverProto.IFullJp>} list
            * @memberof serverProto.FullJpAllResp
            * @instance
            */


            FullJpAllResp.prototype.list = $util.emptyArray;
            /**
            * Creates a new FullJpAllResp instance using the specified properties.
            * @function create
            * @memberof serverProto.FullJpAllResp
            * @static
            * @param {serverProto.IFullJpAllResp=} [properties] Properties to set
            * @returns {serverProto.FullJpAllResp} FullJpAllResp instance
            */

            FullJpAllResp.create = function create(properties) {
              return new FullJpAllResp(properties);
            };
            /**
            * Encodes the specified FullJpAllResp message. Does not implicitly {@link serverProto.FullJpAllResp.verify|verify} messages.
            * @function encode
            * @memberof serverProto.FullJpAllResp
            * @static
            * @param {serverProto.IFullJpAllResp} message FullJpAllResp message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            FullJpAllResp.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.list != null && message.list.length) for (var i = 0; i < message.list.length; ++i) {
                $root.serverProto.FullJp.encode(message.list[i], writer.uint32(
                /* id 1, wireType 2 =*/
                10).fork()).ldelim();
              }
              return writer;
            };
            /**
            * Encodes the specified FullJpAllResp message, length delimited. Does not implicitly {@link serverProto.FullJpAllResp.verify|verify} messages.
            * @function encodeDelimited
            * @memberof serverProto.FullJpAllResp
            * @static
            * @param {serverProto.IFullJpAllResp} message FullJpAllResp message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            FullJpAllResp.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a FullJpAllResp message from the specified reader or buffer.
            * @function decode
            * @memberof serverProto.FullJpAllResp
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {serverProto.FullJpAllResp} FullJpAllResp
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            FullJpAllResp.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.serverProto.FullJpAllResp();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      if (!(message.list && message.list.length)) message.list = [];
                      message.list.push($root.serverProto.FullJp.decode(reader, reader.uint32()));
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a FullJpAllResp message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof serverProto.FullJpAllResp
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {serverProto.FullJpAllResp} FullJpAllResp
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            FullJpAllResp.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a FullJpAllResp message.
            * @function verify
            * @memberof serverProto.FullJpAllResp
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            FullJpAllResp.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";

              if (message.list != null && message.hasOwnProperty("list")) {
                if (!Array.isArray(message.list)) return "list: array expected";

                for (var i = 0; i < message.list.length; ++i) {
                  var error = $root.serverProto.FullJp.verify(message.list[i]);
                  if (error) return "list." + error;
                }
              }

              return null;
            };
            /**
            * Creates a FullJpAllResp message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof serverProto.FullJpAllResp
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {serverProto.FullJpAllResp} FullJpAllResp
            */


            FullJpAllResp.fromObject = function fromObject(object) {
              if (object instanceof $root.serverProto.FullJpAllResp) return object;
              var message = new $root.serverProto.FullJpAllResp();

              if (object.list) {
                if (!Array.isArray(object.list)) throw TypeError(".serverProto.FullJpAllResp.list: array expected");
                message.list = [];

                for (var i = 0; i < object.list.length; ++i) {
                  if (typeof object.list[i] !== "object") throw TypeError(".serverProto.FullJpAllResp.list: object expected");
                  message.list[i] = $root.serverProto.FullJp.fromObject(object.list[i]);
                }
              }

              return message;
            };
            /**
            * Creates a plain object from a FullJpAllResp message. Also converts values to other types if specified.
            * @function toObject
            * @memberof serverProto.FullJpAllResp
            * @static
            * @param {serverProto.FullJpAllResp} message FullJpAllResp
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            FullJpAllResp.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};
              if (options.arrays || options.defaults) object.list = [];

              if (message.list && message.list.length) {
                object.list = [];

                for (var j = 0; j < message.list.length; ++j) {
                  object.list[j] = $root.serverProto.FullJp.toObject(message.list[j], options);
                }
              }

              return object;
            };
            /**
            * Converts this FullJpAllResp to JSON.
            * @function toJSON
            * @memberof serverProto.FullJpAllResp
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            FullJpAllResp.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
            * Gets the default type url for FullJpAllResp
            * @function getTypeUrl
            * @memberof serverProto.FullJpAllResp
            * @static
            * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
            * @returns {string} The default type url
            */


            FullJpAllResp.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/serverProto.FullJpAllResp";
            };

            return FullJpAllResp;
          }();

          serverProto.FullJpHistoryInfo = function () {
            /**
            * Properties of a FullJpHistoryInfo.
            * @memberof serverProto
            * @interface IFullJpHistoryInfo
            * @property {string|null} [winner] FullJpHistoryInfo winner
            * @property {number|null} [win] FullJpHistoryInfo win
            * @property {number|Long|null} [time] FullJpHistoryInfo time
            */

            /**
            * Constructs a new FullJpHistoryInfo.
            * @memberof serverProto
            * @classdesc Represents a FullJpHistoryInfo.
            * @implements IFullJpHistoryInfo
            * @constructor
            * @param {serverProto.IFullJpHistoryInfo=} [properties] Properties to set
            */
            function FullJpHistoryInfo(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * FullJpHistoryInfo winner.
            * @member {string} winner
            * @memberof serverProto.FullJpHistoryInfo
            * @instance
            */


            FullJpHistoryInfo.prototype.winner = "";
            /**
            * FullJpHistoryInfo win.
            * @member {number} win
            * @memberof serverProto.FullJpHistoryInfo
            * @instance
            */

            FullJpHistoryInfo.prototype.win = 0;
            /**
            * FullJpHistoryInfo time.
            * @member {number|Long} time
            * @memberof serverProto.FullJpHistoryInfo
            * @instance
            */

            FullJpHistoryInfo.prototype.time = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
            * Creates a new FullJpHistoryInfo instance using the specified properties.
            * @function create
            * @memberof serverProto.FullJpHistoryInfo
            * @static
            * @param {serverProto.IFullJpHistoryInfo=} [properties] Properties to set
            * @returns {serverProto.FullJpHistoryInfo} FullJpHistoryInfo instance
            */

            FullJpHistoryInfo.create = function create(properties) {
              return new FullJpHistoryInfo(properties);
            };
            /**
            * Encodes the specified FullJpHistoryInfo message. Does not implicitly {@link serverProto.FullJpHistoryInfo.verify|verify} messages.
            * @function encode
            * @memberof serverProto.FullJpHistoryInfo
            * @static
            * @param {serverProto.IFullJpHistoryInfo} message FullJpHistoryInfo message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            FullJpHistoryInfo.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.winner != null && Object.hasOwnProperty.call(message, "winner")) writer.uint32(
              /* id 1, wireType 2 =*/
              10).string(message.winner);
              if (message.win != null && Object.hasOwnProperty.call(message, "win")) writer.uint32(
              /* id 2, wireType 1 =*/
              17)["double"](message.win);
              if (message.time != null && Object.hasOwnProperty.call(message, "time")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int64(message.time);
              return writer;
            };
            /**
            * Encodes the specified FullJpHistoryInfo message, length delimited. Does not implicitly {@link serverProto.FullJpHistoryInfo.verify|verify} messages.
            * @function encodeDelimited
            * @memberof serverProto.FullJpHistoryInfo
            * @static
            * @param {serverProto.IFullJpHistoryInfo} message FullJpHistoryInfo message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            FullJpHistoryInfo.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a FullJpHistoryInfo message from the specified reader or buffer.
            * @function decode
            * @memberof serverProto.FullJpHistoryInfo
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {serverProto.FullJpHistoryInfo} FullJpHistoryInfo
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            FullJpHistoryInfo.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.serverProto.FullJpHistoryInfo();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      message.winner = reader.string();
                      break;
                    }

                  case 2:
                    {
                      message.win = reader["double"]();
                      break;
                    }

                  case 3:
                    {
                      message.time = reader.int64();
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a FullJpHistoryInfo message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof serverProto.FullJpHistoryInfo
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {serverProto.FullJpHistoryInfo} FullJpHistoryInfo
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            FullJpHistoryInfo.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a FullJpHistoryInfo message.
            * @function verify
            * @memberof serverProto.FullJpHistoryInfo
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            FullJpHistoryInfo.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.winner != null && message.hasOwnProperty("winner")) if (!$util.isString(message.winner)) return "winner: string expected";
              if (message.win != null && message.hasOwnProperty("win")) if (typeof message.win !== "number") return "win: number expected";
              if (message.time != null && message.hasOwnProperty("time")) if (!$util.isInteger(message.time) && !(message.time && $util.isInteger(message.time.low) && $util.isInteger(message.time.high))) return "time: integer|Long expected";
              return null;
            };
            /**
            * Creates a FullJpHistoryInfo message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof serverProto.FullJpHistoryInfo
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {serverProto.FullJpHistoryInfo} FullJpHistoryInfo
            */


            FullJpHistoryInfo.fromObject = function fromObject(object) {
              if (object instanceof $root.serverProto.FullJpHistoryInfo) return object;
              var message = new $root.serverProto.FullJpHistoryInfo();
              if (object.winner != null) message.winner = String(object.winner);
              if (object.win != null) message.win = Number(object.win);
              if (object.time != null) if ($util.Long) (message.time = $util.Long.fromValue(object.time)).unsigned = false;else if (typeof object.time === "string") message.time = parseInt(object.time, 10);else if (typeof object.time === "number") message.time = object.time;else if (typeof object.time === "object") message.time = new $util.LongBits(object.time.low >>> 0, object.time.high >>> 0).toNumber();
              return message;
            };
            /**
            * Creates a plain object from a FullJpHistoryInfo message. Also converts values to other types if specified.
            * @function toObject
            * @memberof serverProto.FullJpHistoryInfo
            * @static
            * @param {serverProto.FullJpHistoryInfo} message FullJpHistoryInfo
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            FullJpHistoryInfo.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.winner = "";
                object.win = 0;

                if ($util.Long) {
                  var _long12 = new $util.Long(0, 0, false);

                  object.time = options.longs === String ? _long12.toString() : options.longs === Number ? _long12.toNumber() : _long12;
                } else object.time = options.longs === String ? "0" : 0;
              }

              if (message.winner != null && message.hasOwnProperty("winner")) object.winner = message.winner;
              if (message.win != null && message.hasOwnProperty("win")) object.win = options.json && !isFinite(message.win) ? String(message.win) : message.win;
              if (message.time != null && message.hasOwnProperty("time")) if (typeof message.time === "number") object.time = options.longs === String ? String(message.time) : message.time;else object.time = options.longs === String ? $util.Long.prototype.toString.call(message.time) : options.longs === Number ? new $util.LongBits(message.time.low >>> 0, message.time.high >>> 0).toNumber() : message.time;
              return object;
            };
            /**
            * Converts this FullJpHistoryInfo to JSON.
            * @function toJSON
            * @memberof serverProto.FullJpHistoryInfo
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            FullJpHistoryInfo.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
            * Gets the default type url for FullJpHistoryInfo
            * @function getTypeUrl
            * @memberof serverProto.FullJpHistoryInfo
            * @static
            * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
            * @returns {string} The default type url
            */


            FullJpHistoryInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/serverProto.FullJpHistoryInfo";
            };

            return FullJpHistoryInfo;
          }();

          serverProto.FullJp = function () {
            /**
            * Properties of a FullJp.
            * @memberof serverProto
            * @interface IFullJp
            * @property {number|null} [gameID] FullJp gameID
            * @property {number|null} [value] FullJp value
            * @property {number|null} [full] FullJp full
            */

            /**
            * Constructs a new FullJp.
            * @memberof serverProto
            * @classdesc Represents a FullJp.
            * @implements IFullJp
            * @constructor
            * @param {serverProto.IFullJp=} [properties] Properties to set
            */
            function FullJp(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * FullJp gameID.
            * @member {number} gameID
            * @memberof serverProto.FullJp
            * @instance
            */


            FullJp.prototype.gameID = 0;
            /**
            * FullJp value.
            * @member {number} value
            * @memberof serverProto.FullJp
            * @instance
            */

            FullJp.prototype.value = 0;
            /**
            * FullJp full.
            * @member {number} full
            * @memberof serverProto.FullJp
            * @instance
            */

            FullJp.prototype.full = 0;
            /**
            * Creates a new FullJp instance using the specified properties.
            * @function create
            * @memberof serverProto.FullJp
            * @static
            * @param {serverProto.IFullJp=} [properties] Properties to set
            * @returns {serverProto.FullJp} FullJp instance
            */

            FullJp.create = function create(properties) {
              return new FullJp(properties);
            };
            /**
            * Encodes the specified FullJp message. Does not implicitly {@link serverProto.FullJp.verify|verify} messages.
            * @function encode
            * @memberof serverProto.FullJp
            * @static
            * @param {serverProto.IFullJp} message FullJp message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            FullJp.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.gameID != null && Object.hasOwnProperty.call(message, "gameID")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).uint32(message.gameID);
              if (message.value != null && Object.hasOwnProperty.call(message, "value")) writer.uint32(
              /* id 2, wireType 1 =*/
              17)["double"](message.value);
              if (message.full != null && Object.hasOwnProperty.call(message, "full")) writer.uint32(
              /* id 3, wireType 1 =*/
              25)["double"](message.full);
              return writer;
            };
            /**
            * Encodes the specified FullJp message, length delimited. Does not implicitly {@link serverProto.FullJp.verify|verify} messages.
            * @function encodeDelimited
            * @memberof serverProto.FullJp
            * @static
            * @param {serverProto.IFullJp} message FullJp message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            FullJp.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a FullJp message from the specified reader or buffer.
            * @function decode
            * @memberof serverProto.FullJp
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {serverProto.FullJp} FullJp
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            FullJp.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.serverProto.FullJp();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      message.gameID = reader.uint32();
                      break;
                    }

                  case 2:
                    {
                      message.value = reader["double"]();
                      break;
                    }

                  case 3:
                    {
                      message.full = reader["double"]();
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a FullJp message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof serverProto.FullJp
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {serverProto.FullJp} FullJp
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            FullJp.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a FullJp message.
            * @function verify
            * @memberof serverProto.FullJp
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            FullJp.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.gameID != null && message.hasOwnProperty("gameID")) if (!$util.isInteger(message.gameID)) return "gameID: integer expected";
              if (message.value != null && message.hasOwnProperty("value")) if (typeof message.value !== "number") return "value: number expected";
              if (message.full != null && message.hasOwnProperty("full")) if (typeof message.full !== "number") return "full: number expected";
              return null;
            };
            /**
            * Creates a FullJp message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof serverProto.FullJp
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {serverProto.FullJp} FullJp
            */


            FullJp.fromObject = function fromObject(object) {
              if (object instanceof $root.serverProto.FullJp) return object;
              var message = new $root.serverProto.FullJp();
              if (object.gameID != null) message.gameID = object.gameID >>> 0;
              if (object.value != null) message.value = Number(object.value);
              if (object.full != null) message.full = Number(object.full);
              return message;
            };
            /**
            * Creates a plain object from a FullJp message. Also converts values to other types if specified.
            * @function toObject
            * @memberof serverProto.FullJp
            * @static
            * @param {serverProto.FullJp} message FullJp
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            FullJp.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.gameID = 0;
                object.value = 0;
                object.full = 0;
              }

              if (message.gameID != null && message.hasOwnProperty("gameID")) object.gameID = message.gameID;
              if (message.value != null && message.hasOwnProperty("value")) object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
              if (message.full != null && message.hasOwnProperty("full")) object.full = options.json && !isFinite(message.full) ? String(message.full) : message.full;
              return object;
            };
            /**
            * Converts this FullJp to JSON.
            * @function toJSON
            * @memberof serverProto.FullJp
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            FullJp.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
            * Gets the default type url for FullJp
            * @function getTypeUrl
            * @memberof serverProto.FullJp
            * @static
            * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
            * @returns {string} The default type url
            */


            FullJp.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/serverProto.FullJp";
            };

            return FullJp;
          }();

          serverProto.SpecialMode = function () {
            /**
            * Properties of a SpecialMode.
            * @memberof serverProto
            * @interface ISpecialMode
            * @property {Array.<serverProto.IEachMode>|null} [mode] SpecialMode mode
            */

            /**
            * Constructs a new SpecialMode.
            * @memberof serverProto
            * @classdesc Represents a SpecialMode.
            * @implements ISpecialMode
            * @constructor
            * @param {serverProto.ISpecialMode=} [properties] Properties to set
            */
            function SpecialMode(properties) {
              this.mode = [];
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * SpecialMode mode.
            * @member {Array.<serverProto.IEachMode>} mode
            * @memberof serverProto.SpecialMode
            * @instance
            */


            SpecialMode.prototype.mode = $util.emptyArray;
            /**
            * Creates a new SpecialMode instance using the specified properties.
            * @function create
            * @memberof serverProto.SpecialMode
            * @static
            * @param {serverProto.ISpecialMode=} [properties] Properties to set
            * @returns {serverProto.SpecialMode} SpecialMode instance
            */

            SpecialMode.create = function create(properties) {
              return new SpecialMode(properties);
            };
            /**
            * Encodes the specified SpecialMode message. Does not implicitly {@link serverProto.SpecialMode.verify|verify} messages.
            * @function encode
            * @memberof serverProto.SpecialMode
            * @static
            * @param {serverProto.ISpecialMode} message SpecialMode message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            SpecialMode.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.mode != null && message.mode.length) for (var i = 0; i < message.mode.length; ++i) {
                $root.serverProto.EachMode.encode(message.mode[i], writer.uint32(
                /* id 1, wireType 2 =*/
                10).fork()).ldelim();
              }
              return writer;
            };
            /**
            * Encodes the specified SpecialMode message, length delimited. Does not implicitly {@link serverProto.SpecialMode.verify|verify} messages.
            * @function encodeDelimited
            * @memberof serverProto.SpecialMode
            * @static
            * @param {serverProto.ISpecialMode} message SpecialMode message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            SpecialMode.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes a SpecialMode message from the specified reader or buffer.
            * @function decode
            * @memberof serverProto.SpecialMode
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {serverProto.SpecialMode} SpecialMode
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            SpecialMode.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.serverProto.SpecialMode();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      if (!(message.mode && message.mode.length)) message.mode = [];
                      message.mode.push($root.serverProto.EachMode.decode(reader, reader.uint32()));
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes a SpecialMode message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof serverProto.SpecialMode
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {serverProto.SpecialMode} SpecialMode
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            SpecialMode.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies a SpecialMode message.
            * @function verify
            * @memberof serverProto.SpecialMode
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            SpecialMode.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";

              if (message.mode != null && message.hasOwnProperty("mode")) {
                if (!Array.isArray(message.mode)) return "mode: array expected";

                for (var i = 0; i < message.mode.length; ++i) {
                  var error = $root.serverProto.EachMode.verify(message.mode[i]);
                  if (error) return "mode." + error;
                }
              }

              return null;
            };
            /**
            * Creates a SpecialMode message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof serverProto.SpecialMode
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {serverProto.SpecialMode} SpecialMode
            */


            SpecialMode.fromObject = function fromObject(object) {
              if (object instanceof $root.serverProto.SpecialMode) return object;
              var message = new $root.serverProto.SpecialMode();

              if (object.mode) {
                if (!Array.isArray(object.mode)) throw TypeError(".serverProto.SpecialMode.mode: array expected");
                message.mode = [];

                for (var i = 0; i < object.mode.length; ++i) {
                  if (typeof object.mode[i] !== "object") throw TypeError(".serverProto.SpecialMode.mode: object expected");
                  message.mode[i] = $root.serverProto.EachMode.fromObject(object.mode[i]);
                }
              }

              return message;
            };
            /**
            * Creates a plain object from a SpecialMode message. Also converts values to other types if specified.
            * @function toObject
            * @memberof serverProto.SpecialMode
            * @static
            * @param {serverProto.SpecialMode} message SpecialMode
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            SpecialMode.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};
              if (options.arrays || options.defaults) object.mode = [];

              if (message.mode && message.mode.length) {
                object.mode = [];

                for (var j = 0; j < message.mode.length; ++j) {
                  object.mode[j] = $root.serverProto.EachMode.toObject(message.mode[j], options);
                }
              }

              return object;
            };
            /**
            * Converts this SpecialMode to JSON.
            * @function toJSON
            * @memberof serverProto.SpecialMode
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            SpecialMode.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
            * Gets the default type url for SpecialMode
            * @function getTypeUrl
            * @memberof serverProto.SpecialMode
            * @static
            * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
            * @returns {string} The default type url
            */


            SpecialMode.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/serverProto.SpecialMode";
            };

            return SpecialMode;
          }();

          serverProto.EachMode = function () {
            /**
            * Properties of an EachMode.
            * @memberof serverProto
            * @interface IEachMode
            * @property {Array.<serverProto.ISpinResponse>|null} [spinResponse] EachMode spinResponse
            */

            /**
            * Constructs a new EachMode.
            * @memberof serverProto
            * @classdesc Represents an EachMode.
            * @implements IEachMode
            * @constructor
            * @param {serverProto.IEachMode=} [properties] Properties to set
            */
            function EachMode(properties) {
              this.spinResponse = [];
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
            * EachMode spinResponse.
            * @member {Array.<serverProto.ISpinResponse>} spinResponse
            * @memberof serverProto.EachMode
            * @instance
            */


            EachMode.prototype.spinResponse = $util.emptyArray;
            /**
            * Creates a new EachMode instance using the specified properties.
            * @function create
            * @memberof serverProto.EachMode
            * @static
            * @param {serverProto.IEachMode=} [properties] Properties to set
            * @returns {serverProto.EachMode} EachMode instance
            */

            EachMode.create = function create(properties) {
              return new EachMode(properties);
            };
            /**
            * Encodes the specified EachMode message. Does not implicitly {@link serverProto.EachMode.verify|verify} messages.
            * @function encode
            * @memberof serverProto.EachMode
            * @static
            * @param {serverProto.IEachMode} message EachMode message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            EachMode.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.spinResponse != null && message.spinResponse.length) for (var i = 0; i < message.spinResponse.length; ++i) {
                $root.serverProto.SpinResponse.encode(message.spinResponse[i], writer.uint32(
                /* id 1, wireType 2 =*/
                10).fork()).ldelim();
              }
              return writer;
            };
            /**
            * Encodes the specified EachMode message, length delimited. Does not implicitly {@link serverProto.EachMode.verify|verify} messages.
            * @function encodeDelimited
            * @memberof serverProto.EachMode
            * @static
            * @param {serverProto.IEachMode} message EachMode message or plain object to encode
            * @param {$protobuf.Writer} [writer] Writer to encode to
            * @returns {$protobuf.Writer} Writer
            */


            EachMode.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
            * Decodes an EachMode message from the specified reader or buffer.
            * @function decode
            * @memberof serverProto.EachMode
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @param {number} [length] Message length if known beforehand
            * @returns {serverProto.EachMode} EachMode
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            EachMode.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.serverProto.EachMode();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      if (!(message.spinResponse && message.spinResponse.length)) message.spinResponse = [];
                      message.spinResponse.push($root.serverProto.SpinResponse.decode(reader, reader.uint32()));
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
            * Decodes an EachMode message from the specified reader or buffer, length delimited.
            * @function decodeDelimited
            * @memberof serverProto.EachMode
            * @static
            * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
            * @returns {serverProto.EachMode} EachMode
            * @throws {Error} If the payload is not a reader or valid buffer
            * @throws {$protobuf.util.ProtocolError} If required fields are missing
            */


            EachMode.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
            * Verifies an EachMode message.
            * @function verify
            * @memberof serverProto.EachMode
            * @static
            * @param {Object.<string,*>} message Plain object to verify
            * @returns {string|null} `null` if valid, otherwise the reason why it is not
            */


            EachMode.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";

              if (message.spinResponse != null && message.hasOwnProperty("spinResponse")) {
                if (!Array.isArray(message.spinResponse)) return "spinResponse: array expected";

                for (var i = 0; i < message.spinResponse.length; ++i) {
                  var error = $root.serverProto.SpinResponse.verify(message.spinResponse[i]);
                  if (error) return "spinResponse." + error;
                }
              }

              return null;
            };
            /**
            * Creates an EachMode message from a plain object. Also converts values to their respective internal types.
            * @function fromObject
            * @memberof serverProto.EachMode
            * @static
            * @param {Object.<string,*>} object Plain object
            * @returns {serverProto.EachMode} EachMode
            */


            EachMode.fromObject = function fromObject(object) {
              if (object instanceof $root.serverProto.EachMode) return object;
              var message = new $root.serverProto.EachMode();

              if (object.spinResponse) {
                if (!Array.isArray(object.spinResponse)) throw TypeError(".serverProto.EachMode.spinResponse: array expected");
                message.spinResponse = [];

                for (var i = 0; i < object.spinResponse.length; ++i) {
                  if (typeof object.spinResponse[i] !== "object") throw TypeError(".serverProto.EachMode.spinResponse: object expected");
                  message.spinResponse[i] = $root.serverProto.SpinResponse.fromObject(object.spinResponse[i]);
                }
              }

              return message;
            };
            /**
            * Creates a plain object from an EachMode message. Also converts values to other types if specified.
            * @function toObject
            * @memberof serverProto.EachMode
            * @static
            * @param {serverProto.EachMode} message EachMode
            * @param {$protobuf.IConversionOptions} [options] Conversion options
            * @returns {Object.<string,*>} Plain object
            */


            EachMode.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};
              if (options.arrays || options.defaults) object.spinResponse = [];

              if (message.spinResponse && message.spinResponse.length) {
                object.spinResponse = [];

                for (var j = 0; j < message.spinResponse.length; ++j) {
                  object.spinResponse[j] = $root.serverProto.SpinResponse.toObject(message.spinResponse[j], options);
                }
              }

              return object;
            };
            /**
            * Converts this EachMode to JSON.
            * @function toJSON
            * @memberof serverProto.EachMode
            * @instance
            * @returns {Object.<string,*>} JSON object
            */


            EachMode.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
            * Gets the default type url for EachMode
            * @function getTypeUrl
            * @memberof serverProto.EachMode
            * @static
            * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
            * @returns {string} The default type url
            */


            EachMode.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/serverProto.EachMode";
            };

            return EachMode;
          }();

          return serverProto;
        }();

        $root.google = function () {
          /**
          * Namespace google.
          * @exports google
          * @namespace
          */
          var google = {};

          google.protobuf = function () {
            /**
            * Namespace protobuf.
            * @memberof google
            * @namespace
            */
            var protobuf = {};

            protobuf.Timestamp = function () {
              /**
              * Properties of a Timestamp.
              * @memberof google.protobuf
              * @interface ITimestamp
              * @property {number|Long|null} [seconds] Timestamp seconds
              * @property {number|null} [nanos] Timestamp nanos
              */

              /**
              * Constructs a new Timestamp.
              * @memberof google.protobuf
              * @classdesc Represents a Timestamp.
              * @implements ITimestamp
              * @constructor
              * @param {google.protobuf.ITimestamp=} [properties] Properties to set
              */
              function Timestamp(properties) {
                if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                  if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
                }
              }
              /**
              * Timestamp seconds.
              * @member {number|Long} seconds
              * @memberof google.protobuf.Timestamp
              * @instance
              */


              Timestamp.prototype.seconds = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
              /**
              * Timestamp nanos.
              * @member {number} nanos
              * @memberof google.protobuf.Timestamp
              * @instance
              */

              Timestamp.prototype.nanos = 0;
              /**
              * Creates a new Timestamp instance using the specified properties.
              * @function create
              * @memberof google.protobuf.Timestamp
              * @static
              * @param {google.protobuf.ITimestamp=} [properties] Properties to set
              * @returns {google.protobuf.Timestamp} Timestamp instance
              */

              Timestamp.create = function create(properties) {
                return new Timestamp(properties);
              };
              /**
              * Encodes the specified Timestamp message. Does not implicitly {@link google.protobuf.Timestamp.verify|verify} messages.
              * @function encode
              * @memberof google.protobuf.Timestamp
              * @static
              * @param {google.protobuf.ITimestamp} message Timestamp message or plain object to encode
              * @param {$protobuf.Writer} [writer] Writer to encode to
              * @returns {$protobuf.Writer} Writer
              */


              Timestamp.encode = function encode(message, writer) {
                if (!writer) writer = $Writer.create();
                if (message.seconds != null && Object.hasOwnProperty.call(message, "seconds")) writer.uint32(
                /* id 1, wireType 0 =*/
                8).int64(message.seconds);
                if (message.nanos != null && Object.hasOwnProperty.call(message, "nanos")) writer.uint32(
                /* id 2, wireType 0 =*/
                16).int32(message.nanos);
                return writer;
              };
              /**
              * Encodes the specified Timestamp message, length delimited. Does not implicitly {@link google.protobuf.Timestamp.verify|verify} messages.
              * @function encodeDelimited
              * @memberof google.protobuf.Timestamp
              * @static
              * @param {google.protobuf.ITimestamp} message Timestamp message or plain object to encode
              * @param {$protobuf.Writer} [writer] Writer to encode to
              * @returns {$protobuf.Writer} Writer
              */


              Timestamp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              /**
              * Decodes a Timestamp message from the specified reader or buffer.
              * @function decode
              * @memberof google.protobuf.Timestamp
              * @static
              * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
              * @param {number} [length] Message length if known beforehand
              * @returns {google.protobuf.Timestamp} Timestamp
              * @throws {Error} If the payload is not a reader or valid buffer
              * @throws {$protobuf.util.ProtocolError} If required fields are missing
              */


              Timestamp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length,
                    message = new $root.google.protobuf.Timestamp();

                while (reader.pos < end) {
                  var tag = reader.uint32();

                  switch (tag >>> 3) {
                    case 1:
                      {
                        message.seconds = reader.int64();
                        break;
                      }

                    case 2:
                      {
                        message.nanos = reader.int32();
                        break;
                      }

                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }

                return message;
              };
              /**
              * Decodes a Timestamp message from the specified reader or buffer, length delimited.
              * @function decodeDelimited
              * @memberof google.protobuf.Timestamp
              * @static
              * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
              * @returns {google.protobuf.Timestamp} Timestamp
              * @throws {Error} If the payload is not a reader or valid buffer
              * @throws {$protobuf.util.ProtocolError} If required fields are missing
              */


              Timestamp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader)) reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              /**
              * Verifies a Timestamp message.
              * @function verify
              * @memberof google.protobuf.Timestamp
              * @static
              * @param {Object.<string,*>} message Plain object to verify
              * @returns {string|null} `null` if valid, otherwise the reason why it is not
              */


              Timestamp.verify = function verify(message) {
                if (typeof message !== "object" || message === null) return "object expected";
                if (message.seconds != null && message.hasOwnProperty("seconds")) if (!$util.isInteger(message.seconds) && !(message.seconds && $util.isInteger(message.seconds.low) && $util.isInteger(message.seconds.high))) return "seconds: integer|Long expected";
                if (message.nanos != null && message.hasOwnProperty("nanos")) if (!$util.isInteger(message.nanos)) return "nanos: integer expected";
                return null;
              };
              /**
              * Creates a Timestamp message from a plain object. Also converts values to their respective internal types.
              * @function fromObject
              * @memberof google.protobuf.Timestamp
              * @static
              * @param {Object.<string,*>} object Plain object
              * @returns {google.protobuf.Timestamp} Timestamp
              */


              Timestamp.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Timestamp) return object;
                var message = new $root.google.protobuf.Timestamp();
                if (object.seconds != null) if ($util.Long) (message.seconds = $util.Long.fromValue(object.seconds)).unsigned = false;else if (typeof object.seconds === "string") message.seconds = parseInt(object.seconds, 10);else if (typeof object.seconds === "number") message.seconds = object.seconds;else if (typeof object.seconds === "object") message.seconds = new $util.LongBits(object.seconds.low >>> 0, object.seconds.high >>> 0).toNumber();
                if (object.nanos != null) message.nanos = object.nanos | 0;
                return message;
              };
              /**
              * Creates a plain object from a Timestamp message. Also converts values to other types if specified.
              * @function toObject
              * @memberof google.protobuf.Timestamp
              * @static
              * @param {google.protobuf.Timestamp} message Timestamp
              * @param {$protobuf.IConversionOptions} [options] Conversion options
              * @returns {Object.<string,*>} Plain object
              */


              Timestamp.toObject = function toObject(message, options) {
                if (!options) options = {};
                var object = {};

                if (options.defaults) {
                  if ($util.Long) {
                    var _long13 = new $util.Long(0, 0, false);

                    object.seconds = options.longs === String ? _long13.toString() : options.longs === Number ? _long13.toNumber() : _long13;
                  } else object.seconds = options.longs === String ? "0" : 0;

                  object.nanos = 0;
                }

                if (message.seconds != null && message.hasOwnProperty("seconds")) if (typeof message.seconds === "number") object.seconds = options.longs === String ? String(message.seconds) : message.seconds;else object.seconds = options.longs === String ? $util.Long.prototype.toString.call(message.seconds) : options.longs === Number ? new $util.LongBits(message.seconds.low >>> 0, message.seconds.high >>> 0).toNumber() : message.seconds;
                if (message.nanos != null && message.hasOwnProperty("nanos")) object.nanos = message.nanos;
                return object;
              };
              /**
              * Converts this Timestamp to JSON.
              * @function toJSON
              * @memberof google.protobuf.Timestamp
              * @instance
              * @returns {Object.<string,*>} JSON object
              */


              Timestamp.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              };
              /**
              * Gets the default type url for Timestamp
              * @function getTypeUrl
              * @memberof google.protobuf.Timestamp
              * @static
              * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
              * @returns {string} The default type url
              */


              Timestamp.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                  typeUrlPrefix = "type.googleapis.com";
                }

                return typeUrlPrefix + "/google.protobuf.Timestamp";
              };

              return Timestamp;
            }();

            return protobuf;
          }();

          return google;
        }();

        module.exports = $root; // #endregion ORIGINAL CODE

        _cjsExports = exports('default', module.exports);
      }, function () {
        return {
          'protobufjs/minimal': __cjsMetaURL$1
        };
      });
    }
  };
});

System.register("chunks:///_virtual/pgame.mjs_cjs=&original=.js", ['./pgame.js', './cjs-loader.mjs'], function (exports, module) {
  'use strict';

  var __cjsMetaURL, loader;

  return {
    setters: [function (module) {
      __cjsMetaURL = module.__cjsMetaURL;
      var _setter = {};
      _setter.__cjsMetaURL = module.__cjsMetaURL;
      _setter.default = module.default;
      exports(_setter);
    }, function (module) {
      loader = module.default;
    }],
    execute: function () {
      // I am the facade module who provides access to the CommonJS module './pgame.js'~
      if (!__cjsMetaURL) {
        loader.throwInvalidWrapper('./pgame.js', module.meta.url);
      }

      loader.require(__cjsMetaURL);
    }
  };
});

System.register("chunks:///_virtual/promotion.js", ['./cjs-loader.mjs', './minimal.js'], function (exports, module) {
  'use strict';

  var loader, __cjsMetaURL$1;

  return {
    setters: [function (module) {
      loader = module.default;
    }, function (module) {
      __cjsMetaURL$1 = module.__cjsMetaURL;
    }],
    execute: function () {
      exports('default', void 0);

      var _cjsExports;

      var __cjsMetaURL = exports('__cjsMetaURL', module.meta.url);

      loader.define(__cjsMetaURL, function (exports$1, require, module, __filename, __dirname) {
        var $protobuf = require("protobufjs/minimal"); // Common aliases


        var $Reader = $protobuf.Reader,
            $Writer = $protobuf.Writer,
            $util = $protobuf.util; // Exported root namespace

        var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

        $root.promotionProto = function () {
          /**
           * Namespace promotionProto.
           * @exports promotionProto
           * @namespace
           */
          var promotionProto = {};

          promotionProto.GameInfoIndia = function () {
            /**
             * Properties of a GameInfoIndia.
             * @memberof promotionProto
             * @interface IGameInfoIndia
             * @property {number|null} [typeID] GameInfoIndia typeID
             * @property {Array.<number>|null} [games] GameInfoIndia games
             */

            /**
             * Constructs a new GameInfoIndia.
             * @memberof promotionProto
             * @classdesc Represents a GameInfoIndia.
             * @implements IGameInfoIndia
             * @constructor
             * @param {promotionProto.IGameInfoIndia=} [properties] Properties to set
             */
            function GameInfoIndia(properties) {
              this.games = [];
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * GameInfoIndia typeID.
             * @member {number} typeID
             * @memberof promotionProto.GameInfoIndia
             * @instance
             */


            GameInfoIndia.prototype.typeID = 0;
            /**
             * GameInfoIndia games.
             * @member {Array.<number>} games
             * @memberof promotionProto.GameInfoIndia
             * @instance
             */

            GameInfoIndia.prototype.games = $util.emptyArray;
            /**
             * Creates a new GameInfoIndia instance using the specified properties.
             * @function create
             * @memberof promotionProto.GameInfoIndia
             * @static
             * @param {promotionProto.IGameInfoIndia=} [properties] Properties to set
             * @returns {promotionProto.GameInfoIndia} GameInfoIndia instance
             */

            GameInfoIndia.create = function create(properties) {
              return new GameInfoIndia(properties);
            };
            /**
             * Encodes the specified GameInfoIndia message. Does not implicitly {@link promotionProto.GameInfoIndia.verify|verify} messages.
             * @function encode
             * @memberof promotionProto.GameInfoIndia
             * @static
             * @param {promotionProto.IGameInfoIndia} message GameInfoIndia message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            GameInfoIndia.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.typeID != null && Object.hasOwnProperty.call(message, "typeID")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.typeID);

              if (message.games != null && message.games.length) {
                writer.uint32(
                /* id 2, wireType 2 =*/
                18).fork();

                for (var i = 0; i < message.games.length; ++i) {
                  writer.int32(message.games[i]);
                }

                writer.ldelim();
              }

              return writer;
            };
            /**
             * Encodes the specified GameInfoIndia message, length delimited. Does not implicitly {@link promotionProto.GameInfoIndia.verify|verify} messages.
             * @function encodeDelimited
             * @memberof promotionProto.GameInfoIndia
             * @static
             * @param {promotionProto.IGameInfoIndia} message GameInfoIndia message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            GameInfoIndia.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a GameInfoIndia message from the specified reader or buffer.
             * @function decode
             * @memberof promotionProto.GameInfoIndia
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {promotionProto.GameInfoIndia} GameInfoIndia
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            GameInfoIndia.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.promotionProto.GameInfoIndia();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.typeID = reader.int32();
                    break;

                  case 2:
                    if (!(message.games && message.games.length)) message.games = [];

                    if ((tag & 7) === 2) {
                      var end2 = reader.uint32() + reader.pos;

                      while (reader.pos < end2) {
                        message.games.push(reader.int32());
                      }
                    } else message.games.push(reader.int32());

                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
             * Decodes a GameInfoIndia message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof promotionProto.GameInfoIndia
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {promotionProto.GameInfoIndia} GameInfoIndia
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            GameInfoIndia.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a GameInfoIndia message.
             * @function verify
             * @memberof promotionProto.GameInfoIndia
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */


            GameInfoIndia.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.typeID != null && message.hasOwnProperty("typeID")) if (!$util.isInteger(message.typeID)) return "typeID: integer expected";

              if (message.games != null && message.hasOwnProperty("games")) {
                if (!Array.isArray(message.games)) return "games: array expected";

                for (var i = 0; i < message.games.length; ++i) {
                  if (!$util.isInteger(message.games[i])) return "games: integer[] expected";
                }
              }

              return null;
            };
            /**
             * Creates a GameInfoIndia message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof promotionProto.GameInfoIndia
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {promotionProto.GameInfoIndia} GameInfoIndia
             */


            GameInfoIndia.fromObject = function fromObject(object) {
              if (object instanceof $root.promotionProto.GameInfoIndia) return object;
              var message = new $root.promotionProto.GameInfoIndia();
              if (object.typeID != null) message.typeID = object.typeID | 0;

              if (object.games) {
                if (!Array.isArray(object.games)) throw TypeError(".promotionProto.GameInfoIndia.games: array expected");
                message.games = [];

                for (var i = 0; i < object.games.length; ++i) {
                  message.games[i] = object.games[i] | 0;
                }
              }

              return message;
            };
            /**
             * Creates a plain object from a GameInfoIndia message. Also converts values to other types if specified.
             * @function toObject
             * @memberof promotionProto.GameInfoIndia
             * @static
             * @param {promotionProto.GameInfoIndia} message GameInfoIndia
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */


            GameInfoIndia.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};
              if (options.arrays || options.defaults) object.games = [];
              if (options.defaults) object.typeID = 0;
              if (message.typeID != null && message.hasOwnProperty("typeID")) object.typeID = message.typeID;

              if (message.games && message.games.length) {
                object.games = [];

                for (var j = 0; j < message.games.length; ++j) {
                  object.games[j] = message.games[j];
                }
              }

              return object;
            };
            /**
             * Converts this GameInfoIndia to JSON.
             * @function toJSON
             * @memberof promotionProto.GameInfoIndia
             * @instance
             * @returns {Object.<string,*>} JSON object
             */


            GameInfoIndia.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GameInfoIndia;
          }();

          promotionProto.GamePromotionIndiaCommand = function () {
            /**
             * Properties of a GamePromotionIndiaCommand.
             * @memberof promotionProto
             * @interface IGamePromotionIndiaCommand
             * @property {boolean|null} [enabled] GamePromotionIndiaCommand enabled
             * @property {Array.<promotionProto.IGameInfoIndia>|null} [promotions] GamePromotionIndiaCommand promotions
             */

            /**
             * Constructs a new GamePromotionIndiaCommand.
             * @memberof promotionProto
             * @classdesc Represents a GamePromotionIndiaCommand.
             * @implements IGamePromotionIndiaCommand
             * @constructor
             * @param {promotionProto.IGamePromotionIndiaCommand=} [properties] Properties to set
             */
            function GamePromotionIndiaCommand(properties) {
              this.promotions = [];
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * GamePromotionIndiaCommand enabled.
             * @member {boolean} enabled
             * @memberof promotionProto.GamePromotionIndiaCommand
             * @instance
             */


            GamePromotionIndiaCommand.prototype.enabled = false;
            /**
             * GamePromotionIndiaCommand promotions.
             * @member {Array.<promotionProto.IGameInfoIndia>} promotions
             * @memberof promotionProto.GamePromotionIndiaCommand
             * @instance
             */

            GamePromotionIndiaCommand.prototype.promotions = $util.emptyArray;
            /**
             * Creates a new GamePromotionIndiaCommand instance using the specified properties.
             * @function create
             * @memberof promotionProto.GamePromotionIndiaCommand
             * @static
             * @param {promotionProto.IGamePromotionIndiaCommand=} [properties] Properties to set
             * @returns {promotionProto.GamePromotionIndiaCommand} GamePromotionIndiaCommand instance
             */

            GamePromotionIndiaCommand.create = function create(properties) {
              return new GamePromotionIndiaCommand(properties);
            };
            /**
             * Encodes the specified GamePromotionIndiaCommand message. Does not implicitly {@link promotionProto.GamePromotionIndiaCommand.verify|verify} messages.
             * @function encode
             * @memberof promotionProto.GamePromotionIndiaCommand
             * @static
             * @param {promotionProto.IGamePromotionIndiaCommand} message GamePromotionIndiaCommand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            GamePromotionIndiaCommand.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.enabled != null && Object.hasOwnProperty.call(message, "enabled")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).bool(message.enabled);
              if (message.promotions != null && message.promotions.length) for (var i = 0; i < message.promotions.length; ++i) {
                $root.promotionProto.GameInfoIndia.encode(message.promotions[i], writer.uint32(
                /* id 2, wireType 2 =*/
                18).fork()).ldelim();
              }
              return writer;
            };
            /**
             * Encodes the specified GamePromotionIndiaCommand message, length delimited. Does not implicitly {@link promotionProto.GamePromotionIndiaCommand.verify|verify} messages.
             * @function encodeDelimited
             * @memberof promotionProto.GamePromotionIndiaCommand
             * @static
             * @param {promotionProto.IGamePromotionIndiaCommand} message GamePromotionIndiaCommand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            GamePromotionIndiaCommand.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a GamePromotionIndiaCommand message from the specified reader or buffer.
             * @function decode
             * @memberof promotionProto.GamePromotionIndiaCommand
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {promotionProto.GamePromotionIndiaCommand} GamePromotionIndiaCommand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            GamePromotionIndiaCommand.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.promotionProto.GamePromotionIndiaCommand();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.enabled = reader.bool();
                    break;

                  case 2:
                    if (!(message.promotions && message.promotions.length)) message.promotions = [];
                    message.promotions.push($root.promotionProto.GameInfoIndia.decode(reader, reader.uint32()));
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
             * Decodes a GamePromotionIndiaCommand message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof promotionProto.GamePromotionIndiaCommand
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {promotionProto.GamePromotionIndiaCommand} GamePromotionIndiaCommand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            GamePromotionIndiaCommand.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a GamePromotionIndiaCommand message.
             * @function verify
             * @memberof promotionProto.GamePromotionIndiaCommand
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */


            GamePromotionIndiaCommand.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.enabled != null && message.hasOwnProperty("enabled")) if (typeof message.enabled !== "boolean") return "enabled: boolean expected";

              if (message.promotions != null && message.hasOwnProperty("promotions")) {
                if (!Array.isArray(message.promotions)) return "promotions: array expected";

                for (var i = 0; i < message.promotions.length; ++i) {
                  var error = $root.promotionProto.GameInfoIndia.verify(message.promotions[i]);
                  if (error) return "promotions." + error;
                }
              }

              return null;
            };
            /**
             * Creates a GamePromotionIndiaCommand message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof promotionProto.GamePromotionIndiaCommand
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {promotionProto.GamePromotionIndiaCommand} GamePromotionIndiaCommand
             */


            GamePromotionIndiaCommand.fromObject = function fromObject(object) {
              if (object instanceof $root.promotionProto.GamePromotionIndiaCommand) return object;
              var message = new $root.promotionProto.GamePromotionIndiaCommand();
              if (object.enabled != null) message.enabled = Boolean(object.enabled);

              if (object.promotions) {
                if (!Array.isArray(object.promotions)) throw TypeError(".promotionProto.GamePromotionIndiaCommand.promotions: array expected");
                message.promotions = [];

                for (var i = 0; i < object.promotions.length; ++i) {
                  if (typeof object.promotions[i] !== "object") throw TypeError(".promotionProto.GamePromotionIndiaCommand.promotions: object expected");
                  message.promotions[i] = $root.promotionProto.GameInfoIndia.fromObject(object.promotions[i]);
                }
              }

              return message;
            };
            /**
             * Creates a plain object from a GamePromotionIndiaCommand message. Also converts values to other types if specified.
             * @function toObject
             * @memberof promotionProto.GamePromotionIndiaCommand
             * @static
             * @param {promotionProto.GamePromotionIndiaCommand} message GamePromotionIndiaCommand
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */


            GamePromotionIndiaCommand.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};
              if (options.arrays || options.defaults) object.promotions = [];
              if (options.defaults) object.enabled = false;
              if (message.enabled != null && message.hasOwnProperty("enabled")) object.enabled = message.enabled;

              if (message.promotions && message.promotions.length) {
                object.promotions = [];

                for (var j = 0; j < message.promotions.length; ++j) {
                  object.promotions[j] = $root.promotionProto.GameInfoIndia.toObject(message.promotions[j], options);
                }
              }

              return object;
            };
            /**
             * Converts this GamePromotionIndiaCommand to JSON.
             * @function toJSON
             * @memberof promotionProto.GamePromotionIndiaCommand
             * @instance
             * @returns {Object.<string,*>} JSON object
             */


            GamePromotionIndiaCommand.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GamePromotionIndiaCommand;
          }();

          promotionProto.Top = function () {
            /**
             * Properties of a Top.
             * @memberof promotionProto
             * @interface ITop
             * @property {number|null} [win] Top win
             * @property {number|null} [Odd] Top Odd
             */

            /**
             * Constructs a new Top.
             * @memberof promotionProto
             * @classdesc Represents a Top.
             * @implements ITop
             * @constructor
             * @param {promotionProto.ITop=} [properties] Properties to set
             */
            function Top(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * Top win.
             * @member {number} win
             * @memberof promotionProto.Top
             * @instance
             */


            Top.prototype.win = 0;
            /**
             * Top Odd.
             * @member {number} Odd
             * @memberof promotionProto.Top
             * @instance
             */

            Top.prototype.Odd = 0;
            /**
             * Creates a new Top instance using the specified properties.
             * @function create
             * @memberof promotionProto.Top
             * @static
             * @param {promotionProto.ITop=} [properties] Properties to set
             * @returns {promotionProto.Top} Top instance
             */

            Top.create = function create(properties) {
              return new Top(properties);
            };
            /**
             * Encodes the specified Top message. Does not implicitly {@link promotionProto.Top.verify|verify} messages.
             * @function encode
             * @memberof promotionProto.Top
             * @static
             * @param {promotionProto.ITop} message Top message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            Top.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.win != null && Object.hasOwnProperty.call(message, "win")) writer.uint32(
              /* id 1, wireType 1 =*/
              9)["double"](message.win);
              if (message.Odd != null && Object.hasOwnProperty.call(message, "Odd")) writer.uint32(
              /* id 2, wireType 1 =*/
              17)["double"](message.Odd);
              return writer;
            };
            /**
             * Encodes the specified Top message, length delimited. Does not implicitly {@link promotionProto.Top.verify|verify} messages.
             * @function encodeDelimited
             * @memberof promotionProto.Top
             * @static
             * @param {promotionProto.ITop} message Top message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            Top.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a Top message from the specified reader or buffer.
             * @function decode
             * @memberof promotionProto.Top
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {promotionProto.Top} Top
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            Top.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.promotionProto.Top();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.win = reader["double"]();
                    break;

                  case 2:
                    message.Odd = reader["double"]();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
             * Decodes a Top message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof promotionProto.Top
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {promotionProto.Top} Top
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            Top.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a Top message.
             * @function verify
             * @memberof promotionProto.Top
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */


            Top.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.win != null && message.hasOwnProperty("win")) if (typeof message.win !== "number") return "win: number expected";
              if (message.Odd != null && message.hasOwnProperty("Odd")) if (typeof message.Odd !== "number") return "Odd: number expected";
              return null;
            };
            /**
             * Creates a Top message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof promotionProto.Top
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {promotionProto.Top} Top
             */


            Top.fromObject = function fromObject(object) {
              if (object instanceof $root.promotionProto.Top) return object;
              var message = new $root.promotionProto.Top();
              if (object.win != null) message.win = Number(object.win);
              if (object.Odd != null) message.Odd = Number(object.Odd);
              return message;
            };
            /**
             * Creates a plain object from a Top message. Also converts values to other types if specified.
             * @function toObject
             * @memberof promotionProto.Top
             * @static
             * @param {promotionProto.Top} message Top
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */


            Top.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.win = 0;
                object.Odd = 0;
              }

              if (message.win != null && message.hasOwnProperty("win")) object.win = options.json && !isFinite(message.win) ? String(message.win) : message.win;
              if (message.Odd != null && message.hasOwnProperty("Odd")) object.Odd = options.json && !isFinite(message.Odd) ? String(message.Odd) : message.Odd;
              return object;
            };
            /**
             * Converts this Top to JSON.
             * @function toJSON
             * @memberof promotionProto.Top
             * @instance
             * @returns {Object.<string,*>} JSON object
             */


            Top.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Top;
          }();

          promotionProto.GamePromotionList = function () {
            /**
             * Properties of a GamePromotionList.
             * @memberof promotionProto
             * @interface IGamePromotionList
             * @property {number|null} [gameID] GamePromotionList gameID
             * @property {Array.<number>|null} [labels] GamePromotionList labels
             * @property {number|null} [mall] GamePromotionList mall
             * @property {number|null} [dAU] GamePromotionList dAU
             * @property {promotionProto.ITop|null} [top] GamePromotionList top
             */

            /**
             * Constructs a new GamePromotionList.
             * @memberof promotionProto
             * @classdesc Represents a GamePromotionList.
             * @implements IGamePromotionList
             * @constructor
             * @param {promotionProto.IGamePromotionList=} [properties] Properties to set
             */
            function GamePromotionList(properties) {
              this.labels = [];
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * GamePromotionList gameID.
             * @member {number} gameID
             * @memberof promotionProto.GamePromotionList
             * @instance
             */


            GamePromotionList.prototype.gameID = 0;
            /**
             * GamePromotionList labels.
             * @member {Array.<number>} labels
             * @memberof promotionProto.GamePromotionList
             * @instance
             */

            GamePromotionList.prototype.labels = $util.emptyArray;
            /**
             * GamePromotionList mall.
             * @member {number} mall
             * @memberof promotionProto.GamePromotionList
             * @instance
             */

            GamePromotionList.prototype.mall = 0;
            /**
             * GamePromotionList dAU.
             * @member {number} dAU
             * @memberof promotionProto.GamePromotionList
             * @instance
             */

            GamePromotionList.prototype.dAU = 0;
            /**
             * GamePromotionList top.
             * @member {promotionProto.ITop|null|undefined} top
             * @memberof promotionProto.GamePromotionList
             * @instance
             */

            GamePromotionList.prototype.top = null;
            /**
             * Creates a new GamePromotionList instance using the specified properties.
             * @function create
             * @memberof promotionProto.GamePromotionList
             * @static
             * @param {promotionProto.IGamePromotionList=} [properties] Properties to set
             * @returns {promotionProto.GamePromotionList} GamePromotionList instance
             */

            GamePromotionList.create = function create(properties) {
              return new GamePromotionList(properties);
            };
            /**
             * Encodes the specified GamePromotionList message. Does not implicitly {@link promotionProto.GamePromotionList.verify|verify} messages.
             * @function encode
             * @memberof promotionProto.GamePromotionList
             * @static
             * @param {promotionProto.IGamePromotionList} message GamePromotionList message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            GamePromotionList.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.gameID != null && Object.hasOwnProperty.call(message, "gameID")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.gameID);

              if (message.labels != null && message.labels.length) {
                writer.uint32(
                /* id 2, wireType 2 =*/
                18).fork();

                for (var i = 0; i < message.labels.length; ++i) {
                  writer.int32(message.labels[i]);
                }

                writer.ldelim();
              }

              if (message.mall != null && Object.hasOwnProperty.call(message, "mall")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.mall);
              if (message.dAU != null && Object.hasOwnProperty.call(message, "dAU")) writer.uint32(
              /* id 4, wireType 0 =*/
              32).int32(message.dAU);
              if (message.top != null && Object.hasOwnProperty.call(message, "top")) $root.promotionProto.Top.encode(message.top, writer.uint32(
              /* id 5, wireType 2 =*/
              42).fork()).ldelim();
              return writer;
            };
            /**
             * Encodes the specified GamePromotionList message, length delimited. Does not implicitly {@link promotionProto.GamePromotionList.verify|verify} messages.
             * @function encodeDelimited
             * @memberof promotionProto.GamePromotionList
             * @static
             * @param {promotionProto.IGamePromotionList} message GamePromotionList message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            GamePromotionList.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a GamePromotionList message from the specified reader or buffer.
             * @function decode
             * @memberof promotionProto.GamePromotionList
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {promotionProto.GamePromotionList} GamePromotionList
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            GamePromotionList.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.promotionProto.GamePromotionList();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.gameID = reader.int32();
                    break;

                  case 2:
                    if (!(message.labels && message.labels.length)) message.labels = [];

                    if ((tag & 7) === 2) {
                      var end2 = reader.uint32() + reader.pos;

                      while (reader.pos < end2) {
                        message.labels.push(reader.int32());
                      }
                    } else message.labels.push(reader.int32());

                    break;

                  case 3:
                    message.mall = reader.int32();
                    break;

                  case 4:
                    message.dAU = reader.int32();
                    break;

                  case 5:
                    message.top = $root.promotionProto.Top.decode(reader, reader.uint32());
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
             * Decodes a GamePromotionList message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof promotionProto.GamePromotionList
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {promotionProto.GamePromotionList} GamePromotionList
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            GamePromotionList.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a GamePromotionList message.
             * @function verify
             * @memberof promotionProto.GamePromotionList
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */


            GamePromotionList.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.gameID != null && message.hasOwnProperty("gameID")) if (!$util.isInteger(message.gameID)) return "gameID: integer expected";

              if (message.labels != null && message.hasOwnProperty("labels")) {
                if (!Array.isArray(message.labels)) return "labels: array expected";

                for (var i = 0; i < message.labels.length; ++i) {
                  if (!$util.isInteger(message.labels[i])) return "labels: integer[] expected";
                }
              }

              if (message.mall != null && message.hasOwnProperty("mall")) if (!$util.isInteger(message.mall)) return "mall: integer expected";
              if (message.dAU != null && message.hasOwnProperty("dAU")) if (!$util.isInteger(message.dAU)) return "dAU: integer expected";

              if (message.top != null && message.hasOwnProperty("top")) {
                var error = $root.promotionProto.Top.verify(message.top);
                if (error) return "top." + error;
              }

              return null;
            };
            /**
             * Creates a GamePromotionList message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof promotionProto.GamePromotionList
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {promotionProto.GamePromotionList} GamePromotionList
             */


            GamePromotionList.fromObject = function fromObject(object) {
              if (object instanceof $root.promotionProto.GamePromotionList) return object;
              var message = new $root.promotionProto.GamePromotionList();
              if (object.gameID != null) message.gameID = object.gameID | 0;

              if (object.labels) {
                if (!Array.isArray(object.labels)) throw TypeError(".promotionProto.GamePromotionList.labels: array expected");
                message.labels = [];

                for (var i = 0; i < object.labels.length; ++i) {
                  message.labels[i] = object.labels[i] | 0;
                }
              }

              if (object.mall != null) message.mall = object.mall | 0;
              if (object.dAU != null) message.dAU = object.dAU | 0;

              if (object.top != null) {
                if (typeof object.top !== "object") throw TypeError(".promotionProto.GamePromotionList.top: object expected");
                message.top = $root.promotionProto.Top.fromObject(object.top);
              }

              return message;
            };
            /**
             * Creates a plain object from a GamePromotionList message. Also converts values to other types if specified.
             * @function toObject
             * @memberof promotionProto.GamePromotionList
             * @static
             * @param {promotionProto.GamePromotionList} message GamePromotionList
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */


            GamePromotionList.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};
              if (options.arrays || options.defaults) object.labels = [];

              if (options.defaults) {
                object.gameID = 0;
                object.mall = 0;
                object.dAU = 0;
                object.top = null;
              }

              if (message.gameID != null && message.hasOwnProperty("gameID")) object.gameID = message.gameID;

              if (message.labels && message.labels.length) {
                object.labels = [];

                for (var j = 0; j < message.labels.length; ++j) {
                  object.labels[j] = message.labels[j];
                }
              }

              if (message.mall != null && message.hasOwnProperty("mall")) object.mall = message.mall;
              if (message.dAU != null && message.hasOwnProperty("dAU")) object.dAU = message.dAU;
              if (message.top != null && message.hasOwnProperty("top")) object.top = $root.promotionProto.Top.toObject(message.top, options);
              return object;
            };
            /**
             * Converts this GamePromotionList to JSON.
             * @function toJSON
             * @memberof promotionProto.GamePromotionList
             * @instance
             * @returns {Object.<string,*>} JSON object
             */


            GamePromotionList.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GamePromotionList;
          }();

          promotionProto.GamePromotionCommand = function () {
            /**
             * Properties of a GamePromotionCommand.
             * @memberof promotionProto
             * @interface IGamePromotionCommand
             * @property {boolean|null} [enabled] GamePromotionCommand enabled
             * @property {Array.<promotionProto.IGamePromotionList>|null} [list] GamePromotionCommand list
             */

            /**
             * Constructs a new GamePromotionCommand.
             * @memberof promotionProto
             * @classdesc Represents a GamePromotionCommand.
             * @implements IGamePromotionCommand
             * @constructor
             * @param {promotionProto.IGamePromotionCommand=} [properties] Properties to set
             */
            function GamePromotionCommand(properties) {
              this.list = [];
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * GamePromotionCommand enabled.
             * @member {boolean} enabled
             * @memberof promotionProto.GamePromotionCommand
             * @instance
             */


            GamePromotionCommand.prototype.enabled = false;
            /**
             * GamePromotionCommand list.
             * @member {Array.<promotionProto.IGamePromotionList>} list
             * @memberof promotionProto.GamePromotionCommand
             * @instance
             */

            GamePromotionCommand.prototype.list = $util.emptyArray;
            /**
             * Creates a new GamePromotionCommand instance using the specified properties.
             * @function create
             * @memberof promotionProto.GamePromotionCommand
             * @static
             * @param {promotionProto.IGamePromotionCommand=} [properties] Properties to set
             * @returns {promotionProto.GamePromotionCommand} GamePromotionCommand instance
             */

            GamePromotionCommand.create = function create(properties) {
              return new GamePromotionCommand(properties);
            };
            /**
             * Encodes the specified GamePromotionCommand message. Does not implicitly {@link promotionProto.GamePromotionCommand.verify|verify} messages.
             * @function encode
             * @memberof promotionProto.GamePromotionCommand
             * @static
             * @param {promotionProto.IGamePromotionCommand} message GamePromotionCommand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            GamePromotionCommand.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.enabled != null && Object.hasOwnProperty.call(message, "enabled")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).bool(message.enabled);
              if (message.list != null && message.list.length) for (var i = 0; i < message.list.length; ++i) {
                $root.promotionProto.GamePromotionList.encode(message.list[i], writer.uint32(
                /* id 2, wireType 2 =*/
                18).fork()).ldelim();
              }
              return writer;
            };
            /**
             * Encodes the specified GamePromotionCommand message, length delimited. Does not implicitly {@link promotionProto.GamePromotionCommand.verify|verify} messages.
             * @function encodeDelimited
             * @memberof promotionProto.GamePromotionCommand
             * @static
             * @param {promotionProto.IGamePromotionCommand} message GamePromotionCommand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            GamePromotionCommand.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a GamePromotionCommand message from the specified reader or buffer.
             * @function decode
             * @memberof promotionProto.GamePromotionCommand
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {promotionProto.GamePromotionCommand} GamePromotionCommand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            GamePromotionCommand.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.promotionProto.GamePromotionCommand();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.enabled = reader.bool();
                    break;

                  case 2:
                    if (!(message.list && message.list.length)) message.list = [];
                    message.list.push($root.promotionProto.GamePromotionList.decode(reader, reader.uint32()));
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
             * Decodes a GamePromotionCommand message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof promotionProto.GamePromotionCommand
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {promotionProto.GamePromotionCommand} GamePromotionCommand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            GamePromotionCommand.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a GamePromotionCommand message.
             * @function verify
             * @memberof promotionProto.GamePromotionCommand
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */


            GamePromotionCommand.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.enabled != null && message.hasOwnProperty("enabled")) if (typeof message.enabled !== "boolean") return "enabled: boolean expected";

              if (message.list != null && message.hasOwnProperty("list")) {
                if (!Array.isArray(message.list)) return "list: array expected";

                for (var i = 0; i < message.list.length; ++i) {
                  var error = $root.promotionProto.GamePromotionList.verify(message.list[i]);
                  if (error) return "list." + error;
                }
              }

              return null;
            };
            /**
             * Creates a GamePromotionCommand message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof promotionProto.GamePromotionCommand
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {promotionProto.GamePromotionCommand} GamePromotionCommand
             */


            GamePromotionCommand.fromObject = function fromObject(object) {
              if (object instanceof $root.promotionProto.GamePromotionCommand) return object;
              var message = new $root.promotionProto.GamePromotionCommand();
              if (object.enabled != null) message.enabled = Boolean(object.enabled);

              if (object.list) {
                if (!Array.isArray(object.list)) throw TypeError(".promotionProto.GamePromotionCommand.list: array expected");
                message.list = [];

                for (var i = 0; i < object.list.length; ++i) {
                  if (typeof object.list[i] !== "object") throw TypeError(".promotionProto.GamePromotionCommand.list: object expected");
                  message.list[i] = $root.promotionProto.GamePromotionList.fromObject(object.list[i]);
                }
              }

              return message;
            };
            /**
             * Creates a plain object from a GamePromotionCommand message. Also converts values to other types if specified.
             * @function toObject
             * @memberof promotionProto.GamePromotionCommand
             * @static
             * @param {promotionProto.GamePromotionCommand} message GamePromotionCommand
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */


            GamePromotionCommand.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};
              if (options.arrays || options.defaults) object.list = [];
              if (options.defaults) object.enabled = false;
              if (message.enabled != null && message.hasOwnProperty("enabled")) object.enabled = message.enabled;

              if (message.list && message.list.length) {
                object.list = [];

                for (var j = 0; j < message.list.length; ++j) {
                  object.list[j] = $root.promotionProto.GamePromotionList.toObject(message.list[j], options);
                }
              }

              return object;
            };
            /**
             * Converts this GamePromotionCommand to JSON.
             * @function toJSON
             * @memberof promotionProto.GamePromotionCommand
             * @instance
             * @returns {Object.<string,*>} JSON object
             */


            GamePromotionCommand.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GamePromotionCommand;
          }();

          promotionProto.PromotionRequest = function () {
            /**
             * Properties of a PromotionRequest.
             * @memberof promotionProto
             * @interface IPromotionRequest
             * @property {number|null} [apiID] PromotionRequest apiID
             * @property {number|null} [accountID] PromotionRequest accountID
             * @property {number|null} [loginGameID] PromotionRequest loginGameID
             * @property {number|null} [gameID] PromotionRequest gameID
             * @property {string|null} [userID] PromotionRequest userID
             * @property {string|null} [token] PromotionRequest token
             * @property {number|null} [siteID] PromotionRequest siteID
             */

            /**
             * Constructs a new PromotionRequest.
             * @memberof promotionProto
             * @classdesc Represents a PromotionRequest.
             * @implements IPromotionRequest
             * @constructor
             * @param {promotionProto.IPromotionRequest=} [properties] Properties to set
             */
            function PromotionRequest(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * PromotionRequest apiID.
             * @member {number} apiID
             * @memberof promotionProto.PromotionRequest
             * @instance
             */


            PromotionRequest.prototype.apiID = 0;
            /**
             * PromotionRequest accountID.
             * @member {number} accountID
             * @memberof promotionProto.PromotionRequest
             * @instance
             */

            PromotionRequest.prototype.accountID = 0;
            /**
             * PromotionRequest loginGameID.
             * @member {number} loginGameID
             * @memberof promotionProto.PromotionRequest
             * @instance
             */

            PromotionRequest.prototype.loginGameID = 0;
            /**
             * PromotionRequest gameID.
             * @member {number} gameID
             * @memberof promotionProto.PromotionRequest
             * @instance
             */

            PromotionRequest.prototype.gameID = 0;
            /**
             * PromotionRequest userID.
             * @member {string} userID
             * @memberof promotionProto.PromotionRequest
             * @instance
             */

            PromotionRequest.prototype.userID = "";
            /**
             * PromotionRequest token.
             * @member {string} token
             * @memberof promotionProto.PromotionRequest
             * @instance
             */

            PromotionRequest.prototype.token = "";
            /**
             * PromotionRequest siteID.
             * @member {number} siteID
             * @memberof promotionProto.PromotionRequest
             * @instance
             */

            PromotionRequest.prototype.siteID = 0;
            /**
             * Creates a new PromotionRequest instance using the specified properties.
             * @function create
             * @memberof promotionProto.PromotionRequest
             * @static
             * @param {promotionProto.IPromotionRequest=} [properties] Properties to set
             * @returns {promotionProto.PromotionRequest} PromotionRequest instance
             */

            PromotionRequest.create = function create(properties) {
              return new PromotionRequest(properties);
            };
            /**
             * Encodes the specified PromotionRequest message. Does not implicitly {@link promotionProto.PromotionRequest.verify|verify} messages.
             * @function encode
             * @memberof promotionProto.PromotionRequest
             * @static
             * @param {promotionProto.IPromotionRequest} message PromotionRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            PromotionRequest.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.apiID != null && Object.hasOwnProperty.call(message, "apiID")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.apiID);
              if (message.accountID != null && Object.hasOwnProperty.call(message, "accountID")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int32(message.accountID);
              if (message.loginGameID != null && Object.hasOwnProperty.call(message, "loginGameID")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.loginGameID);
              if (message.gameID != null && Object.hasOwnProperty.call(message, "gameID")) writer.uint32(
              /* id 4, wireType 0 =*/
              32).int32(message.gameID);
              if (message.userID != null && Object.hasOwnProperty.call(message, "userID")) writer.uint32(
              /* id 5, wireType 2 =*/
              42).string(message.userID);
              if (message.token != null && Object.hasOwnProperty.call(message, "token")) writer.uint32(
              /* id 6, wireType 2 =*/
              50).string(message.token);
              if (message.siteID != null && Object.hasOwnProperty.call(message, "siteID")) writer.uint32(
              /* id 7, wireType 0 =*/
              56).int32(message.siteID);
              return writer;
            };
            /**
             * Encodes the specified PromotionRequest message, length delimited. Does not implicitly {@link promotionProto.PromotionRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof promotionProto.PromotionRequest
             * @static
             * @param {promotionProto.IPromotionRequest} message PromotionRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            PromotionRequest.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a PromotionRequest message from the specified reader or buffer.
             * @function decode
             * @memberof promotionProto.PromotionRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {promotionProto.PromotionRequest} PromotionRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            PromotionRequest.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.promotionProto.PromotionRequest();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    message.apiID = reader.int32();
                    break;

                  case 2:
                    message.accountID = reader.int32();
                    break;

                  case 3:
                    message.loginGameID = reader.int32();
                    break;

                  case 4:
                    message.gameID = reader.int32();
                    break;

                  case 5:
                    message.userID = reader.string();
                    break;

                  case 6:
                    message.token = reader.string();
                    break;

                  case 7:
                    message.siteID = reader.int32();
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
             * Decodes a PromotionRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof promotionProto.PromotionRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {promotionProto.PromotionRequest} PromotionRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            PromotionRequest.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a PromotionRequest message.
             * @function verify
             * @memberof promotionProto.PromotionRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */


            PromotionRequest.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.apiID != null && message.hasOwnProperty("apiID")) if (!$util.isInteger(message.apiID)) return "apiID: integer expected";
              if (message.accountID != null && message.hasOwnProperty("accountID")) if (!$util.isInteger(message.accountID)) return "accountID: integer expected";
              if (message.loginGameID != null && message.hasOwnProperty("loginGameID")) if (!$util.isInteger(message.loginGameID)) return "loginGameID: integer expected";
              if (message.gameID != null && message.hasOwnProperty("gameID")) if (!$util.isInteger(message.gameID)) return "gameID: integer expected";
              if (message.userID != null && message.hasOwnProperty("userID")) if (!$util.isString(message.userID)) return "userID: string expected";
              if (message.token != null && message.hasOwnProperty("token")) if (!$util.isString(message.token)) return "token: string expected";
              if (message.siteID != null && message.hasOwnProperty("siteID")) if (!$util.isInteger(message.siteID)) return "siteID: integer expected";
              return null;
            };
            /**
             * Creates a PromotionRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof promotionProto.PromotionRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {promotionProto.PromotionRequest} PromotionRequest
             */


            PromotionRequest.fromObject = function fromObject(object) {
              if (object instanceof $root.promotionProto.PromotionRequest) return object;
              var message = new $root.promotionProto.PromotionRequest();
              if (object.apiID != null) message.apiID = object.apiID | 0;
              if (object.accountID != null) message.accountID = object.accountID | 0;
              if (object.loginGameID != null) message.loginGameID = object.loginGameID | 0;
              if (object.gameID != null) message.gameID = object.gameID | 0;
              if (object.userID != null) message.userID = String(object.userID);
              if (object.token != null) message.token = String(object.token);
              if (object.siteID != null) message.siteID = object.siteID | 0;
              return message;
            };
            /**
             * Creates a plain object from a PromotionRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof promotionProto.PromotionRequest
             * @static
             * @param {promotionProto.PromotionRequest} message PromotionRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */


            PromotionRequest.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.apiID = 0;
                object.accountID = 0;
                object.loginGameID = 0;
                object.gameID = 0;
                object.userID = "";
                object.token = "";
                object.siteID = 0;
              }

              if (message.apiID != null && message.hasOwnProperty("apiID")) object.apiID = message.apiID;
              if (message.accountID != null && message.hasOwnProperty("accountID")) object.accountID = message.accountID;
              if (message.loginGameID != null && message.hasOwnProperty("loginGameID")) object.loginGameID = message.loginGameID;
              if (message.gameID != null && message.hasOwnProperty("gameID")) object.gameID = message.gameID;
              if (message.userID != null && message.hasOwnProperty("userID")) object.userID = message.userID;
              if (message.token != null && message.hasOwnProperty("token")) object.token = message.token;
              if (message.siteID != null && message.hasOwnProperty("siteID")) object.siteID = message.siteID;
              return object;
            };
            /**
             * Converts this PromotionRequest to JSON.
             * @function toJSON
             * @memberof promotionProto.PromotionRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */


            PromotionRequest.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PromotionRequest;
          }();

          return promotionProto;
        }();

        module.exports = $root; // #endregion ORIGINAL CODE

        _cjsExports = exports('default', module.exports);
      }, function () {
        return {
          'protobufjs/minimal': __cjsMetaURL$1
        };
      });
    }
  };
});

System.register("chunks:///_virtual/promotion.mjs_cjs=&original=.js", ['./promotion.js', './cjs-loader.mjs'], function (exports, module) {
  'use strict';

  var __cjsMetaURL, loader;

  return {
    setters: [function (module) {
      __cjsMetaURL = module.__cjsMetaURL;
      var _setter = {};
      _setter.__cjsMetaURL = module.__cjsMetaURL;
      _setter.default = module.default;
      exports(_setter);
    }, function (module) {
      loader = module.default;
    }],
    execute: function () {
      // I am the facade module who provides access to the CommonJS module './promotion.js'~
      if (!__cjsMetaURL) {
        loader.throwInvalidWrapper('./promotion.js', module.meta.url);
      }

      loader.require(__cjsMetaURL);
    }
  };
});

System.register("chunks:///_virtual/reader_buffer.js", ['./cjs-loader.mjs', './reader.js', './minimal2.js'], function (exports, module) {
  'use strict';

  var loader, __cjsMetaURL$1, __cjsMetaURL$2;

  return {
    setters: [function (module) {
      loader = module.default;
    }, function (module) {
      __cjsMetaURL$1 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$2 = module.__cjsMetaURL;
    }],
    execute: function () {
      var __cjsMetaURL = exports('__cjsMetaURL', module.meta.url);

      loader.define(__cjsMetaURL, function (exports, require, module, __filename, __dirname) {
        module.exports = BufferReader; // extends Reader

        var Reader = require("./reader");

        (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;

        var util = require("./util/minimal");
        /**
         * Constructs a new buffer reader instance.
         * @classdesc Wire format reader using node buffers.
         * @extends Reader
         * @constructor
         * @param {Buffer} buffer Buffer to read from
         */


        function BufferReader(buffer) {
          Reader.call(this, buffer);
          /**
           * Read buffer.
           * @name BufferReader#buf
           * @type {Buffer}
           */
        }

        BufferReader._configure = function () {
          /* istanbul ignore else */
          if (util.Buffer) BufferReader.prototype._slice = util.Buffer.prototype.slice;
        };
        /**
         * @override
         */


        BufferReader.prototype.string = function read_string_buffer() {
          var len = this.uint32(); // modifies pos

          return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
        };
        /**
         * Reads a sequence of bytes preceeded by its length as a varint.
         * @name BufferReader#bytes
         * @function
         * @returns {Buffer} Value read
         */


        BufferReader._configure(); // #endregion ORIGINAL CODE


        module.exports;
      }, function () {
        return {
          './reader': __cjsMetaURL$1,
          './util/minimal': __cjsMetaURL$2
        };
      });
    }
  };
});

System.register("chunks:///_virtual/reader.js", ['./cjs-loader.mjs', './minimal2.js'], function (exports, module) {
  'use strict';

  var loader, __cjsMetaURL$1;

  return {
    setters: [function (module) {
      loader = module.default;
    }, function (module) {
      __cjsMetaURL$1 = module.__cjsMetaURL;
    }],
    execute: function () {
      var __cjsMetaURL = exports('__cjsMetaURL', module.meta.url);

      loader.define(__cjsMetaURL, function (exports, require, module, __filename, __dirname) {
        module.exports = Reader;

        var util = require("./util/minimal");

        var BufferReader; // cyclic

        var LongBits = util.LongBits,
            utf8 = util.utf8;
        /* istanbul ignore next */

        function indexOutOfRange(reader, writeLength) {
          return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
        }
        /**
         * Constructs a new reader instance using the specified buffer.
         * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.
         * @constructor
         * @param {Uint8Array} buffer Buffer to read from
         */


        function Reader(buffer) {
          /**
           * Read buffer.
           * @type {Uint8Array}
           */
          this.buf = buffer;
          /**
           * Read buffer position.
           * @type {number}
           */

          this.pos = 0;
          /**
           * Read buffer length.
           * @type {number}
           */

          this.len = buffer.length;
        }

        var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer) {
          if (buffer instanceof Uint8Array || Array.isArray(buffer)) return new Reader(buffer);
          throw Error("illegal buffer");
        }
        /* istanbul ignore next */
        : function create_array(buffer) {
          if (Array.isArray(buffer)) return new Reader(buffer);
          throw Error("illegal buffer");
        };

        var create = function create() {
          return util.Buffer ? function create_buffer_setup(buffer) {
            return (Reader.create = function create_buffer(buffer) {
              return util.Buffer.isBuffer(buffer) ? new BufferReader(buffer)
              /* istanbul ignore next */
              : create_array(buffer);
            })(buffer);
          }
          /* istanbul ignore next */
          : create_array;
        };
        /**
         * Creates a new reader using the specified buffer.
         * @function
         * @param {Uint8Array|Buffer} buffer Buffer to read from
         * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}
         * @throws {Error} If `buffer` is not a valid buffer
         */


        Reader.create = create();
        Reader.prototype._slice = util.Array.prototype.subarray ||
        /* istanbul ignore next */
        util.Array.prototype.slice;
        /**
         * Reads a varint as an unsigned 32 bit value.
         * @function
         * @returns {number} Value read
         */

        Reader.prototype.uint32 = function read_uint32_setup() {
          var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)

          return function read_uint32() {
            value = (this.buf[this.pos] & 127) >>> 0;
            if (this.buf[this.pos++] < 128) return value;
            value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
            if (this.buf[this.pos++] < 128) return value;
            value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
            if (this.buf[this.pos++] < 128) return value;
            value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
            if (this.buf[this.pos++] < 128) return value;
            value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
            if (this.buf[this.pos++] < 128) return value;
            /* istanbul ignore if */

            if ((this.pos += 5) > this.len) {
              this.pos = this.len;
              throw indexOutOfRange(this, 10);
            }

            return value;
          };
        }();
        /**
         * Reads a varint as a signed 32 bit value.
         * @returns {number} Value read
         */


        Reader.prototype.int32 = function read_int32() {
          return this.uint32() | 0;
        };
        /**
         * Reads a zig-zag encoded varint as a signed 32 bit value.
         * @returns {number} Value read
         */


        Reader.prototype.sint32 = function read_sint32() {
          var value = this.uint32();
          return value >>> 1 ^ -(value & 1) | 0;
        };
        /* eslint-disable no-invalid-this */


        function readLongVarint() {
          // tends to deopt with local vars for octet etc.
          var bits = new LongBits(0, 0);
          var i = 0;

          if (this.len - this.pos > 4) {
            // fast route (lo)
            for (; i < 4; ++i) {
              // 1st..4th
              bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
              if (this.buf[this.pos++] < 128) return bits;
            } // 5th


            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
            if (this.buf[this.pos++] < 128) return bits;
            i = 0;
          } else {
            for (; i < 3; ++i) {
              /* istanbul ignore if */
              if (this.pos >= this.len) throw indexOutOfRange(this); // 1st..3th

              bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
              if (this.buf[this.pos++] < 128) return bits;
            } // 4th


            bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
            return bits;
          }

          if (this.len - this.pos > 4) {
            // fast route (hi)
            for (; i < 5; ++i) {
              // 6th..10th
              bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
              if (this.buf[this.pos++] < 128) return bits;
            }
          } else {
            for (; i < 5; ++i) {
              /* istanbul ignore if */
              if (this.pos >= this.len) throw indexOutOfRange(this); // 6th..10th

              bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
              if (this.buf[this.pos++] < 128) return bits;
            }
          }
          /* istanbul ignore next */


          throw Error("invalid varint encoding");
        }
        /* eslint-enable no-invalid-this */

        /**
         * Reads a varint as a signed 64 bit value.
         * @name Reader#int64
         * @function
         * @returns {Long} Value read
         */

        /**
         * Reads a varint as an unsigned 64 bit value.
         * @name Reader#uint64
         * @function
         * @returns {Long} Value read
         */

        /**
         * Reads a zig-zag encoded varint as a signed 64 bit value.
         * @name Reader#sint64
         * @function
         * @returns {Long} Value read
         */

        /**
         * Reads a varint as a boolean.
         * @returns {boolean} Value read
         */


        Reader.prototype.bool = function read_bool() {
          return this.uint32() !== 0;
        };

        function readFixed32_end(buf, end) {
          // note that this uses `end`, not `pos`
          return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
        }
        /**
         * Reads fixed 32 bits as an unsigned 32 bit integer.
         * @returns {number} Value read
         */


        Reader.prototype.fixed32 = function read_fixed32() {
          /* istanbul ignore if */
          if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4);
          return readFixed32_end(this.buf, this.pos += 4);
        };
        /**
         * Reads fixed 32 bits as a signed 32 bit integer.
         * @returns {number} Value read
         */


        Reader.prototype.sfixed32 = function read_sfixed32() {
          /* istanbul ignore if */
          if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4);
          return readFixed32_end(this.buf, this.pos += 4) | 0;
        };
        /* eslint-disable no-invalid-this */


        function
        /* this: Reader */
        readFixed64() {
          /* istanbul ignore if */
          if (this.pos + 8 > this.len) throw indexOutOfRange(this, 8);
          return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
        }
        /* eslint-enable no-invalid-this */

        /**
         * Reads fixed 64 bits.
         * @name Reader#fixed64
         * @function
         * @returns {Long} Value read
         */

        /**
         * Reads zig-zag encoded fixed 64 bits.
         * @name Reader#sfixed64
         * @function
         * @returns {Long} Value read
         */

        /**
         * Reads a float (32 bit) as a number.
         * @function
         * @returns {number} Value read
         */


        Reader.prototype["float"] = function read_float() {
          /* istanbul ignore if */
          if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4);
          var value = util["float"].readFloatLE(this.buf, this.pos);
          this.pos += 4;
          return value;
        };
        /**
         * Reads a double (64 bit float) as a number.
         * @function
         * @returns {number} Value read
         */


        Reader.prototype["double"] = function read_double() {
          /* istanbul ignore if */
          if (this.pos + 8 > this.len) throw indexOutOfRange(this, 4);
          var value = util["float"].readDoubleLE(this.buf, this.pos);
          this.pos += 8;
          return value;
        };
        /**
         * Reads a sequence of bytes preceeded by its length as a varint.
         * @returns {Uint8Array} Value read
         */


        Reader.prototype.bytes = function read_bytes() {
          var length = this.uint32(),
              start = this.pos,
              end = this.pos + length;
          /* istanbul ignore if */

          if (end > this.len) throw indexOutOfRange(this, length);
          this.pos += length;
          if (Array.isArray(this.buf)) // plain array
            return this.buf.slice(start, end);
          return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1
          ? new this.buf.constructor(0) : this._slice.call(this.buf, start, end);
        };
        /**
         * Reads a string preceeded by its byte length as a varint.
         * @returns {string} Value read
         */


        Reader.prototype.string = function read_string() {
          var bytes = this.bytes();
          return utf8.read(bytes, 0, bytes.length);
        };
        /**
         * Skips the specified number of bytes if specified, otherwise skips a varint.
         * @param {number} [length] Length if known, otherwise a varint is assumed
         * @returns {Reader} `this`
         */


        Reader.prototype.skip = function skip(length) {
          if (typeof length === "number") {
            /* istanbul ignore if */
            if (this.pos + length > this.len) throw indexOutOfRange(this, length);
            this.pos += length;
          } else {
            do {
              /* istanbul ignore if */
              if (this.pos >= this.len) throw indexOutOfRange(this);
            } while (this.buf[this.pos++] & 128);
          }

          return this;
        };
        /**
         * Skips the next element of the specified wire type.
         * @param {number} wireType Wire type received
         * @returns {Reader} `this`
         */


        Reader.prototype.skipType = function (wireType) {
          switch (wireType) {
            case 0:
              this.skip();
              break;

            case 1:
              this.skip(8);
              break;

            case 2:
              this.skip(this.uint32());
              break;

            case 3:
              while ((wireType = this.uint32() & 7) !== 4) {
                this.skipType(wireType);
              }

              break;

            case 5:
              this.skip(4);
              break;

            /* istanbul ignore next */

            default:
              throw Error("invalid wire type " + wireType + " at offset " + this.pos);
          }

          return this;
        };

        Reader._configure = function (BufferReader_) {
          BufferReader = BufferReader_;
          Reader.create = create();

          BufferReader._configure();

          var fn = util.Long ? "toLong" :
          /* istanbul ignore next */
          "toNumber";
          util.merge(Reader.prototype, {
            int64: function read_int64() {
              return readLongVarint.call(this)[fn](false);
            },
            uint64: function read_uint64() {
              return readLongVarint.call(this)[fn](true);
            },
            sint64: function read_sint64() {
              return readLongVarint.call(this).zzDecode()[fn](false);
            },
            fixed64: function read_fixed64() {
              return readFixed64.call(this)[fn](true);
            },
            sfixed64: function read_sfixed64() {
              return readFixed64.call(this)[fn](false);
            }
          });
        }; // #endregion ORIGINAL CODE


        module.exports;
      }, function () {
        return {
          './util/minimal': __cjsMetaURL$1
        };
      });
    }
  };
});

System.register("chunks:///_virtual/rollupPluginModLoBabelHelpers.js", [], function (exports) {
  'use strict';

  return {
    execute: function () {
      exports({
        applyDecoratedDescriptor: _applyDecoratedDescriptor,
        arrayLikeToArray: _arrayLikeToArray,
        assertThisInitialized: _assertThisInitialized,
        asyncToGenerator: _asyncToGenerator,
        construct: _construct,
        createClass: _createClass,
        createForOfIteratorHelperLoose: _createForOfIteratorHelperLoose,
        getPrototypeOf: _getPrototypeOf,
        inheritsLoose: _inheritsLoose,
        initializerDefineProperty: _initializerDefineProperty,
        isNativeFunction: _isNativeFunction,
        isNativeReflectConstruct: _isNativeReflectConstruct,
        regeneratorRuntime: _regeneratorRuntime,
        setPrototypeOf: _setPrototypeOf,
        unsupportedIterableToArray: _unsupportedIterableToArray,
        wrapNativeSuper: _wrapNativeSuper
      });

      function _regeneratorRuntime() {
        /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
        _regeneratorRuntime = exports('regeneratorRuntime', function () {
          return exports$1;
        });
        var exports$1 = {},
            Op = Object.prototype,
            hasOwn = Op.hasOwnProperty,
            $Symbol = "function" == typeof Symbol ? Symbol : {},
            iteratorSymbol = $Symbol.iterator || "@@iterator",
            asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
            toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

        function define(obj, key, value) {
          return Object.defineProperty(obj, key, {
            value: value,
            enumerable: !0,
            configurable: !0,
            writable: !0
          }), obj[key];
        }

        try {
          define({}, "");
        } catch (err) {
          define = function (obj, key, value) {
            return obj[key] = value;
          };
        }

        function wrap(innerFn, outerFn, self, tryLocsList) {
          var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
              generator = Object.create(protoGenerator.prototype),
              context = new Context(tryLocsList || []);
          return generator._invoke = function (innerFn, self, context) {
            var state = "suspendedStart";
            return function (method, arg) {
              if ("executing" === state) throw new Error("Generator is already running");

              if ("completed" === state) {
                if ("throw" === method) throw arg;
                return doneResult();
              }

              for (context.method = method, context.arg = arg;;) {
                var delegate = context.delegate;

                if (delegate) {
                  var delegateResult = maybeInvokeDelegate(delegate, context);

                  if (delegateResult) {
                    if (delegateResult === ContinueSentinel) continue;
                    return delegateResult;
                  }
                }

                if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
                  if ("suspendedStart" === state) throw state = "completed", context.arg;
                  context.dispatchException(context.arg);
                } else "return" === context.method && context.abrupt("return", context.arg);
                state = "executing";
                var record = tryCatch(innerFn, self, context);

                if ("normal" === record.type) {
                  if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
                  return {
                    value: record.arg,
                    done: context.done
                  };
                }

                "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
              }
            };
          }(innerFn, self, context), generator;
        }

        function tryCatch(fn, obj, arg) {
          try {
            return {
              type: "normal",
              arg: fn.call(obj, arg)
            };
          } catch (err) {
            return {
              type: "throw",
              arg: err
            };
          }
        }

        exports$1.wrap = wrap;
        var ContinueSentinel = {};

        function Generator() {}

        function GeneratorFunction() {}

        function GeneratorFunctionPrototype() {}

        var IteratorPrototype = {};
        define(IteratorPrototype, iteratorSymbol, function () {
          return this;
        });
        var getProto = Object.getPrototypeOf,
            NativeIteratorPrototype = getProto && getProto(getProto(values([])));
        NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
        var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);

        function defineIteratorMethods(prototype) {
          ["next", "throw", "return"].forEach(function (method) {
            define(prototype, method, function (arg) {
              return this._invoke(method, arg);
            });
          });
        }

        function AsyncIterator(generator, PromiseImpl) {
          function invoke(method, arg, resolve, reject) {
            var record = tryCatch(generator[method], generator, arg);

            if ("throw" !== record.type) {
              var result = record.arg,
                  value = result.value;
              return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
                invoke("next", value, resolve, reject);
              }, function (err) {
                invoke("throw", err, resolve, reject);
              }) : PromiseImpl.resolve(value).then(function (unwrapped) {
                result.value = unwrapped, resolve(result);
              }, function (error) {
                return invoke("throw", error, resolve, reject);
              });
            }

            reject(record.arg);
          }

          var previousPromise;

          this._invoke = function (method, arg) {
            function callInvokeWithMethodAndArg() {
              return new PromiseImpl(function (resolve, reject) {
                invoke(method, arg, resolve, reject);
              });
            }

            return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
          };
        }

        function maybeInvokeDelegate(delegate, context) {
          var method = delegate.iterator[context.method];

          if (undefined === method) {
            if (context.delegate = null, "throw" === context.method) {
              if (delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel;
              context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method");
            }

            return ContinueSentinel;
          }

          var record = tryCatch(method, delegate.iterator, context.arg);
          if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
          var info = record.arg;
          return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
        }

        function pushTryEntry(locs) {
          var entry = {
            tryLoc: locs[0]
          };
          1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
        }

        function resetTryEntry(entry) {
          var record = entry.completion || {};
          record.type = "normal", delete record.arg, entry.completion = record;
        }

        function Context(tryLocsList) {
          this.tryEntries = [{
            tryLoc: "root"
          }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
        }

        function values(iterable) {
          if (iterable) {
            var iteratorMethod = iterable[iteratorSymbol];
            if (iteratorMethod) return iteratorMethod.call(iterable);
            if ("function" == typeof iterable.next) return iterable;

            if (!isNaN(iterable.length)) {
              var i = -1,
                  next = function next() {
                for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;

                return next.value = undefined, next.done = !0, next;
              };

              return next.next = next;
            }
          }

          return {
            next: doneResult
          };
        }

        function doneResult() {
          return {
            value: undefined,
            done: !0
          };
        }

        return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports$1.isGeneratorFunction = function (genFun) {
          var ctor = "function" == typeof genFun && genFun.constructor;
          return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
        }, exports$1.mark = function (genFun) {
          return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
        }, exports$1.awrap = function (arg) {
          return {
            __await: arg
          };
        }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
          return this;
        }), exports$1.AsyncIterator = AsyncIterator, exports$1.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
          void 0 === PromiseImpl && (PromiseImpl = Promise);
          var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
          return exports$1.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
            return result.done ? result.value : iter.next();
          });
        }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
          return this;
        }), define(Gp, "toString", function () {
          return "[object Generator]";
        }), exports$1.keys = function (object) {
          var keys = [];

          for (var key in object) keys.push(key);

          return keys.reverse(), function next() {
            for (; keys.length;) {
              var key = keys.pop();
              if (key in object) return next.value = key, next.done = !1, next;
            }

            return next.done = !0, next;
          };
        }, exports$1.values = values, Context.prototype = {
          constructor: Context,
          reset: function (skipTempReset) {
            if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
          },
          stop: function () {
            this.done = !0;
            var rootRecord = this.tryEntries[0].completion;
            if ("throw" === rootRecord.type) throw rootRecord.arg;
            return this.rval;
          },
          dispatchException: function (exception) {
            if (this.done) throw exception;
            var context = this;

            function handle(loc, caught) {
              return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
            }

            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
              var entry = this.tryEntries[i],
                  record = entry.completion;
              if ("root" === entry.tryLoc) return handle("end");

              if (entry.tryLoc <= this.prev) {
                var hasCatch = hasOwn.call(entry, "catchLoc"),
                    hasFinally = hasOwn.call(entry, "finallyLoc");

                if (hasCatch && hasFinally) {
                  if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
                  if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
                } else if (hasCatch) {
                  if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
                } else {
                  if (!hasFinally) throw new Error("try statement without catch or finally");
                  if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
                }
              }
            }
          },
          abrupt: function (type, arg) {
            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
              var entry = this.tryEntries[i];

              if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
                var finallyEntry = entry;
                break;
              }
            }

            finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
            var record = finallyEntry ? finallyEntry.completion : {};
            return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
          },
          complete: function (record, afterLoc) {
            if ("throw" === record.type) throw record.arg;
            return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
          },
          finish: function (finallyLoc) {
            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
              var entry = this.tryEntries[i];
              if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
            }
          },
          catch: function (tryLoc) {
            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
              var entry = this.tryEntries[i];

              if (entry.tryLoc === tryLoc) {
                var record = entry.completion;

                if ("throw" === record.type) {
                  var thrown = record.arg;
                  resetTryEntry(entry);
                }

                return thrown;
              }
            }

            throw new Error("illegal catch attempt");
          },
          delegateYield: function (iterable, resultName, nextLoc) {
            return this.delegate = {
              iterator: values(iterable),
              resultName: resultName,
              nextLoc: nextLoc
            }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
          }
        }, exports$1;
      }

      function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
        try {
          var info = gen[key](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }

        if (info.done) {
          resolve(value);
        } else {
          Promise.resolve(value).then(_next, _throw);
        }
      }

      function _asyncToGenerator(fn) {
        return function () {
          var self = this,
              args = arguments;
          return new Promise(function (resolve, reject) {
            var gen = fn.apply(self, args);

            function _next(value) {
              asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }

            function _throw(err) {
              asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }

            _next(undefined);
          });
        };
      }

      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        Object.defineProperty(Constructor, "prototype", {
          writable: false
        });
        return Constructor;
      }

      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;

        _setPrototypeOf(subClass, superClass);
      }

      function _getPrototypeOf(o) {
        _getPrototypeOf = exports('getPrototypeOf', Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
          return o.__proto__ || Object.getPrototypeOf(o);
        });
        return _getPrototypeOf(o);
      }

      function _setPrototypeOf(o, p) {
        _setPrototypeOf = exports('setPrototypeOf', Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
          o.__proto__ = p;
          return o;
        });
        return _setPrototypeOf(o, p);
      }

      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct) return false;
        if (Reflect.construct.sham) return false;
        if (typeof Proxy === "function") return true;

        try {
          Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
          return true;
        } catch (e) {
          return false;
        }
      }

      function _construct(Parent, args, Class) {
        if (_isNativeReflectConstruct()) {
          _construct = exports('construct', Reflect.construct.bind());
        } else {
          _construct = exports('construct', function _construct(Parent, args, Class) {
            var a = [null];
            a.push.apply(a, args);
            var Constructor = Function.bind.apply(Parent, a);
            var instance = new Constructor();
            if (Class) _setPrototypeOf(instance, Class.prototype);
            return instance;
          });
        }

        return _construct.apply(null, arguments);
      }

      function _isNativeFunction(fn) {
        return Function.toString.call(fn).indexOf("[native code]") !== -1;
      }

      function _wrapNativeSuper(Class) {
        var _cache = typeof Map === "function" ? new Map() : undefined;

        _wrapNativeSuper = exports('wrapNativeSuper', function _wrapNativeSuper(Class) {
          if (Class === null || !_isNativeFunction(Class)) return Class;

          if (typeof Class !== "function") {
            throw new TypeError("Super expression must either be null or a function");
          }

          if (typeof _cache !== "undefined") {
            if (_cache.has(Class)) return _cache.get(Class);

            _cache.set(Class, Wrapper);
          }

          function Wrapper() {
            return _construct(Class, arguments, _getPrototypeOf(this).constructor);
          }

          Wrapper.prototype = Object.create(Class.prototype, {
            constructor: {
              value: Wrapper,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          return _setPrototypeOf(Wrapper, Class);
        });
        return _wrapNativeSuper(Class);
      }

      function _assertThisInitialized(self) {
        if (self === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return self;
      }

      function _unsupportedIterableToArray(o, minLen) {
        if (!o) return;
        if (typeof o === "string") return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor) n = o.constructor.name;
        if (n === "Map" || n === "Set") return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
      }

      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length) len = arr.length;

        for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

        return arr2;
      }

      function _createForOfIteratorHelperLoose(o, allowArrayLike) {
        var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
        if (it) return (it = it.call(o)).next.bind(it);

        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it) o = it;
          var i = 0;
          return function () {
            if (i >= o.length) return {
              done: true
            };
            return {
              done: false,
              value: o[i++]
            };
          };
        }

        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }

      function _initializerDefineProperty(target, property, descriptor, context) {
        if (!descriptor) return;
        Object.defineProperty(target, property, {
          enumerable: descriptor.enumerable,
          configurable: descriptor.configurable,
          writable: descriptor.writable,
          value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
        });
      }

      function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
        var desc = {};
        Object.keys(descriptor).forEach(function (key) {
          desc[key] = descriptor[key];
        });
        desc.enumerable = !!desc.enumerable;
        desc.configurable = !!desc.configurable;

        if ('value' in desc || desc.initializer) {
          desc.writable = true;
        }

        desc = decorators.slice().reverse().reduce(function (desc, decorator) {
          return decorator(target, property, desc) || desc;
        }, desc);

        if (context && desc.initializer !== void 0) {
          desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
          desc.initializer = undefined;
        }

        if (desc.initializer === void 0) {
          Object.defineProperty(target, property, desc);
          desc = null;
        }

        return desc;
      }
    }
  };
});

System.register("chunks:///_virtual/root.js", ['./cjs-loader.mjs', './namespace.js', './field.js', './enum.js', './oneof.js', './util.js'], function (exports, module) {
  'use strict';

  var loader, __cjsMetaURL$1, __cjsMetaURL$2, __cjsMetaURL$3, __cjsMetaURL$4, __cjsMetaURL$5;

  return {
    setters: [function (module) {
      loader = module.default;
    }, function (module) {
      __cjsMetaURL$1 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$2 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$3 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$4 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$5 = module.__cjsMetaURL;
    }],
    execute: function () {
      var __cjsMetaURL = exports('__cjsMetaURL', module.meta.url);

      loader.define(__cjsMetaURL, function (exports, require, module, __filename, __dirname) {
        module.exports = Root; // extends Namespace

        var Namespace = require("./namespace");

        ((Root.prototype = Object.create(Namespace.prototype)).constructor = Root).className = "Root";

        var Field = require("./field"),
            Enum = require("./enum"),
            OneOf = require("./oneof"),
            util = require("./util");

        var Type, // cyclic
        parse, // might be excluded
        common; // "

        /**
         * Constructs a new root namespace instance.
         * @classdesc Root namespace wrapping all types, enums, services, sub-namespaces etc. that belong together.
         * @extends NamespaceBase
         * @constructor
         * @param {Object.<string,*>} [options] Top level options
         */

        function Root(options) {
          Namespace.call(this, "", options);
          /**
           * Deferred extension fields.
           * @type {Field[]}
           */

          this.deferred = [];
          /**
           * Resolved file names of loaded files.
           * @type {string[]}
           */

          this.files = [];
        }
        /**
         * Loads a namespace descriptor into a root namespace.
         * @param {INamespace} json Nameespace descriptor
         * @param {Root} [root] Root namespace, defaults to create a new one if omitted
         * @returns {Root} Root namespace
         */


        Root.fromJSON = function fromJSON(json, root) {
          if (!root) root = new Root();
          if (json.options) root.setOptions(json.options);
          return root.addJSON(json.nested);
        };
        /**
         * Resolves the path of an imported file, relative to the importing origin.
         * This method exists so you can override it with your own logic in case your imports are scattered over multiple directories.
         * @function
         * @param {string} origin The file name of the importing file
         * @param {string} target The file name being imported
         * @returns {string|null} Resolved path to `target` or `null` to skip the file
         */


        Root.prototype.resolvePath = util.path.resolve;
        /**
         * Fetch content from file path or url
         * This method exists so you can override it with your own logic.
         * @function
         * @param {string} path File path or url
         * @param {FetchCallback} callback Callback function
         * @returns {undefined}
         */

        Root.prototype.fetch = util.fetch; // A symbol-like function to safely signal synchronous loading

        /* istanbul ignore next */

        function SYNC() {} // eslint-disable-line no-empty-function

        /**
         * Loads one or multiple .proto or preprocessed .json files into this root namespace and calls the callback.
         * @param {string|string[]} filename Names of one or multiple files to load
         * @param {IParseOptions} options Parse options
         * @param {LoadCallback} callback Callback function
         * @returns {undefined}
         */


        Root.prototype.load = function load(filename, options, callback) {
          if (typeof options === "function") {
            callback = options;
            options = undefined;
          }

          var self = this;
          if (!callback) return util.asPromise(load, self, filename, options);
          var sync = callback === SYNC; // undocumented
          // Finishes loading by calling the callback (exactly once)

          function finish(err, root) {
            /* istanbul ignore if */
            if (!callback) return;
            var cb = callback;
            callback = null;
            if (sync) throw err;
            cb(err, root);
          } // Bundled definition existence checking


          function getBundledFileName(filename) {
            var idx = filename.lastIndexOf("google/protobuf/");

            if (idx > -1) {
              var altname = filename.substring(idx);
              if (altname in common) return altname;
            }

            return null;
          } // Processes a single file


          function process(filename, source) {
            try {
              if (util.isString(source) && source.charAt(0) === "{") source = JSON.parse(source);
              if (!util.isString(source)) self.setOptions(source.options).addJSON(source.nested);else {
                parse.filename = filename;
                var parsed = parse(source, self, options),
                    resolved,
                    i = 0;
                if (parsed.imports) for (; i < parsed.imports.length; ++i) {
                  if (resolved = getBundledFileName(parsed.imports[i]) || self.resolvePath(filename, parsed.imports[i])) fetch(resolved);
                }
                if (parsed.weakImports) for (i = 0; i < parsed.weakImports.length; ++i) {
                  if (resolved = getBundledFileName(parsed.weakImports[i]) || self.resolvePath(filename, parsed.weakImports[i])) fetch(resolved, true);
                }
              }
            } catch (err) {
              finish(err);
            }

            if (!sync && !queued) finish(null, self); // only once anyway
          } // Fetches a single file


          function fetch(filename, weak) {
            // Skip if already loaded / attempted
            if (self.files.indexOf(filename) > -1) return;
            self.files.push(filename); // Shortcut bundled definitions

            if (filename in common) {
              if (sync) process(filename, common[filename]);else {
                ++queued;
                setTimeout(function () {
                  --queued;
                  process(filename, common[filename]);
                });
              }
              return;
            } // Otherwise fetch from disk or network


            if (sync) {
              var source;

              try {
                source = util.fs.readFileSync(filename).toString("utf8");
              } catch (err) {
                if (!weak) finish(err);
                return;
              }

              process(filename, source);
            } else {
              ++queued;
              self.fetch(filename, function (err, source) {
                --queued;
                /* istanbul ignore if */

                if (!callback) return; // terminated meanwhile

                if (err) {
                  /* istanbul ignore else */
                  if (!weak) finish(err);else if (!queued) // can't be covered reliably
                    finish(null, self);
                  return;
                }

                process(filename, source);
              });
            }
          }

          var queued = 0; // Assembling the root namespace doesn't require working type
          // references anymore, so we can load everything in parallel

          if (util.isString(filename)) filename = [filename];

          for (var i = 0, resolved; i < filename.length; ++i) {
            if (resolved = self.resolvePath("", filename[i])) fetch(resolved);
          }

          if (sync) return self;
          if (!queued) finish(null, self);
          return undefined;
        }; // function load(filename:string, options:IParseOptions, callback:LoadCallback):undefined

        /**
         * Loads one or multiple .proto or preprocessed .json files into this root namespace and calls the callback.
         * @function Root#load
         * @param {string|string[]} filename Names of one or multiple files to load
         * @param {LoadCallback} callback Callback function
         * @returns {undefined}
         * @variation 2
         */
        // function load(filename:string, callback:LoadCallback):undefined

        /**
         * Loads one or multiple .proto or preprocessed .json files into this root namespace and returns a promise.
         * @function Root#load
         * @param {string|string[]} filename Names of one or multiple files to load
         * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
         * @returns {Promise<Root>} Promise
         * @variation 3
         */
        // function load(filename:string, [options:IParseOptions]):Promise<Root>

        /**
         * Synchronously loads one or multiple .proto or preprocessed .json files into this root namespace (node only).
         * @function Root#loadSync
         * @param {string|string[]} filename Names of one or multiple files to load
         * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
         * @returns {Root} Root namespace
         * @throws {Error} If synchronous fetching is not supported (i.e. in browsers) or if a file's syntax is invalid
         */


        Root.prototype.loadSync = function loadSync(filename, options) {
          if (!util.isNode) throw Error("not supported");
          return this.load(filename, options, SYNC);
        };
        /**
         * @override
         */


        Root.prototype.resolveAll = function resolveAll() {
          if (this.deferred.length) throw Error("unresolvable extensions: " + this.deferred.map(function (field) {
            return "'extend " + field.extend + "' in " + field.parent.fullName;
          }).join(", "));
          return Namespace.prototype.resolveAll.call(this);
        }; // only uppercased (and thus conflict-free) children are exposed, see below


        var exposeRe = /^[A-Z]/;
        /**
         * Handles a deferred declaring extension field by creating a sister field to represent it within its extended type.
         * @param {Root} root Root instance
         * @param {Field} field Declaring extension field witin the declaring type
         * @returns {boolean} `true` if successfully added to the extended type, `false` otherwise
         * @inner
         * @ignore
         */

        function tryHandleExtension(root, field) {
          var extendedType = field.parent.lookup(field.extend);

          if (extendedType) {
            var sisterField = new Field(field.fullName, field.id, field.type, field.rule, undefined, field.options);
            sisterField.declaringField = field;
            field.extensionField = sisterField;
            extendedType.add(sisterField);
            return true;
          }

          return false;
        }
        /**
         * Called when any object is added to this root or its sub-namespaces.
         * @param {ReflectionObject} object Object added
         * @returns {undefined}
         * @private
         */


        Root.prototype._handleAdd = function _handleAdd(object) {
          if (object instanceof Field) {
            if (
            /* an extension field (implies not part of a oneof) */
            object.extend !== undefined &&
            /* not already handled */
            !object.extensionField) if (!tryHandleExtension(this, object)) this.deferred.push(object);
          } else if (object instanceof Enum) {
            if (exposeRe.test(object.name)) object.parent[object.name] = object.values; // expose enum values as property of its parent
          } else if (!(object instanceof OneOf))
            /* everything else is a namespace */
            {
              if (object instanceof Type) // Try to handle any deferred extensions
                for (var i = 0; i < this.deferred.length;) {
                  if (tryHandleExtension(this, this.deferred[i])) this.deferred.splice(i, 1);else ++i;
                }

              for (var j = 0; j <
              /* initializes */
              object.nestedArray.length; ++j) {
                // recurse into the namespace
                this._handleAdd(object._nestedArray[j]);
              }

              if (exposeRe.test(object.name)) object.parent[object.name] = object; // expose namespace as property of its parent
            } // The above also adds uppercased (and thus conflict-free) nested types, services and enums as
          // properties of namespaces just like static code does. This allows using a .d.ts generated for
          // a static module with reflection-based solutions where the condition is met.

        };
        /**
         * Called when any object is removed from this root or its sub-namespaces.
         * @param {ReflectionObject} object Object removed
         * @returns {undefined}
         * @private
         */


        Root.prototype._handleRemove = function _handleRemove(object) {
          if (object instanceof Field) {
            if (
            /* an extension field */
            object.extend !== undefined) {
              if (
              /* already handled */
              object.extensionField) {
                // remove its sister field
                object.extensionField.parent.remove(object.extensionField);
                object.extensionField = null;
              } else {
                // cancel the extension
                var index = this.deferred.indexOf(object);
                /* istanbul ignore else */

                if (index > -1) this.deferred.splice(index, 1);
              }
            }
          } else if (object instanceof Enum) {
            if (exposeRe.test(object.name)) delete object.parent[object.name]; // unexpose enum values
          } else if (object instanceof Namespace) {
            for (var i = 0; i <
            /* initializes */
            object.nestedArray.length; ++i) {
              // recurse into the namespace
              this._handleRemove(object._nestedArray[i]);
            }

            if (exposeRe.test(object.name)) delete object.parent[object.name]; // unexpose namespaces
          }
        }; // Sets up cyclic dependencies (called in index-light)


        Root._configure = function (Type_, parse_, common_) {
          Type = Type_;
          parse = parse_;
          common = common_;
        }; // #endregion ORIGINAL CODE


        module.exports;
      }, function () {
        return {
          './namespace': __cjsMetaURL$1,
          './field': __cjsMetaURL$2,
          './enum': __cjsMetaURL$3,
          './oneof': __cjsMetaURL$4,
          './util': __cjsMetaURL$5
        };
      });
    }
  };
});

System.register("chunks:///_virtual/roots.js", ['./cjs-loader.mjs'], function (exports, module) {
  'use strict';

  var loader;
  return {
    setters: [function (module) {
      loader = module.default;
    }],
    execute: function () {
      var __cjsMetaURL = exports('__cjsMetaURL', module.meta.url);

      loader.define(__cjsMetaURL, function (exports, require, module, __filename, __dirname) {
        module.exports = {};
        /**
         * Named roots.
         * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).
         * Can also be used manually to make roots available accross modules.
         * @name roots
         * @type {Object.<string,Root>}
         * @example
         * // pbjs -r myroot -o compiled.js ...
         *
         * // in another module:
         * require("./compiled.js");
         *
         * // in any subsequent module:
         * var root = protobuf.roots["myroot"];
         */
        // #endregion ORIGINAL CODE

        module.exports;
      }, {});
    }
  };
});

System.register("chunks:///_virtual/rpc.js", ['./cjs-loader.mjs', './service2.js'], function (exports, module) {
  'use strict';

  var loader, __cjsMetaURL$1;

  return {
    setters: [function (module) {
      loader = module.default;
    }, function (module) {
      __cjsMetaURL$1 = module.__cjsMetaURL;
    }],
    execute: function () {
      var __cjsMetaURL = exports('__cjsMetaURL', module.meta.url);

      loader.define(__cjsMetaURL, function (exports, require, module, __filename, __dirname) {
        /**
         * Streaming RPC helpers.
         * @namespace
         */
        var rpc = exports;
        /**
         * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.
         * @typedef RPCImpl
         * @type {function}
         * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called
         * @param {Uint8Array} requestData Request data
         * @param {RPCImplCallback} callback Callback function
         * @returns {undefined}
         * @example
         * function rpcImpl(method, requestData, callback) {
         *     if (protobuf.util.lcFirst(method.name) !== "myMethod") // compatible with static code
         *         throw Error("no such method");
         *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {
         *         callback(err, responseData);
         *     });
         * }
         */

        /**
         * Node-style callback as used by {@link RPCImpl}.
         * @typedef RPCImplCallback
         * @type {function}
         * @param {Error|null} error Error, if any, otherwise `null`
         * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error
         * @returns {undefined}
         */

        rpc.Service = require("./rpc/service"); // #endregion ORIGINAL CODE

        module.exports;
      }, function () {
        return {
          './rpc/service': __cjsMetaURL$1
        };
      });
    }
  };
});

System.register("chunks:///_virtual/service.js", ['./cjs-loader.mjs', './namespace.js', './method.js', './util.js', './rpc.js'], function (exports, module) {
  'use strict';

  var loader, __cjsMetaURL$1, __cjsMetaURL$2, __cjsMetaURL$3, __cjsMetaURL$4;

  return {
    setters: [function (module) {
      loader = module.default;
    }, function (module) {
      __cjsMetaURL$1 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$2 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$3 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$4 = module.__cjsMetaURL;
    }],
    execute: function () {
      var __cjsMetaURL = exports('__cjsMetaURL', module.meta.url);

      loader.define(__cjsMetaURL, function (exports, require, module, __filename, __dirname) {
        module.exports = Service; // extends Namespace

        var Namespace = require("./namespace");

        ((Service.prototype = Object.create(Namespace.prototype)).constructor = Service).className = "Service";

        var Method = require("./method"),
            util = require("./util"),
            rpc = require("./rpc");
        /**
         * Constructs a new service instance.
         * @classdesc Reflected service.
         * @extends NamespaceBase
         * @constructor
         * @param {string} name Service name
         * @param {Object.<string,*>} [options] Service options
         * @throws {TypeError} If arguments are invalid
         */


        function Service(name, options) {
          Namespace.call(this, name, options);
          /**
           * Service methods.
           * @type {Object.<string,Method>}
           */

          this.methods = {}; // toJSON, marker

          /**
           * Cached methods as an array.
           * @type {Method[]|null}
           * @private
           */

          this._methodsArray = null;
        }
        /**
         * Service descriptor.
         * @interface IService
         * @extends INamespace
         * @property {Object.<string,IMethod>} methods Method descriptors
         */

        /**
         * Constructs a service from a service descriptor.
         * @param {string} name Service name
         * @param {IService} json Service descriptor
         * @returns {Service} Created service
         * @throws {TypeError} If arguments are invalid
         */


        Service.fromJSON = function fromJSON(name, json) {
          var service = new Service(name, json.options);
          /* istanbul ignore else */

          if (json.methods) for (var names = Object.keys(json.methods), i = 0; i < names.length; ++i) {
            service.add(Method.fromJSON(names[i], json.methods[names[i]]));
          }
          if (json.nested) service.addJSON(json.nested);
          service.comment = json.comment;
          return service;
        };
        /**
         * Converts this service to a service descriptor.
         * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
         * @returns {IService} Service descriptor
         */


        Service.prototype.toJSON = function toJSON(toJSONOptions) {
          var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);
          var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
          return util.toObject(["options", inherited && inherited.options || undefined, "methods", Namespace.arrayToJSON(this.methodsArray, toJSONOptions) ||
          /* istanbul ignore next */
          {}, "nested", inherited && inherited.nested || undefined, "comment", keepComments ? this.comment : undefined]);
        };
        /**
         * Methods of this service as an array for iteration.
         * @name Service#methodsArray
         * @type {Method[]}
         * @readonly
         */


        Object.defineProperty(Service.prototype, "methodsArray", {
          get: function get() {
            return this._methodsArray || (this._methodsArray = util.toArray(this.methods));
          }
        });

        function clearCache(service) {
          service._methodsArray = null;
          return service;
        }
        /**
         * @override
         */


        Service.prototype.get = function get(name) {
          return this.methods[name] || Namespace.prototype.get.call(this, name);
        };
        /**
         * @override
         */


        Service.prototype.resolveAll = function resolveAll() {
          var methods = this.methodsArray;

          for (var i = 0; i < methods.length; ++i) {
            methods[i].resolve();
          }

          return Namespace.prototype.resolve.call(this);
        };
        /**
         * @override
         */


        Service.prototype.add = function add(object) {
          /* istanbul ignore if */
          if (this.get(object.name)) throw Error("duplicate name '" + object.name + "' in " + this);

          if (object instanceof Method) {
            this.methods[object.name] = object;
            object.parent = this;
            return clearCache(this);
          }

          return Namespace.prototype.add.call(this, object);
        };
        /**
         * @override
         */


        Service.prototype.remove = function remove(object) {
          if (object instanceof Method) {
            /* istanbul ignore if */
            if (this.methods[object.name] !== object) throw Error(object + " is not a member of " + this);
            delete this.methods[object.name];
            object.parent = null;
            return clearCache(this);
          }

          return Namespace.prototype.remove.call(this, object);
        };
        /**
         * Creates a runtime service using the specified rpc implementation.
         * @param {RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         * @returns {rpc.Service} RPC service. Useful where requests and/or responses are streamed.
         */


        Service.prototype.create = function create(rpcImpl, requestDelimited, responseDelimited) {
          var rpcService = new rpc.Service(rpcImpl, requestDelimited, responseDelimited);

          for (var i = 0, method; i <
          /* initializes */
          this.methodsArray.length; ++i) {
            var methodName = util.lcFirst((method = this._methodsArray[i]).resolve().name).replace(/[^$\w_]/g, "");
            rpcService[methodName] = util.codegen(["r", "c"], util.isReserved(methodName) ? methodName + "_" : methodName)("return this.rpcCall(m,q,s,r,c)")({
              m: method,
              q: method.resolvedRequestType.ctor,
              s: method.resolvedResponseType.ctor
            });
          }

          return rpcService;
        }; // #endregion ORIGINAL CODE


        module.exports;
      }, function () {
        return {
          './namespace': __cjsMetaURL$1,
          './method': __cjsMetaURL$2,
          './util': __cjsMetaURL$3,
          './rpc': __cjsMetaURL$4
        };
      });
    }
  };
});

System.register("chunks:///_virtual/service2.js", ['./cjs-loader.mjs', './minimal2.js'], function (exports, module) {
  'use strict';

  var loader, __cjsMetaURL$1;

  return {
    setters: [function (module) {
      loader = module.default;
    }, function (module) {
      __cjsMetaURL$1 = module.__cjsMetaURL;
    }],
    execute: function () {
      var __cjsMetaURL = exports('__cjsMetaURL', module.meta.url);

      loader.define(__cjsMetaURL, function (exports, require, module, __filename, __dirname) {
        module.exports = Service;

        var util = require("../util/minimal"); // Extends EventEmitter


        (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
        /**
         * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.
         *
         * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.
         * @typedef rpc.ServiceMethodCallback
         * @template TRes extends Message<TRes>
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {TRes} [response] Response message
         * @returns {undefined}
         */

        /**
         * A service method part of a {@link rpc.Service} as created by {@link Service.create}.
         * @typedef rpc.ServiceMethod
         * @template TReq extends Message<TReq>
         * @template TRes extends Message<TRes>
         * @type {function}
         * @param {TReq|Properties<TReq>} request Request message or plain object
         * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message
         * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`
         */

        /**
         * Constructs a new RPC service instance.
         * @classdesc An RPC service as returned by {@link Service#create}.
         * @exports rpc.Service
         * @extends util.EventEmitter
         * @constructor
         * @param {RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */

        function Service(rpcImpl, requestDelimited, responseDelimited) {
          if (typeof rpcImpl !== "function") throw TypeError("rpcImpl must be a function");
          util.EventEmitter.call(this);
          /**
           * RPC implementation. Becomes `null` once the service is ended.
           * @type {RPCImpl|null}
           */

          this.rpcImpl = rpcImpl;
          /**
           * Whether requests are length-delimited.
           * @type {boolean}
           */

          this.requestDelimited = Boolean(requestDelimited);
          /**
           * Whether responses are length-delimited.
           * @type {boolean}
           */

          this.responseDelimited = Boolean(responseDelimited);
        }
        /**
         * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.
         * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method
         * @param {Constructor<TReq>} requestCtor Request constructor
         * @param {Constructor<TRes>} responseCtor Response constructor
         * @param {TReq|Properties<TReq>} request Request message or plain object
         * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback
         * @returns {undefined}
         * @template TReq extends Message<TReq>
         * @template TRes extends Message<TRes>
         */


        Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
          if (!request) throw TypeError("request must be specified");
          var self = this;
          if (!callback) return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);

          if (!self.rpcImpl) {
            setTimeout(function () {
              callback(Error("already ended"));
            }, 0);
            return undefined;
          }

          try {
            return self.rpcImpl(method, requestCtor[self.requestDelimited ? "encodeDelimited" : "encode"](request).finish(), function rpcCallback(err, response) {
              if (err) {
                self.emit("error", err, method);
                return callback(err);
              }

              if (response === null) {
                self.end(
                /* endedByRPC */
                true);
                return undefined;
              }

              if (!(response instanceof responseCtor)) {
                try {
                  response = responseCtor[self.responseDelimited ? "decodeDelimited" : "decode"](response);
                } catch (err) {
                  self.emit("error", err, method);
                  return callback(err);
                }
              }

              self.emit("data", response, method);
              return callback(null, response);
            });
          } catch (err) {
            self.emit("error", err, method);
            setTimeout(function () {
              callback(err);
            }, 0);
            return undefined;
          }
        };
        /**
         * Ends this service and emits the `end` event.
         * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.
         * @returns {rpc.Service} `this`
         */


        Service.prototype.end = function end(endedByRPC) {
          if (this.rpcImpl) {
            if (!endedByRPC) // signal end to rpcImpl
              this.rpcImpl(null, null, null);
            this.rpcImpl = null;
            this.emit("end").off();
          }

          return this;
        }; // #endregion ORIGINAL CODE


        module.exports;
      }, function () {
        return {
          '../util/minimal': __cjsMetaURL$1
        };
      });
    }
  };
});

System.register("chunks:///_virtual/smartNotice.js", ['./cjs-loader.mjs', './minimal.js'], function (exports, module) {
  'use strict';

  var loader, __cjsMetaURL$1;

  return {
    setters: [function (module) {
      loader = module.default;
    }, function (module) {
      __cjsMetaURL$1 = module.__cjsMetaURL;
    }],
    execute: function () {
      exports('default', void 0);

      var _cjsExports;

      var __cjsMetaURL = exports('__cjsMetaURL', module.meta.url);

      loader.define(__cjsMetaURL, function (exports$1, require, module, __filename, __dirname) {
        var $protobuf = require("protobufjs/minimal"); // Common aliases


        var $Reader = $protobuf.Reader,
            $Writer = $protobuf.Writer,
            $util = $protobuf.util; // Exported root namespace

        var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

        $root.snProto = function () {
          /**
           * Namespace snProto.
           * @exports snProto
           * @namespace
           */
          var snProto = {};
          /**
           * noticeType enum.
           * @name snProto.noticeType
           * @enum {number}
           * @property {number} SignUp=0 SignUp value
           * @property {number} ItemNotUsed=1 ItemNotUsed value
           * @property {number} ItemTomorrow=2 ItemTomorrow value
           * @property {number} Message=3 Message value
           * @property {number} ToGame=4 ToGame value
           * @property {number} BuyGame=5 BuyGame value
           * @property {number} JiliLv=6 JiliLv value
           * @property {number} Mission=7 Mission value
           * @property {number} SignIn=8 SignIn value
           * @property {number} SignInFull=9 SignInFull value
           * @property {number} BuyBonus=10 BuyBonus value
           * @property {number} Debris=11 Debris value
           * @property {number} Longhu=12 Longhu value
           */

          snProto.noticeType = function () {
            var valuesById = {},
                values = Object.create(valuesById);
            values[valuesById[0] = "SignUp"] = 0;
            values[valuesById[1] = "ItemNotUsed"] = 1;
            values[valuesById[2] = "ItemTomorrow"] = 2;
            values[valuesById[3] = "Message"] = 3;
            values[valuesById[4] = "ToGame"] = 4;
            values[valuesById[5] = "BuyGame"] = 5;
            values[valuesById[6] = "JiliLv"] = 6;
            values[valuesById[7] = "Mission"] = 7;
            values[valuesById[8] = "SignIn"] = 8;
            values[valuesById[9] = "SignInFull"] = 9;
            values[valuesById[10] = "BuyBonus"] = 10;
            values[valuesById[11] = "Debris"] = 11;
            values[valuesById[12] = "Longhu"] = 12;
            return values;
          }();

          snProto.getNoticeReq = function () {
            /**
             * Properties of a getNoticeReq.
             * @memberof snProto
             * @interface IgetNoticeReq
             * @property {number|Long|null} [gameID] getNoticeReq gameID
             * @property {string|null} [lang] getNoticeReq lang
             * @property {number|Long|null} [apiID] getNoticeReq apiID
             * @property {number|Long|null} [accountID] getNoticeReq accountID
             * @property {number|Long|null} [subAgentCode] getNoticeReq subAgentCode
             */

            /**
             * Constructs a new getNoticeReq.
             * @memberof snProto
             * @classdesc Represents a getNoticeReq.
             * @implements IgetNoticeReq
             * @constructor
             * @param {snProto.IgetNoticeReq=} [properties] Properties to set
             */
            function getNoticeReq(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * getNoticeReq gameID.
             * @member {number|Long} gameID
             * @memberof snProto.getNoticeReq
             * @instance
             */


            getNoticeReq.prototype.gameID = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
             * getNoticeReq lang.
             * @member {string} lang
             * @memberof snProto.getNoticeReq
             * @instance
             */

            getNoticeReq.prototype.lang = "";
            /**
             * getNoticeReq apiID.
             * @member {number|Long} apiID
             * @memberof snProto.getNoticeReq
             * @instance
             */

            getNoticeReq.prototype.apiID = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
             * getNoticeReq accountID.
             * @member {number|Long} accountID
             * @memberof snProto.getNoticeReq
             * @instance
             */

            getNoticeReq.prototype.accountID = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
             * getNoticeReq subAgentCode.
             * @member {number|Long} subAgentCode
             * @memberof snProto.getNoticeReq
             * @instance
             */

            getNoticeReq.prototype.subAgentCode = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
             * Creates a new getNoticeReq instance using the specified properties.
             * @function create
             * @memberof snProto.getNoticeReq
             * @static
             * @param {snProto.IgetNoticeReq=} [properties] Properties to set
             * @returns {snProto.getNoticeReq} getNoticeReq instance
             */

            getNoticeReq.create = function create(properties) {
              return new getNoticeReq(properties);
            };
            /**
             * Encodes the specified getNoticeReq message. Does not implicitly {@link snProto.getNoticeReq.verify|verify} messages.
             * @function encode
             * @memberof snProto.getNoticeReq
             * @static
             * @param {snProto.IgetNoticeReq} message getNoticeReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            getNoticeReq.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.gameID != null && Object.hasOwnProperty.call(message, "gameID")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int64(message.gameID);
              if (message.lang != null && Object.hasOwnProperty.call(message, "lang")) writer.uint32(
              /* id 2, wireType 2 =*/
              18).string(message.lang);
              if (message.apiID != null && Object.hasOwnProperty.call(message, "apiID")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int64(message.apiID);
              if (message.accountID != null && Object.hasOwnProperty.call(message, "accountID")) writer.uint32(
              /* id 4, wireType 0 =*/
              32).int64(message.accountID);
              if (message.subAgentCode != null && Object.hasOwnProperty.call(message, "subAgentCode")) writer.uint32(
              /* id 5, wireType 0 =*/
              40).int64(message.subAgentCode);
              return writer;
            };
            /**
             * Encodes the specified getNoticeReq message, length delimited. Does not implicitly {@link snProto.getNoticeReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof snProto.getNoticeReq
             * @static
             * @param {snProto.IgetNoticeReq} message getNoticeReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            getNoticeReq.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a getNoticeReq message from the specified reader or buffer.
             * @function decode
             * @memberof snProto.getNoticeReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {snProto.getNoticeReq} getNoticeReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            getNoticeReq.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.snProto.getNoticeReq();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      message.gameID = reader.int64();
                      break;
                    }

                  case 2:
                    {
                      message.lang = reader.string();
                      break;
                    }

                  case 3:
                    {
                      message.apiID = reader.int64();
                      break;
                    }

                  case 4:
                    {
                      message.accountID = reader.int64();
                      break;
                    }

                  case 5:
                    {
                      message.subAgentCode = reader.int64();
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
             * Decodes a getNoticeReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof snProto.getNoticeReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {snProto.getNoticeReq} getNoticeReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            getNoticeReq.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a getNoticeReq message.
             * @function verify
             * @memberof snProto.getNoticeReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */


            getNoticeReq.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.gameID != null && message.hasOwnProperty("gameID")) if (!$util.isInteger(message.gameID) && !(message.gameID && $util.isInteger(message.gameID.low) && $util.isInteger(message.gameID.high))) return "gameID: integer|Long expected";
              if (message.lang != null && message.hasOwnProperty("lang")) if (!$util.isString(message.lang)) return "lang: string expected";
              if (message.apiID != null && message.hasOwnProperty("apiID")) if (!$util.isInteger(message.apiID) && !(message.apiID && $util.isInteger(message.apiID.low) && $util.isInteger(message.apiID.high))) return "apiID: integer|Long expected";
              if (message.accountID != null && message.hasOwnProperty("accountID")) if (!$util.isInteger(message.accountID) && !(message.accountID && $util.isInteger(message.accountID.low) && $util.isInteger(message.accountID.high))) return "accountID: integer|Long expected";
              if (message.subAgentCode != null && message.hasOwnProperty("subAgentCode")) if (!$util.isInteger(message.subAgentCode) && !(message.subAgentCode && $util.isInteger(message.subAgentCode.low) && $util.isInteger(message.subAgentCode.high))) return "subAgentCode: integer|Long expected";
              return null;
            };
            /**
             * Creates a getNoticeReq message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof snProto.getNoticeReq
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {snProto.getNoticeReq} getNoticeReq
             */


            getNoticeReq.fromObject = function fromObject(object) {
              if (object instanceof $root.snProto.getNoticeReq) return object;
              var message = new $root.snProto.getNoticeReq();
              if (object.gameID != null) if ($util.Long) (message.gameID = $util.Long.fromValue(object.gameID)).unsigned = false;else if (typeof object.gameID === "string") message.gameID = parseInt(object.gameID, 10);else if (typeof object.gameID === "number") message.gameID = object.gameID;else if (typeof object.gameID === "object") message.gameID = new $util.LongBits(object.gameID.low >>> 0, object.gameID.high >>> 0).toNumber();
              if (object.lang != null) message.lang = String(object.lang);
              if (object.apiID != null) if ($util.Long) (message.apiID = $util.Long.fromValue(object.apiID)).unsigned = false;else if (typeof object.apiID === "string") message.apiID = parseInt(object.apiID, 10);else if (typeof object.apiID === "number") message.apiID = object.apiID;else if (typeof object.apiID === "object") message.apiID = new $util.LongBits(object.apiID.low >>> 0, object.apiID.high >>> 0).toNumber();
              if (object.accountID != null) if ($util.Long) (message.accountID = $util.Long.fromValue(object.accountID)).unsigned = false;else if (typeof object.accountID === "string") message.accountID = parseInt(object.accountID, 10);else if (typeof object.accountID === "number") message.accountID = object.accountID;else if (typeof object.accountID === "object") message.accountID = new $util.LongBits(object.accountID.low >>> 0, object.accountID.high >>> 0).toNumber();
              if (object.subAgentCode != null) if ($util.Long) (message.subAgentCode = $util.Long.fromValue(object.subAgentCode)).unsigned = false;else if (typeof object.subAgentCode === "string") message.subAgentCode = parseInt(object.subAgentCode, 10);else if (typeof object.subAgentCode === "number") message.subAgentCode = object.subAgentCode;else if (typeof object.subAgentCode === "object") message.subAgentCode = new $util.LongBits(object.subAgentCode.low >>> 0, object.subAgentCode.high >>> 0).toNumber();
              return message;
            };
            /**
             * Creates a plain object from a getNoticeReq message. Also converts values to other types if specified.
             * @function toObject
             * @memberof snProto.getNoticeReq
             * @static
             * @param {snProto.getNoticeReq} message getNoticeReq
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */


            getNoticeReq.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                if ($util.Long) {
                  var _long = new $util.Long(0, 0, false);

                  object.gameID = options.longs === String ? _long.toString() : options.longs === Number ? _long.toNumber() : _long;
                } else object.gameID = options.longs === String ? "0" : 0;

                object.lang = "";

                if ($util.Long) {
                  var _long = new $util.Long(0, 0, false);

                  object.apiID = options.longs === String ? _long.toString() : options.longs === Number ? _long.toNumber() : _long;
                } else object.apiID = options.longs === String ? "0" : 0;

                if ($util.Long) {
                  var _long = new $util.Long(0, 0, false);

                  object.accountID = options.longs === String ? _long.toString() : options.longs === Number ? _long.toNumber() : _long;
                } else object.accountID = options.longs === String ? "0" : 0;

                if ($util.Long) {
                  var _long = new $util.Long(0, 0, false);

                  object.subAgentCode = options.longs === String ? _long.toString() : options.longs === Number ? _long.toNumber() : _long;
                } else object.subAgentCode = options.longs === String ? "0" : 0;
              }

              if (message.gameID != null && message.hasOwnProperty("gameID")) if (typeof message.gameID === "number") object.gameID = options.longs === String ? String(message.gameID) : message.gameID;else object.gameID = options.longs === String ? $util.Long.prototype.toString.call(message.gameID) : options.longs === Number ? new $util.LongBits(message.gameID.low >>> 0, message.gameID.high >>> 0).toNumber() : message.gameID;
              if (message.lang != null && message.hasOwnProperty("lang")) object.lang = message.lang;
              if (message.apiID != null && message.hasOwnProperty("apiID")) if (typeof message.apiID === "number") object.apiID = options.longs === String ? String(message.apiID) : message.apiID;else object.apiID = options.longs === String ? $util.Long.prototype.toString.call(message.apiID) : options.longs === Number ? new $util.LongBits(message.apiID.low >>> 0, message.apiID.high >>> 0).toNumber() : message.apiID;
              if (message.accountID != null && message.hasOwnProperty("accountID")) if (typeof message.accountID === "number") object.accountID = options.longs === String ? String(message.accountID) : message.accountID;else object.accountID = options.longs === String ? $util.Long.prototype.toString.call(message.accountID) : options.longs === Number ? new $util.LongBits(message.accountID.low >>> 0, message.accountID.high >>> 0).toNumber() : message.accountID;
              if (message.subAgentCode != null && message.hasOwnProperty("subAgentCode")) if (typeof message.subAgentCode === "number") object.subAgentCode = options.longs === String ? String(message.subAgentCode) : message.subAgentCode;else object.subAgentCode = options.longs === String ? $util.Long.prototype.toString.call(message.subAgentCode) : options.longs === Number ? new $util.LongBits(message.subAgentCode.low >>> 0, message.subAgentCode.high >>> 0).toNumber() : message.subAgentCode;
              return object;
            };
            /**
             * Converts this getNoticeReq to JSON.
             * @function toJSON
             * @memberof snProto.getNoticeReq
             * @instance
             * @returns {Object.<string,*>} JSON object
             */


            getNoticeReq.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
             * Gets the default type url for getNoticeReq
             * @function getTypeUrl
             * @memberof snProto.getNoticeReq
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */


            getNoticeReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/snProto.getNoticeReq";
            };

            return getNoticeReq;
          }();

          snProto.getNoticeResp = function () {
            /**
             * Properties of a getNoticeResp.
             * @memberof snProto
             * @interface IgetNoticeResp
             * @property {number|null} [error] getNoticeResp error
             * @property {Array.<snProto.InoticeInfo>|null} [list] getNoticeResp list
             */

            /**
             * Constructs a new getNoticeResp.
             * @memberof snProto
             * @classdesc Represents a getNoticeResp.
             * @implements IgetNoticeResp
             * @constructor
             * @param {snProto.IgetNoticeResp=} [properties] Properties to set
             */
            function getNoticeResp(properties) {
              this.list = [];
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * getNoticeResp error.
             * @member {number} error
             * @memberof snProto.getNoticeResp
             * @instance
             */


            getNoticeResp.prototype.error = 0;
            /**
             * getNoticeResp list.
             * @member {Array.<snProto.InoticeInfo>} list
             * @memberof snProto.getNoticeResp
             * @instance
             */

            getNoticeResp.prototype.list = $util.emptyArray;
            /**
             * Creates a new getNoticeResp instance using the specified properties.
             * @function create
             * @memberof snProto.getNoticeResp
             * @static
             * @param {snProto.IgetNoticeResp=} [properties] Properties to set
             * @returns {snProto.getNoticeResp} getNoticeResp instance
             */

            getNoticeResp.create = function create(properties) {
              return new getNoticeResp(properties);
            };
            /**
             * Encodes the specified getNoticeResp message. Does not implicitly {@link snProto.getNoticeResp.verify|verify} messages.
             * @function encode
             * @memberof snProto.getNoticeResp
             * @static
             * @param {snProto.IgetNoticeResp} message getNoticeResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            getNoticeResp.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.error != null && Object.hasOwnProperty.call(message, "error")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.error);
              if (message.list != null && message.list.length) for (var i = 0; i < message.list.length; ++i) {
                $root.snProto.noticeInfo.encode(message.list[i], writer.uint32(
                /* id 2, wireType 2 =*/
                18).fork()).ldelim();
              }
              return writer;
            };
            /**
             * Encodes the specified getNoticeResp message, length delimited. Does not implicitly {@link snProto.getNoticeResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof snProto.getNoticeResp
             * @static
             * @param {snProto.IgetNoticeResp} message getNoticeResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            getNoticeResp.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a getNoticeResp message from the specified reader or buffer.
             * @function decode
             * @memberof snProto.getNoticeResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {snProto.getNoticeResp} getNoticeResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            getNoticeResp.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.snProto.getNoticeResp();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      message.error = reader.int32();
                      break;
                    }

                  case 2:
                    {
                      if (!(message.list && message.list.length)) message.list = [];
                      message.list.push($root.snProto.noticeInfo.decode(reader, reader.uint32()));
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
             * Decodes a getNoticeResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof snProto.getNoticeResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {snProto.getNoticeResp} getNoticeResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            getNoticeResp.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a getNoticeResp message.
             * @function verify
             * @memberof snProto.getNoticeResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */


            getNoticeResp.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.error != null && message.hasOwnProperty("error")) if (!$util.isInteger(message.error)) return "error: integer expected";

              if (message.list != null && message.hasOwnProperty("list")) {
                if (!Array.isArray(message.list)) return "list: array expected";

                for (var i = 0; i < message.list.length; ++i) {
                  var error = $root.snProto.noticeInfo.verify(message.list[i]);
                  if (error) return "list." + error;
                }
              }

              return null;
            };
            /**
             * Creates a getNoticeResp message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof snProto.getNoticeResp
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {snProto.getNoticeResp} getNoticeResp
             */


            getNoticeResp.fromObject = function fromObject(object) {
              if (object instanceof $root.snProto.getNoticeResp) return object;
              var message = new $root.snProto.getNoticeResp();
              if (object.error != null) message.error = object.error | 0;

              if (object.list) {
                if (!Array.isArray(object.list)) throw TypeError(".snProto.getNoticeResp.list: array expected");
                message.list = [];

                for (var i = 0; i < object.list.length; ++i) {
                  if (typeof object.list[i] !== "object") throw TypeError(".snProto.getNoticeResp.list: object expected");
                  message.list[i] = $root.snProto.noticeInfo.fromObject(object.list[i]);
                }
              }

              return message;
            };
            /**
             * Creates a plain object from a getNoticeResp message. Also converts values to other types if specified.
             * @function toObject
             * @memberof snProto.getNoticeResp
             * @static
             * @param {snProto.getNoticeResp} message getNoticeResp
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */


            getNoticeResp.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};
              if (options.arrays || options.defaults) object.list = [];
              if (options.defaults) object.error = 0;
              if (message.error != null && message.hasOwnProperty("error")) object.error = message.error;

              if (message.list && message.list.length) {
                object.list = [];

                for (var j = 0; j < message.list.length; ++j) {
                  object.list[j] = $root.snProto.noticeInfo.toObject(message.list[j], options);
                }
              }

              return object;
            };
            /**
             * Converts this getNoticeResp to JSON.
             * @function toJSON
             * @memberof snProto.getNoticeResp
             * @instance
             * @returns {Object.<string,*>} JSON object
             */


            getNoticeResp.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
             * Gets the default type url for getNoticeResp
             * @function getTypeUrl
             * @memberof snProto.getNoticeResp
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */


            getNoticeResp.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/snProto.getNoticeResp";
            };

            return getNoticeResp;
          }();

          snProto.noticeInfo = function () {
            /**
             * Properties of a noticeInfo.
             * @memberof snProto
             * @interface InoticeInfo
             * @property {snProto.noticeType|null} [type] noticeInfo type
             * @property {string|null} [desc] noticeInfo desc
             * @property {number|Long|null} [game] noticeInfo game
             */

            /**
             * Constructs a new noticeInfo.
             * @memberof snProto
             * @classdesc Represents a noticeInfo.
             * @implements InoticeInfo
             * @constructor
             * @param {snProto.InoticeInfo=} [properties] Properties to set
             */
            function noticeInfo(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * noticeInfo type.
             * @member {snProto.noticeType} type
             * @memberof snProto.noticeInfo
             * @instance
             */


            noticeInfo.prototype.type = 0;
            /**
             * noticeInfo desc.
             * @member {string} desc
             * @memberof snProto.noticeInfo
             * @instance
             */

            noticeInfo.prototype.desc = "";
            /**
             * noticeInfo game.
             * @member {number|Long} game
             * @memberof snProto.noticeInfo
             * @instance
             */

            noticeInfo.prototype.game = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
             * Creates a new noticeInfo instance using the specified properties.
             * @function create
             * @memberof snProto.noticeInfo
             * @static
             * @param {snProto.InoticeInfo=} [properties] Properties to set
             * @returns {snProto.noticeInfo} noticeInfo instance
             */

            noticeInfo.create = function create(properties) {
              return new noticeInfo(properties);
            };
            /**
             * Encodes the specified noticeInfo message. Does not implicitly {@link snProto.noticeInfo.verify|verify} messages.
             * @function encode
             * @memberof snProto.noticeInfo
             * @static
             * @param {snProto.InoticeInfo} message noticeInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            noticeInfo.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.type != null && Object.hasOwnProperty.call(message, "type")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.type);
              if (message.desc != null && Object.hasOwnProperty.call(message, "desc")) writer.uint32(
              /* id 2, wireType 2 =*/
              18).string(message.desc);
              if (message.game != null && Object.hasOwnProperty.call(message, "game")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int64(message.game);
              return writer;
            };
            /**
             * Encodes the specified noticeInfo message, length delimited. Does not implicitly {@link snProto.noticeInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof snProto.noticeInfo
             * @static
             * @param {snProto.InoticeInfo} message noticeInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            noticeInfo.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a noticeInfo message from the specified reader or buffer.
             * @function decode
             * @memberof snProto.noticeInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {snProto.noticeInfo} noticeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            noticeInfo.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.snProto.noticeInfo();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      message.type = reader.int32();
                      break;
                    }

                  case 2:
                    {
                      message.desc = reader.string();
                      break;
                    }

                  case 3:
                    {
                      message.game = reader.int64();
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
             * Decodes a noticeInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof snProto.noticeInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {snProto.noticeInfo} noticeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            noticeInfo.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a noticeInfo message.
             * @function verify
             * @memberof snProto.noticeInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */


            noticeInfo.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.type != null && message.hasOwnProperty("type")) switch (message.type) {
                default:
                  return "type: enum value expected";

                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                  break;
              }
              if (message.desc != null && message.hasOwnProperty("desc")) if (!$util.isString(message.desc)) return "desc: string expected";
              if (message.game != null && message.hasOwnProperty("game")) if (!$util.isInteger(message.game) && !(message.game && $util.isInteger(message.game.low) && $util.isInteger(message.game.high))) return "game: integer|Long expected";
              return null;
            };
            /**
             * Creates a noticeInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof snProto.noticeInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {snProto.noticeInfo} noticeInfo
             */


            noticeInfo.fromObject = function fromObject(object) {
              if (object instanceof $root.snProto.noticeInfo) return object;
              var message = new $root.snProto.noticeInfo();

              switch (object.type) {
                default:
                  if (typeof object.type === "number") {
                    message.type = object.type;
                    break;
                  }

                  break;

                case "SignUp":
                case 0:
                  message.type = 0;
                  break;

                case "ItemNotUsed":
                case 1:
                  message.type = 1;
                  break;

                case "ItemTomorrow":
                case 2:
                  message.type = 2;
                  break;

                case "Message":
                case 3:
                  message.type = 3;
                  break;

                case "ToGame":
                case 4:
                  message.type = 4;
                  break;

                case "BuyGame":
                case 5:
                  message.type = 5;
                  break;

                case "JiliLv":
                case 6:
                  message.type = 6;
                  break;

                case "Mission":
                case 7:
                  message.type = 7;
                  break;

                case "SignIn":
                case 8:
                  message.type = 8;
                  break;

                case "SignInFull":
                case 9:
                  message.type = 9;
                  break;

                case "BuyBonus":
                case 10:
                  message.type = 10;
                  break;

                case "Debris":
                case 11:
                  message.type = 11;
                  break;

                case "Longhu":
                case 12:
                  message.type = 12;
                  break;
              }

              if (object.desc != null) message.desc = String(object.desc);
              if (object.game != null) if ($util.Long) (message.game = $util.Long.fromValue(object.game)).unsigned = false;else if (typeof object.game === "string") message.game = parseInt(object.game, 10);else if (typeof object.game === "number") message.game = object.game;else if (typeof object.game === "object") message.game = new $util.LongBits(object.game.low >>> 0, object.game.high >>> 0).toNumber();
              return message;
            };
            /**
             * Creates a plain object from a noticeInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof snProto.noticeInfo
             * @static
             * @param {snProto.noticeInfo} message noticeInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */


            noticeInfo.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.type = options.enums === String ? "SignUp" : 0;
                object.desc = "";

                if ($util.Long) {
                  var _long2 = new $util.Long(0, 0, false);

                  object.game = options.longs === String ? _long2.toString() : options.longs === Number ? _long2.toNumber() : _long2;
                } else object.game = options.longs === String ? "0" : 0;
              }

              if (message.type != null && message.hasOwnProperty("type")) object.type = options.enums === String ? $root.snProto.noticeType[message.type] === undefined ? message.type : $root.snProto.noticeType[message.type] : message.type;
              if (message.desc != null && message.hasOwnProperty("desc")) object.desc = message.desc;
              if (message.game != null && message.hasOwnProperty("game")) if (typeof message.game === "number") object.game = options.longs === String ? String(message.game) : message.game;else object.game = options.longs === String ? $util.Long.prototype.toString.call(message.game) : options.longs === Number ? new $util.LongBits(message.game.low >>> 0, message.game.high >>> 0).toNumber() : message.game;
              return object;
            };
            /**
             * Converts this noticeInfo to JSON.
             * @function toJSON
             * @memberof snProto.noticeInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */


            noticeInfo.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
             * Gets the default type url for noticeInfo
             * @function getTypeUrl
             * @memberof snProto.noticeInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */


            noticeInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/snProto.noticeInfo";
            };

            return noticeInfo;
          }();

          snProto.signNoticeReq = function () {
            /**
             * Properties of a signNoticeReq.
             * @memberof snProto
             * @interface IsignNoticeReq
             * @property {number|null} [accountID] signNoticeReq accountID
             * @property {number|null} [apiID] signNoticeReq apiID
             */

            /**
             * Constructs a new signNoticeReq.
             * @memberof snProto
             * @classdesc Represents a signNoticeReq.
             * @implements IsignNoticeReq
             * @constructor
             * @param {snProto.IsignNoticeReq=} [properties] Properties to set
             */
            function signNoticeReq(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * signNoticeReq accountID.
             * @member {number} accountID
             * @memberof snProto.signNoticeReq
             * @instance
             */


            signNoticeReq.prototype.accountID = 0;
            /**
             * signNoticeReq apiID.
             * @member {number} apiID
             * @memberof snProto.signNoticeReq
             * @instance
             */

            signNoticeReq.prototype.apiID = 0;
            /**
             * Creates a new signNoticeReq instance using the specified properties.
             * @function create
             * @memberof snProto.signNoticeReq
             * @static
             * @param {snProto.IsignNoticeReq=} [properties] Properties to set
             * @returns {snProto.signNoticeReq} signNoticeReq instance
             */

            signNoticeReq.create = function create(properties) {
              return new signNoticeReq(properties);
            };
            /**
             * Encodes the specified signNoticeReq message. Does not implicitly {@link snProto.signNoticeReq.verify|verify} messages.
             * @function encode
             * @memberof snProto.signNoticeReq
             * @static
             * @param {snProto.IsignNoticeReq} message signNoticeReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            signNoticeReq.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.accountID != null && Object.hasOwnProperty.call(message, "accountID")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.accountID);
              if (message.apiID != null && Object.hasOwnProperty.call(message, "apiID")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int32(message.apiID);
              return writer;
            };
            /**
             * Encodes the specified signNoticeReq message, length delimited. Does not implicitly {@link snProto.signNoticeReq.verify|verify} messages.
             * @function encodeDelimited
             * @memberof snProto.signNoticeReq
             * @static
             * @param {snProto.IsignNoticeReq} message signNoticeReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            signNoticeReq.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a signNoticeReq message from the specified reader or buffer.
             * @function decode
             * @memberof snProto.signNoticeReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {snProto.signNoticeReq} signNoticeReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            signNoticeReq.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.snProto.signNoticeReq();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      message.accountID = reader.int32();
                      break;
                    }

                  case 2:
                    {
                      message.apiID = reader.int32();
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
             * Decodes a signNoticeReq message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof snProto.signNoticeReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {snProto.signNoticeReq} signNoticeReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            signNoticeReq.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a signNoticeReq message.
             * @function verify
             * @memberof snProto.signNoticeReq
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */


            signNoticeReq.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.accountID != null && message.hasOwnProperty("accountID")) if (!$util.isInteger(message.accountID)) return "accountID: integer expected";
              if (message.apiID != null && message.hasOwnProperty("apiID")) if (!$util.isInteger(message.apiID)) return "apiID: integer expected";
              return null;
            };
            /**
             * Creates a signNoticeReq message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof snProto.signNoticeReq
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {snProto.signNoticeReq} signNoticeReq
             */


            signNoticeReq.fromObject = function fromObject(object) {
              if (object instanceof $root.snProto.signNoticeReq) return object;
              var message = new $root.snProto.signNoticeReq();
              if (object.accountID != null) message.accountID = object.accountID | 0;
              if (object.apiID != null) message.apiID = object.apiID | 0;
              return message;
            };
            /**
             * Creates a plain object from a signNoticeReq message. Also converts values to other types if specified.
             * @function toObject
             * @memberof snProto.signNoticeReq
             * @static
             * @param {snProto.signNoticeReq} message signNoticeReq
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */


            signNoticeReq.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.accountID = 0;
                object.apiID = 0;
              }

              if (message.accountID != null && message.hasOwnProperty("accountID")) object.accountID = message.accountID;
              if (message.apiID != null && message.hasOwnProperty("apiID")) object.apiID = message.apiID;
              return object;
            };
            /**
             * Converts this signNoticeReq to JSON.
             * @function toJSON
             * @memberof snProto.signNoticeReq
             * @instance
             * @returns {Object.<string,*>} JSON object
             */


            signNoticeReq.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
             * Gets the default type url for signNoticeReq
             * @function getTypeUrl
             * @memberof snProto.signNoticeReq
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */


            signNoticeReq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/snProto.signNoticeReq";
            };

            return signNoticeReq;
          }();

          snProto.lifeResp = function () {
            /**
             * Properties of a lifeResp.
             * @memberof snProto
             * @interface IlifeResp
             * @property {Object.<string,snProto.IgetNoticeResp>|null} [allResp] lifeResp allResp
             */

            /**
             * Constructs a new lifeResp.
             * @memberof snProto
             * @classdesc Represents a lifeResp.
             * @implements IlifeResp
             * @constructor
             * @param {snProto.IlifeResp=} [properties] Properties to set
             */
            function lifeResp(properties) {
              this.allResp = {};
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * lifeResp allResp.
             * @member {Object.<string,snProto.IgetNoticeResp>} allResp
             * @memberof snProto.lifeResp
             * @instance
             */


            lifeResp.prototype.allResp = $util.emptyObject;
            /**
             * Creates a new lifeResp instance using the specified properties.
             * @function create
             * @memberof snProto.lifeResp
             * @static
             * @param {snProto.IlifeResp=} [properties] Properties to set
             * @returns {snProto.lifeResp} lifeResp instance
             */

            lifeResp.create = function create(properties) {
              return new lifeResp(properties);
            };
            /**
             * Encodes the specified lifeResp message. Does not implicitly {@link snProto.lifeResp.verify|verify} messages.
             * @function encode
             * @memberof snProto.lifeResp
             * @static
             * @param {snProto.IlifeResp} message lifeResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            lifeResp.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.allResp != null && Object.hasOwnProperty.call(message, "allResp")) for (var keys = Object.keys(message.allResp), i = 0; i < keys.length; ++i) {
                writer.uint32(
                /* id 1, wireType 2 =*/
                10).fork().uint32(
                /* id 1, wireType 2 =*/
                10).string(keys[i]);
                $root.snProto.getNoticeResp.encode(message.allResp[keys[i]], writer.uint32(
                /* id 2, wireType 2 =*/
                18).fork()).ldelim().ldelim();
              }
              return writer;
            };
            /**
             * Encodes the specified lifeResp message, length delimited. Does not implicitly {@link snProto.lifeResp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof snProto.lifeResp
             * @static
             * @param {snProto.IlifeResp} message lifeResp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            lifeResp.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes a lifeResp message from the specified reader or buffer.
             * @function decode
             * @memberof snProto.lifeResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {snProto.lifeResp} lifeResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            lifeResp.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.snProto.lifeResp(),
                  key,
                  value;

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      if (message.allResp === $util.emptyObject) message.allResp = {};
                      var end2 = reader.uint32() + reader.pos;
                      key = "";
                      value = null;

                      while (reader.pos < end2) {
                        var tag2 = reader.uint32();

                        switch (tag2 >>> 3) {
                          case 1:
                            key = reader.string();
                            break;

                          case 2:
                            value = $root.snProto.getNoticeResp.decode(reader, reader.uint32());
                            break;

                          default:
                            reader.skipType(tag2 & 7);
                            break;
                        }
                      }

                      message.allResp[key] = value;
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
             * Decodes a lifeResp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof snProto.lifeResp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {snProto.lifeResp} lifeResp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            lifeResp.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies a lifeResp message.
             * @function verify
             * @memberof snProto.lifeResp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */


            lifeResp.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";

              if (message.allResp != null && message.hasOwnProperty("allResp")) {
                if (!$util.isObject(message.allResp)) return "allResp: object expected";
                var key = Object.keys(message.allResp);

                for (var i = 0; i < key.length; ++i) {
                  var error = $root.snProto.getNoticeResp.verify(message.allResp[key[i]]);
                  if (error) return "allResp." + error;
                }
              }

              return null;
            };
            /**
             * Creates a lifeResp message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof snProto.lifeResp
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {snProto.lifeResp} lifeResp
             */


            lifeResp.fromObject = function fromObject(object) {
              if (object instanceof $root.snProto.lifeResp) return object;
              var message = new $root.snProto.lifeResp();

              if (object.allResp) {
                if (typeof object.allResp !== "object") throw TypeError(".snProto.lifeResp.allResp: object expected");
                message.allResp = {};

                for (var keys = Object.keys(object.allResp), i = 0; i < keys.length; ++i) {
                  if (typeof object.allResp[keys[i]] !== "object") throw TypeError(".snProto.lifeResp.allResp: object expected");
                  message.allResp[keys[i]] = $root.snProto.getNoticeResp.fromObject(object.allResp[keys[i]]);
                }
              }

              return message;
            };
            /**
             * Creates a plain object from a lifeResp message. Also converts values to other types if specified.
             * @function toObject
             * @memberof snProto.lifeResp
             * @static
             * @param {snProto.lifeResp} message lifeResp
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */


            lifeResp.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};
              if (options.objects || options.defaults) object.allResp = {};
              var keys2;

              if (message.allResp && (keys2 = Object.keys(message.allResp)).length) {
                object.allResp = {};

                for (var j = 0; j < keys2.length; ++j) {
                  object.allResp[keys2[j]] = $root.snProto.getNoticeResp.toObject(message.allResp[keys2[j]], options);
                }
              }

              return object;
            };
            /**
             * Converts this lifeResp to JSON.
             * @function toJSON
             * @memberof snProto.lifeResp
             * @instance
             * @returns {Object.<string,*>} JSON object
             */


            lifeResp.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
             * Gets the default type url for lifeResp
             * @function getTypeUrl
             * @memberof snProto.lifeResp
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */


            lifeResp.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/snProto.lifeResp";
            };

            return lifeResp;
          }();
          /**
           * UpdateType enum.
           * @name snProto.UpdateType
           * @enum {number}
           * @property {number} None=0 None value
           * @property {number} Update=1 Update value
           * @property {number} Delete=2 Delete value
           */


          snProto.UpdateType = function () {
            var valuesById = {},
                values = Object.create(valuesById);
            values[valuesById[0] = "None"] = 0;
            values[valuesById[1] = "Update"] = 1;
            values[valuesById[2] = "Delete"] = 2;
            return values;
          }();

          snProto.UpdateGame = function () {
            /**
             * Properties of an UpdateGame.
             * @memberof snProto
             * @interface IUpdateGame
             * @property {number|null} [apiID] UpdateGame apiID
             * @property {number|null} [gameID] UpdateGame gameID
             * @property {number|null} [subAgentCode] UpdateGame subAgentCode
             * @property {snProto.UpdateType|null} [updateType] UpdateGame updateType
             */

            /**
             * Constructs a new UpdateGame.
             * @memberof snProto
             * @classdesc Represents an UpdateGame.
             * @implements IUpdateGame
             * @constructor
             * @param {snProto.IUpdateGame=} [properties] Properties to set
             */
            function UpdateGame(properties) {
              if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }
            }
            /**
             * UpdateGame apiID.
             * @member {number} apiID
             * @memberof snProto.UpdateGame
             * @instance
             */


            UpdateGame.prototype.apiID = 0;
            /**
             * UpdateGame gameID.
             * @member {number} gameID
             * @memberof snProto.UpdateGame
             * @instance
             */

            UpdateGame.prototype.gameID = 0;
            /**
             * UpdateGame subAgentCode.
             * @member {number} subAgentCode
             * @memberof snProto.UpdateGame
             * @instance
             */

            UpdateGame.prototype.subAgentCode = 0;
            /**
             * UpdateGame updateType.
             * @member {snProto.UpdateType} updateType
             * @memberof snProto.UpdateGame
             * @instance
             */

            UpdateGame.prototype.updateType = 0;
            /**
             * Creates a new UpdateGame instance using the specified properties.
             * @function create
             * @memberof snProto.UpdateGame
             * @static
             * @param {snProto.IUpdateGame=} [properties] Properties to set
             * @returns {snProto.UpdateGame} UpdateGame instance
             */

            UpdateGame.create = function create(properties) {
              return new UpdateGame(properties);
            };
            /**
             * Encodes the specified UpdateGame message. Does not implicitly {@link snProto.UpdateGame.verify|verify} messages.
             * @function encode
             * @memberof snProto.UpdateGame
             * @static
             * @param {snProto.IUpdateGame} message UpdateGame message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            UpdateGame.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.apiID != null && Object.hasOwnProperty.call(message, "apiID")) writer.uint32(
              /* id 1, wireType 0 =*/
              8).int32(message.apiID);
              if (message.gameID != null && Object.hasOwnProperty.call(message, "gameID")) writer.uint32(
              /* id 2, wireType 0 =*/
              16).int32(message.gameID);
              if (message.subAgentCode != null && Object.hasOwnProperty.call(message, "subAgentCode")) writer.uint32(
              /* id 3, wireType 0 =*/
              24).int32(message.subAgentCode);
              if (message.updateType != null && Object.hasOwnProperty.call(message, "updateType")) writer.uint32(
              /* id 4, wireType 0 =*/
              32).int32(message.updateType);
              return writer;
            };
            /**
             * Encodes the specified UpdateGame message, length delimited. Does not implicitly {@link snProto.UpdateGame.verify|verify} messages.
             * @function encodeDelimited
             * @memberof snProto.UpdateGame
             * @static
             * @param {snProto.IUpdateGame} message UpdateGame message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */


            UpdateGame.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            /**
             * Decodes an UpdateGame message from the specified reader or buffer.
             * @function decode
             * @memberof snProto.UpdateGame
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {snProto.UpdateGame} UpdateGame
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            UpdateGame.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.snProto.UpdateGame();

              while (reader.pos < end) {
                var tag = reader.uint32();

                switch (tag >>> 3) {
                  case 1:
                    {
                      message.apiID = reader.int32();
                      break;
                    }

                  case 2:
                    {
                      message.gameID = reader.int32();
                      break;
                    }

                  case 3:
                    {
                      message.subAgentCode = reader.int32();
                      break;
                    }

                  case 4:
                    {
                      message.updateType = reader.int32();
                      break;
                    }

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }

              return message;
            };
            /**
             * Decodes an UpdateGame message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof snProto.UpdateGame
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {snProto.UpdateGame} UpdateGame
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */


            UpdateGame.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            /**
             * Verifies an UpdateGame message.
             * @function verify
             * @memberof snProto.UpdateGame
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */


            UpdateGame.verify = function verify(message) {
              if (typeof message !== "object" || message === null) return "object expected";
              if (message.apiID != null && message.hasOwnProperty("apiID")) if (!$util.isInteger(message.apiID)) return "apiID: integer expected";
              if (message.gameID != null && message.hasOwnProperty("gameID")) if (!$util.isInteger(message.gameID)) return "gameID: integer expected";
              if (message.subAgentCode != null && message.hasOwnProperty("subAgentCode")) if (!$util.isInteger(message.subAgentCode)) return "subAgentCode: integer expected";
              if (message.updateType != null && message.hasOwnProperty("updateType")) switch (message.updateType) {
                default:
                  return "updateType: enum value expected";

                case 0:
                case 1:
                case 2:
                  break;
              }
              return null;
            };
            /**
             * Creates an UpdateGame message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof snProto.UpdateGame
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {snProto.UpdateGame} UpdateGame
             */


            UpdateGame.fromObject = function fromObject(object) {
              if (object instanceof $root.snProto.UpdateGame) return object;
              var message = new $root.snProto.UpdateGame();
              if (object.apiID != null) message.apiID = object.apiID | 0;
              if (object.gameID != null) message.gameID = object.gameID | 0;
              if (object.subAgentCode != null) message.subAgentCode = object.subAgentCode | 0;

              switch (object.updateType) {
                default:
                  if (typeof object.updateType === "number") {
                    message.updateType = object.updateType;
                    break;
                  }

                  break;

                case "None":
                case 0:
                  message.updateType = 0;
                  break;

                case "Update":
                case 1:
                  message.updateType = 1;
                  break;

                case "Delete":
                case 2:
                  message.updateType = 2;
                  break;
              }

              return message;
            };
            /**
             * Creates a plain object from an UpdateGame message. Also converts values to other types if specified.
             * @function toObject
             * @memberof snProto.UpdateGame
             * @static
             * @param {snProto.UpdateGame} message UpdateGame
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */


            UpdateGame.toObject = function toObject(message, options) {
              if (!options) options = {};
              var object = {};

              if (options.defaults) {
                object.apiID = 0;
                object.gameID = 0;
                object.subAgentCode = 0;
                object.updateType = options.enums === String ? "None" : 0;
              }

              if (message.apiID != null && message.hasOwnProperty("apiID")) object.apiID = message.apiID;
              if (message.gameID != null && message.hasOwnProperty("gameID")) object.gameID = message.gameID;
              if (message.subAgentCode != null && message.hasOwnProperty("subAgentCode")) object.subAgentCode = message.subAgentCode;
              if (message.updateType != null && message.hasOwnProperty("updateType")) object.updateType = options.enums === String ? $root.snProto.UpdateType[message.updateType] === undefined ? message.updateType : $root.snProto.UpdateType[message.updateType] : message.updateType;
              return object;
            };
            /**
             * Converts this UpdateGame to JSON.
             * @function toJSON
             * @memberof snProto.UpdateGame
             * @instance
             * @returns {Object.<string,*>} JSON object
             */


            UpdateGame.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            /**
             * Gets the default type url for UpdateGame
             * @function getTypeUrl
             * @memberof snProto.UpdateGame
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */


            UpdateGame.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }

              return typeUrlPrefix + "/snProto.UpdateGame";
            };

            return UpdateGame;
          }();

          return snProto;
        }();

        module.exports = $root; // #endregion ORIGINAL CODE

        _cjsExports = exports('default', module.exports);
      }, function () {
        return {
          'protobufjs/minimal': __cjsMetaURL$1
        };
      });
    }
  };
});

System.register("chunks:///_virtual/smartNotice.mjs_cjs=&original=.js", ['./smartNotice.js', './cjs-loader.mjs'], function (exports, module) {
  'use strict';

  var __cjsMetaURL, loader;

  return {
    setters: [function (module) {
      __cjsMetaURL = module.__cjsMetaURL;
      var _setter = {};
      _setter.__cjsMetaURL = module.__cjsMetaURL;
      _setter.default = module.default;
      exports(_setter);
    }, function (module) {
      loader = module.default;
    }],
    execute: function () {
      // I am the facade module who provides access to the CommonJS module './smartNotice.js'~
      if (!__cjsMetaURL) {
        loader.throwInvalidWrapper('./smartNotice.js', module.meta.url);
      }

      loader.require(__cjsMetaURL);
    }
  };
});

System.register("chunks:///_virtual/tokenize.js", ['./cjs-loader.mjs'], function (exports, module) {
  'use strict';

  var loader;
  return {
    setters: [function (module) {
      loader = module.default;
    }],
    execute: function () {
      var __cjsMetaURL = exports('__cjsMetaURL', module.meta.url);

      loader.define(__cjsMetaURL, function (exports, require, module, __filename, __dirname) {
        module.exports = tokenize;
        var delimRe = /[\s{}=;:[\],'"()<>]/g,
            stringDoubleRe = /(?:"([^"\\]*(?:\\.[^"\\]*)*)")/g,
            stringSingleRe = /(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g;
        var setCommentRe = /^ *[*/]+ */,
            setCommentAltRe = /^\s*\*?\/*/,
            setCommentSplitRe = /\n/g,
            whitespaceRe = /\s/,
            unescapeRe = /\\(.?)/g;
        var unescapeMap = {
          "0": "\0",
          "r": "\r",
          "n": "\n",
          "t": "\t"
        };
        /**
         * Unescapes a string.
         * @param {string} str String to unescape
         * @returns {string} Unescaped string
         * @property {Object.<string,string>} map Special characters map
         * @memberof tokenize
         */

        function unescape(str) {
          return str.replace(unescapeRe, function ($0, $1) {
            switch ($1) {
              case "\\":
              case "":
                return $1;

              default:
                return unescapeMap[$1] || "";
            }
          });
        }

        tokenize.unescape = unescape;
        /**
         * Gets the next token and advances.
         * @typedef TokenizerHandleNext
         * @type {function}
         * @returns {string|null} Next token or `null` on eof
         */

        /**
         * Peeks for the next token.
         * @typedef TokenizerHandlePeek
         * @type {function}
         * @returns {string|null} Next token or `null` on eof
         */

        /**
         * Pushes a token back to the stack.
         * @typedef TokenizerHandlePush
         * @type {function}
         * @param {string} token Token
         * @returns {undefined}
         */

        /**
         * Skips the next token.
         * @typedef TokenizerHandleSkip
         * @type {function}
         * @param {string} expected Expected token
         * @param {boolean} [optional=false] If optional
         * @returns {boolean} Whether the token matched
         * @throws {Error} If the token didn't match and is not optional
         */

        /**
         * Gets the comment on the previous line or, alternatively, the line comment on the specified line.
         * @typedef TokenizerHandleCmnt
         * @type {function}
         * @param {number} [line] Line number
         * @returns {string|null} Comment text or `null` if none
         */

        /**
         * Handle object returned from {@link tokenize}.
         * @interface ITokenizerHandle
         * @property {TokenizerHandleNext} next Gets the next token and advances (`null` on eof)
         * @property {TokenizerHandlePeek} peek Peeks for the next token (`null` on eof)
         * @property {TokenizerHandlePush} push Pushes a token back to the stack
         * @property {TokenizerHandleSkip} skip Skips a token, returns its presence and advances or, if non-optional and not present, throws
         * @property {TokenizerHandleCmnt} cmnt Gets the comment on the previous line or the line comment on the specified line, if any
         * @property {number} line Current line number
         */

        /**
         * Tokenizes the given .proto source and returns an object with useful utility functions.
         * @param {string} source Source contents
         * @param {boolean} alternateCommentMode Whether we should activate alternate comment parsing mode.
         * @returns {ITokenizerHandle} Tokenizer handle
         */

        function tokenize(source, alternateCommentMode) {
          /* eslint-disable callback-return */
          source = source.toString();
          var offset = 0,
              length = source.length,
              line = 1,
              commentType = null,
              commentText = null,
              commentLine = 0,
              commentLineEmpty = false,
              commentIsLeading = false;
          var stack = [];
          var stringDelim = null;
          /* istanbul ignore next */

          /**
           * Creates an error for illegal syntax.
           * @param {string} subject Subject
           * @returns {Error} Error created
           * @inner
           */

          function illegal(subject) {
            return Error("illegal " + subject + " (line " + line + ")");
          }
          /**
           * Reads a string till its end.
           * @returns {string} String read
           * @inner
           */


          function readString() {
            var re = stringDelim === "'" ? stringSingleRe : stringDoubleRe;
            re.lastIndex = offset - 1;
            var match = re.exec(source);
            if (!match) throw illegal("string");
            offset = re.lastIndex;
            push(stringDelim);
            stringDelim = null;
            return unescape(match[1]);
          }
          /**
           * Gets the character at `pos` within the source.
           * @param {number} pos Position
           * @returns {string} Character
           * @inner
           */


          function charAt(pos) {
            return source.charAt(pos);
          }
          /**
           * Sets the current comment text.
           * @param {number} start Start offset
           * @param {number} end End offset
           * @param {boolean} isLeading set if a leading comment
           * @returns {undefined}
           * @inner
           */


          function setComment(start, end, isLeading) {
            commentType = source.charAt(start++);
            commentLine = line;
            commentLineEmpty = false;
            commentIsLeading = isLeading;
            var lookback;

            if (alternateCommentMode) {
              lookback = 2; // alternate comment parsing: "//" or "/*"
            } else {
              lookback = 3; // "///" or "/**"
            }

            var commentOffset = start - lookback,
                c;

            do {
              if (--commentOffset < 0 || (c = source.charAt(commentOffset)) === "\n") {
                commentLineEmpty = true;
                break;
              }
            } while (c === " " || c === "\t");

            var lines = source.substring(start, end).split(setCommentSplitRe);

            for (var i = 0; i < lines.length; ++i) {
              lines[i] = lines[i].replace(alternateCommentMode ? setCommentAltRe : setCommentRe, "").trim();
            }

            commentText = lines.join("\n").trim();
          }

          function isDoubleSlashCommentLine(startOffset) {
            var endOffset = findEndOfLine(startOffset); // see if remaining line matches comment pattern

            var lineText = source.substring(startOffset, endOffset); // look for 1 or 2 slashes since startOffset would already point past
            // the first slash that started the comment.

            var isComment = /^\s*\/{1,2}/.test(lineText);
            return isComment;
          }

          function findEndOfLine(cursor) {
            // find end of cursor's line
            var endOffset = cursor;

            while (endOffset < length && charAt(endOffset) !== "\n") {
              endOffset++;
            }

            return endOffset;
          }
          /**
           * Obtains the next token.
           * @returns {string|null} Next token or `null` on eof
           * @inner
           */


          function next() {
            if (stack.length > 0) return stack.shift();
            if (stringDelim) return readString();
            var repeat,
                prev,
                curr,
                start,
                isDoc,
                isLeadingComment = offset === 0;

            do {
              if (offset === length) return null;
              repeat = false;

              while (whitespaceRe.test(curr = charAt(offset))) {
                if (curr === "\n") {
                  isLeadingComment = true;
                  ++line;
                }

                if (++offset === length) return null;
              }

              if (charAt(offset) === "/") {
                if (++offset === length) {
                  throw illegal("comment");
                }

                if (charAt(offset) === "/") {
                  // Line
                  if (!alternateCommentMode) {
                    // check for triple-slash comment
                    isDoc = charAt(start = offset + 1) === "/";

                    while (charAt(++offset) !== "\n") {
                      if (offset === length) {
                        return null;
                      }
                    }

                    ++offset;

                    if (isDoc) {
                      setComment(start, offset - 1, isLeadingComment);
                    }

                    ++line;
                    repeat = true;
                  } else {
                    // check for double-slash comments, consolidating consecutive lines
                    start = offset;
                    isDoc = false;

                    if (isDoubleSlashCommentLine(offset)) {
                      isDoc = true;

                      do {
                        offset = findEndOfLine(offset);

                        if (offset === length) {
                          break;
                        }

                        offset++;
                      } while (isDoubleSlashCommentLine(offset));
                    } else {
                      offset = Math.min(length, findEndOfLine(offset) + 1);
                    }

                    if (isDoc) {
                      setComment(start, offset, isLeadingComment);
                    }

                    line++;
                    repeat = true;
                  }
                } else if ((curr = charAt(offset)) === "*") {
                  /* Block */
                  // check for /** (regular comment mode) or /* (alternate comment mode)
                  start = offset + 1;
                  isDoc = alternateCommentMode || charAt(start) === "*";

                  do {
                    if (curr === "\n") {
                      ++line;
                    }

                    if (++offset === length) {
                      throw illegal("comment");
                    }

                    prev = curr;
                    curr = charAt(offset);
                  } while (prev !== "*" || curr !== "/");

                  ++offset;

                  if (isDoc) {
                    setComment(start, offset - 2, isLeadingComment);
                  }

                  repeat = true;
                } else {
                  return "/";
                }
              }
            } while (repeat); // offset !== length if we got here


            var end = offset;
            delimRe.lastIndex = 0;
            var delim = delimRe.test(charAt(end++));
            if (!delim) while (end < length && !delimRe.test(charAt(end))) {
              ++end;
            }
            var token = source.substring(offset, offset = end);
            if (token === "\"" || token === "'") stringDelim = token;
            return token;
          }
          /**
           * Pushes a token back to the stack.
           * @param {string} token Token
           * @returns {undefined}
           * @inner
           */


          function push(token) {
            stack.push(token);
          }
          /**
           * Peeks for the next token.
           * @returns {string|null} Token or `null` on eof
           * @inner
           */


          function peek() {
            if (!stack.length) {
              var token = next();
              if (token === null) return null;
              push(token);
            }

            return stack[0];
          }
          /**
           * Skips a token.
           * @param {string} expected Expected token
           * @param {boolean} [optional=false] Whether the token is optional
           * @returns {boolean} `true` when skipped, `false` if not
           * @throws {Error} When a required token is not present
           * @inner
           */


          function skip(expected, optional) {
            var actual = peek(),
                equals = actual === expected;

            if (equals) {
              next();
              return true;
            }

            if (!optional) throw illegal("token '" + actual + "', '" + expected + "' expected");
            return false;
          }
          /**
           * Gets a comment.
           * @param {number} [trailingLine] Line number if looking for a trailing comment
           * @returns {string|null} Comment text
           * @inner
           */


          function cmnt(trailingLine) {
            var ret = null;

            if (trailingLine === undefined) {
              if (commentLine === line - 1 && (alternateCommentMode || commentType === "*" || commentLineEmpty)) {
                ret = commentIsLeading ? commentText : null;
              }
            } else {
              /* istanbul ignore else */
              if (commentLine < trailingLine) {
                peek();
              }

              if (commentLine === trailingLine && !commentLineEmpty && (alternateCommentMode || commentType === "/")) {
                ret = commentIsLeading ? null : commentText;
              }
            }

            return ret;
          }

          return Object.defineProperty({
            next: next,
            peek: peek,
            push: push,
            skip: skip,
            cmnt: cmnt
          }, "line", {
            get: function get() {
              return line;
            }
          });
          /* eslint-enable callback-return */
        } // #endregion ORIGINAL CODE


        module.exports;
      }, {});
    }
  };
});

System.register("chunks:///_virtual/type.js", ['./cjs-loader.mjs', './namespace.js', './enum.js', './oneof.js', './field.js', './mapfield.js', './service.js', './message.js', './reader.js', './writer.js', './util.js', './encoder.js', './decoder.js', './verifier.js', './converter.js', './wrappers.js'], function (exports, module) {
  'use strict';

  var loader, __cjsMetaURL$1, __cjsMetaURL$2, __cjsMetaURL$3, __cjsMetaURL$4, __cjsMetaURL$5, __cjsMetaURL$6, __cjsMetaURL$7, __cjsMetaURL$8, __cjsMetaURL$9, __cjsMetaURL$a, __cjsMetaURL$b, __cjsMetaURL$c, __cjsMetaURL$d, __cjsMetaURL$e, __cjsMetaURL$f;

  return {
    setters: [function (module) {
      loader = module.default;
    }, function (module) {
      __cjsMetaURL$1 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$2 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$3 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$4 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$5 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$6 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$7 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$8 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$9 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$a = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$b = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$c = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$d = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$e = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$f = module.__cjsMetaURL;
    }],
    execute: function () {
      var __cjsMetaURL = exports('__cjsMetaURL', module.meta.url);

      loader.define(__cjsMetaURL, function (exports, require, module, __filename, __dirname) {
        module.exports = Type; // extends Namespace

        var Namespace = require("./namespace");

        ((Type.prototype = Object.create(Namespace.prototype)).constructor = Type).className = "Type";

        var Enum = require("./enum"),
            OneOf = require("./oneof"),
            Field = require("./field"),
            MapField = require("./mapfield"),
            Service = require("./service"),
            Message = require("./message"),
            Reader = require("./reader"),
            Writer = require("./writer"),
            util = require("./util"),
            encoder = require("./encoder"),
            decoder = require("./decoder"),
            verifier = require("./verifier"),
            converter = require("./converter"),
            wrappers = require("./wrappers");
        /**
         * Constructs a new reflected message type instance.
         * @classdesc Reflected message type.
         * @extends NamespaceBase
         * @constructor
         * @param {string} name Message name
         * @param {Object.<string,*>} [options] Declared options
         */


        function Type(name, options) {
          Namespace.call(this, name, options);
          /**
           * Message fields.
           * @type {Object.<string,Field>}
           */

          this.fields = {}; // toJSON, marker

          /**
           * Oneofs declared within this namespace, if any.
           * @type {Object.<string,OneOf>}
           */

          this.oneofs = undefined; // toJSON

          /**
           * Extension ranges, if any.
           * @type {number[][]}
           */

          this.extensions = undefined; // toJSON

          /**
           * Reserved ranges, if any.
           * @type {Array.<number[]|string>}
           */

          this.reserved = undefined; // toJSON

          /*?
           * Whether this type is a legacy group.
           * @type {boolean|undefined}
           */

          this.group = undefined; // toJSON

          /**
           * Cached fields by id.
           * @type {Object.<number,Field>|null}
           * @private
           */

          this._fieldsById = null;
          /**
           * Cached fields as an array.
           * @type {Field[]|null}
           * @private
           */

          this._fieldsArray = null;
          /**
           * Cached oneofs as an array.
           * @type {OneOf[]|null}
           * @private
           */

          this._oneofsArray = null;
          /**
           * Cached constructor.
           * @type {Constructor<{}>}
           * @private
           */

          this._ctor = null;
        }

        Object.defineProperties(Type.prototype, {
          /**
           * Message fields by id.
           * @name Type#fieldsById
           * @type {Object.<number,Field>}
           * @readonly
           */
          fieldsById: {
            get: function get() {
              /* istanbul ignore if */
              if (this._fieldsById) return this._fieldsById;
              this._fieldsById = {};

              for (var names = Object.keys(this.fields), i = 0; i < names.length; ++i) {
                var field = this.fields[names[i]],
                    id = field.id;
                /* istanbul ignore if */

                if (this._fieldsById[id]) throw Error("duplicate id " + id + " in " + this);
                this._fieldsById[id] = field;
              }

              return this._fieldsById;
            }
          },

          /**
           * Fields of this message as an array for iteration.
           * @name Type#fieldsArray
           * @type {Field[]}
           * @readonly
           */
          fieldsArray: {
            get: function get() {
              return this._fieldsArray || (this._fieldsArray = util.toArray(this.fields));
            }
          },

          /**
           * Oneofs of this message as an array for iteration.
           * @name Type#oneofsArray
           * @type {OneOf[]}
           * @readonly
           */
          oneofsArray: {
            get: function get() {
              return this._oneofsArray || (this._oneofsArray = util.toArray(this.oneofs));
            }
          },

          /**
           * The registered constructor, if any registered, otherwise a generic constructor.
           * Assigning a function replaces the internal constructor. If the function does not extend {@link Message} yet, its prototype will be setup accordingly and static methods will be populated. If it already extends {@link Message}, it will just replace the internal constructor.
           * @name Type#ctor
           * @type {Constructor<{}>}
           */
          ctor: {
            get: function get() {
              return this._ctor || (this.ctor = Type.generateConstructor(this)());
            },
            set: function set(ctor) {
              // Ensure proper prototype
              var prototype = ctor.prototype;

              if (!(prototype instanceof Message)) {
                (ctor.prototype = new Message()).constructor = ctor;
                util.merge(ctor.prototype, prototype);
              } // Classes and messages reference their reflected type


              ctor.$type = ctor.prototype.$type = this; // Mix in static methods

              util.merge(ctor, Message, true);
              this._ctor = ctor; // Messages have non-enumerable default values on their prototype

              var i = 0;

              for (; i <
              /* initializes */
              this.fieldsArray.length; ++i) {
                this._fieldsArray[i].resolve();
              } // ensures a proper value
              // Messages have non-enumerable getters and setters for each virtual oneof field


              var ctorProperties = {};

              for (i = 0; i <
              /* initializes */
              this.oneofsArray.length; ++i) {
                ctorProperties[this._oneofsArray[i].resolve().name] = {
                  get: util.oneOfGetter(this._oneofsArray[i].oneof),
                  set: util.oneOfSetter(this._oneofsArray[i].oneof)
                };
              }

              if (i) Object.defineProperties(ctor.prototype, ctorProperties);
            }
          }
        });
        /**
         * Generates a constructor function for the specified type.
         * @param {Type} mtype Message type
         * @returns {Codegen} Codegen instance
         */

        Type.generateConstructor = function generateConstructor(mtype) {
          /* eslint-disable no-unexpected-multiline */
          var gen = util.codegen(["p"], mtype.name); // explicitly initialize mutable object/array fields so that these aren't just inherited from the prototype

          for (var i = 0, field; i < mtype.fieldsArray.length; ++i) {
            if ((field = mtype._fieldsArray[i]).map) gen("this%s={}", util.safeProp(field.name));else if (field.repeated) gen("this%s=[]", util.safeProp(field.name));
          }

          return gen("if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)") // omit undefined or null
          ("this[ks[i]]=p[ks[i]]");
          /* eslint-enable no-unexpected-multiline */
        };

        function clearCache(type) {
          type._fieldsById = type._fieldsArray = type._oneofsArray = null;
          delete type.encode;
          delete type.decode;
          delete type.verify;
          return type;
        }
        /**
         * Message type descriptor.
         * @interface IType
         * @extends INamespace
         * @property {Object.<string,IOneOf>} [oneofs] Oneof descriptors
         * @property {Object.<string,IField>} fields Field descriptors
         * @property {number[][]} [extensions] Extension ranges
         * @property {number[][]} [reserved] Reserved ranges
         * @property {boolean} [group=false] Whether a legacy group or not
         */

        /**
         * Creates a message type from a message type descriptor.
         * @param {string} name Message name
         * @param {IType} json Message type descriptor
         * @returns {Type} Created message type
         */


        Type.fromJSON = function fromJSON(name, json) {
          var type = new Type(name, json.options);
          type.extensions = json.extensions;
          type.reserved = json.reserved;
          var names = Object.keys(json.fields),
              i = 0;

          for (; i < names.length; ++i) {
            type.add((typeof json.fields[names[i]].keyType !== "undefined" ? MapField.fromJSON : Field.fromJSON)(names[i], json.fields[names[i]]));
          }

          if (json.oneofs) for (names = Object.keys(json.oneofs), i = 0; i < names.length; ++i) {
            type.add(OneOf.fromJSON(names[i], json.oneofs[names[i]]));
          }
          if (json.nested) for (names = Object.keys(json.nested), i = 0; i < names.length; ++i) {
            var nested = json.nested[names[i]];
            type.add( // most to least likely
            (nested.id !== undefined ? Field.fromJSON : nested.fields !== undefined ? Type.fromJSON : nested.values !== undefined ? Enum.fromJSON : nested.methods !== undefined ? Service.fromJSON : Namespace.fromJSON)(names[i], nested));
          }
          if (json.extensions && json.extensions.length) type.extensions = json.extensions;
          if (json.reserved && json.reserved.length) type.reserved = json.reserved;
          if (json.group) type.group = true;
          if (json.comment) type.comment = json.comment;
          return type;
        };
        /**
         * Converts this message type to a message type descriptor.
         * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
         * @returns {IType} Message type descriptor
         */


        Type.prototype.toJSON = function toJSON(toJSONOptions) {
          var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);
          var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
          return util.toObject(["options", inherited && inherited.options || undefined, "oneofs", Namespace.arrayToJSON(this.oneofsArray, toJSONOptions), "fields", Namespace.arrayToJSON(this.fieldsArray.filter(function (obj) {
            return !obj.declaringField;
          }), toJSONOptions) || {}, "extensions", this.extensions && this.extensions.length ? this.extensions : undefined, "reserved", this.reserved && this.reserved.length ? this.reserved : undefined, "group", this.group || undefined, "nested", inherited && inherited.nested || undefined, "comment", keepComments ? this.comment : undefined]);
        };
        /**
         * @override
         */


        Type.prototype.resolveAll = function resolveAll() {
          var fields = this.fieldsArray,
              i = 0;

          while (i < fields.length) {
            fields[i++].resolve();
          }

          var oneofs = this.oneofsArray;
          i = 0;

          while (i < oneofs.length) {
            oneofs[i++].resolve();
          }

          return Namespace.prototype.resolveAll.call(this);
        };
        /**
         * @override
         */


        Type.prototype.get = function get(name) {
          return this.fields[name] || this.oneofs && this.oneofs[name] || this.nested && this.nested[name] || null;
        };
        /**
         * Adds a nested object to this type.
         * @param {ReflectionObject} object Nested object to add
         * @returns {Type} `this`
         * @throws {TypeError} If arguments are invalid
         * @throws {Error} If there is already a nested object with this name or, if a field, when there is already a field with this id
         */


        Type.prototype.add = function add(object) {
          if (this.get(object.name)) throw Error("duplicate name '" + object.name + "' in " + this);

          if (object instanceof Field && object.extend === undefined) {
            // NOTE: Extension fields aren't actual fields on the declaring type, but nested objects.
            // The root object takes care of adding distinct sister-fields to the respective extended
            // type instead.
            // avoids calling the getter if not absolutely necessary because it's called quite frequently
            if (this._fieldsById ?
            /* istanbul ignore next */
            this._fieldsById[object.id] : this.fieldsById[object.id]) throw Error("duplicate id " + object.id + " in " + this);
            if (this.isReservedId(object.id)) throw Error("id " + object.id + " is reserved in " + this);
            if (this.isReservedName(object.name)) throw Error("name '" + object.name + "' is reserved in " + this);
            if (object.parent) object.parent.remove(object);
            this.fields[object.name] = object;
            object.message = this;
            object.onAdd(this);
            return clearCache(this);
          }

          if (object instanceof OneOf) {
            if (!this.oneofs) this.oneofs = {};
            this.oneofs[object.name] = object;
            object.onAdd(this);
            return clearCache(this);
          }

          return Namespace.prototype.add.call(this, object);
        };
        /**
         * Removes a nested object from this type.
         * @param {ReflectionObject} object Nested object to remove
         * @returns {Type} `this`
         * @throws {TypeError} If arguments are invalid
         * @throws {Error} If `object` is not a member of this type
         */


        Type.prototype.remove = function remove(object) {
          if (object instanceof Field && object.extend === undefined) {
            // See Type#add for the reason why extension fields are excluded here.

            /* istanbul ignore if */
            if (!this.fields || this.fields[object.name] !== object) throw Error(object + " is not a member of " + this);
            delete this.fields[object.name];
            object.parent = null;
            object.onRemove(this);
            return clearCache(this);
          }

          if (object instanceof OneOf) {
            /* istanbul ignore if */
            if (!this.oneofs || this.oneofs[object.name] !== object) throw Error(object + " is not a member of " + this);
            delete this.oneofs[object.name];
            object.parent = null;
            object.onRemove(this);
            return clearCache(this);
          }

          return Namespace.prototype.remove.call(this, object);
        };
        /**
         * Tests if the specified id is reserved.
         * @param {number} id Id to test
         * @returns {boolean} `true` if reserved, otherwise `false`
         */


        Type.prototype.isReservedId = function isReservedId(id) {
          return Namespace.isReservedId(this.reserved, id);
        };
        /**
         * Tests if the specified name is reserved.
         * @param {string} name Name to test
         * @returns {boolean} `true` if reserved, otherwise `false`
         */


        Type.prototype.isReservedName = function isReservedName(name) {
          return Namespace.isReservedName(this.reserved, name);
        };
        /**
         * Creates a new message of this type using the specified properties.
         * @param {Object.<string,*>} [properties] Properties to set
         * @returns {Message<{}>} Message instance
         */


        Type.prototype.create = function create(properties) {
          return new this.ctor(properties);
        };
        /**
         * Sets up {@link Type#encode|encode}, {@link Type#decode|decode} and {@link Type#verify|verify}.
         * @returns {Type} `this`
         */


        Type.prototype.setup = function setup() {
          // Sets up everything at once so that the prototype chain does not have to be re-evaluated
          // multiple times (V8, soft-deopt prototype-check).
          var fullName = this.fullName,
              types = [];

          for (var i = 0; i <
          /* initializes */
          this.fieldsArray.length; ++i) {
            types.push(this._fieldsArray[i].resolve().resolvedType);
          } // Replace setup methods with type-specific generated functions


          this.encode = encoder(this)({
            Writer: Writer,
            types: types,
            util: util
          });
          this.decode = decoder(this)({
            Reader: Reader,
            types: types,
            util: util
          });
          this.verify = verifier(this)({
            types: types,
            util: util
          });
          this.fromObject = converter.fromObject(this)({
            types: types,
            util: util
          });
          this.toObject = converter.toObject(this)({
            types: types,
            util: util
          }); // Inject custom wrappers for common types

          var wrapper = wrappers[fullName];

          if (wrapper) {
            var originalThis = Object.create(this); // if (wrapper.fromObject) {

            originalThis.fromObject = this.fromObject;
            this.fromObject = wrapper.fromObject.bind(originalThis); // }
            // if (wrapper.toObject) {

            originalThis.toObject = this.toObject;
            this.toObject = wrapper.toObject.bind(originalThis); // }
          }

          return this;
        };
        /**
         * Encodes a message of this type. Does not implicitly {@link Type#verify|verify} messages.
         * @param {Message<{}>|Object.<string,*>} message Message instance or plain object
         * @param {Writer} [writer] Writer to encode to
         * @returns {Writer} writer
         */


        Type.prototype.encode = function encode_setup(message, writer) {
          return this.setup().encode(message, writer); // overrides this method
        };
        /**
         * Encodes a message of this type preceeded by its byte length as a varint. Does not implicitly {@link Type#verify|verify} messages.
         * @param {Message<{}>|Object.<string,*>} message Message instance or plain object
         * @param {Writer} [writer] Writer to encode to
         * @returns {Writer} writer
         */


        Type.prototype.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();
        };
        /**
         * Decodes a message of this type.
         * @param {Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Length of the message, if known beforehand
         * @returns {Message<{}>} Decoded message
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {util.ProtocolError<{}>} If required fields are missing
         */


        Type.prototype.decode = function decode_setup(reader, length) {
          return this.setup().decode(reader, length); // overrides this method
        };
        /**
         * Decodes a message of this type preceeded by its byte length as a varint.
         * @param {Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Message<{}>} Decoded message
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {util.ProtocolError} If required fields are missing
         */


        Type.prototype.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof Reader)) reader = Reader.create(reader);
          return this.decode(reader, reader.uint32());
        };
        /**
         * Verifies that field values are valid and that required fields are present.
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {null|string} `null` if valid, otherwise the reason why it is not
         */


        Type.prototype.verify = function verify_setup(message) {
          return this.setup().verify(message); // overrides this method
        };
        /**
         * Creates a new message of this type from a plain object. Also converts values to their respective internal types.
         * @param {Object.<string,*>} object Plain object to convert
         * @returns {Message<{}>} Message instance
         */


        Type.prototype.fromObject = function fromObject(object) {
          return this.setup().fromObject(object);
        };
        /**
         * Conversion options as used by {@link Type#toObject} and {@link Message.toObject}.
         * @interface IConversionOptions
         * @property {Function} [longs] Long conversion type.
         * Valid values are `String` and `Number` (the global types).
         * Defaults to copy the present value, which is a possibly unsafe number without and a {@link Long} with a long library.
         * @property {Function} [enums] Enum value conversion type.
         * Only valid value is `String` (the global type).
         * Defaults to copy the present value, which is the numeric id.
         * @property {Function} [bytes] Bytes value conversion type.
         * Valid values are `Array` and (a base64 encoded) `String` (the global types).
         * Defaults to copy the present value, which usually is a Buffer under node and an Uint8Array in the browser.
         * @property {boolean} [defaults=false] Also sets default values on the resulting object
         * @property {boolean} [arrays=false] Sets empty arrays for missing repeated fields even if `defaults=false`
         * @property {boolean} [objects=false] Sets empty objects for missing map fields even if `defaults=false`
         * @property {boolean} [oneofs=false] Includes virtual oneof properties set to the present field's name, if any
         * @property {boolean} [json=false] Performs additional JSON compatibility conversions, i.e. NaN and Infinity to strings
         */

        /**
         * Creates a plain object from a message of this type. Also converts values to other types if specified.
         * @param {Message<{}>} message Message instance
         * @param {IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */


        Type.prototype.toObject = function toObject(message, options) {
          return this.setup().toObject(message, options);
        };
        /**
         * Decorator function as returned by {@link Type.d} (TypeScript).
         * @typedef TypeDecorator
         * @type {function}
         * @param {Constructor<T>} target Target constructor
         * @returns {undefined}
         * @template T extends Message<T>
         */

        /**
         * Type decorator (TypeScript).
         * @param {string} [typeName] Type name, defaults to the constructor's name
         * @returns {TypeDecorator<T>} Decorator function
         * @template T extends Message<T>
         */


        Type.d = function decorateType(typeName) {
          return function typeDecorator(target) {
            util.decorateType(target, typeName);
          };
        }; // #endregion ORIGINAL CODE


        module.exports;
      }, function () {
        return {
          './namespace': __cjsMetaURL$1,
          './enum': __cjsMetaURL$2,
          './oneof': __cjsMetaURL$3,
          './field': __cjsMetaURL$4,
          './mapfield': __cjsMetaURL$5,
          './service': __cjsMetaURL$6,
          './message': __cjsMetaURL$7,
          './reader': __cjsMetaURL$8,
          './writer': __cjsMetaURL$9,
          './util': __cjsMetaURL$a,
          './encoder': __cjsMetaURL$b,
          './decoder': __cjsMetaURL$c,
          './verifier': __cjsMetaURL$d,
          './converter': __cjsMetaURL$e,
          './wrappers': __cjsMetaURL$f
        };
      });
    }
  };
});

System.register("chunks:///_virtual/types.js", ['./cjs-loader.mjs', './util.js'], function (exports, module) {
  'use strict';

  var loader, __cjsMetaURL$1;

  return {
    setters: [function (module) {
      loader = module.default;
    }, function (module) {
      __cjsMetaURL$1 = module.__cjsMetaURL;
    }],
    execute: function () {
      var __cjsMetaURL = exports('__cjsMetaURL', module.meta.url);

      loader.define(__cjsMetaURL, function (exports, require, module, __filename, __dirname) {
        /**
         * Common type constants.
         * @namespace
         */
        var types = exports;

        var util = require("./util");

        var s = ["double", // 0
        "float", // 1
        "int32", // 2
        "uint32", // 3
        "sint32", // 4
        "fixed32", // 5
        "sfixed32", // 6
        "int64", // 7
        "uint64", // 8
        "sint64", // 9
        "fixed64", // 10
        "sfixed64", // 11
        "bool", // 12
        "string", // 13
        "bytes" // 14
        ];

        function bake(values, offset) {
          var i = 0,
              o = {};
          offset |= 0;

          while (i < values.length) {
            o[s[i + offset]] = values[i++];
          }

          return o;
        }
        /**
         * Basic type wire types.
         * @type {Object.<string,number>}
         * @const
         * @property {number} double=1 Fixed64 wire type
         * @property {number} float=5 Fixed32 wire type
         * @property {number} int32=0 Varint wire type
         * @property {number} uint32=0 Varint wire type
         * @property {number} sint32=0 Varint wire type
         * @property {number} fixed32=5 Fixed32 wire type
         * @property {number} sfixed32=5 Fixed32 wire type
         * @property {number} int64=0 Varint wire type
         * @property {number} uint64=0 Varint wire type
         * @property {number} sint64=0 Varint wire type
         * @property {number} fixed64=1 Fixed64 wire type
         * @property {number} sfixed64=1 Fixed64 wire type
         * @property {number} bool=0 Varint wire type
         * @property {number} string=2 Ldelim wire type
         * @property {number} bytes=2 Ldelim wire type
         */


        types.basic = bake([
        /* double   */
        1,
        /* float    */
        5,
        /* int32    */
        0,
        /* uint32   */
        0,
        /* sint32   */
        0,
        /* fixed32  */
        5,
        /* sfixed32 */
        5,
        /* int64    */
        0,
        /* uint64   */
        0,
        /* sint64   */
        0,
        /* fixed64  */
        1,
        /* sfixed64 */
        1,
        /* bool     */
        0,
        /* string   */
        2,
        /* bytes    */
        2]);
        /**
         * Basic type defaults.
         * @type {Object.<string,*>}
         * @const
         * @property {number} double=0 Double default
         * @property {number} float=0 Float default
         * @property {number} int32=0 Int32 default
         * @property {number} uint32=0 Uint32 default
         * @property {number} sint32=0 Sint32 default
         * @property {number} fixed32=0 Fixed32 default
         * @property {number} sfixed32=0 Sfixed32 default
         * @property {number} int64=0 Int64 default
         * @property {number} uint64=0 Uint64 default
         * @property {number} sint64=0 Sint32 default
         * @property {number} fixed64=0 Fixed64 default
         * @property {number} sfixed64=0 Sfixed64 default
         * @property {boolean} bool=false Bool default
         * @property {string} string="" String default
         * @property {Array.<number>} bytes=Array(0) Bytes default
         * @property {null} message=null Message default
         */

        types.defaults = bake([
        /* double   */
        0,
        /* float    */
        0,
        /* int32    */
        0,
        /* uint32   */
        0,
        /* sint32   */
        0,
        /* fixed32  */
        0,
        /* sfixed32 */
        0,
        /* int64    */
        0,
        /* uint64   */
        0,
        /* sint64   */
        0,
        /* fixed64  */
        0,
        /* sfixed64 */
        0,
        /* bool     */
        false,
        /* string   */
        "",
        /* bytes    */
        util.emptyArray,
        /* message  */
        null]);
        /**
         * Basic long type wire types.
         * @type {Object.<string,number>}
         * @const
         * @property {number} int64=0 Varint wire type
         * @property {number} uint64=0 Varint wire type
         * @property {number} sint64=0 Varint wire type
         * @property {number} fixed64=1 Fixed64 wire type
         * @property {number} sfixed64=1 Fixed64 wire type
         */

        types["long"] = bake([
        /* int64    */
        0,
        /* uint64   */
        0,
        /* sint64   */
        0,
        /* fixed64  */
        1,
        /* sfixed64 */
        1], 7);
        /**
         * Allowed types for map keys with their associated wire type.
         * @type {Object.<string,number>}
         * @const
         * @property {number} int32=0 Varint wire type
         * @property {number} uint32=0 Varint wire type
         * @property {number} sint32=0 Varint wire type
         * @property {number} fixed32=5 Fixed32 wire type
         * @property {number} sfixed32=5 Fixed32 wire type
         * @property {number} int64=0 Varint wire type
         * @property {number} uint64=0 Varint wire type
         * @property {number} sint64=0 Varint wire type
         * @property {number} fixed64=1 Fixed64 wire type
         * @property {number} sfixed64=1 Fixed64 wire type
         * @property {number} bool=0 Varint wire type
         * @property {number} string=2 Ldelim wire type
         */

        types.mapKey = bake([
        /* int32    */
        0,
        /* uint32   */
        0,
        /* sint32   */
        0,
        /* fixed32  */
        5,
        /* sfixed32 */
        5,
        /* int64    */
        0,
        /* uint64   */
        0,
        /* sint64   */
        0,
        /* fixed64  */
        1,
        /* sfixed64 */
        1,
        /* bool     */
        0,
        /* string   */
        2], 2);
        /**
         * Allowed types for packed repeated fields with their associated wire type.
         * @type {Object.<string,number>}
         * @const
         * @property {number} double=1 Fixed64 wire type
         * @property {number} float=5 Fixed32 wire type
         * @property {number} int32=0 Varint wire type
         * @property {number} uint32=0 Varint wire type
         * @property {number} sint32=0 Varint wire type
         * @property {number} fixed32=5 Fixed32 wire type
         * @property {number} sfixed32=5 Fixed32 wire type
         * @property {number} int64=0 Varint wire type
         * @property {number} uint64=0 Varint wire type
         * @property {number} sint64=0 Varint wire type
         * @property {number} fixed64=1 Fixed64 wire type
         * @property {number} sfixed64=1 Fixed64 wire type
         * @property {number} bool=0 Varint wire type
         */

        types.packed = bake([
        /* double   */
        1,
        /* float    */
        5,
        /* int32    */
        0,
        /* uint32   */
        0,
        /* sint32   */
        0,
        /* fixed32  */
        5,
        /* sfixed32 */
        5,
        /* int64    */
        0,
        /* uint64   */
        0,
        /* sint64   */
        0,
        /* fixed64  */
        1,
        /* sfixed64 */
        1,
        /* bool     */
        0]); // #endregion ORIGINAL CODE

        module.exports;
      }, function () {
        return {
          './util': __cjsMetaURL$1
        };
      });
    }
  };
});

System.register("chunks:///_virtual/util.js", ['./cjs-loader.mjs', './minimal2.js', './roots.js', './index12.js', './index10.js', './index11.js', './type.js', './enum.js', './root.js'], function (exports, module) {
  'use strict';

  var loader, __cjsMetaURL$1, __cjsMetaURL$2, __cjsMetaURL$3, __cjsMetaURL$4, __cjsMetaURL$5, __cjsMetaURL$6, __cjsMetaURL$7, __cjsMetaURL$8;

  return {
    setters: [function (module) {
      loader = module.default;
    }, function (module) {
      __cjsMetaURL$1 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$2 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$3 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$4 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$5 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$6 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$7 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$8 = module.__cjsMetaURL;
    }],
    execute: function () {
      var __cjsMetaURL = exports('__cjsMetaURL', module.meta.url);

      loader.define(__cjsMetaURL, function (exports, require, module, __filename, __dirname) {
        /**
         * Various utility functions.
         * @namespace
         */
        var util = module.exports = require("./util/minimal");

        var roots = require("./roots");

        var Type, // cyclic
        Enum;
        util.codegen = require("@protobufjs/codegen");
        util.fetch = require("@protobufjs/fetch");
        util.path = require("@protobufjs/path");
        /**
         * Node's fs module if available.
         * @type {Object.<string,*>}
         */

        util.fs = util.inquire("fs");
        /**
         * Converts an object's values to an array.
         * @param {Object.<string,*>} object Object to convert
         * @returns {Array.<*>} Converted array
         */

        util.toArray = function toArray(object) {
          if (object) {
            var keys = Object.keys(object),
                array = new Array(keys.length),
                index = 0;

            while (index < keys.length) {
              array[index] = object[keys[index++]];
            }

            return array;
          }

          return [];
        };
        /**
         * Converts an array of keys immediately followed by their respective value to an object, omitting undefined values.
         * @param {Array.<*>} array Array to convert
         * @returns {Object.<string,*>} Converted object
         */


        util.toObject = function toObject(array) {
          var object = {},
              index = 0;

          while (index < array.length) {
            var key = array[index++],
                val = array[index++];
            if (val !== undefined) object[key] = val;
          }

          return object;
        };

        var safePropBackslashRe = /\\/g,
            safePropQuoteRe = /"/g;
        /**
         * Tests whether the specified name is a reserved word in JS.
         * @param {string} name Name to test
         * @returns {boolean} `true` if reserved, otherwise `false`
         */

        util.isReserved = function isReserved(name) {
          return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(name);
        };
        /**
         * Returns a safe property accessor for the specified property name.
         * @param {string} prop Property name
         * @returns {string} Safe accessor
         */


        util.safeProp = function safeProp(prop) {
          if (!/^[$\w_]+$/.test(prop) || util.isReserved(prop)) return "[\"" + prop.replace(safePropBackslashRe, "\\\\").replace(safePropQuoteRe, "\\\"") + "\"]";
          return "." + prop;
        };
        /**
         * Converts the first character of a string to upper case.
         * @param {string} str String to convert
         * @returns {string} Converted string
         */


        util.ucFirst = function ucFirst(str) {
          return str.charAt(0).toUpperCase() + str.substring(1);
        };

        var camelCaseRe = /_([a-z])/g;
        /**
         * Converts a string to camel case.
         * @param {string} str String to convert
         * @returns {string} Converted string
         */

        util.camelCase = function camelCase(str) {
          return str.substring(0, 1) + str.substring(1).replace(camelCaseRe, function ($0, $1) {
            return $1.toUpperCase();
          });
        };
        /**
         * Compares reflected fields by id.
         * @param {Field} a First field
         * @param {Field} b Second field
         * @returns {number} Comparison value
         */


        util.compareFieldsById = function compareFieldsById(a, b) {
          return a.id - b.id;
        };
        /**
         * Decorator helper for types (TypeScript).
         * @param {Constructor<T>} ctor Constructor function
         * @param {string} [typeName] Type name, defaults to the constructor's name
         * @returns {Type} Reflected type
         * @template T extends Message<T>
         * @property {Root} root Decorators root
         */


        util.decorateType = function decorateType(ctor, typeName) {
          /* istanbul ignore if */
          if (ctor.$type) {
            if (typeName && ctor.$type.name !== typeName) {
              util.decorateRoot.remove(ctor.$type);
              ctor.$type.name = typeName;
              util.decorateRoot.add(ctor.$type);
            }

            return ctor.$type;
          }
          /* istanbul ignore next */


          if (!Type) Type = require("./type");
          var type = new Type(typeName || ctor.name);
          util.decorateRoot.add(type);
          type.ctor = ctor; // sets up .encode, .decode etc.

          Object.defineProperty(ctor, "$type", {
            value: type,
            enumerable: false
          });
          Object.defineProperty(ctor.prototype, "$type", {
            value: type,
            enumerable: false
          });
          return type;
        };

        var decorateEnumIndex = 0;
        /**
         * Decorator helper for enums (TypeScript).
         * @param {Object} object Enum object
         * @returns {Enum} Reflected enum
         */

        util.decorateEnum = function decorateEnum(object) {
          /* istanbul ignore if */
          if (object.$type) return object.$type;
          /* istanbul ignore next */

          if (!Enum) Enum = require("./enum");
          var enm = new Enum("Enum" + decorateEnumIndex++, object);
          util.decorateRoot.add(enm);
          Object.defineProperty(object, "$type", {
            value: enm,
            enumerable: false
          });
          return enm;
        };
        /**
         * Sets the value of a property by property path. If a value already exists, it is turned to an array
         * @param {Object.<string,*>} dst Destination object
         * @param {string} path dot '.' delimited path of the property to set
         * @param {Object} value the value to set
         * @returns {Object.<string,*>} Destination object
         */


        util.setProperty = function setProperty(dst, path, value) {
          function setProp(dst, path, value) {
            var part = path.shift();

            if (path.length > 0) {
              dst[part] = setProp(dst[part] || {}, path, value);
            } else {
              var prevValue = dst[part];
              if (prevValue) value = [].concat(prevValue).concat(value);
              dst[part] = value;
            }

            return dst;
          }

          if (typeof dst !== "object") throw TypeError("dst must be an object");
          if (!path) throw TypeError("path must be specified");
          path = path.split(".");
          return setProp(dst, path, value);
        };
        /**
         * Decorator root (TypeScript).
         * @name util.decorateRoot
         * @type {Root}
         * @readonly
         */


        Object.defineProperty(util, "decorateRoot", {
          get: function get() {
            return roots["decorated"] || (roots["decorated"] = new (require("./root"))());
          }
        }); // #endregion ORIGINAL CODE

        module.exports;
      }, function () {
        return {
          './util/minimal': __cjsMetaURL$1,
          './roots': __cjsMetaURL$2,
          '@protobufjs/codegen': __cjsMetaURL$3,
          '@protobufjs/fetch': __cjsMetaURL$4,
          '@protobufjs/path': __cjsMetaURL$5,
          './type': __cjsMetaURL$6,
          './enum': __cjsMetaURL$7,
          './root': __cjsMetaURL$8
        };
      });
    }
  };
});

System.register("chunks:///_virtual/verifier.js", ['./cjs-loader.mjs', './enum.js', './util.js'], function (exports, module) {
  'use strict';

  var loader, __cjsMetaURL$1, __cjsMetaURL$2;

  return {
    setters: [function (module) {
      loader = module.default;
    }, function (module) {
      __cjsMetaURL$1 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$2 = module.__cjsMetaURL;
    }],
    execute: function () {
      var __cjsMetaURL = exports('__cjsMetaURL', module.meta.url);

      loader.define(__cjsMetaURL, function (exports, require, module, __filename, __dirname) {
        module.exports = verifier;

        var Enum = require("./enum"),
            util = require("./util");

        function invalid(field, expected) {
          return field.name + ": " + expected + (field.repeated && expected !== "array" ? "[]" : field.map && expected !== "object" ? "{k:" + field.keyType + "}" : "") + " expected";
        }
        /**
         * Generates a partial value verifier.
         * @param {Codegen} gen Codegen instance
         * @param {Field} field Reflected field
         * @param {number} fieldIndex Field index
         * @param {string} ref Variable reference
         * @returns {Codegen} Codegen instance
         * @ignore
         */


        function genVerifyValue(gen, field, fieldIndex, ref) {
          /* eslint-disable no-unexpected-multiline */
          if (field.resolvedType) {
            if (field.resolvedType instanceof Enum) {
              gen("switch(%s){", ref)("default:")("return%j", invalid(field, "enum value"));

              for (var keys = Object.keys(field.resolvedType.values), j = 0; j < keys.length; ++j) {
                gen("case %i:", field.resolvedType.values[keys[j]]);
              }

              gen("break")("}");
            } else {
              gen("{")("var e=types[%i].verify(%s);", fieldIndex, ref)("if(e)")("return%j+e", field.name + ".")("}");
            }
          } else {
            switch (field.type) {
              case "int32":
              case "uint32":
              case "sint32":
              case "fixed32":
              case "sfixed32":
                gen("if(!util.isInteger(%s))", ref)("return%j", invalid(field, "integer"));
                break;

              case "int64":
              case "uint64":
              case "sint64":
              case "fixed64":
              case "sfixed64":
                gen("if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))", ref, ref, ref, ref)("return%j", invalid(field, "integer|Long"));
                break;

              case "float":
              case "double":
                gen("if(typeof %s!==\"number\")", ref)("return%j", invalid(field, "number"));
                break;

              case "bool":
                gen("if(typeof %s!==\"boolean\")", ref)("return%j", invalid(field, "boolean"));
                break;

              case "string":
                gen("if(!util.isString(%s))", ref)("return%j", invalid(field, "string"));
                break;

              case "bytes":
                gen("if(!(%s&&typeof %s.length===\"number\"||util.isString(%s)))", ref, ref, ref)("return%j", invalid(field, "buffer"));
                break;
            }
          }

          return gen;
          /* eslint-enable no-unexpected-multiline */
        }
        /**
         * Generates a partial key verifier.
         * @param {Codegen} gen Codegen instance
         * @param {Field} field Reflected field
         * @param {string} ref Variable reference
         * @returns {Codegen} Codegen instance
         * @ignore
         */


        function genVerifyKey(gen, field, ref) {
          /* eslint-disable no-unexpected-multiline */
          switch (field.keyType) {
            case "int32":
            case "uint32":
            case "sint32":
            case "fixed32":
            case "sfixed32":
              gen("if(!util.key32Re.test(%s))", ref)("return%j", invalid(field, "integer key"));
              break;

            case "int64":
            case "uint64":
            case "sint64":
            case "fixed64":
            case "sfixed64":
              gen("if(!util.key64Re.test(%s))", ref) // see comment above: x is ok, d is not
              ("return%j", invalid(field, "integer|Long key"));
              break;

            case "bool":
              gen("if(!util.key2Re.test(%s))", ref)("return%j", invalid(field, "boolean key"));
              break;
          }

          return gen;
          /* eslint-enable no-unexpected-multiline */
        }
        /**
         * Generates a verifier specific to the specified message type.
         * @param {Type} mtype Message type
         * @returns {Codegen} Codegen instance
         */


        function verifier(mtype) {
          /* eslint-disable no-unexpected-multiline */
          var gen = util.codegen(["m"], mtype.name + "$verify")("if(typeof m!==\"object\"||m===null)")("return%j", "object expected");
          var oneofs = mtype.oneofsArray,
              seenFirstField = {};
          if (oneofs.length) gen("var p={}");

          for (var i = 0; i <
          /* initializes */
          mtype.fieldsArray.length; ++i) {
            var field = mtype._fieldsArray[i].resolve(),
                ref = "m" + util.safeProp(field.name);

            if (field.optional) gen("if(%s!=null&&m.hasOwnProperty(%j)){", ref, field.name); // !== undefined && !== null
            // map fields

            if (field.map) {
              gen("if(!util.isObject(%s))", ref)("return%j", invalid(field, "object"))("var k=Object.keys(%s)", ref)("for(var i=0;i<k.length;++i){");
              genVerifyKey(gen, field, "k[i]");
              genVerifyValue(gen, field, i, ref + "[k[i]]")("}"); // repeated fields
            } else if (field.repeated) {
              gen("if(!Array.isArray(%s))", ref)("return%j", invalid(field, "array"))("for(var i=0;i<%s.length;++i){", ref);
              genVerifyValue(gen, field, i, ref + "[i]")("}"); // required or present fields
            } else {
              if (field.partOf) {
                var oneofProp = util.safeProp(field.partOf.name);
                if (seenFirstField[field.partOf.name] === 1) gen("if(p%s===1)", oneofProp)("return%j", field.partOf.name + ": multiple values");
                seenFirstField[field.partOf.name] = 1;
                gen("p%s=1", oneofProp);
              }

              genVerifyValue(gen, field, i, ref);
            }

            if (field.optional) gen("}");
          }

          return gen("return null");
          /* eslint-enable no-unexpected-multiline */
        } // #endregion ORIGINAL CODE


        module.exports;
      }, function () {
        return {
          './enum': __cjsMetaURL$1,
          './util': __cjsMetaURL$2
        };
      });
    }
  };
});

System.register("chunks:///_virtual/wrappers.js", ['./cjs-loader.mjs', './message.js'], function (exports, module) {
  'use strict';

  var loader, __cjsMetaURL$1;

  return {
    setters: [function (module) {
      loader = module.default;
    }, function (module) {
      __cjsMetaURL$1 = module.__cjsMetaURL;
    }],
    execute: function () {
      var __cjsMetaURL = exports('__cjsMetaURL', module.meta.url);

      loader.define(__cjsMetaURL, function (exports, require, module, __filename, __dirname) {
        /**
         * Wrappers for common types.
         * @type {Object.<string,IWrapper>}
         * @const
         */
        var wrappers = exports;

        var Message = require("./message");
        /**
         * From object converter part of an {@link IWrapper}.
         * @typedef WrapperFromObjectConverter
         * @type {function}
         * @param {Object.<string,*>} object Plain object
         * @returns {Message<{}>} Message instance
         * @this Type
         */

        /**
         * To object converter part of an {@link IWrapper}.
         * @typedef WrapperToObjectConverter
         * @type {function}
         * @param {Message<{}>} message Message instance
         * @param {IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         * @this Type
         */

        /**
         * Common type wrapper part of {@link wrappers}.
         * @interface IWrapper
         * @property {WrapperFromObjectConverter} [fromObject] From object converter
         * @property {WrapperToObjectConverter} [toObject] To object converter
         */
        // Custom wrapper for Any


        wrappers[".google.protobuf.Any"] = {
          fromObject: function fromObject(object) {
            // unwrap value type if mapped
            if (object && object["@type"]) {
              // Only use fully qualified type name after the last '/'
              var name = object["@type"].substring(object["@type"].lastIndexOf("/") + 1);
              var type = this.lookup(name);
              /* istanbul ignore else */

              if (type) {
                // type_url does not accept leading "."
                var type_url = object["@type"].charAt(0) === "." ? object["@type"].substr(1) : object["@type"]; // type_url prefix is optional, but path seperator is required

                if (type_url.indexOf("/") === -1) {
                  type_url = "/" + type_url;
                }

                return this.create({
                  type_url: type_url,
                  value: type.encode(type.fromObject(object)).finish()
                });
              }
            }

            return this.fromObject(object);
          },
          toObject: function toObject(message, options) {
            // Default prefix
            var googleApi = "type.googleapis.com/";
            var prefix = "";
            var name = ""; // decode value if requested and unmapped

            if (options && options.json && message.type_url && message.value) {
              // Only use fully qualified type name after the last '/'
              name = message.type_url.substring(message.type_url.lastIndexOf("/") + 1); // Separate the prefix used

              prefix = message.type_url.substring(0, message.type_url.lastIndexOf("/") + 1);
              var type = this.lookup(name);
              /* istanbul ignore else */

              if (type) message = type.decode(message.value);
            } // wrap value if unmapped


            if (!(message instanceof this.ctor) && message instanceof Message) {
              var object = message.$type.toObject(message, options);
              var messageName = message.$type.fullName[0] === "." ? message.$type.fullName.substr(1) : message.$type.fullName; // Default to type.googleapis.com prefix if no prefix is used

              if (prefix === "") {
                prefix = googleApi;
              }

              name = prefix + messageName;
              object["@type"] = name;
              return object;
            }

            return this.toObject(message, options);
          }
        }; // #endregion ORIGINAL CODE

        module.exports;
      }, function () {
        return {
          './message': __cjsMetaURL$1
        };
      });
    }
  };
});

System.register("chunks:///_virtual/writer_buffer.js", ['./cjs-loader.mjs', './writer.js', './minimal2.js'], function (exports, module) {
  'use strict';

  var loader, __cjsMetaURL$1, __cjsMetaURL$2;

  return {
    setters: [function (module) {
      loader = module.default;
    }, function (module) {
      __cjsMetaURL$1 = module.__cjsMetaURL;
    }, function (module) {
      __cjsMetaURL$2 = module.__cjsMetaURL;
    }],
    execute: function () {
      var __cjsMetaURL = exports('__cjsMetaURL', module.meta.url);

      loader.define(__cjsMetaURL, function (exports, require, module, __filename, __dirname) {
        module.exports = BufferWriter; // extends Writer

        var Writer = require("./writer");

        (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;

        var util = require("./util/minimal");
        /**
         * Constructs a new buffer writer instance.
         * @classdesc Wire format writer using node buffers.
         * @extends Writer
         * @constructor
         */


        function BufferWriter() {
          Writer.call(this);
        }

        BufferWriter._configure = function () {
          /**
           * Allocates a buffer of the specified size.
           * @function
           * @param {number} size Buffer size
           * @returns {Buffer} Buffer
           */
          BufferWriter.alloc = util._Buffer_allocUnsafe;
          BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf, pos) {
            buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)
            // also works for plain array values
          }
          /* istanbul ignore next */
          : function writeBytesBuffer_copy(val, buf, pos) {
            if (val.copy) // Buffer values
              val.copy(buf, pos, 0, val.length);else for (var i = 0; i < val.length;) {
              // plain array values
              buf[pos++] = val[i++];
            }
          };
        };
        /**
         * @override
         */


        BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
          if (util.isString(value)) value = util._Buffer_from(value, "base64");
          var len = value.length >>> 0;
          this.uint32(len);
          if (len) this._push(BufferWriter.writeBytesBuffer, len, value);
          return this;
        };

        function writeStringBuffer(val, buf, pos) {
          if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)
            util.utf8.write(val, buf, pos);else if (buf.utf8Write) buf.utf8Write(val, pos);else buf.write(val, pos);
        }
        /**
         * @override
         */


        BufferWriter.prototype.string = function write_string_buffer(value) {
          var len = util.Buffer.byteLength(value);
          this.uint32(len);
          if (len) this._push(writeStringBuffer, len, value);
          return this;
        };
        /**
         * Finishes the write operation.
         * @name BufferWriter#finish
         * @function
         * @returns {Buffer} Finished buffer
         */


        BufferWriter._configure(); // #endregion ORIGINAL CODE


        module.exports;
      }, function () {
        return {
          './writer': __cjsMetaURL$1,
          './util/minimal': __cjsMetaURL$2
        };
      });
    }
  };
});

System.register("chunks:///_virtual/writer.js", ['./cjs-loader.mjs', './minimal2.js'], function (exports, module) {
  'use strict';

  var loader, __cjsMetaURL$1;

  return {
    setters: [function (module) {
      loader = module.default;
    }, function (module) {
      __cjsMetaURL$1 = module.__cjsMetaURL;
    }],
    execute: function () {
      var __cjsMetaURL = exports('__cjsMetaURL', module.meta.url);

      loader.define(__cjsMetaURL, function (exports, require, module, __filename, __dirname) {
        module.exports = Writer;

        var util = require("./util/minimal");

        var BufferWriter; // cyclic

        var LongBits = util.LongBits,
            base64 = util.base64,
            utf8 = util.utf8;
        /**
         * Constructs a new writer operation instance.
         * @classdesc Scheduled writer operation.
         * @constructor
         * @param {function(*, Uint8Array, number)} fn Function to call
         * @param {number} len Value byte length
         * @param {*} val Value to write
         * @ignore
         */

        function Op(fn, len, val) {
          /**
           * Function to call.
           * @type {function(Uint8Array, number, *)}
           */
          this.fn = fn;
          /**
           * Value byte length.
           * @type {number}
           */

          this.len = len;
          /**
           * Next operation.
           * @type {Writer.Op|undefined}
           */

          this.next = undefined;
          /**
           * Value to write.
           * @type {*}
           */

          this.val = val; // type varies
        }
        /* istanbul ignore next */


        function noop() {} // eslint-disable-line no-empty-function

        /**
         * Constructs a new writer state instance.
         * @classdesc Copied writer state.
         * @memberof Writer
         * @constructor
         * @param {Writer} writer Writer to copy state from
         * @ignore
         */


        function State(writer) {
          /**
           * Current head.
           * @type {Writer.Op}
           */
          this.head = writer.head;
          /**
           * Current tail.
           * @type {Writer.Op}
           */

          this.tail = writer.tail;
          /**
           * Current buffer length.
           * @type {number}
           */

          this.len = writer.len;
          /**
           * Next state.
           * @type {State|null}
           */

          this.next = writer.states;
        }
        /**
         * Constructs a new writer instance.
         * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.
         * @constructor
         */


        function Writer() {
          /**
           * Current length.
           * @type {number}
           */
          this.len = 0;
          /**
           * Operations head.
           * @type {Object}
           */

          this.head = new Op(noop, 0, 0);
          /**
           * Operations tail
           * @type {Object}
           */

          this.tail = this.head;
          /**
           * Linked forked states.
           * @type {Object|null}
           */

          this.states = null; // When a value is written, the writer calculates its byte length and puts it into a linked
          // list of operations to perform when finish() is called. This both allows us to allocate
          // buffers of the exact required size and reduces the amount of work we have to do compared
          // to first calculating over objects and then encoding over objects. In our case, the encoding
          // part is just a linked list walk calling operations with already prepared values.
        }

        var create = function create() {
          return util.Buffer ? function create_buffer_setup() {
            return (Writer.create = function create_buffer() {
              return new BufferWriter();
            })();
          }
          /* istanbul ignore next */
          : function create_array() {
            return new Writer();
          };
        };
        /**
         * Creates a new writer.
         * @function
         * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}
         */


        Writer.create = create();
        /**
         * Allocates a buffer of the specified size.
         * @param {number} size Buffer size
         * @returns {Uint8Array} Buffer
         */

        Writer.alloc = function alloc(size) {
          return new util.Array(size);
        }; // Use Uint8Array buffer pool in the browser, just like node does with buffers

        /* istanbul ignore else */


        if (util.Array !== Array) Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);
        /**
         * Pushes a new operation to the queue.
         * @param {function(Uint8Array, number, *)} fn Function to call
         * @param {number} len Value byte length
         * @param {number} val Value to write
         * @returns {Writer} `this`
         * @private
         */

        Writer.prototype._push = function push(fn, len, val) {
          this.tail = this.tail.next = new Op(fn, len, val);
          this.len += len;
          return this;
        };

        function writeByte(val, buf, pos) {
          buf[pos] = val & 255;
        }

        function writeVarint32(val, buf, pos) {
          while (val > 127) {
            buf[pos++] = val & 127 | 128;
            val >>>= 7;
          }

          buf[pos] = val;
        }
        /**
         * Constructs a new varint writer operation instance.
         * @classdesc Scheduled varint writer operation.
         * @extends Op
         * @constructor
         * @param {number} len Value byte length
         * @param {number} val Value to write
         * @ignore
         */


        function VarintOp(len, val) {
          this.len = len;
          this.next = undefined;
          this.val = val;
        }

        VarintOp.prototype = Object.create(Op.prototype);
        VarintOp.prototype.fn = writeVarint32;
        /**
         * Writes an unsigned 32 bit value as a varint.
         * @param {number} value Value to write
         * @returns {Writer} `this`
         */

        Writer.prototype.uint32 = function write_uint32(value) {
          // here, the call to this.push has been inlined and a varint specific Op subclass is used.
          // uint32 is by far the most frequently used operation and benefits significantly from this.
          this.len += (this.tail = this.tail.next = new VarintOp((value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5, value)).len;
          return this;
        };
        /**
         * Writes a signed 32 bit value as a varint.
         * @function
         * @param {number} value Value to write
         * @returns {Writer} `this`
         */


        Writer.prototype.int32 = function write_int32(value) {
          return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec
          : this.uint32(value);
        };
        /**
         * Writes a 32 bit value as a varint, zig-zag encoded.
         * @param {number} value Value to write
         * @returns {Writer} `this`
         */


        Writer.prototype.sint32 = function write_sint32(value) {
          return this.uint32((value << 1 ^ value >> 31) >>> 0);
        };

        function writeVarint64(val, buf, pos) {
          while (val.hi) {
            buf[pos++] = val.lo & 127 | 128;
            val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
            val.hi >>>= 7;
          }

          while (val.lo > 127) {
            buf[pos++] = val.lo & 127 | 128;
            val.lo = val.lo >>> 7;
          }

          buf[pos++] = val.lo;
        }
        /**
         * Writes an unsigned 64 bit value as a varint.
         * @param {Long|number|string} value Value to write
         * @returns {Writer} `this`
         * @throws {TypeError} If `value` is a string and no long library is present.
         */


        Writer.prototype.uint64 = function write_uint64(value) {
          var bits = LongBits.from(value);
          return this._push(writeVarint64, bits.length(), bits);
        };
        /**
         * Writes a signed 64 bit value as a varint.
         * @function
         * @param {Long|number|string} value Value to write
         * @returns {Writer} `this`
         * @throws {TypeError} If `value` is a string and no long library is present.
         */


        Writer.prototype.int64 = Writer.prototype.uint64;
        /**
         * Writes a signed 64 bit value as a varint, zig-zag encoded.
         * @param {Long|number|string} value Value to write
         * @returns {Writer} `this`
         * @throws {TypeError} If `value` is a string and no long library is present.
         */

        Writer.prototype.sint64 = function write_sint64(value) {
          var bits = LongBits.from(value).zzEncode();
          return this._push(writeVarint64, bits.length(), bits);
        };
        /**
         * Writes a boolish value as a varint.
         * @param {boolean} value Value to write
         * @returns {Writer} `this`
         */


        Writer.prototype.bool = function write_bool(value) {
          return this._push(writeByte, 1, value ? 1 : 0);
        };

        function writeFixed32(val, buf, pos) {
          buf[pos] = val & 255;
          buf[pos + 1] = val >>> 8 & 255;
          buf[pos + 2] = val >>> 16 & 255;
          buf[pos + 3] = val >>> 24;
        }
        /**
         * Writes an unsigned 32 bit value as fixed 32 bits.
         * @param {number} value Value to write
         * @returns {Writer} `this`
         */


        Writer.prototype.fixed32 = function write_fixed32(value) {
          return this._push(writeFixed32, 4, value >>> 0);
        };
        /**
         * Writes a signed 32 bit value as fixed 32 bits.
         * @function
         * @param {number} value Value to write
         * @returns {Writer} `this`
         */


        Writer.prototype.sfixed32 = Writer.prototype.fixed32;
        /**
         * Writes an unsigned 64 bit value as fixed 64 bits.
         * @param {Long|number|string} value Value to write
         * @returns {Writer} `this`
         * @throws {TypeError} If `value` is a string and no long library is present.
         */

        Writer.prototype.fixed64 = function write_fixed64(value) {
          var bits = LongBits.from(value);
          return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
        };
        /**
         * Writes a signed 64 bit value as fixed 64 bits.
         * @function
         * @param {Long|number|string} value Value to write
         * @returns {Writer} `this`
         * @throws {TypeError} If `value` is a string and no long library is present.
         */


        Writer.prototype.sfixed64 = Writer.prototype.fixed64;
        /**
         * Writes a float (32 bit).
         * @function
         * @param {number} value Value to write
         * @returns {Writer} `this`
         */

        Writer.prototype["float"] = function write_float(value) {
          return this._push(util["float"].writeFloatLE, 4, value);
        };
        /**
         * Writes a double (64 bit float).
         * @function
         * @param {number} value Value to write
         * @returns {Writer} `this`
         */


        Writer.prototype["double"] = function write_double(value) {
          return this._push(util["float"].writeDoubleLE, 8, value);
        };

        var writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {
          buf.set(val, pos); // also works for plain array values
        }
        /* istanbul ignore next */
        : function writeBytes_for(val, buf, pos) {
          for (var i = 0; i < val.length; ++i) {
            buf[pos + i] = val[i];
          }
        };
        /**
         * Writes a sequence of bytes.
         * @param {Uint8Array|string} value Buffer or base64 encoded string to write
         * @returns {Writer} `this`
         */

        Writer.prototype.bytes = function write_bytes(value) {
          var len = value.length >>> 0;
          if (!len) return this._push(writeByte, 1, 0);

          if (util.isString(value)) {
            var buf = Writer.alloc(len = base64.length(value));
            base64.decode(value, buf, 0);
            value = buf;
          }

          return this.uint32(len)._push(writeBytes, len, value);
        };
        /**
         * Writes a string.
         * @param {string} value Value to write
         * @returns {Writer} `this`
         */


        Writer.prototype.string = function write_string(value) {
          var len = utf8.length(value);
          return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
        };
        /**
         * Forks this writer's state by pushing it to a stack.
         * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
         * @returns {Writer} `this`
         */


        Writer.prototype.fork = function fork() {
          this.states = new State(this);
          this.head = this.tail = new Op(noop, 0, 0);
          this.len = 0;
          return this;
        };
        /**
         * Resets this instance to the last state.
         * @returns {Writer} `this`
         */


        Writer.prototype.reset = function reset() {
          if (this.states) {
            this.head = this.states.head;
            this.tail = this.states.tail;
            this.len = this.states.len;
            this.states = this.states.next;
          } else {
            this.head = this.tail = new Op(noop, 0, 0);
            this.len = 0;
          }

          return this;
        };
        /**
         * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
         * @returns {Writer} `this`
         */


        Writer.prototype.ldelim = function ldelim() {
          var head = this.head,
              tail = this.tail,
              len = this.len;
          this.reset().uint32(len);

          if (len) {
            this.tail.next = head.next; // skip noop

            this.tail = tail;
            this.len += len;
          }

          return this;
        };
        /**
         * Finishes the write operation.
         * @returns {Uint8Array} Finished buffer
         */


        Writer.prototype.finish = function finish() {
          var head = this.head.next,
              // skip noop
          buf = this.constructor.alloc(this.len),
              pos = 0;

          while (head) {
            head.fn(head.val, buf, pos);
            pos += head.len;
            head = head.next;
          } // this.head = this.tail = null;


          return buf;
        };

        Writer._configure = function (BufferWriter_) {
          BufferWriter = BufferWriter_;
          Writer.create = create();

          BufferWriter._configure();
        }; // #endregion ORIGINAL CODE


        module.exports;
      }, function () {
        return {
          './util/minimal': __cjsMetaURL$1
        };
      });
    }
  };
});

} }; });